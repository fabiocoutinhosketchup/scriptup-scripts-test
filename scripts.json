[
  {
    "id": "tour-virtual-8wge1",
    "title": {
      "pt": "Tour Virtual",
      "en": "Virtual Tour",
      "es": "Visita virtual"
    },
    "author": "Fábio Coutinho",
    "version": "2.8",
    "description": {
      "pt": "Permite criar e gerenciar a criação de cenas em linha de tempo, várias linhas de tempo, apresentar a transição entre elas de forma suave e sem impacto de troca de cena e exportação de vídeo com FFMPEG de forma rápida por captura de tela enquanto apresenta.",
      "en": "It allows you to create and manage timeline scenes, multiple timelines, present the transition between them smoothly and without scene change impact, and quickly export video with FFMPEG by screen capture while presenting.",
      "es": "Le permite crear y administrar escenas de línea de tiempo, múltiples líneas de tiempo, presentar la transición entre ellas sin problemas y sin impacto en el cambio de escena, y exportar rápidamente video con FFMPEG mediante captura de pantalla mientras se presenta."
    },
    "keywords": {
      "pt": [
        "tour",
        "apresentação",
        "vídeo"
      ],
      "en": [
        "tour",
        "presentation",
        "video"
      ],
      "es": [
        "recorrido",
        "presentación",
        "video"
      ]
    },
    "code": {
      "pt": "require 'json'\r\nrequire 'sketchup.rb'\r\nrequire 'base64'\r\nrequire 'tmpdir'\r\nrequire 'fiddle/import'\r\nrequire 'fileutils'\r\nrequire 'open3'\r\nrequire 'etc'\r\nrequire 'open-uri'\r\nif Sketchup.platform == :platform_win\r\n  require 'win32ole'\r\nend\r\n\r\nmodule ScriptUpComunidade\r\nmodule TourVirtual\r\n\r\n# --- Definições de Diretórios ---\r\nplugins_root = Sketchup.find_support_file(\"Plugins\")\r\nPLUGIN_DIR = if plugins_root\r\n               File.expand_path(File.join(plugins_root, 'ScriptUp'))\r\n             else\r\n               File.expand_path(File.dirname(__FILE__))\r\n             end unless defined?(PLUGIN_DIR)\r\n\r\nIDIOMAS ||= {\r\n  'pt-BR' => {\r\n    :status_clicar_arrastar  => \"CLIQUE E ARRASTE para definir a área de gravação do vídeo.\",\r\n    :area_pequena            => \"Área muito pequena. Tente novamente.\",\r\n    :selecionar_pasta        => \"Selecione a pasta para salvar\",\r\n    :ffmpeg_nao_encontrado   => \"FFmpeg não encontrado.\",\r\n    :erro_gravador           => \"Erro ao iniciar gravador: \",\r\n    :gravacao_finalizada     => \"Gravação finalizada!\\nSalvo em: \",\r\n    :ffmpeg_instalado        => \"FFmpeg instalado. Execute o Tour Virtual novamente.\",\r\n    :titulo_dialogo          => \"Tour Virtual\",\r\n    :ffmpeg_plugins_erro     => \"Não foi possível resolver a pasta Plugins automaticamente.\",\r\n    :ffmpeg_instalar_em      => \"Instalar FFmpeg em:\",\r\n    :ffmpeg_origem           => \"Origem:\",\r\n    :ffmpeg_continuar        => \"Continuar?\",\r\n    :ffmpeg_cancelada        => \"Instalação cancelada.\",\r\n    :ffmpeg_ja_existe        => \"Já existe:\",\r\n    :ffmpeg_sobrescrever     => \"Deseja sobrescrever?\",\r\n    :ffmpeg_falha_expand     => \"Falha no Expand-Archive (PowerShell).\",\r\n    :ffmpeg_falha_unzip      => \"Falha no unzip (macOS).\",\r\n    :ffmpeg_exe_nao_encontrado => \"Executável ffmpeg não encontrado no pacote baixado.\",\r\n    :ffmpeg_sucesso          => \"FFmpeg instalado com sucesso em:\",\r\n    :ffmpeg_falhou           => \"Falhou:\",\r\n    :ffmpeg_abrindo_nav      => \"Abrindo o link no navegador...\",\r\n    :titulo                  => \"Tour Virtual\",\r\n    :subtitulo               => \"Linha do Tempo\",\r\n    :total                   => \"Total:\",\r\n    :visao                   => \"Visão\",\r\n    :play                    => \"Play\",\r\n    :stop                    => \"Stop\",\r\n    :play_all                => \"Play All\",\r\n    :stop_all                => \"Stop All\",\r\n    :atalho                  => \"Atalho\",\r\n    :pressione               => \"Pressione...\",\r\n    :ok                      => \"Ok\",\r\n    :loop                    => \"Loop\",\r\n    :easing                  => \"Easing\",\r\n    :visoes_salvas           => \"Visões salvas\",\r\n    :gerenciar_timeline      => \"Gerenciar Time Line\",\r\n    :nova                    => \"Nova\",\r\n    :exportar_atual          => \"Exportar Atual\",\r\n    :exportar_projeto        => \"Exportar Projeto\",\r\n    :importar                => \"Importar\",\r\n    :exportar_video          => \"Exportar Vídeo\",\r\n    :selecione_formato       => \"Selecione o formato…\",\r\n    :largura                 => \"Largura\",\r\n    :altura                  => \"Altura\",\r\n    :gravar_projeto          => \"Gravar todo o projeto (todas as Time Lines)\",\r\n    :iniciar_quadro1         => \"Iniciar do quadro 1\",\r\n    :iniciar_gravacao        => \"Iniciar Gravação\",\r\n    :gravando                => \"Gravando...\",\r\n    :ffmpeg_necessario       => \"FFmpeg necessário para gravar vídeo.\",\r\n    :instalar_ffmpeg         => \"Instalar FFmpeg\",\r\n    :nome_arquivo            => \"Nome do arquivo\",\r\n    :extensao_mp4            => \"A extensão .mp4 será adicionada automaticamente.\",\r\n    :cancelar                => \"Cancelar\",\r\n    :salvar                  => \"Salvar\",\r\n    :viewport_atual          => \"Viewport atual:\",\r\n    :paisagem                => \"Paisagem\",\r\n    :retrato                 => \"Retrato\",\r\n    :quadrado                => \"Quadrado\",\r\n    :classico                => \"Clássico\",\r\n    :ultra_wide              => \"Ultra-wide\",\r\n    :viewport_inteira        => \"Viewport Inteira\",\r\n    :personalizado           => \"Personalizado\",\r\n    :nome_timeline           => \"Nome da Time Line:\",\r\n    :nenhuma_visao           => \"Nenhuma visão adicionada.\",\r\n    :dica_visao              => \"Posicione a câmera e clique em <b>+ Visão</b>.\",\r\n    :ancora                  => \"Âncora\",\r\n    :excluir                 => \"Excluir\",\r\n    :min_duas_visoes         => \"Adicione pelo menos duas visões.\",\r\n    :sem_tl_2mais            => \"Nenhuma Time Line com 2+ visões.\",\r\n    :sem_visoes_exportar     => \"Nenhuma visão para exportar.\",\r\n    :sem_tl_exportar         => \"Nenhuma Time Line para exportar.\",\r\n    :importada               => \"Importada\",\r\n    :formato_invalido        => \"Formato inválido.\",\r\n    :erro_importar           => \"Erro ao importar: \",\r\n    :visoes                  => \"visões\",\r\n    :nova_timeline           => \"Nome da nova Time Line:\",\r\n    :area_gravacao           => \"Área de gravação: \",\r\n    :sem_tl_min_duas         => \"Nenhuma Time Line com pelo menos duas visões.\",\r\n    :dims_invalidas          => \"Dimensões inválidas (mínimo 50 x 50 px).\",\r\n    :digite_nome             => \"Digite um nome para o arquivo.\",\r\n  },\r\n  'en-US' => {\r\n    :status_clicar_arrastar  => \"CLICK AND DRAG to define the video recording area.\",\r\n    :area_pequena            => \"Area too small. Try again.\",\r\n    :selecionar_pasta        => \"Select folder to save\",\r\n    :ffmpeg_nao_encontrado   => \"FFmpeg not found.\",\r\n    :erro_gravador           => \"Error starting recorder: \",\r\n    :gravacao_finalizada     => \"Recording finished!\\nSaved to: \",\r\n    :ffmpeg_instalado        => \"FFmpeg installed. Run Virtual Tour again.\",\r\n    :titulo_dialogo          => \"Virtual Tour\",\r\n    :ffmpeg_plugins_erro     => \"Could not resolve the Plugins folder automatically.\",\r\n    :ffmpeg_instalar_em      => \"Install FFmpeg to:\",\r\n    :ffmpeg_origem           => \"Source:\",\r\n    :ffmpeg_continuar        => \"Continue?\",\r\n    :ffmpeg_cancelada        => \"Installation cancelled.\",\r\n    :ffmpeg_ja_existe        => \"Already exists:\",\r\n    :ffmpeg_sobrescrever     => \"Overwrite?\",\r\n    :ffmpeg_falha_expand     => \"Expand-Archive failed (PowerShell).\",\r\n    :ffmpeg_falha_unzip      => \"unzip failed (macOS).\",\r\n    :ffmpeg_exe_nao_encontrado => \"FFmpeg executable not found in downloaded package.\",\r\n    :ffmpeg_sucesso          => \"FFmpeg successfully installed to:\",\r\n    :ffmpeg_falhou           => \"Failed:\",\r\n    :ffmpeg_abrindo_nav      => \"Opening the link in browser...\",\r\n    :titulo                  => \"Virtual Tour\",\r\n    :subtitulo               => \"Timeline\",\r\n    :total                   => \"Total:\",\r\n    :visao                   => \"Vision\",\r\n    :play                    => \"Play\",\r\n    :stop                    => \"Stop\",\r\n    :play_all                => \"Play All\",\r\n    :stop_all                => \"Stop All\",\r\n    :atalho                  => \"Hotkey\",\r\n    :pressione               => \"Press a key...\",\r\n    :ok                      => \"Ok\",\r\n    :loop                    => \"Loop\",\r\n    :easing                  => \"Easing\",\r\n    :visoes_salvas           => \"Saved visions\",\r\n    :gerenciar_timeline      => \"Manage Timeline\",\r\n    :nova                    => \"New\",\r\n    :exportar_atual          => \"Export Current\",\r\n    :exportar_projeto        => \"Export Project\",\r\n    :importar                => \"Import\",\r\n    :exportar_video          => \"Export Video\",\r\n    :selecione_formato       => \"Select format…\",\r\n    :largura                 => \"Width\",\r\n    :altura                  => \"Height\",\r\n    :gravar_projeto          => \"Record entire project (all Timelines)\",\r\n    :iniciar_quadro1         => \"Start from frame 1\",\r\n    :iniciar_gravacao        => \"Start Recording\",\r\n    :gravando                => \"Recording...\",\r\n    :ffmpeg_necessario       => \"FFmpeg is required to record video.\",\r\n    :instalar_ffmpeg         => \"Install FFmpeg\",\r\n    :nome_arquivo            => \"File name\",\r\n    :extensao_mp4            => \"The .mp4 extension will be added automatically.\",\r\n    :cancelar                => \"Cancel\",\r\n    :salvar                  => \"Save\",\r\n    :viewport_atual          => \"Current viewport:\",\r\n    :paisagem                => \"Landscape\",\r\n    :retrato                 => \"Portrait\",\r\n    :quadrado                => \"Square\",\r\n    :classico                => \"Classic\",\r\n    :ultra_wide              => \"Ultra-wide\",\r\n    :viewport_inteira        => \"Full Viewport\",\r\n    :personalizado           => \"Custom\",\r\n    :nome_timeline           => \"Timeline name:\",\r\n    :nenhuma_visao           => \"No visions added.\",\r\n    :dica_visao              => \"Position the camera and click <b>+ Vision</b>.\",\r\n    :ancora                  => \"Anchor\",\r\n    :excluir                 => \"Delete\",\r\n    :min_duas_visoes         => \"Add at least two visions.\",\r\n    :sem_tl_2mais            => \"No Timeline with 2+ visions.\",\r\n    :sem_visoes_exportar     => \"No visions to export.\",\r\n    :sem_tl_exportar         => \"No Timeline to export.\",\r\n    :importada               => \"Imported\",\r\n    :formato_invalido        => \"Invalid format.\",\r\n    :erro_importar           => \"Import error: \",\r\n    :visoes                  => \"visions\",\r\n    :nova_timeline           => \"New Timeline name:\",\r\n    :area_gravacao           => \"Recording area: \",\r\n    :sem_tl_min_duas         => \"No Timeline with at least two visions.\",\r\n    :dims_invalidas          => \"Invalid dimensions (minimum 50 x 50 px).\",\r\n    :digite_nome             => \"Enter a file name.\",\r\n  },\r\n  'es' => {\r\n    :status_clicar_arrastar  => \"HAZ CLIC Y ARRASTRA para definir el área de grabación del video.\",\r\n    :area_pequena            => \"Área demasiado pequeña. Inténtalo de nuevo.\",\r\n    :selecionar_pasta        => \"Selecciona la carpeta para guardar\",\r\n    :ffmpeg_nao_encontrado   => \"FFmpeg no encontrado.\",\r\n    :erro_gravador           => \"Error al iniciar grabador: \",\r\n    :gravacao_finalizada     => \"¡Grabación finalizada!\\nGuardado en: \",\r\n    :ffmpeg_instalado        => \"FFmpeg instalado. Ejecuta Tour Virtual de nuevo.\",\r\n    :titulo_dialogo          => \"Tour Virtual\",\r\n    :ffmpeg_plugins_erro     => \"No se pudo resolver la carpeta Plugins automáticamente.\",\r\n    :ffmpeg_instalar_em      => \"Instalar FFmpeg en:\",\r\n    :ffmpeg_origem           => \"Origen:\",\r\n    :ffmpeg_continuar        => \"¿Continuar?\",\r\n    :ffmpeg_cancelada        => \"Instalación cancelada.\",\r\n    :ffmpeg_ja_existe        => \"Ya existe:\",\r\n    :ffmpeg_sobrescrever     => \"¿Sobrescribir?\",\r\n    :ffmpeg_falha_expand     => \"Error en Expand-Archive (PowerShell).\",\r\n    :ffmpeg_falha_unzip      => \"Error en unzip (macOS).\",\r\n    :ffmpeg_exe_nao_encontrado => \"Ejecutable FFmpeg no encontrado en el paquete descargado.\",\r\n    :ffmpeg_sucesso          => \"FFmpeg instalado con éxito en:\",\r\n    :ffmpeg_falhou           => \"Falló:\",\r\n    :ffmpeg_abrindo_nav      => \"Abriendo el enlace en el navegador...\",\r\n    :titulo                  => \"Tour Virtual\",\r\n    :subtitulo               => \"Línea de Tiempo\",\r\n    :total                   => \"Total:\",\r\n    :visao                   => \"Visión\",\r\n    :play                    => \"Play\",\r\n    :stop                    => \"Stop\",\r\n    :play_all                => \"Play All\",\r\n    :stop_all                => \"Stop All\",\r\n    :atalho                  => \"Atajo\",\r\n    :pressione               => \"Presiona...\",\r\n    :ok                      => \"Ok\",\r\n    :loop                    => \"Loop\",\r\n    :easing                  => \"Easing\",\r\n    :visoes_salvas           => \"Visiones guardadas\",\r\n    :gerenciar_timeline      => \"Gestionar Línea de Tiempo\",\r\n    :nova                    => \"Nueva\",\r\n    :exportar_atual          => \"Exportar Actual\",\r\n    :exportar_projeto        => \"Exportar Proyecto\",\r\n    :importar                => \"Importar\",\r\n    :exportar_video          => \"Exportar Video\",\r\n    :selecione_formato       => \"Selecciona el formato…\",\r\n    :largura                 => \"Ancho\",\r\n    :altura                  => \"Alto\",\r\n    :gravar_projeto          => \"Grabar todo el proyecto (todas las Líneas de Tiempo)\",\r\n    :iniciar_quadro1         => \"Iniciar desde el cuadro 1\",\r\n    :iniciar_gravacao        => \"Iniciar Grabación\",\r\n    :gravando                => \"Grabando...\",\r\n    :ffmpeg_necessario       => \"FFmpeg necesario para grabar video.\",\r\n    :instalar_ffmpeg         => \"Instalar FFmpeg\",\r\n    :nome_arquivo            => \"Nombre del archivo\",\r\n    :extensao_mp4            => \"La extensión .mp4 se añadirá automáticamente.\",\r\n    :cancelar                => \"Cancelar\",\r\n    :salvar                  => \"Guardar\",\r\n    :viewport_atual          => \"Viewport actual:\",\r\n    :paisagem                => \"Paisaje\",\r\n    :retrato                 => \"Retrato\",\r\n    :quadrado                => \"Cuadrado\",\r\n    :classico                => \"Clásico\",\r\n    :ultra_wide              => \"Ultra-wide\",\r\n    :viewport_inteira        => \"Viewport Completa\",\r\n    :personalizado           => \"Personalizado\",\r\n    :nome_timeline           => \"Nombre de la Línea de Tiempo:\",\r\n    :nenhuma_visao           => \"Ninguna visión añadida.\",\r\n    :dica_visao              => \"Posiciona la cámara y haz clic en <b>+ Visión</b>.\",\r\n    :ancora                  => \"Ancla\",\r\n    :excluir                 => \"Eliminar\",\r\n    :min_duas_visoes         => \"Añade al menos dos visiones.\",\r\n    :sem_tl_2mais            => \"Ninguna Línea de Tiempo con 2+ visiones.\",\r\n    :sem_visoes_exportar     => \"Ninguna visión para exportar.\",\r\n    :sem_tl_exportar         => \"Ninguna Línea de Tiempo para exportar.\",\r\n    :importada               => \"Importada\",\r\n    :formato_invalido        => \"Formato inválido.\",\r\n    :erro_importar           => \"Error al importar: \",\r\n    :visoes                  => \"visiones\",\r\n    :nova_timeline           => \"Nombre de la nueva Línea de Tiempo:\",\r\n    :area_gravacao           => \"Área de grabación: \",\r\n    :sem_tl_min_duas         => \"Ninguna Línea de Tiempo con al menos dos visiones.\",\r\n    :dims_invalidas          => \"Dimensiones inválidas (mínimo 50 x 50 px).\",\r\n    :digite_nome             => \"Escribe un nombre para el archivo.\",\r\n  },\r\n}\r\n\r\ndef self.obter_texto(chave)\r\n  locale = Sketchup.get_locale\r\n  lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n  IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\nend\r\n\r\n# --- Script de Instalação do FFmpeg (Mantido) ---\r\nFFMPEG_INSTALL_SCRIPT ||= <<~'RUBY'\r\n  require 'sketchup'\r\n  require 'open-uri'\r\n  require 'fileutils'\r\n  require 'tmpdir'\r\n\r\n  URL_WIN ||= 'https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-master-latest-win64-gpl.zip'\r\n  URL_MAC ||= 'https://evermeet.cx/ffmpeg/getrelease/zip'\r\n\r\n  win = Sketchup.platform == :platform_win\r\n  major = Sketchup.version.to_s[/^\\d+/].to_i\r\n  sketchup_year = 2000 + major\r\n\r\n  plugins_dir = Sketchup.find_support_file('Plugins')\r\n  if !plugins_dir || plugins_dir.empty? || !Dir.exist?(plugins_dir)\r\n    if win\r\n      base = ENV['APPDATA'].to_s\r\n      plugins_dir = File.join(base, 'SketchUp', \"SketchUp #{sketchup_year}\", 'SketchUp', 'Plugins')\r\n    else\r\n      plugins_dir = File.expand_path(\"~/Library/Application Support/SketchUp #{sketchup_year}/SketchUp/Plugins\")\r\n    end\r\n  end\r\n\r\n  target_dir = File.join(plugins_dir, 'ScriptUp', 'ffmpeg')\r\n  target_exe = File.join(target_dir, win ? 'ffmpeg.exe' : 'ffmpeg')\r\n  url = win ? URL_WIN : URL_MAC\r\n  default_zip_name = win ? 'ffmpeg-win64-gpl-latest.zip' : 'ffmpeg-macos-release.zip'\r\n\r\n  proceed = true\r\n\r\n  unless plugins_dir && !plugins_dir.empty?\r\n    UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_plugins_erro))\r\n    proceed = false\r\n  end\r\n\r\n  if proceed\r\n    msg = \"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_instalar_em)}\\n#{target_dir}\\n\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_origem)}\\n#{url}\\n\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_continuar)}\"\r\n    if UI.messagebox(msg, MB_YESNO) != IDYES\r\n      UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_cancelada))\r\n      proceed = false\r\n    end\r\n  end\r\n\r\n  if proceed && File.exist?(target_exe)\r\n    overwrite = UI.messagebox(\"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_ja_existe)}\\n#{target_exe}\\n\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_sobrescrever)}\", MB_YESNO)\r\n    if overwrite != IDYES\r\n      UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_cancelada))\r\n      proceed = false\r\n    end\r\n  end\r\n\r\n  if proceed\r\n    Dir.mktmpdir('ffmpeg_dl_') do |tmp|\r\n      zip_path = File.join(tmp, default_zip_name)\r\n      extract_dir = File.join(tmp, 'unzipped')\r\n      begin\r\n        URI.open(url, 'rb') do |io|\r\n          File.open(zip_path, 'wb') { |f| IO.copy_stream(io, f) }\r\n        end\r\n        Dir.mkdir(extract_dir)\r\n        if win\r\n          ps = 'powershell -NoProfile -ExecutionPolicy Bypass -Command'\r\n          cmd = \"#{ps} \\\"Expand-Archive -LiteralPath '#{zip_path}' -DestinationPath '#{extract_dir}' -Force\\\"\"\r\n          ok = system(cmd)\r\n          raise ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_falha_expand) unless ok\r\n        else\r\n          ok = system(\"unzip -o -q '#{zip_path}' -d '#{extract_dir}'\")\r\n          raise ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_falha_unzip) unless ok\r\n        end\r\n\r\n        pattern = win ? '**/ffmpeg.exe' : '**/ffmpeg'\r\n        bin = Dir.glob(File.join(extract_dir, pattern)).find { |p| File.file?(p) }\r\n        raise ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_exe_nao_encontrado) unless bin\r\n\r\n        FileUtils.mkdir_p(target_dir) unless Dir.exist?(target_dir)\r\n        FileUtils.cp(bin, target_exe)\r\n        unless win\r\n          FileUtils.chmod(0o755, target_exe)\r\n          system(\"xattr -d com.apple.quarantine '#{target_exe}' 2>/dev/null\")\r\n        end\r\n\r\n        UI.messagebox(\"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_sucesso)}\\n#{target_exe}\")\r\n        puts \"OK: #{target_exe}\"\r\n      rescue => e\r\n        UI.messagebox(\"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_falhou)} #{e.message}\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_abrindo_nav)}\")\r\n        UI.openURL(url)\r\n      end\r\n    end\r\n  end\r\nRUBY\r\n\r\n# --- Módulo WindowUtils ---\r\nmodule WindowUtils\r\n  extend Fiddle::Importer\r\n  dlload 'user32.dll' if Sketchup.platform == :platform_win\r\n\r\n  if Sketchup.platform == :platform_win\r\n    typealias 'HWND', 'void*'\r\n    extern 'HWND GetActiveWindow()'\r\n    extern 'HWND GetForegroundWindow()'\r\n    extern 'HWND GetWindow(HWND, int)'\r\n    extern 'int GetWindowRect(HWND, void*)'\r\n    extern 'HWND GetParent(HWND)'\r\n    \r\n    GW_CHILD = 5 unless defined?(GW_CHILD)\r\n    GW_HWNDNEXT = 2 unless defined?(GW_HWNDNEXT)\r\n    Rect = struct ['long left', 'long top', 'long right', 'long bottom'] unless defined?(Rect)\r\n  end\r\n\r\n  def self.get_viewport_rect_deep(view)\r\n    return nil unless Sketchup.platform == :platform_win\r\n    \r\n    hwnd = GetForegroundWindow()\r\n    return nil if hwnd.nil? || hwnd == 0\r\n\r\n    vw = view.vpwidth\r\n    vh = view.vpheight\r\n    \r\n    found = find_recursive(hwnd, vw, vh)\r\n    return found if found\r\n\r\n    parent = GetParent(hwnd)\r\n    if parent && parent != 0\r\n      found = find_recursive(parent, vw, vh)\r\n      return found if found\r\n    end\r\n\r\n    nil\r\n  end\r\n\r\n  def self.find_recursive(parent_hwnd, target_w, target_h)\r\n    child = GetWindow(parent_hwnd, GW_CHILD)\r\n    while child && child.to_i != 0\r\n      rect = Rect.malloc\r\n      if GetWindowRect(child, rect) != 0\r\n        w = rect.right - rect.left\r\n        h = rect.bottom - rect.top\r\n        match = check_match(w, h, target_w, target_h, rect)\r\n        return match if match\r\n      end\r\n      found_in_child = find_recursive(child, target_w, target_h)\r\n      return found_in_child if found_in_child\r\n      child = GetWindow(child, GW_HWNDNEXT)\r\n    end\r\n    nil\r\n  end\r\n\r\n  def self.check_match(w, h, target_w, target_h, rect)\r\n    tol = 30\r\n    [1.0, 1.25, 1.5, 2.0].each do |scale|\r\n      if (w - target_w * scale).abs <= tol && (h - target_h * scale).abs <= tol\r\n        return { :x => rect.left, :y => rect.top, :w => w, :h => h, :scale => scale }\r\n      end\r\n    end\r\n    nil\r\n  end\r\nend\r\n\r\n# --- Módulo ScreenCapture (GDI32) ---\r\n# Captures the SketchUp viewport via Win32 GDI and produces a BMP thumbnail\r\n# encoded as Base64, suitable for embedding in an HTML <img> tag.\r\n#\r\n# Uses Fiddle::Importer (Ruby stdlib) to call gdi32.dll and user32.dll functions.\r\n# Also declares PrintWindow from user32.dll as a fallback for occluded windows.\r\n#\r\n# Fiddle type mapping reference (from fiddle/types.rb Win32Types):\r\n#   HANDLE / HDC / HWND / HBITMAP  ->  void*   (pointer-sized, correct for 32/64-bit)\r\n#   DWORD                          ->  unsigned long\r\n#   BOOL                           ->  int\r\n#   UINT                           ->  unsigned int\r\n#\r\n# The extern signatures below use 'void*' directly for all handle types\r\n# (HDC, HBITMAP, HGDIOBJ) so we do not need to include Fiddle::Win32Types\r\n# or add custom typealiases beyond what WindowUtils already defines.\r\nmodule ScreenCapture\r\n  extend Fiddle::Importer\r\n\r\n  if Sketchup.platform == :platform_win\r\n    dlload 'gdi32.dll', 'user32.dll'\r\n\r\n    # --- user32.dll functions ---\r\n    # HDC GetDC(HWND hWnd)\r\n    #   hWnd=NULL(0) returns DC for entire screen\r\n    extern 'void* GetDC(void*)'\r\n\r\n    # int ReleaseDC(HWND hWnd, HDC hDC)\r\n    extern 'int ReleaseDC(void*, void*)'\r\n\r\n    # BOOL PrintWindow(HWND hwnd, HDC hdcBlt, UINT nFlags)\r\n    #   Asks the window to paint itself into the given DC.\r\n    #   Works even when the window is partially occluded (unlike BitBlt from screen DC).\r\n    extern 'int PrintWindow(void*, void*, unsigned int)'\r\n\r\n    # --- gdi32.dll functions ---\r\n    # HDC CreateCompatibleDC(HDC hdc)\r\n    extern 'void* CreateCompatibleDC(void*)'\r\n\r\n    # HBITMAP CreateCompatibleBitmap(HDC hdc, int cx, int cy)\r\n    extern 'void* CreateCompatibleBitmap(void*, int, int)'\r\n\r\n    # HGDIOBJ SelectObject(HDC hdc, HGDIOBJ h)\r\n    extern 'void* SelectObject(void*, void*)'\r\n\r\n    # BOOL BitBlt(HDC hdc, int x, int y, int cx, int cy,\r\n    #             HDC hdcSrc, int x1, int y1, DWORD rop)\r\n    extern 'int BitBlt(void*, int, int, int, int, void*, int, int, unsigned long)'\r\n\r\n    # BOOL StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest,\r\n    #                 HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop)\r\n    extern 'int StretchBlt(void*, int, int, int, int, void*, int, int, int, int, unsigned long)'\r\n\r\n    # int SetStretchBltMode(HDC hdc, int mode)\r\n    extern 'int SetStretchBltMode(void*, int)'\r\n\r\n    # int GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines,\r\n    #               LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage)\r\n    #   lpvBits and lpbmi are both void* (raw pointers to caller-allocated buffers)\r\n    extern 'int GetDIBits(void*, void*, unsigned int, unsigned int, void*, void*, unsigned int)'\r\n\r\n    # BOOL DeleteDC(HDC hdc)\r\n    extern 'int DeleteDC(void*)'\r\n\r\n    # BOOL DeleteObject(HGDIOBJ ho)\r\n    extern 'int DeleteObject(void*)'\r\n\r\n    # --- Raster-operation and mode constants ---\r\n    SRCCOPY        = 0x00CC0020 unless defined?(SRCCOPY)\r\n    HALFTONE       = 4 unless defined?(HALFTONE)          # SetStretchBltMode mode for high-quality shrinking\r\n    DIB_RGB_COLORS = 0 unless defined?(DIB_RGB_COLORS)    # GetDIBits color table usage\r\n\r\n    # --- PrintWindow flags ---\r\n    PW_CLIENTONLY          = 0x00000001 unless defined?(PW_CLIENTONLY)          # capture client area only (no title bar)\r\n    PW_RENDERFULLCONTENT   = 0x00000002 unless defined?(PW_RENDERFULLCONTENT)  # Win 8.1+: captures DirectX/DWM content\r\n  end\r\n\r\n  # Build a 40-byte BITMAPINFOHEADER as a packed binary string.\r\n  #\r\n  # The BITMAPINFOHEADER struct layout (40 bytes total):\r\n  #   DWORD  biSize          (4 bytes, unsigned 32-bit LE)   = 40\r\n  #   LONG   biWidth         (4 bytes, signed   32-bit LE)\r\n  #   LONG   biHeight        (4 bytes, signed   32-bit LE)   negative = top-down DIB\r\n  #   WORD   biPlanes        (2 bytes, unsigned 16-bit LE)   = 1\r\n  #   WORD   biBitCount      (2 bytes, unsigned 16-bit LE)   = 24 for RGB\r\n  #   DWORD  biCompression   (4 bytes, unsigned 32-bit LE)   = 0 (BI_RGB)\r\n  #   DWORD  biSizeImage     (4 bytes, unsigned 32-bit LE)\r\n  #   LONG   biXPelsPerMeter (4 bytes, signed   32-bit LE)   = 0\r\n  #   LONG   biYPelsPerMeter (4 bytes, signed   32-bit LE)   = 0\r\n  #   DWORD  biClrUsed       (4 bytes, unsigned 32-bit LE)   = 0\r\n  #   DWORD  biClrImportant  (4 bytes, unsigned 32-bit LE)   = 0\r\n  #\r\n  # Pack template: 'L<' = uint32 LE, 'l<' = int32 LE, 'S<' = uint16 LE\r\n  # Combined: 'L< l< l< S< S< L< L< l< l< L< L<'  (spaces for clarity)\r\n  #\r\n  # Using negative biHeight produces a top-down DIB, which means:\r\n  #  - Row 0 in memory is the top row of the image\r\n  #  - No vertical flip is needed when writing the BMP file\r\n  #  - The BMP file header must also use the negative height to match\r\n  def self.pack_bitmapinfoheader(width, height, image_size)\r\n    [\r\n      40,           # biSize\r\n      width,        # biWidth\r\n      -height,      # biHeight (negative = top-down)\r\n      1,            # biPlanes\r\n      24,           # biBitCount (24-bit RGB)\r\n      0,            # biCompression (BI_RGB = uncompressed)\r\n      image_size,   # biSizeImage\r\n      0,            # biXPelsPerMeter\r\n      0,            # biYPelsPerMeter\r\n      0,            # biClrUsed\r\n      0             # biClrImportant\r\n    ].pack('L<l<l<S<S<L<L<l<l<L<L<')\r\n  end\r\n\r\n  # Build the 14-byte BMP file header (BITMAPFILEHEADER).\r\n  #\r\n  # Layout:\r\n  #   WORD   bfType      = 0x4D42 (\"BM\")\r\n  #   DWORD  bfSize      = total file size in bytes\r\n  #   WORD   bfReserved1 = 0\r\n  #   WORD   bfReserved2 = 0\r\n  #   DWORD  bfOffBits   = offset to pixel data = 14 + 40 = 54\r\n  #\r\n  # Pack template: 'S< L< S< S< L<'\r\n  def self.pack_bmp_file_header(pixel_data_size)\r\n    file_size = 14 + 40 + pixel_data_size\r\n    [\r\n      0x4D42,       # bfType (\"BM\")\r\n      file_size,    # bfSize\r\n      0,            # bfReserved1\r\n      0,            # bfReserved2\r\n      54            # bfOffBits (14-byte file header + 40-byte info header)\r\n    ].pack('S<L<S<S<L<')\r\n  end\r\n\r\n  # Capture the SketchUp viewport as a scaled-down BMP thumbnail and return\r\n  # a Base64-encoded string. Returns nil on failure (non-Windows, HWND not found, etc.).\r\n  #\r\n  # Strategy:\r\n  #   1. StretchBlt from screen DC (fast, works when viewport is visible)\r\n  #   2. If vp[:hwnd] is available, PrintWindow can be used as alternative\r\n  #\r\n  # Parameters:\r\n  #   view     - Sketchup::View instance\r\n  #   thumb_w  - desired thumbnail width  in pixels (default 96)\r\n  #   thumb_h  - desired thumbnail height in pixels (default 60)\r\n  #\r\n  # Returns: Base64-encoded BMP string, or nil on failure.\r\n  def self.capture_viewport(view, thumb_w = 96, thumb_h = 60)\r\n    return nil unless Sketchup.platform == :platform_win\r\n\r\n    vp = WindowUtils.get_viewport_rect_deep(view)\r\n    return nil unless vp\r\n\r\n    src_w = vp[:w]\r\n    src_h = vp[:h]\r\n\r\n    # Get screen DC -- needed for CreateCompatibleBitmap color depth\r\n    screen_dc = GetDC(0)\r\n    return nil if screen_dc.nil? || screen_dc.to_i == 0\r\n\r\n    begin\r\n      # Create a memory DC compatible with the screen\r\n      mem_dc = CreateCompatibleDC(screen_dc)\r\n      return nil if mem_dc.nil? || mem_dc.to_i == 0\r\n\r\n      begin\r\n        # Create a bitmap at the desired thumbnail size\r\n        bmp = CreateCompatibleBitmap(screen_dc, thumb_w, thumb_h)\r\n        return nil if bmp.nil? || bmp.to_i == 0\r\n\r\n        begin\r\n          old = SelectObject(mem_dc, bmp)\r\n          SetStretchBltMode(mem_dc, HALFTONE)\r\n\r\n          # StretchBlt from the screen DC directly into the thumbnail-sized bitmap.\r\n          # This both captures AND scales in a single operation.\r\n          ok = StretchBlt(\r\n            mem_dc, 0, 0, thumb_w, thumb_h,\r\n            screen_dc, vp[:x], vp[:y], src_w, src_h,\r\n            SRCCOPY\r\n          )\r\n          return nil if ok == 0\r\n\r\n          # IMPORTANT: Deselect the bitmap from the DC before calling GetDIBits.\r\n          # Per MSDN: \"The bitmap identified by hbmp must not be selected into\r\n          # a device context when the application calls this function.\"\r\n          SelectObject(mem_dc, old)\r\n          old = nil\r\n\r\n          # Calculate row stride (BMP rows must be padded to 4-byte boundaries)\r\n          stride     = ((thumb_w * 3 + 3) & ~3)\r\n          pixel_size = stride * thumb_h\r\n\r\n          # Pack the BITMAPINFOHEADER into a Fiddle::Pointer buffer.\r\n          # GetDIBits may modify the header (e.g., filling in biSizeImage),\r\n          # so we use a mutable native buffer rather than a Ruby String.\r\n          bmi_bytes = pack_bitmapinfoheader(thumb_w, thumb_h, pixel_size)\r\n          bmi_ptr   = Fiddle::Pointer.malloc(bmi_bytes.bytesize)\r\n          bmi_ptr[0, bmi_bytes.bytesize] = bmi_bytes\r\n\r\n          # Allocate the pixel data buffer\r\n          buf = Fiddle::Pointer.malloc(pixel_size)\r\n\r\n          begin\r\n            # GetDIBits(hdc, hbm, start, cLines, lpvBits, lpbmi, usage)\r\n            # hdc: a DC compatible with the bitmap (mem_dc works)\r\n            # hbm: the bitmap handle (NOT selected into any DC)\r\n            rows = GetDIBits(mem_dc, bmp, 0, thumb_h, buf, bmi_ptr, DIB_RGB_COLORS)\r\n            return nil if rows == 0\r\n\r\n            # Read the raw pixel bytes from the Fiddle::Pointer buffer.\r\n            # ptr[offset, length] returns a Ruby String (binary safe, works since Ruby 2.0).\r\n            pixel_data = buf[0, pixel_size]\r\n\r\n            # Assemble the complete BMP file: file header + info header + pixel data\r\n            file_hdr = pack_bmp_file_header(pixel_size)\r\n            info_hdr = pack_bitmapinfoheader(thumb_w, thumb_h, pixel_size)\r\n\r\n            Base64.strict_encode64(file_hdr + info_hdr + pixel_data)\r\n          ensure\r\n            Fiddle.free(bmi_ptr) if bmi_ptr\r\n            Fiddle.free(buf)     if buf\r\n          end\r\n        ensure\r\n          SelectObject(mem_dc, old) if old\r\n          DeleteObject(bmp)\r\n        end\r\n      ensure\r\n        DeleteDC(mem_dc)\r\n      end\r\n    ensure\r\n      ReleaseDC(0, screen_dc)\r\n    end\r\n  rescue => e\r\n    puts \"ScreenCapture error: #{e.message}\"\r\n    puts e.backtrace.first(5).join(\"\\n\")\r\n    nil\r\n  end\r\nend\r\n\r\nmodule TourPlugin\r\n  class AreaSelectorTool\r\n    def initialize(callback)\r\n      @callback = callback\r\n      @start_x = nil; @start_y = nil; @current_x = nil; @current_y = nil\r\n      @drawing = false\r\n    end\r\n\r\n    def activate\r\n      Sketchup.active_model.active_view.invalidate\r\n      Sketchup.status_text = ScriptUpComunidade::TourVirtual.obter_texto(:status_clicar_arrastar)\r\n    end\r\n\r\n    def onLButtonDown(flags, x, y, view)\r\n      @start_x = x; @start_y = y; @current_x = x; @current_y = y\r\n      @drawing = true\r\n    end\r\n\r\n    def onMouseMove(flags, x, y, view)\r\n      if @drawing\r\n        @current_x = x; @current_y = y\r\n        view.invalidate\r\n      end\r\n    end\r\n\r\n    def onLButtonUp(flags, x, y, view)\r\n      return unless @drawing\r\n      @drawing = false\r\n      x1 = [@start_x, @current_x].min\r\n      y1 = [@start_y, @current_y].min\r\n      x2 = [@start_x, @current_x].max\r\n      y2 = [@start_y, @current_y].max\r\n      width = x2 - x1\r\n      height = y2 - y1\r\n\r\n      if width < 50 || height < 50\r\n        UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:area_pequena))\r\n        Sketchup.active_model.select_tool(nil)\r\n        return\r\n      end\r\n\r\n      @callback.call({ :x => x1, :y => y1, :w => width, :h => height })\r\n      Sketchup.active_model.select_tool(nil) \r\n    end\r\n\r\n    def draw(view)\r\n      return unless @drawing && @start_x && @current_x\r\n      points = [\r\n        Geom::Point3d.new(@start_x, @start_y, 0),\r\n        Geom::Point3d.new(@current_x, @start_y, 0),\r\n        Geom::Point3d.new(@current_x, @current_y, 0),\r\n        Geom::Point3d.new(@start_x, @current_y, 0)\r\n      ]\r\n      view.line_width = 3\r\n      view.drawing_color = 'red'\r\n      view.draw2d(GL_LINE_LOOP, points)\r\n    end\r\n  end\r\n\r\n  class ExportPreviewTool\r\n    def initialize(target_w, target_h)\r\n      @target_w = target_w\r\n      @target_h = target_h\r\n    end\r\n\r\n    def activate\r\n      Sketchup.active_model.active_view.invalidate\r\n    end\r\n\r\n    def deactivate(view)\r\n      view.invalidate\r\n    end\r\n\r\n    def draw(view)\r\n      vw = view.vpwidth\r\n      vh = view.vpheight\r\n      ew = [@target_w, vw].min\r\n      eh = [@target_h, vh].min\r\n      ox = (vw - ew) / 2\r\n      oy = (vh - eh) / 2\r\n\r\n      # Escurecer áreas fora da gravação (letterbox/pillarbox)\r\n      view.drawing_color = Sketchup::Color.new(0, 0, 0, 120)\r\n      if oy > 0\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(0, 0, 0), Geom::Point3d.new(vw, 0, 0),\r\n          Geom::Point3d.new(vw, oy, 0), Geom::Point3d.new(0, oy, 0)\r\n        ])\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(0, oy + eh, 0), Geom::Point3d.new(vw, oy + eh, 0),\r\n          Geom::Point3d.new(vw, vh, 0), Geom::Point3d.new(0, vh, 0)\r\n        ])\r\n      end\r\n      if ox > 0\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(0, oy, 0), Geom::Point3d.new(ox, oy, 0),\r\n          Geom::Point3d.new(ox, oy + eh, 0), Geom::Point3d.new(0, oy + eh, 0)\r\n        ])\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(ox + ew, oy, 0), Geom::Point3d.new(vw, oy, 0),\r\n          Geom::Point3d.new(vw, oy + eh, 0), Geom::Point3d.new(ox + ew, oy + eh, 0)\r\n        ])\r\n      end\r\n\r\n      # Borda branca ao redor da área de gravação\r\n      view.line_width = 2\r\n      view.drawing_color = Sketchup::Color.new(255, 255, 255, 200)\r\n      view.draw2d(GL_LINE_LOOP, [\r\n        Geom::Point3d.new(ox, oy, 0), Geom::Point3d.new(ox + ew, oy, 0),\r\n        Geom::Point3d.new(ox + ew, oy + eh, 0), Geom::Point3d.new(ox, oy + eh, 0)\r\n      ])\r\n    end\r\n  end\r\n\r\n  module CameraTimeline\r\n    def self.obter_texto(chave)\r\n      ScriptUpComunidade::TourVirtual.obter_texto(chave)\r\n    end\r\n\r\n    module GlobalKey\r\n      extend Fiddle::Importer\r\n      if Sketchup.platform == :platform_win\r\n        dlload 'user32.dll'\r\n        extern 'short GetAsyncKeyState(int)'\r\n      else\r\n        dlload '/System/Library/Frameworks/ApplicationServices.framework/ApplicationServices'\r\n        extern 'bool CGEventSourceKeyState(int, int)'\r\n      end\r\n\r\n      DEFAULT_HOTKEY = (Sketchup.platform == :platform_win ? 0x6B : 69) unless defined?(DEFAULT_HOTKEY)\r\n      @key_code = Sketchup.read_default(\"TourVirtual\", \"Hotkey\", DEFAULT_HOTKEY).to_i\r\n      @ctrl = Sketchup.read_default(\"TourVirtual\", \"HotkeyCtrl\", false)\r\n      @alt = Sketchup.read_default(\"TourVirtual\", \"HotkeyAlt\", false)\r\n      @shift = Sketchup.read_default(\"TourVirtual\", \"HotkeyShift\", false)\r\n\r\n      # Windows virtual key codes for modifiers\r\n      VK_CONTROL = 0x11 unless defined?(VK_CONTROL)\r\n      VK_MENU    = 0x12 unless defined?(VK_MENU)\r\n      VK_SHIFT   = 0x10 unless defined?(VK_SHIFT)\r\n      # macOS key codes for modifiers\r\n      MAC_CTRL  = 59 unless defined?(MAC_CTRL)\r\n      MAC_SHIFT = 56 unless defined?(MAC_SHIFT)\r\n      MAC_ALT   = 58 unless defined?(MAC_ALT)\r\n\r\n      def self.set_hotkey(code, ctrl, alt, shift)\r\n        @key_code = code.to_i\r\n        @ctrl = ctrl\r\n        @alt = alt\r\n        @shift = shift\r\n      end\r\n\r\n      def self.key_code; @key_code; end\r\n      def self.ctrl; @ctrl; end\r\n      def self.alt; @alt; end\r\n      def self.shift; @shift; end\r\n\r\n      def self.key_pressed?(code)\r\n        if Sketchup.platform == :platform_win\r\n          GetAsyncKeyState(code) & 0x8000 != 0\r\n        else\r\n          CGEventSourceKeyState(0, code)\r\n        end\r\n      end\r\n\r\n      def self.space_pressed?\r\n        return false unless key_pressed?(@key_code)\r\n        if Sketchup.platform == :platform_win\r\n          return false if @ctrl && !key_pressed?(VK_CONTROL)\r\n          return false if @alt && !key_pressed?(VK_MENU)\r\n          return false if @shift && !key_pressed?(VK_SHIFT)\r\n        else\r\n          return false if @ctrl && !key_pressed?(MAC_CTRL)\r\n          return false if @alt && !key_pressed?(MAC_ALT)\r\n          return false if @shift && !key_pressed?(MAC_SHIFT)\r\n        end\r\n        true\r\n      end\r\n    end\r\n\r\n    def self.start_space_timer\r\n      return if defined?(@space_timer) && @space_timer\r\n      @space_down = false\r\n      @space_timer = UI.start_timer(0.1, true) do\r\n        if GlobalKey.space_pressed?\r\n          unless @space_down\r\n            @space_down = true\r\n            @dialog.execute_script('triggerSpaceFromRuby()')\r\n          end\r\n        else\r\n          @space_down = false\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.stop_space_timer\r\n      if defined?(@space_timer) && @space_timer\r\n        UI.stop_timer(@space_timer)\r\n        @space_timer = nil\r\n      end\r\n    end\r\n\r\n    def self.capture_thumbnail\r\n      view = Sketchup.active_model.active_view\r\n      # Tentar screen capture instantâneo via GDI32 (Windows)\r\n      result = ScreenCapture.capture_viewport(view, 96, 60) rescue nil\r\n      return result if result && result.length > 0\r\n      # Fallback: write_image (lento, mas funciona em qualquer plataforma)\r\n      path = File.join(Dir.tmpdir, \"thumb_#{Time.now.to_i}.jpg\")\r\n      view.write_image(path, 96, 60, false, 0.5)\r\n      encoded = Base64.strict_encode64(File.binread(path))\r\n      File.delete(path) if File.exist?(path)\r\n      encoded\r\n    end\r\n\r\n    # --- Lógica de Exportação ---\r\n    def self.calcular_rect_gravacao(export_width, export_height)\r\n      view = Sketchup.active_model.active_view\r\n      viewport_global = WindowUtils.get_viewport_rect_deep(view)\r\n\r\n      unless viewport_global\r\n        viewport_global = { :x => 0, :y => 0, :w => view.vpwidth, :h => view.vpheight, :scale => 1.0 }\r\n      end\r\n\r\n      vp_w = viewport_global[:w]\r\n      vp_h = viewport_global[:h]\r\n\r\n      final_w = [export_width.to_i, vp_w].min\r\n      final_h = [export_height.to_i, vp_h].min\r\n\r\n      offset_x = viewport_global[:x] + ((vp_w - final_w) / 2).to_i\r\n      offset_y = viewport_global[:y] + ((vp_h - final_h) / 2).to_i\r\n\r\n      final_w -= 1 if final_w.odd?\r\n      final_h -= 1 if final_h.odd?\r\n\r\n      { :x => offset_x, :y => offset_y, :w => final_w, :h => final_h }\r\n    end\r\n\r\n    def self.iniciar_processo_exportacao(json_data, use_easing, start_index_from_js, export_width, export_height, filename)\r\n      effective_index = start_index_from_js.to_i\r\n\r\n      if effective_index == 0\r\n        @dialog.execute_script(\"currentIndex = 0; updateTime(0); sketchup.goto_camera(JSON.stringify(visoes[0]));\")\r\n        sleep(0.5)\r\n      end\r\n\r\n      rect = calcular_rect_gravacao(export_width, export_height)\r\n      executar_gravacao_ffmpeg(json_data, use_easing, rect, effective_index, filename)\r\n    end\r\n\r\n    def self.iniciar_processo_exportacao_projeto(all_timelines_json, use_easing, active_tl_index, start_vision_index, export_width, export_height, filename)\r\n      timelines = JSON.parse(all_timelines_json, symbolize_names: true)\r\n      rect = calcular_rect_gravacao(export_width, export_height)\r\n\r\n      start_tl = active_tl_index.to_i\r\n      start_vision = start_vision_index.to_i\r\n\r\n      # Calcular duração total a partir do ponto de início\r\n      total_time = 0.0\r\n      timelines.each_with_index do |tl, i|\r\n        next if i < start_tl\r\n        next unless tl[:visoes] && tl[:visoes].length >= 2\r\n        sorted = tl[:visoes].sort_by { |v| v[:time] }\r\n        first_v = (i == start_tl && start_vision > 0 && start_vision < sorted.length) ? start_vision : 0\r\n        if first_v < sorted.length - 1\r\n          total_time += sorted.last[:time] - sorted[first_v][:time]\r\n          total_time += 0.5\r\n        end\r\n      end\r\n\r\n      play_cmd = \"startRecordingPlayAll(#{start_tl}, #{start_vision})\"\r\n      executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, play_cmd)\r\n    end\r\n\r\n    def self.executar_gravacao_ffmpeg(json_data, use_easing, rect, start_index, filename)\r\n      camera_keys = JSON.parse(json_data, symbolize_names: true)\r\n      camera_keys.sort_by! { |v| v[:time] }\r\n\r\n      total_time = 0\r\n      if start_index < camera_keys.length - 1\r\n        relevant_keys = camera_keys[start_index..-1]\r\n        relevant_keys.each_cons(2) { |c, n| total_time += (n[:time] - c[:time]).abs }\r\n      end\r\n\r\n      executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, \"triggerSpaceFromRuby()\")\r\n    end\r\n\r\n    def self.executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, play_command)\r\n      folder = UI.select_directory(title: obter_texto(:selecionar_pasta))\r\n      return unless folder\r\n\r\n      output_path = File.join(folder, \"#{filename}.mp4\")\r\n\r\n      is_win = Sketchup.platform == :platform_win\r\n      ffmpeg_path = File.join(PLUGIN_DIR, 'ffmpeg', is_win ? 'ffmpeg.exe' : 'ffmpeg')\r\n\r\n      unless File.exist?(ffmpeg_path)\r\n        UI.messagebox(obter_texto(:ffmpeg_nao_encontrado))\r\n        return\r\n      end\r\n\r\n      duration_padding = 4.0\r\n      recording_duration = total_time + duration_padding\r\n\r\n      input_format = is_win ? 'gdigrab' : 'avfoundation'\r\n      input_source = is_win ? 'desktop' : '1:none'\r\n\r\n      cmd_array = [\r\n        \"\\\"#{ffmpeg_path}\\\"\",\r\n        '-y',\r\n        '-f', input_format,\r\n        '-framerate', '30',\r\n        '-t', recording_duration.to_s\r\n      ]\r\n\r\n      if is_win\r\n        cmd_array.concat([\r\n          '-draw_mouse', '0',\r\n          '-offset_x', rect[:x].to_s,\r\n          '-offset_y', rect[:y].to_s,\r\n          '-video_size', \"#{rect[:w]}x#{rect[:h]}\",\r\n          '-i', input_source\r\n        ])\r\n      else\r\n        cmd_array.concat([\r\n          '-i', input_source,\r\n          '-vf', \"crop=#{rect[:w]}:#{rect[:h]}:#{rect[:x]}:#{rect[:y]}\"\r\n        ])\r\n      end\r\n\r\n      cmd_array.concat([\r\n        '-c:v', 'libx264',\r\n        '-preset', 'ultrafast',\r\n        '-pix_fmt', 'yuv420p',\r\n        \"\\\"#{output_path}\\\"\"\r\n      ])\r\n\r\n      cmd = cmd_array.join(' ')\r\n\r\n      begin\r\n        if is_win\r\n           WIN32OLE.new('WScript.Shell').Run(cmd, 0, false)\r\n        else\r\n           pid = spawn(cmd)\r\n           Process.detach(pid)\r\n        end\r\n      rescue => e\r\n        UI.messagebox(\"#{obter_texto(:erro_gravador)}#{e.message}\")\r\n        return\r\n      end\r\n\r\n      sleep(1.5)\r\n\r\n      @dialog.execute_script(\"showRecordingIndicator()\")\r\n      @dialog.execute_script(play_command)\r\n\r\n      UI.start_timer(recording_duration + 1.0, false) do\r\n        @dialog.execute_script(\"hideRecordingIndicator()\")\r\n        UI.messagebox(\"#{obter_texto(:gravacao_finalizada)}#{output_path}\")\r\n        @dialog.execute_script(\"resetPlayButton(); resetPlayAll();\")\r\n      end\r\n    end\r\n\r\n    def self.start_ui\r\n      current_hotkey = GlobalKey.key_code\r\n      hotkey_ctrl = GlobalKey.ctrl ? 'true' : 'false'\r\n      hotkey_alt = GlobalKey.alt ? 'true' : 'false'\r\n      hotkey_shift = GlobalKey.shift ? 'true' : 'false'\r\n      ffmpeg_path = File.join(PLUGIN_DIR, 'ffmpeg', Sketchup.platform == :platform_win ? 'ffmpeg.exe' : 'ffmpeg')\r\n      \r\n      has_ffmpeg = File.exist?(ffmpeg_path)\r\n\r\n      view = Sketchup.active_model.active_view\r\n      vp_width = view.vpwidth\r\n      vp_height = view.vpheight\r\n\r\n      js_i18n_hash = {}\r\n      IDIOMAS[IDIOMAS.key?(Sketchup.get_locale) ? Sketchup.get_locale : 'en-US'].each { |k, v| js_i18n_hash[k] = v }\r\n      js_i18n_json = js_i18n_hash.to_json\r\n\r\n      html = <<-HTML\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n  <meta charset=\"utf-8\">\r\n  <title>#{obter_texto(:titulo)}</title>\r\n  <style>\r\n    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }\r\n    body {\r\n      font-family: system-ui, -apple-system, 'Segoe UI', sans-serif;\r\n      background: #f5f5f5; color: #333; font-size: 13px;\r\n      padding: 16px; line-height: 1.4;\r\n    }\r\n\r\n    /* Header */\r\n    .header {\r\n      display: flex; align-items: center; gap: 10px;\r\n      padding-bottom: 14px; border-bottom: 2px solid #0066cc;\r\n      margin-bottom: 16px;\r\n    }\r\n    .header svg { flex-shrink: 0; }\r\n    .header h1 { font-size: 17px; font-weight: 700; color: #1a1a1a; }\r\n    .header .subtitle { font-size: 11px; color: #888; font-weight: 400; }\r\n\r\n    /* Cards */\r\n    .card {\r\n      background: #fff; border: 1px solid #e0e0e0; border-radius: 8px;\r\n      box-shadow: 0 1px 3px rgba(0,0,0,0.06); margin-bottom: 12px;\r\n      overflow: hidden;\r\n    }\r\n    .card-header {\r\n      display: flex; align-items: center; justify-content: space-between;\r\n      padding: 10px 14px; background: #fafafa; border-bottom: 1px solid #eee;\r\n      cursor: pointer; user-select: none;\r\n    }\r\n    .card-header h2 { font-size: 13px; font-weight: 600; color: #444; }\r\n    .card-header .toggle-icon { font-size: 11px; color: #999; transition: transform 0.2s; }\r\n    .card-header.collapsed .toggle-icon { transform: rotate(-90deg); }\r\n    .card-body { padding: 14px; }\r\n    .card-body.collapsed { display: none; }\r\n\r\n    /* Timeline */\r\n    .timeline-wrapper { position: relative; padding: 8px 0 20px; }\r\n    .timeline-track {\r\n      position: absolute; top: 20px; left: 6px; right: 6px; height: 4px;\r\n      background: #ddd; border-radius: 2px; z-index: 0;\r\n    }\r\n    #timeline_range {\r\n      -webkit-appearance: none; appearance: none; width: 100%;\r\n      height: 6px; background: transparent; outline: none;\r\n      position: relative; z-index: 2; cursor: pointer;\r\n    }\r\n    #timeline_range::-webkit-slider-runnable-track {\r\n      height: 6px; background: linear-gradient(90deg, #0066cc 0%, #4da6ff 100%);\r\n      border-radius: 3px;\r\n    }\r\n    #timeline_range::-webkit-slider-thumb {\r\n      -webkit-appearance: none; width: 16px; height: 16px;\r\n      background: #0066cc; border: 2px solid #fff; border-radius: 50%;\r\n      margin-top: -5px; cursor: grab; box-shadow: 0 1px 4px rgba(0,0,0,0.2);\r\n    }\r\n    #timeline_range::-webkit-slider-thumb:active { cursor: grabbing; transform: scale(1.15); }\r\n    #markers_layer {\r\n      position: absolute; top: 0; left: 0; width: 100%; height: 40px;\r\n      pointer-events: none; z-index: 3;\r\n    }\r\n    .marker {\r\n      position: absolute; top: 26px; width: 14px; height: 14px;\r\n      background: #0066cc; border-radius: 50%; border: 2px solid #fff;\r\n      transform: translateX(-50%); pointer-events: auto; cursor: pointer;\r\n      box-shadow: 0 1px 3px rgba(0,0,0,0.15); transition: transform 0.15s, background 0.15s;\r\n    }\r\n    .marker:hover { transform: translateX(-50%) scale(1.25); }\r\n    .marker.anchor { background: #dc3545; }\r\n    .marker .marker-tooltip {\r\n      position: absolute; bottom: 18px; left: 50%; transform: translateX(-50%);\r\n      background: #333; color: #fff; font-size: 10px; padding: 2px 6px;\r\n      border-radius: 3px; white-space: nowrap; opacity: 0;\r\n      pointer-events: none; transition: opacity 0.15s;\r\n    }\r\n    .marker:hover .marker-tooltip { opacity: 1; }\r\n    .time-row {\r\n      display: flex; align-items: center; justify-content: space-between;\r\n      margin-top: 8px; gap: 12px;\r\n    }\r\n    .time-display { font-size: 20px; font-weight: 700; color: #0066cc; font-variant-numeric: tabular-nums; }\r\n    .time-display small { font-size: 12px; color: #888; font-weight: 400; }\r\n    .time-input-group { display: flex; align-items: center; gap: 6px; }\r\n    .time-input-group label { font-size: 11px; color: #666; }\r\n\r\n    /* Buttons */\r\n    .btn {\r\n      display: inline-flex; align-items: center; justify-content: center; gap: 6px;\r\n      padding: 7px 14px; border: 1px solid transparent; border-radius: 6px;\r\n      font-size: 12px; font-weight: 500; cursor: pointer;\r\n      transition: all 0.15s; outline: none; font-family: inherit;\r\n    }\r\n    .btn:active { transform: scale(0.97); }\r\n    .btn-primary { background: #0066cc; color: #fff; }\r\n    .btn-primary:hover { background: #0052a3; }\r\n    .btn-success { background: #28a745; color: #fff; }\r\n    .btn-success:hover { background: #218838; }\r\n    .btn-danger { background: #dc3545; color: #fff; }\r\n    .btn-danger:hover { background: #c82333; }\r\n    .btn-outline { background: transparent; border: 1px solid #ccc; color: #555; }\r\n    .btn-outline:hover { background: #f0f0f0; border-color: #aaa; }\r\n    .btn-sm { padding: 4px 10px; font-size: 11px; }\r\n    .btn-record { background: #dc3545; color: #fff; padding: 10px 20px; font-size: 13px; font-weight: 600; }\r\n    .btn-record:hover { background: #c82333; }\r\n    .btn-record:disabled { background: #ccc; color: #888; cursor: not-allowed; }\r\n\r\n    .btn-group { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }\r\n\r\n    /* Checkboxes */\r\n    .check-group { display: flex; align-items: center; gap: 16px; margin-top: 10px; }\r\n    .check-item { display: flex; align-items: center; gap: 5px; }\r\n    .check-item input[type=\"checkbox\"] {\r\n      width: 15px; height: 15px; accent-color: #0066cc; cursor: pointer;\r\n    }\r\n    .check-item label { font-size: 12px; color: #555; cursor: pointer; }\r\n\r\n    /* Hotkey */\r\n    .hotkey-editor {\r\n      display: none; align-items: center; gap: 6px;\r\n      background: #f9f9f9; padding: 6px 10px; border-radius: 6px; border: 1px solid #ddd;\r\n    }\r\n    .hotkey-editor.visible { display: inline-flex; }\r\n    .hotkey-editor input {\r\n      width: 100px; padding: 4px 8px; border: 1px solid #ccc;\r\n      border-radius: 4px; font-size: 12px; font-family: monospace;\r\n      outline: none;\r\n    }\r\n    .hotkey-editor input:focus { border-color: #0066cc; }\r\n\r\n    /* Vision List */\r\n    .vision-list { max-height: 350px; overflow-y: auto; }\r\n    .vision-list::-webkit-scrollbar { width: 6px; }\r\n    .vision-list::-webkit-scrollbar-track { background: #f0f0f0; border-radius: 3px; }\r\n    .vision-list::-webkit-scrollbar-thumb { background: #ccc; border-radius: 3px; }\r\n    .vision-list::-webkit-scrollbar-thumb:hover { background: #aaa; }\r\n    .vision-item {\r\n      display: flex; align-items: center; gap: 10px; padding: 8px 10px;\r\n      border-bottom: 1px solid #f0f0f0; cursor: pointer;\r\n      transition: background 0.12s;\r\n    }\r\n    .vision-item:hover { background: #f7faff; }\r\n    .vision-item:last-child { border-bottom: none; }\r\n    .vision-item .vision-num {\r\n      font-size: 11px; font-weight: 700; color: #999; width: 20px;\r\n      text-align: center; flex-shrink: 0;\r\n    }\r\n    .vision-item img {\r\n      width: 72px; height: 45px; object-fit: cover; border-radius: 4px;\r\n      border: 1px solid #ddd; flex-shrink: 0;\r\n    }\r\n    .vision-item img.thumb-placeholder {\r\n      background: linear-gradient(135deg, #e0e0e0 0%, #c0c0c0 100%);\r\n      animation: pulse-placeholder 1s ease-in-out infinite alternate;\r\n    }\r\n    @keyframes pulse-placeholder {\r\n      from { opacity: 0.6; }\r\n      to { opacity: 1.0; }\r\n    }\r\n    .vision-item .vision-info { flex: 1; min-width: 0; }\r\n    .vision-item .vision-time-input {\r\n      width: 58px; padding: 3px 6px; border: 1px solid #ddd; border-radius: 4px;\r\n      font-size: 12px; text-align: center; outline: none; font-family: inherit;\r\n    }\r\n    .vision-item .vision-time-input:focus { border-color: #0066cc; }\r\n    .vision-item .vision-time-input:disabled { background: #f5f5f5; color: #999; }\r\n    .vision-actions { display: flex; align-items: center; gap: 6px; flex-shrink: 0; }\r\n    .anchor-toggle {\r\n      width: 26px; height: 26px; border-radius: 50%; border: 2px solid #ddd;\r\n      background: transparent; cursor: pointer; display: flex;\r\n      align-items: center; justify-content: center; transition: all 0.15s;\r\n      font-size: 12px; color: #ccc;\r\n    }\r\n    .anchor-toggle:hover { border-color: #dc3545; color: #dc3545; }\r\n    .anchor-toggle.active { background: #dc3545; border-color: #dc3545; color: #fff; }\r\n    .delete-btn {\r\n      width: 26px; height: 26px; border-radius: 50%; border: 1px solid #eee;\r\n      background: transparent; cursor: pointer; display: flex;\r\n      align-items: center; justify-content: center; transition: all 0.15s;\r\n      font-size: 14px; color: #ccc;\r\n    }\r\n    .delete-btn:hover { background: #fee; border-color: #dc3545; color: #dc3545; }\r\n    .empty-state {\r\n      text-align: center; padding: 30px 16px; color: #aaa;\r\n    }\r\n    .empty-state svg { margin-bottom: 8px; opacity: 0.4; }\r\n    .empty-state p { font-size: 12px; }\r\n\r\n    /* Export Section */\r\n    .preset-select {\r\n      width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px;\r\n      font-size: 12px; font-family: inherit; outline: none; background: #fff;\r\n      cursor: pointer; color: #333;\r\n    }\r\n    .preset-select:focus { border-color: #0066cc; }\r\n    .preset-preview {\r\n      display: flex; align-items: center; justify-content: center;\r\n      padding: 8px; margin-top: 8px; background: #f7faff;\r\n      border: 1px dashed #b3d4fc; border-radius: 6px;\r\n      font-size: 12px; color: #0066cc; font-weight: 600;\r\n    }\r\n    .custom-dims {\r\n      display: none; gap: 8px; align-items: center; margin-top: 8px;\r\n    }\r\n    .custom-dims.visible { display: flex; }\r\n    .custom-dims input {\r\n      width: 80px; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px;\r\n      font-size: 12px; text-align: center; outline: none; font-family: inherit;\r\n    }\r\n    .custom-dims input:focus { border-color: #0066cc; }\r\n    .custom-dims span { color: #999; font-weight: 600; }\r\n\r\n    /* Recording indicator */\r\n    .recording-bar {\r\n      display: none; align-items: center; gap: 8px; padding: 10px 14px;\r\n      background: #fff5f5; border: 1px solid #f5c6cb; border-radius: 6px;\r\n      margin-top: 10px;\r\n    }\r\n    .recording-bar.active { display: flex; }\r\n    .recording-dot {\r\n      width: 10px; height: 10px; background: #dc3545; border-radius: 50%;\r\n      animation: pulse 1s infinite;\r\n    }\r\n    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }\r\n    .recording-bar span { font-size: 12px; color: #dc3545; font-weight: 600; }\r\n\r\n    /* Playing overlay */\r\n    body.playing .card { opacity: 0.6; pointer-events: none; }\r\n    body.playing .card.playback-card { opacity: 1; pointer-events: auto; }\r\n    body.playing .card.playback-card .btn:not(#play_button):not(#play_all_button) { pointer-events: none; opacity: 0.4; }\r\n    body.playing #play_button, body.playing #play_all_button { pointer-events: auto !important; opacity: 1 !important; }\r\n\r\n    /* Input base */\r\n    input[type=\"number\"] {\r\n      -moz-appearance: textfield;\r\n    }\r\n    input[type=\"number\"]::-webkit-inner-spin-button {\r\n      -webkit-appearance: none;\r\n    }\r\n\r\n    /* Draggable markers */\r\n    .marker { cursor: grab; }\r\n    .marker.dragging {\r\n      transform: translateX(-50%) scale(1.3);\r\n      z-index: 20;\r\n      cursor: grabbing;\r\n    }\r\n    .marker.no-drag { cursor: default; }\r\n\r\n    /* Saved timelines list */\r\n    .saved-timelines-list { margin-top: 10px; }\r\n    .saved-timelines-list:empty { display: none; }\r\n    .tl-item {\r\n      display: flex; align-items: center; gap: 8px;\r\n      padding: 6px 10px; border-bottom: 1px solid #f0f0f0;\r\n      cursor: pointer; transition: background 0.12s; font-size: 12px;\r\n    }\r\n    .tl-item:hover { background: #f7faff; }\r\n    .tl-item:last-child { border-bottom: none; }\r\n    .tl-item .tl-indicator {\r\n      width: 8px; height: 8px; border-radius: 50%;\r\n      background: #ccc; flex-shrink: 0;\r\n    }\r\n    .tl-item.active .tl-indicator { background: #0066cc; }\r\n    .tl-item .tl-name { flex: 1; font-weight: 500; color: #333; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }\r\n    .tl-item .tl-count { color: #999; font-size: 11px; flex-shrink: 0; }\r\n    .tl-item .tl-delete {\r\n      width: 20px; height: 20px; border-radius: 50%; border: 1px solid #eee;\r\n      background: transparent; cursor: pointer; display: flex;\r\n      align-items: center; justify-content: center; font-size: 12px; color: #ccc;\r\n      flex-shrink: 0; transition: all 0.15s;\r\n    }\r\n    .tl-item .tl-delete:hover { background: #fee; border-color: #dc3545; color: #dc3545; }\r\n\r\n    /* Drag-and-drop for timeline reordering */\r\n    .tl-drag-handle {\r\n      cursor: grab; flex-shrink: 0; color: #ccc; font-size: 14px;\r\n      padding: 0 4px; user-select: none;\r\n    }\r\n    .tl-drag-handle:active { cursor: grabbing; }\r\n    .tl-item.dragging { opacity: 0.4; }\r\n    .tl-item.drag-over-top { border-top: 2px solid #0066cc; }\r\n    .tl-item.drag-over-bottom { border-bottom: 2px solid #0066cc; }\r\n\r\n    /* Viewport info */\r\n    .viewport-info {\r\n      font-size: 11px; color: #666; margin-bottom: 10px;\r\n      padding: 6px 10px; background: #f9f9f9; border-radius: 4px; border: 1px solid #eee;\r\n    }\r\n\r\n    /* Misc */\r\n    .hidden { display: none !important; }\r\n    .mt-8 { margin-top: 8px; }\r\n  </style>\r\n</head>\r\n<body>\r\n\r\n<!-- Header -->\r\n<div class=\"header\">\r\n  <svg width=\"28\" height=\"28\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"#0066cc\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <path d=\"M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z\"/>\r\n    <circle cx=\"12\" cy=\"13\" r=\"4\"/>\r\n  </svg>\r\n  <div>\r\n    <h1>#{obter_texto(:titulo)}</h1>\r\n    <span class=\"subtitle\">#{obter_texto(:subtitulo)}</span>\r\n  </div>\r\n</div>\r\n\r\n<!-- Timeline Card -->\r\n<div class=\"card\">\r\n  <div class=\"card-body\">\r\n    <div class=\"timeline-wrapper\">\r\n      <div class=\"timeline-track\"></div>\r\n      <input type=\"range\" min=\"0\" max=\"60\" step=\"0.1\" value=\"0\" id=\"timeline_range\" oninput=\"updateTime(this.value)\">\r\n      <div id=\"markers_layer\"></div>\r\n    </div>\r\n    <div class=\"time-row\">\r\n      <div class=\"time-display\"><span id=\"current_time\">0.0</span><small>s</small></div>\r\n      <div class=\"time-input-group\">\r\n        <label>#{obter_texto(:total)}</label>\r\n        <input id=\"max_time\" type=\"number\" step=\"1\" value=\"60\" min=\"1\" onchange=\"atualizarTempoTotal()\"\r\n          style=\"width:65px; padding:4px 8px; border:1px solid #ddd; border-radius:4px; font-size:12px; text-align:center; outline:none; font-family:inherit;\">\r\n        <small style=\"color:#888;\">s</small>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Playback Controls Card -->\r\n<div class=\"card playback-card\">\r\n  <div class=\"card-body\">\r\n    <div class=\"btn-group\">\r\n      <button class=\"btn btn-primary\" onclick=\"addVision()\">\r\n        <svg width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2.5\"><line x1=\"12\" y1=\"5\" x2=\"12\" y2=\"19\"/><line x1=\"5\" y1=\"12\" x2=\"19\" y2=\"12\"/></svg>\r\n        #{obter_texto(:visao)}\r\n      </button>\r\n      <button id=\"play_button\" class=\"btn btn-success\" onclick=\"togglePlay()\">&#9654; #{obter_texto(:play)}</button>\r\n      <button id=\"play_all_button\" class=\"btn btn-outline btn-sm hidden\" onclick=\"togglePlayAll()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><polygon points=\"5 3 19 12 5 21 5 3\"/><line x1=\"19\" y1=\"3\" x2=\"19\" y2=\"21\"/></svg>\r\n        #{obter_texto(:play_all)}\r\n      </button>\r\n      <button class=\"btn btn-outline btn-sm\" onclick=\"mostrarCampoAtalho()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><rect x=\"2\" y=\"4\" width=\"20\" height=\"16\" rx=\"2\"/><line x1=\"6\" y1=\"8\" x2=\"6\" y2=\"8\"/><line x1=\"10\" y1=\"8\" x2=\"10\" y2=\"8\"/><line x1=\"14\" y1=\"8\" x2=\"14\" y2=\"8\"/><line x1=\"18\" y1=\"8\" x2=\"18\" y2=\"8\"/><line x1=\"8\" y1=\"16\" x2=\"16\" y2=\"16\"/></svg>\r\n        #{obter_texto(:atalho)}\r\n      </button>\r\n      <span id=\"hotkey_edit\" class=\"hotkey-editor\">\r\n        <input id=\"hotkey_input\" type=\"text\" placeholder=\"#{obter_texto(:pressione)}\" onkeydown=\"capturarAtalhoInput(event)\">\r\n        <button class=\"btn btn-primary btn-sm\" onclick=\"confirmarAtalho()\">#{obter_texto(:ok)}</button>\r\n      </span>\r\n    </div>\r\n    <div class=\"check-group\">\r\n      <div class=\"check-item\">\r\n        <input type=\"checkbox\" id=\"loop_checkbox\">\r\n        <label for=\"loop_checkbox\">#{obter_texto(:loop)}</label>\r\n      </div>\r\n      <div class=\"check-item\">\r\n        <input type=\"checkbox\" id=\"easing_checkbox\">\r\n        <label for=\"easing_checkbox\">#{obter_texto(:easing)}</label>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Visions Card -->\r\n<div class=\"card\">\r\n  <div class=\"card-header\" onclick=\"toggleSection('visions')\">\r\n    <h2>#{obter_texto(:visoes_salvas)} <span id=\"vision_count\" style=\"color:#999; font-weight:400;\"></span></h2>\r\n    <span class=\"toggle-icon\" id=\"visions_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body\" id=\"visions_body\">\r\n    <div class=\"vision-list\" id=\"lista_visoes\"></div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Gerenciar Time Line Card -->\r\n<div class=\"card\">\r\n  <div class=\"card-header\" onclick=\"toggleSection('timeline_mgr')\">\r\n    <h2>#{obter_texto(:gerenciar_timeline)}</h2>\r\n    <span class=\"toggle-icon\" id=\"timeline_mgr_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body\" id=\"timeline_mgr_body\">\r\n    <div class=\"btn-group\">\r\n      <button class=\"btn btn-outline\" onclick=\"novaTimeline()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z\"/><polyline points=\"14 2 14 8 20 8\"/><line x1=\"12\" y1=\"18\" x2=\"12\" y2=\"12\"/><line x1=\"9\" y1=\"15\" x2=\"15\" y2=\"15\"/></svg>\r\n        #{obter_texto(:nova)}\r\n      </button>\r\n      <button class=\"btn btn-outline\" onclick=\"exportarTimeline()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\"/><polyline points=\"7 10 12 15 17 10\"/><line x1=\"12\" y1=\"15\" x2=\"12\" y2=\"3\"/></svg>\r\n        #{obter_texto(:exportar_atual)}\r\n      </button>\r\n      <button class=\"btn btn-outline\" onclick=\"exportarProjeto()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z\"/><polyline points=\"9 14 12 17 15 14\"/><line x1=\"12\" y1=\"17\" x2=\"12\" y2=\"10\"/></svg>\r\n        #{obter_texto(:exportar_projeto)}\r\n      </button>\r\n      <input type=\"file\" id=\"import_file\" class=\"hidden\" accept=\".json\" onchange=\"importarTimeline(this)\">\r\n      <button class=\"btn btn-outline\" onclick=\"document.getElementById('import_file').click()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\"/><polyline points=\"17 8 12 3 7 8\"/><line x1=\"12\" y1=\"3\" x2=\"12\" y2=\"15\"/></svg>\r\n        #{obter_texto(:importar)}\r\n      </button>\r\n    </div>\r\n    <div id=\"saved_timelines_list\" class=\"saved-timelines-list\"></div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Exportar Vídeo Card (colapsado por padrão) -->\r\n<div class=\"card\">\r\n  <div class=\"card-header collapsed\" onclick=\"toggleSection('export')\">\r\n    <h2>#{obter_texto(:exportar_video)}</h2>\r\n    <span class=\"toggle-icon\" id=\"export_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body collapsed\" id=\"export_body\">\r\n    <div id=\"ffmpeg_section\" class=\"#{has_ffmpeg ? '' : 'hidden'}\">\r\n      <div class=\"viewport-info\">\r\n        #{obter_texto(:viewport_atual)} <strong>#{vp_width} x #{vp_height} px</strong>\r\n      </div>\r\n\r\n      <select id=\"preset_select\" class=\"preset-select\" onchange=\"onPresetChange()\">\r\n        <option value=\"\" disabled selected>#{obter_texto(:selecione_formato)}</option>\r\n      </select>\r\n\r\n      <div class=\"custom-dims\" id=\"custom_dims\">\r\n        <input type=\"number\" id=\"custom_w\" min=\"50\" placeholder=\"#{obter_texto(:largura)}\" value=\"1280\">\r\n        <span>x</span>\r\n        <input type=\"number\" id=\"custom_h\" min=\"50\" placeholder=\"#{obter_texto(:altura)}\" value=\"720\">\r\n        <small style=\"color:#888;\">px</small>\r\n      </div>\r\n\r\n      <div class=\"preset-preview\" id=\"preset_preview\" style=\"display:none;\"></div>\r\n\r\n      <div class=\"check-group\" style=\"margin-top:12px; flex-direction:column; align-items:flex-start; gap:8px;\">\r\n        <div class=\"check-item\">\r\n          <input type=\"checkbox\" id=\"rec_projeto\">\r\n          <label for=\"rec_projeto\">#{obter_texto(:gravar_projeto)}</label>\r\n        </div>\r\n        <div class=\"check-item\">\r\n          <input type=\"checkbox\" id=\"rec_inicio\" checked>\r\n          <label for=\"rec_inicio\">#{obter_texto(:iniciar_quadro1)}</label>\r\n        </div>\r\n      </div>\r\n\r\n      <button class=\"btn btn-record mt-8\" id=\"btn_record\" onclick=\"iniciarGravacao()\" disabled style=\"width:100%; margin-top:12px;\">\r\n        <svg width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><circle cx=\"12\" cy=\"12\" r=\"4\" fill=\"currentColor\"/></svg>\r\n        #{obter_texto(:iniciar_gravacao)}\r\n      </button>\r\n\r\n      <div class=\"recording-bar\" id=\"recording_bar\">\r\n        <div class=\"recording-dot\"></div>\r\n        <span>#{obter_texto(:gravando)}</span>\r\n      </div>\r\n    </div>\r\n\r\n    <div id=\"ffmpeg_install\" class=\"#{has_ffmpeg ? 'hidden' : ''}\" style=\"text-align:center; padding:12px 0;\">\r\n      <p style=\"color:#888; font-size:12px; margin-bottom:10px;\">#{obter_texto(:ffmpeg_necessario)}</p>\r\n      <button class=\"btn btn-primary\" onclick=\"instalarExportacao()\">#{obter_texto(:instalar_ffmpeg)}</button>\r\n    </div>\r\n\r\n    <!-- Modal de nome do arquivo -->\r\n    <div id=\"filename_modal\" style=\"display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.4);z-index:100;align-items:center;justify-content:center;\">\r\n      <div style=\"background:#fff;border-radius:10px;padding:24px;width:320px;box-shadow:0 8px 30px rgba(0,0,0,0.2);\">\r\n        <h3 style=\"font-size:14px;font-weight:600;color:#333;margin-bottom:12px;\">#{obter_texto(:nome_arquivo)}</h3>\r\n        <input id=\"filename_input\" type=\"text\" value=\"tour_final\" style=\"width:100%;padding:8px 12px;border:1px solid #ddd;border-radius:6px;font-size:13px;font-family:inherit;outline:none;margin-bottom:6px;\">\r\n        <small style=\"color:#888;\">#{obter_texto(:extensao_mp4)}</small>\r\n        <div style=\"display:flex;gap:8px;margin-top:16px;justify-content:flex-end;\">\r\n          <button class=\"btn btn-outline btn-sm\" onclick=\"fecharModalFilename()\">#{obter_texto(:cancelar)}</button>\r\n          <button class=\"btn btn-primary btn-sm\" onclick=\"confirmarFilename()\">#{obter_texto(:salvar)}</button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Modal de nome da timeline -->\r\n<div id=\"timeline_name_modal\" style=\"display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.4);z-index:100;align-items:center;justify-content:center;\">\r\n  <div style=\"background:#fff;border-radius:10px;padding:24px;width:320px;box-shadow:0 8px 30px rgba(0,0,0,0.2);\">\r\n    <h3 id=\"timeline_name_title\" style=\"font-size:14px;font-weight:600;color:#333;margin-bottom:12px;\"></h3>\r\n    <input id=\"timeline_name_input\" type=\"text\" onkeydown=\"if(event.keyCode===13){confirmarModalTimeline();}\" style=\"width:100%;padding:8px 12px;border:1px solid #ddd;border-radius:6px;font-size:13px;font-family:inherit;outline:none;margin-bottom:6px;\">\r\n    <div style=\"display:flex;gap:8px;margin-top:16px;justify-content:flex-end;\">\r\n      <button class=\"btn btn-outline btn-sm\" onclick=\"fecharModalTimeline()\">#{obter_texto(:cancelar)}</button>\r\n      <button class=\"btn btn-primary btn-sm\" onclick=\"confirmarModalTimeline()\">#{obter_texto(:ok)}</button>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<script>\r\n    const I18N = #{js_i18n_json};\r\n    let visoes = [], playing = false, currentIndex = 0;\r\n    let hotkey = { keyCode: #{current_hotkey}, ctrl: #{hotkey_ctrl}, alt: #{hotkey_alt}, shift: #{hotkey_shift} };\r\n    let capturingHotkey = false, pendingHotkey = null;\r\n    let savedTimelines = [];\r\n    let activeTimelineIndex = -1;\r\n    let playingAll = false, playAllQueue = [], playAllCurrentIdx = 0;\r\n    var viewportW = #{vp_width}, viewportH = #{vp_height};\r\n\r\n    if (window.sketchup) { window.sketchup.set_hotkey(hotkey.keyCode, hotkey.ctrl, hotkey.alt, hotkey.shift); }\r\n\r\n    /* --- Export Formats (aspect ratios) --- */\r\n    const EXPORT_FORMATS = [\r\n      { label: '16:9 ' + I18N.paisagem, ratio: [16, 9] },\r\n      { label: '9:16 ' + I18N.retrato, ratio: [9, 16] },\r\n      { label: '1:1 ' + I18N.quadrado, ratio: [1, 1] },\r\n      { label: '4:3 ' + I18N.classico, ratio: [4, 3] },\r\n      { label: '21:9 ' + I18N.ultra_wide, ratio: [21, 9] },\r\n      { label: I18N.viewport_inteira, ratio: null },\r\n      { label: I18N.personalizado, ratio: null, custom: true }\r\n    ];\r\n\r\n    function calcEffectiveDims(ratioW, ratioH, vpW, vpH) {\r\n      const scaleW = vpW / ratioW;\r\n      const scaleH = vpH / ratioH;\r\n      const scale = Math.min(scaleW, scaleH);\r\n      let w = Math.floor(ratioW * scale);\r\n      let h = Math.floor(ratioH * scale);\r\n      w = w % 2 === 0 ? w : w - 1;\r\n      h = h % 2 === 0 ? h : h - 1;\r\n      return { w: w, h: h };\r\n    }\r\n\r\n    function populatePresets() {\r\n      const sel = document.getElementById(\"preset_select\");\r\n      sel.innerHTML = '<option value=\"\" disabled selected>' + I18N.selecione_formato + '</option>';\r\n      EXPORT_FORMATS.forEach((fmt, i) => {\r\n        const opt = document.createElement(\"option\");\r\n        opt.value = i.toString();\r\n        if (fmt.custom) {\r\n          opt.textContent = fmt.label;\r\n        } else if (fmt.ratio) {\r\n          const dims = calcEffectiveDims(fmt.ratio[0], fmt.ratio[1], viewportW, viewportH);\r\n          opt.textContent = fmt.label + \" (\" + dims.w + \" x \" + dims.h + \" px)\";\r\n        } else {\r\n          let w = viewportW % 2 === 0 ? viewportW : viewportW - 1;\r\n          let h = viewportH % 2 === 0 ? viewportH : viewportH - 1;\r\n          opt.textContent = fmt.label + \" (\" + w + \" x \" + h + \" px)\";\r\n        }\r\n        sel.appendChild(opt);\r\n      });\r\n    }\r\n\r\n    /* --- Section Toggle --- */\r\n    function toggleSection(name) {\r\n      const body = document.getElementById(name + '_body');\r\n      const icon = document.getElementById(name + '_toggle');\r\n      const header = icon.parentElement;\r\n      const wasCollapsed = body.classList.contains('collapsed');\r\n      if (wasCollapsed) {\r\n        body.classList.remove('collapsed');\r\n        header.classList.remove('collapsed');\r\n      } else {\r\n        body.classList.add('collapsed');\r\n        header.classList.add('collapsed');\r\n      }\r\n      /* Hide viewport preview when closing export card */\r\n      if (name === 'export' && !wasCollapsed) {\r\n        if (window.sketchup) window.sketchup.hide_export_preview();\r\n      }\r\n    }\r\n\r\n    /* --- Timeline --- */\r\n    function updateTime(val) {\r\n      document.getElementById(\"current_time\").innerText = parseFloat(val).toFixed(1);\r\n    }\r\n\r\n    function atualizarTempoTotal() {\r\n      const novoMax = parseFloat(document.getElementById(\"max_time\").value);\r\n      if (isNaN(novoMax) || novoMax <= 0) return;\r\n      document.getElementById(\"timeline_range\").max = novoMax;\r\n      visoes.forEach(v => { if (v.time > novoMax) v.time = novoMax - 0.1; });\r\n      renderMarkers();\r\n    }\r\n\r\n    /* --- Timeline Name Modal --- */\r\n    var _timelineModalCallback = null;\r\n\r\n    function abrirModalTimeline(titulo, valorPadrao, callback) {\r\n      _timelineModalCallback = callback;\r\n      document.getElementById(\"timeline_name_title\").textContent = titulo;\r\n      var input = document.getElementById(\"timeline_name_input\");\r\n      input.value = valorPadrao;\r\n      var modal = document.getElementById(\"timeline_name_modal\");\r\n      modal.style.display = \"flex\";\r\n      setTimeout(function() { input.focus(); input.select(); }, 50);\r\n    }\r\n\r\n    function fecharModalTimeline() {\r\n      document.getElementById(\"timeline_name_modal\").style.display = \"none\";\r\n      _timelineModalCallback = null;\r\n    }\r\n\r\n    function confirmarModalTimeline() {\r\n      var name = document.getElementById(\"timeline_name_input\").value.trim();\r\n      if (!name) return;\r\n      document.getElementById(\"timeline_name_modal\").style.display = \"none\";\r\n      if (_timelineModalCallback) {\r\n        _timelineModalCallback(name);\r\n        _timelineModalCallback = null;\r\n      }\r\n    }\r\n\r\n    /* --- Visions --- */\r\n    function addVision() {\r\n      if (savedTimelines.length === 0 && visoes.length === 0) {\r\n        abrirModalTimeline(I18N.nome_timeline, \"Time Line 1\", function(name) {\r\n          savedTimelines.push({ name: name, visoes: [], maxTime: 60 });\r\n          activeTimelineIndex = 0;\r\n          renderSavedTimelines();\r\n          var time = parseFloat(document.getElementById(\"timeline_range\").value);\r\n          sketchup.capture_camera(time);\r\n        });\r\n        return;\r\n      }\r\n      var time = parseFloat(document.getElementById(\"timeline_range\").value);\r\n      sketchup.capture_camera(time);\r\n    }\r\n\r\n    function captureVisionFromRuby(camJson) {\r\n      const obj = JSON.parse(camJson);\r\n      obj.walk = false; obj.anchor = false;\r\n      visoes = visoes.filter(v => v.time !== obj.time);\r\n      visoes.push(obj);\r\n      visoes.sort((a, b) => a.time - b.time);\r\n      visoes[0].time = 0.0;\r\n      syncActiveTimeline();\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    /* --- Draggable markers --- */\r\n    function setupMarkerDrag(marker, visionIndex, slider, maxTime) {\r\n      if (visionIndex === 0) {\r\n        marker.classList.add(\"no-drag\");\r\n        return;\r\n      }\r\n      marker.addEventListener(\"mousedown\", function(e) {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        marker.classList.add(\"dragging\");\r\n        const sliderPadding = 8;\r\n\r\n        function onMove(ev) {\r\n          const sliderRect = slider.getBoundingClientRect();\r\n          const usableWidth = sliderRect.width - sliderPadding * 2;\r\n          const relativeX = Math.max(0, Math.min(ev.clientX - sliderRect.left - sliderPadding, usableWidth));\r\n          const newTime = parseFloat(((relativeX / usableWidth) * maxTime).toFixed(1));\r\n          marker.style.left = (relativeX + sliderPadding) + \"px\";\r\n          const tooltip = marker.querySelector(\".marker-tooltip\");\r\n          if (tooltip) tooltip.textContent = newTime.toFixed(1) + \"s\";\r\n        }\r\n\r\n        function onUp(ev) {\r\n          marker.classList.remove(\"dragging\");\r\n          document.removeEventListener(\"mousemove\", onMove);\r\n          document.removeEventListener(\"mouseup\", onUp);\r\n          const sliderRect = slider.getBoundingClientRect();\r\n          const usableWidth = sliderRect.width - sliderPadding * 2;\r\n          const relativeX = Math.max(0, Math.min(ev.clientX - sliderRect.left - sliderPadding, usableWidth));\r\n          const newTime = parseFloat(((relativeX / usableWidth) * maxTime).toFixed(1));\r\n          visoes[visionIndex].time = Math.max(0.1, newTime);\r\n          visoes.sort((a, b) => a.time - b.time);\r\n          if (visoes.length > 0) visoes[0].time = 0.0;\r\n          renderMarkers();\r\n        }\r\n\r\n        document.addEventListener(\"mousemove\", onMove);\r\n        document.addEventListener(\"mouseup\", onUp);\r\n      });\r\n    }\r\n\r\n    function syncActiveTimeline() {\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n    }\r\n\r\n    function renderMarkers() {\r\n      const layer = document.getElementById(\"markers_layer\");\r\n      const lista = document.getElementById(\"lista_visoes\");\r\n      const slider = document.getElementById(\"timeline_range\");\r\n      const max = parseFloat(slider.max);\r\n      const width = slider.offsetWidth;\r\n      const countEl = document.getElementById(\"vision_count\");\r\n\r\n      layer.innerHTML = \"\"; lista.innerHTML = \"\";\r\n      countEl.textContent = visoes.length > 0 ? \"(\" + visoes.length + \")\" : \"\";\r\n\r\n      if (visoes.length === 0) {\r\n        lista.innerHTML = '<div class=\"empty-state\">' +\r\n          '<svg width=\"36\" height=\"36\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"#ccc\" stroke-width=\"1.5\"><path d=\"M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z\"/><circle cx=\"12\" cy=\"13\" r=\"4\"/></svg>' +\r\n          '<p>' + I18N.nenhuma_visao + '<br>' + I18N.dica_visao + '</p></div>';\r\n        return;\r\n      }\r\n\r\n      visoes.forEach((v, i) => {\r\n        /* Marker on timeline */\r\n        const percent = max > 0 ? v.time / max : 0;\r\n        const marker = document.createElement(\"div\");\r\n        marker.className = \"marker\" + (v.anchor ? \" anchor\" : \"\");\r\n        const sliderPadding = 8;\r\n        const usableWidth = width - sliderPadding * 2;\r\n        marker.style.left = (percent * usableWidth + sliderPadding) + \"px\";\r\n        const tooltip = document.createElement(\"span\");\r\n        tooltip.className = \"marker-tooltip\";\r\n        tooltip.textContent = v.time.toFixed(1) + \"s\";\r\n        marker.appendChild(tooltip);\r\n        marker.onclick = () => {\r\n          slider.value = v.time; updateTime(v.time); currentIndex = i;\r\n          resetPlayButton(); sketchup.goto_camera(JSON.stringify(v));\r\n        };\r\n        /* Draggable */\r\n        setupMarkerDrag(marker, i, slider, max);\r\n        layer.appendChild(marker);\r\n\r\n        /* Vision list item */\r\n        const item = document.createElement(\"div\");\r\n        item.className = \"vision-item\";\r\n        item.onclick = () => {\r\n          slider.value = v.time; updateTime(v.time); currentIndex = i;\r\n          resetPlayButton(); sketchup.goto_camera(JSON.stringify(v));\r\n        };\r\n\r\n        const num = document.createElement(\"span\");\r\n        num.className = \"vision-num\";\r\n        num.textContent = (i + 1);\r\n\r\n        const img = document.createElement(\"img\");\r\n        if (v.thumb && v.thumb.length > 0) {\r\n          const mime = v.thumb.startsWith(\"/9j/\") ? \"image/jpeg\" : \"image/bmp\";\r\n          img.src = \"data:\" + mime + \";base64,\" + v.thumb;\r\n        } else {\r\n          img.src = \"\";\r\n          img.className = \"thumb-placeholder\";\r\n        }\r\n\r\n        const info = document.createElement(\"div\");\r\n        info.className = \"vision-info\";\r\n        const timeInput = document.createElement(\"input\");\r\n        timeInput.type = \"number\"; timeInput.step = \"0.1\";\r\n        timeInput.value = v.time.toFixed(1);\r\n        timeInput.className = \"vision-time-input\";\r\n        timeInput.disabled = (i === 0);\r\n        timeInput.onclick = (e) => e.stopPropagation();\r\n        timeInput.onchange = () => {\r\n          v.time = parseFloat(timeInput.value);\r\n          visoes.sort((a, b) => a.time - b.time);\r\n          renderMarkers();\r\n        };\r\n        info.appendChild(timeInput);\r\n\r\n        const actions = document.createElement(\"div\");\r\n        actions.className = \"vision-actions\";\r\n\r\n        const anchorBtn = document.createElement(\"button\");\r\n        anchorBtn.className = \"anchor-toggle\" + (v.anchor ? \" active\" : \"\");\r\n        anchorBtn.innerHTML = \"&#9875;\";\r\n        anchorBtn.title = I18N.ancora;\r\n        anchorBtn.onclick = (e) => {\r\n          e.stopPropagation();\r\n          v.anchor = !v.anchor;\r\n          renderMarkers();\r\n        };\r\n        actions.appendChild(anchorBtn);\r\n\r\n        const delBtn = document.createElement(\"button\");\r\n        delBtn.className = \"delete-btn\";\r\n        delBtn.innerHTML = \"&times;\";\r\n        delBtn.title = I18N.excluir;\r\n        delBtn.onclick = (e) => {\r\n          e.stopPropagation();\r\n          visoes.splice(i, 1);\r\n          if (visoes.length > 0) visoes[0].time = 0.0;\r\n          syncActiveTimeline();\r\n          renderMarkers();\r\n          renderSavedTimelines();\r\n        };\r\n        actions.appendChild(delBtn);\r\n\r\n        item.appendChild(num);\r\n        item.appendChild(img);\r\n        item.appendChild(info);\r\n        item.appendChild(actions);\r\n        lista.appendChild(item);\r\n      });\r\n    }\r\n\r\n    /* --- Playback --- */\r\n    function togglePlay() {\r\n      if (!playing) {\r\n        if (visoes.length < 2) return alert(I18N.min_duas_visoes);\r\n        if (currentIndex >= visoes.length - 1) currentIndex = 0;\r\n        playing = true;\r\n        document.body.classList.add(\"playing\");\r\n        document.getElementById(\"play_button\").innerHTML = \"&#9724; \" + I18N.stop;\r\n        document.getElementById(\"play_button\").className = \"btn btn-danger\";\r\n        sketchup.play_tour(JSON.stringify(visoes), document.getElementById(\"loop_checkbox\").checked, false, document.getElementById(\"easing_checkbox\").checked, currentIndex);\r\n      } else {\r\n        resetPlayButton();\r\n        sketchup.stop_tour();\r\n      }\r\n    }\r\n\r\n    function resetPlayButton() {\r\n      playing = false;\r\n      document.body.classList.remove(\"playing\");\r\n      document.getElementById(\"play_button\").innerHTML = \"&#9654; \" + I18N.play;\r\n      document.getElementById(\"play_button\").className = \"btn btn-success\";\r\n    }\r\n\r\n    function togglePlayAll() {\r\n      if (playingAll) {\r\n        resetPlayAll();\r\n        sketchup.stop_tour();\r\n        return;\r\n      }\r\n      if (savedTimelines.length < 2) return;\r\n      /* Save current timeline state */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n      /* Build queue of timelines with 2+ visions */\r\n      playAllQueue = savedTimelines.map(function(tl, i) { return i; }).filter(function(i) { return savedTimelines[i].visoes.length >= 2; });\r\n      if (playAllQueue.length < 1) { alert(I18N.sem_tl_2mais); return; }\r\n      playingAll = true;\r\n      playAllCurrentIdx = 0;\r\n      document.body.classList.add(\"playing\");\r\n      document.getElementById(\"play_all_button\").innerHTML = \"&#9724; \" + I18N.stop_all;\r\n      document.getElementById(\"play_all_button\").className = \"btn btn-danger btn-sm\";\r\n      playTimelineAtQueueIndex(0);\r\n    }\r\n\r\n    function playTimelineAtQueueIndex(qIdx) {\r\n      var tlIdx = playAllQueue[qIdx];\r\n      var tl = savedTimelines[tlIdx];\r\n      visoes = JSON.parse(JSON.stringify(tl.visoes));\r\n      document.getElementById(\"max_time\").value = tl.maxTime;\r\n      document.getElementById(\"timeline_range\").max = tl.maxTime;\r\n      activeTimelineIndex = tlIdx;\r\n      currentIndex = 0;\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n      sketchup.play_tour(\r\n        JSON.stringify(visoes),\r\n        false,\r\n        false,\r\n        document.getElementById(\"easing_checkbox\").checked,\r\n        0\r\n      );\r\n    }\r\n\r\n    function resetPlayAll() {\r\n      playingAll = false;\r\n      playAllQueue = [];\r\n      playAllCurrentIdx = 0;\r\n      document.body.classList.remove(\"playing\");\r\n      var btn = document.getElementById(\"play_all_button\");\r\n      btn.innerHTML = '<svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><polygon points=\"5 3 19 12 5 21 5 3\"/><line x1=\"19\" y1=\"3\" x2=\"19\" y2=\"21\"/></svg> ' + I18N.play_all;\r\n      btn.className = \"btn btn-outline btn-sm\";\r\n      playing = false;\r\n      document.getElementById(\"play_button\").innerHTML = \"&#9654; \" + I18N.play;\r\n      document.getElementById(\"play_button\").className = \"btn btn-success\";\r\n    }\r\n\r\n    function startRecordingPlayAll(startTlIdx, startVisionIdx) {\r\n      syncActiveTimeline();\r\n      /* Montar fila de timelines com 2+ visões, a partir de startTlIdx */\r\n      playAllQueue = [];\r\n      for (var i = startTlIdx; i < savedTimelines.length; i++) {\r\n        if (savedTimelines[i].visoes.length >= 2) playAllQueue.push(i);\r\n      }\r\n      if (playAllQueue.length === 0) return;\r\n\r\n      playingAll = true;\r\n      playAllCurrentIdx = 0;\r\n      playing = true;\r\n      document.body.classList.add(\"playing\");\r\n      document.getElementById(\"play_button\").innerHTML = \"&#9724; \" + I18N.stop;\r\n      document.getElementById(\"play_button\").className = \"btn btn-danger\";\r\n\r\n      /* Carregar a primeira timeline da fila */\r\n      var firstTlIdx = playAllQueue[0];\r\n      var tl = savedTimelines[firstTlIdx];\r\n      visoes = JSON.parse(JSON.stringify(tl.visoes));\r\n      document.getElementById(\"max_time\").value = tl.maxTime;\r\n      document.getElementById(\"timeline_range\").max = tl.maxTime;\r\n      activeTimelineIndex = firstTlIdx;\r\n      currentIndex = startVisionIdx;\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n\r\n      sketchup.play_tour(\r\n        JSON.stringify(visoes),\r\n        false,\r\n        false,\r\n        document.getElementById(\"easing_checkbox\").checked,\r\n        startVisionIdx\r\n      );\r\n    }\r\n\r\n    function updatePlayAllButton() {\r\n      var btn = document.getElementById(\"play_all_button\");\r\n      if (savedTimelines.length > 1) {\r\n        btn.classList.remove(\"hidden\");\r\n      } else {\r\n        btn.classList.add(\"hidden\");\r\n      }\r\n    }\r\n\r\n    function pauseAtIndex(idx) {\r\n      currentIndex = idx;\r\n      if (playingAll) {\r\n        playAllCurrentIdx++;\r\n        if (playAllCurrentIdx < playAllQueue.length) {\r\n          playTimelineAtQueueIndex(playAllCurrentIdx);\r\n          return;\r\n        } else {\r\n          resetPlayAll();\r\n          return;\r\n        }\r\n      }\r\n      resetPlayButton();\r\n    }\r\n    function triggerSpaceFromRuby() { togglePlay(); }\r\n    function updatePlayhead(time) {\r\n      var slider = document.getElementById(\"timeline_range\");\r\n      slider.value = time;\r\n      document.getElementById(\"current_time\").innerText = parseFloat(time).toFixed(1);\r\n    }\r\n\r\n    /* --- Timeline Management --- */\r\n    function exportarTimeline() {\r\n      if (visoes.length === 0) { alert(I18N.sem_visoes_exportar); return; }\r\n      var tlName = (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length)\r\n        ? savedTimelines[activeTimelineIndex].name : \"Time Line\";\r\n      /* Download JSON */\r\n      var dataStr = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(visoes, null, 2));\r\n      var a = document.createElement(\"a\");\r\n      a.setAttribute(\"href\", dataStr);\r\n      a.setAttribute(\"download\", tlName.replace(/[^a-zA-Z0-9_-]/g, \"_\") + \".json\");\r\n      document.body.appendChild(a); a.click(); a.remove();\r\n      /* Salvar na lista */\r\n      saveCurrentToTimelines(tlName);\r\n    }\r\n\r\n    function exportarProjeto() {\r\n      syncActiveTimeline();\r\n      if (savedTimelines.length === 0) { alert(I18N.sem_tl_exportar); return; }\r\n      var projeto = { type: \"tour_virtual_project\", timelines: savedTimelines };\r\n      var dataStr = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(projeto, null, 2));\r\n      var a = document.createElement(\"a\");\r\n      a.setAttribute(\"href\", dataStr);\r\n      a.setAttribute(\"download\", \"projeto_tour_virtual.json\");\r\n      document.body.appendChild(a); a.click(); a.remove();\r\n    }\r\n\r\n    function saveCurrentToTimelines(name) {\r\n      var maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      var entry = { name: name, visoes: JSON.parse(JSON.stringify(visoes)), maxTime: maxTime };\r\n      /* Atualizar existente se ativo, senão adicionar novo */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex] = entry;\r\n      } else {\r\n        savedTimelines.push(entry);\r\n        activeTimelineIndex = savedTimelines.length - 1;\r\n      }\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    function importarTimeline(input) {\r\n      var file = input.files[0];\r\n      if (!file) return;\r\n      var reader = new FileReader();\r\n      reader.onload = function(e) {\r\n        try {\r\n          var imported = JSON.parse(e.target.result);\r\n          /* Detectar se é um projeto completo */\r\n          if (imported && imported.type === \"tour_virtual_project\" && Array.isArray(imported.timelines)) {\r\n            syncActiveTimeline();\r\n            imported.timelines.forEach(function(tl) {\r\n              if (tl.visoes) {\r\n                tl.visoes.sort(function(a, b) { return a.time - b.time; });\r\n                if (tl.visoes.length > 0) tl.visoes[0].time = 0.0;\r\n              }\r\n              savedTimelines.push({ name: tl.name || I18N.importada, visoes: tl.visoes || [], maxTime: tl.maxTime || 60 });\r\n            });\r\n            if (savedTimelines.length > 0 && activeTimelineIndex < 0) {\r\n              activeTimelineIndex = 0;\r\n              var first = savedTimelines[0];\r\n              visoes = JSON.parse(JSON.stringify(first.visoes));\r\n              document.getElementById(\"max_time\").value = first.maxTime;\r\n              document.getElementById(\"timeline_range\").max = first.maxTime;\r\n              renderMarkers();\r\n            }\r\n            renderSavedTimelines();\r\n            return;\r\n          }\r\n          /* Time Line única */\r\n          if (!Array.isArray(imported)) throw I18N.formato_invalido;\r\n          imported.sort(function(a, b) { return a.time - b.time; });\r\n          if (imported.length > 0) imported[0].time = 0.0;\r\n          var maxTime = imported.length > 0 ? Math.ceil(imported[imported.length - 1].time + 1) : 60;\r\n          var name = file.name.replace(/\\\\.json$/i, \"\");\r\n          savedTimelines.push({ name: name, visoes: imported, maxTime: maxTime });\r\n          renderSavedTimelines();\r\n        } catch (err) { alert(I18N.erro_importar + err); }\r\n      };\r\n      reader.readAsText(file);\r\n      input.value = \"\";\r\n    }\r\n\r\n    function switchTimeline(index) {\r\n      if (index === activeTimelineIndex) return;\r\n      /* Save current state if there's an active timeline */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n      /* Load selected timeline */\r\n      const tl = savedTimelines[index];\r\n      visoes = JSON.parse(JSON.stringify(tl.visoes));\r\n      document.getElementById(\"max_time\").value = tl.maxTime;\r\n      document.getElementById(\"timeline_range\").max = tl.maxTime;\r\n      activeTimelineIndex = index;\r\n      currentIndex = 0;\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    function deleteTimeline(index) {\r\n      if (index === activeTimelineIndex) return;\r\n      savedTimelines.splice(index, 1);\r\n      if (activeTimelineIndex > index) activeTimelineIndex--;\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    function renderSavedTimelines() {\r\n      var container = document.getElementById(\"saved_timelines_list\");\r\n      container.innerHTML = \"\";\r\n      if (savedTimelines.length === 0) { updatePlayAllButton(); return; }\r\n      var dragSrcIndex = null;\r\n\r\n      savedTimelines.forEach(function(tl, i) {\r\n        var item = document.createElement(\"div\");\r\n        item.className = \"tl-item\" + (i === activeTimelineIndex ? \" active\" : \"\");\r\n        item.draggable = true;\r\n        item.dataset.index = i;\r\n\r\n        /* Drag handle */\r\n        var handle = document.createElement(\"span\");\r\n        handle.className = \"tl-drag-handle\";\r\n        handle.innerHTML = \"&#9776;\";\r\n        item.appendChild(handle);\r\n\r\n        /* Drag events */\r\n        item.addEventListener(\"dragstart\", function(e) {\r\n          dragSrcIndex = i;\r\n          item.classList.add(\"dragging\");\r\n          e.dataTransfer.effectAllowed = \"move\";\r\n        });\r\n        item.addEventListener(\"dragover\", function(e) {\r\n          e.preventDefault();\r\n          e.dataTransfer.dropEffect = \"move\";\r\n          var rect = item.getBoundingClientRect();\r\n          var midY = rect.top + rect.height / 2;\r\n          item.classList.remove(\"drag-over-top\", \"drag-over-bottom\");\r\n          item.classList.add(e.clientY < midY ? \"drag-over-top\" : \"drag-over-bottom\");\r\n        });\r\n        item.addEventListener(\"dragleave\", function() {\r\n          item.classList.remove(\"drag-over-top\", \"drag-over-bottom\");\r\n        });\r\n        item.addEventListener(\"drop\", function(e) {\r\n          e.preventDefault();\r\n          item.classList.remove(\"drag-over-top\", \"drag-over-bottom\");\r\n          if (dragSrcIndex === null || dragSrcIndex === i) return;\r\n          var rect = item.getBoundingClientRect();\r\n          var midY = rect.top + rect.height / 2;\r\n          var targetIndex = e.clientY < midY ? i : i + 1;\r\n          if (dragSrcIndex < targetIndex) targetIndex--;\r\n          var moved = savedTimelines.splice(dragSrcIndex, 1)[0];\r\n          savedTimelines.splice(targetIndex, 0, moved);\r\n          if (activeTimelineIndex === dragSrcIndex) {\r\n            activeTimelineIndex = targetIndex;\r\n          } else if (dragSrcIndex < activeTimelineIndex && targetIndex >= activeTimelineIndex) {\r\n            activeTimelineIndex--;\r\n          } else if (dragSrcIndex > activeTimelineIndex && targetIndex <= activeTimelineIndex) {\r\n            activeTimelineIndex++;\r\n          }\r\n          renderSavedTimelines();\r\n        });\r\n        item.addEventListener(\"dragend\", function() {\r\n          item.classList.remove(\"dragging\");\r\n          dragSrcIndex = null;\r\n        });\r\n\r\n        item.onclick = function() { switchTimeline(i); };\r\n\r\n        var indicator = document.createElement(\"span\");\r\n        indicator.className = \"tl-indicator\";\r\n        item.appendChild(indicator);\r\n\r\n        var nameEl = document.createElement(\"span\");\r\n        nameEl.className = \"tl-name\";\r\n        nameEl.textContent = tl.name;\r\n        item.appendChild(nameEl);\r\n\r\n        var count = document.createElement(\"span\");\r\n        count.className = \"tl-count\";\r\n        count.textContent = tl.visoes.length + \" \" + I18N.visoes;\r\n        item.appendChild(count);\r\n\r\n        if (i !== activeTimelineIndex) {\r\n          var del = document.createElement(\"button\");\r\n          del.className = \"tl-delete\";\r\n          del.innerHTML = \"&times;\";\r\n          del.title = I18N.excluir;\r\n          del.onclick = function(e) { e.stopPropagation(); deleteTimeline(i); };\r\n          item.appendChild(del);\r\n        }\r\n\r\n        container.appendChild(item);\r\n      });\r\n\r\n      updatePlayAllButton();\r\n    }\r\n\r\n    function novaTimeline() {\r\n      abrirModalTimeline(I18N.nova_timeline, \"Time Line \" + (savedTimelines.length + 1), function(name) {\r\n        /* Salvar timeline atual na lista se pertencer a uma timeline salva */\r\n        if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n          savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n          savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n        }\r\n        /* Criar nova timeline vazia e adicioná-la à lista */\r\n        savedTimelines.push({ name: name, visoes: [], maxTime: 60 });\r\n        activeTimelineIndex = savedTimelines.length - 1;\r\n        /* Limpar estado */\r\n        visoes = [];\r\n        currentIndex = 0;\r\n        document.getElementById(\"max_time\").value = 60;\r\n        document.getElementById(\"timeline_range\").max = 60;\r\n        document.getElementById(\"timeline_range\").value = 0;\r\n        updateTime(0);\r\n        renderMarkers();\r\n        renderSavedTimelines();\r\n      });\r\n    }\r\n\r\n    /* --- Video Export with Proportional Presets --- */\r\n    function onPresetChange() {\r\n      const sel = document.getElementById(\"preset_select\");\r\n      const preview = document.getElementById(\"preset_preview\");\r\n      const customDims = document.getElementById(\"custom_dims\");\r\n      const btnRecord = document.getElementById(\"btn_record\");\r\n      const idx = parseInt(sel.value);\r\n\r\n      if (isNaN(idx)) {\r\n        customDims.classList.remove(\"visible\");\r\n        preview.style.display = \"none\";\r\n        btnRecord.disabled = true;\r\n        if (window.sketchup) window.sketchup.hide_export_preview();\r\n        return;\r\n      }\r\n\r\n      const fmt = EXPORT_FORMATS[idx];\r\n      btnRecord.disabled = false;\r\n\r\n      if (fmt.custom) {\r\n        customDims.classList.add(\"visible\");\r\n        preview.style.display = \"none\";\r\n        if (window.sketchup) window.sketchup.hide_export_preview();\r\n      } else {\r\n        customDims.classList.remove(\"visible\");\r\n        let dims;\r\n        if (fmt.ratio) {\r\n          dims = calcEffectiveDims(fmt.ratio[0], fmt.ratio[1], viewportW, viewportH);\r\n        } else {\r\n          dims = { w: viewportW % 2 === 0 ? viewportW : viewportW - 1, h: viewportH % 2 === 0 ? viewportH : viewportH - 1 };\r\n        }\r\n        preview.textContent = I18N.area_gravacao + dims.w + \" x \" + dims.h + \" px\";\r\n        preview.style.display = \"flex\";\r\n        /* Show preview overlay in viewport */\r\n        if (window.sketchup) window.sketchup.show_export_preview(dims.w, dims.h);\r\n      }\r\n    }\r\n\r\n    function getExportDimensions() {\r\n      const sel = document.getElementById(\"preset_select\");\r\n      const idx = parseInt(sel.value);\r\n      if (isNaN(idx)) return null;\r\n      const fmt = EXPORT_FORMATS[idx];\r\n      if (fmt.custom) {\r\n        return {\r\n          w: parseInt(document.getElementById(\"custom_w\").value) || 1280,\r\n          h: parseInt(document.getElementById(\"custom_h\").value) || 720\r\n        };\r\n      }\r\n      if (fmt.ratio) {\r\n        return calcEffectiveDims(fmt.ratio[0], fmt.ratio[1], viewportW, viewportH);\r\n      }\r\n      return { w: viewportW % 2 === 0 ? viewportW : viewportW - 1, h: viewportH % 2 === 0 ? viewportH : viewportH - 1 };\r\n    }\r\n\r\n    function iniciarGravacao() {\r\n      var gravarProjeto = document.getElementById(\"rec_projeto\").checked;\r\n      var desdeInicio = document.getElementById(\"rec_inicio\").checked;\r\n\r\n      if (gravarProjeto) {\r\n        syncActiveTimeline();\r\n        var temVisoes = savedTimelines.some(function(tl) { return tl.visoes.length >= 2; });\r\n        if (!temVisoes) { alert(I18N.sem_tl_min_duas); return; }\r\n      } else {\r\n        if (visoes.length < 2) { alert(I18N.min_duas_visoes); return; }\r\n      }\r\n      var dims = getExportDimensions();\r\n      if (!dims || dims.w < 50 || dims.h < 50) { alert(I18N.dims_invalidas); return; }\r\n\r\n      /* Mostrar modal de nome */\r\n      document.getElementById(\"filename_input\").value = gravarProjeto ? \"projeto_tour\" : \"tour_final\";\r\n      document.getElementById(\"filename_modal\").style.display = \"flex\";\r\n      document.getElementById(\"filename_input\").focus();\r\n      document.getElementById(\"filename_input\").select();\r\n    }\r\n\r\n    function fecharModalFilename() {\r\n      document.getElementById(\"filename_modal\").style.display = \"none\";\r\n    }\r\n\r\n    function confirmarFilename() {\r\n      var nome = document.getElementById(\"filename_input\").value.trim();\r\n      if (!nome) { alert(I18N.digite_nome); return; }\r\n      document.getElementById(\"filename_modal\").style.display = \"none\";\r\n\r\n      var gravarProjeto = document.getElementById(\"rec_projeto\").checked;\r\n      var desdeInicio = document.getElementById(\"rec_inicio\").checked;\r\n      var dims = getExportDimensions();\r\n      var startIdx = desdeInicio ? 0 : currentIndex;\r\n\r\n      if (window.sketchup) window.sketchup.hide_export_preview();\r\n\r\n      if (gravarProjeto) {\r\n        syncActiveTimeline();\r\n        var allTimelines = JSON.stringify(savedTimelines);\r\n        var startTl = desdeInicio ? 0 : activeTimelineIndex;\r\n        var startVision = desdeInicio ? 0 : currentIndex;\r\n        if (window.sketchup) {\r\n          window.sketchup.start_export_project(\r\n            allTimelines,\r\n            document.getElementById(\"easing_checkbox\").checked,\r\n            startTl,\r\n            startVision,\r\n            dims.w,\r\n            dims.h,\r\n            nome\r\n          );\r\n        }\r\n      } else {\r\n        if (window.sketchup) {\r\n          window.sketchup.start_export_process(\r\n            JSON.stringify(visoes),\r\n            document.getElementById(\"easing_checkbox\").checked,\r\n            startIdx,\r\n            dims.w,\r\n            dims.h,\r\n            nome\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    function showRecordingIndicator() {\r\n      document.getElementById(\"recording_bar\").classList.add(\"active\");\r\n    }\r\n    function hideRecordingIndicator() {\r\n      document.getElementById(\"recording_bar\").classList.remove(\"active\");\r\n    }\r\n\r\n    function instalarExportacao() {\r\n      if (window.sketchup) { window.sketchup.install_ffmpeg(); }\r\n    }\r\n\r\n    /* --- Hotkey --- */\r\n    function mostrarCampoAtalho() {\r\n      capturingHotkey = true; pendingHotkey = null;\r\n      document.getElementById(\"hotkey_input\").value = \"\";\r\n      document.getElementById(\"hotkey_edit\").classList.add(\"visible\");\r\n      document.getElementById(\"hotkey_input\").focus();\r\n    }\r\n    function capturarAtalhoInput(e) {\r\n      e.preventDefault();\r\n      /* Ignorar teclas modificadoras sozinhas */\r\n      if ([16, 17, 18, 91, 93].includes(e.keyCode)) return;\r\n      pendingHotkey = {\r\n        keyCode: e.keyCode,\r\n        ctrl: e.ctrlKey,\r\n        alt: e.altKey,\r\n        shift: e.shiftKey\r\n      };\r\n      /* Montar label legivel */\r\n      var parts = [];\r\n      if (e.ctrlKey) parts.push(\"Ctrl\");\r\n      if (e.altKey) parts.push(\"Alt\");\r\n      if (e.shiftKey) parts.push(\"Shift\");\r\n      parts.push(e.code.replace(\"Key\", \"\").replace(\"Digit\", \"\"));\r\n      document.getElementById(\"hotkey_input\").value = parts.join(\" + \");\r\n    }\r\n    function confirmarAtalho() {\r\n      if (pendingHotkey !== null) {\r\n        hotkey = pendingHotkey;\r\n        if (window.sketchup) {\r\n          window.sketchup.set_hotkey(hotkey.keyCode, hotkey.ctrl, hotkey.alt, hotkey.shift);\r\n        }\r\n      }\r\n      capturingHotkey = false;\r\n      document.getElementById(\"hotkey_edit\").classList.remove(\"visible\");\r\n    }\r\n\r\n    /* --- Global bindings --- */\r\n    window.captureVisionFromRuby = captureVisionFromRuby;\r\n    window.resetPlayButton = resetPlayButton;\r\n    window.pauseAtIndex = pauseAtIndex;\r\n    window.triggerSpaceFromRuby = triggerSpaceFromRuby;\r\n    window.showRecordingIndicator = showRecordingIndicator;\r\n    window.hideRecordingIndicator = hideRecordingIndicator;\r\n    window.updatePlayhead = updatePlayhead;\r\n    window.resetPlayAll = resetPlayAll;\r\n    window.startRecordingPlayAll = startRecordingPlayAll;\r\n    window.addEventListener(\"resize\", () => { renderMarkers(); });\r\n\r\n    document.addEventListener(\"keydown\", (e) => {\r\n      if (!capturingHotkey &&\r\n          e.keyCode === hotkey.keyCode &&\r\n          e.ctrlKey === hotkey.ctrl &&\r\n          e.altKey === hotkey.alt &&\r\n          e.shiftKey === hotkey.shift &&\r\n          ![\"INPUT\", \"TEXTAREA\"].includes(e.target.tagName)) {\r\n        e.preventDefault(); togglePlay();\r\n      }\r\n    });\r\n\r\n    /* Init */\r\n    populatePresets();\r\n    renderMarkers();\r\n</script>\r\n</body>\r\n</html>\r\nHTML\r\n\r\n      @dialog ||= UI::HtmlDialog.new({\r\n        :dialog_title => obter_texto(:titulo_dialogo),\r\n        :preferences_key => \"com.example.tour\",\r\n        :scrollable => true,\r\n        :resizable => true,\r\n        :width => 430,\r\n        :height => 790,\r\n        :style => UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n\r\n      @dialog.set_html(html)\r\n      start_space_timer\r\n\r\n      @dialog.add_action_callback(\"set_hotkey\") do |_, key_code, ctrl, alt, shift|\r\n        GlobalKey.set_hotkey(key_code.to_i, ctrl, alt, shift)\r\n        Sketchup.write_default(\"TourVirtual\", \"Hotkey\", key_code.to_i)\r\n        Sketchup.write_default(\"TourVirtual\", \"HotkeyCtrl\", ctrl ? true : false)\r\n        Sketchup.write_default(\"TourVirtual\", \"HotkeyAlt\", alt ? true : false)\r\n        Sketchup.write_default(\"TourVirtual\", \"HotkeyShift\", shift ? true : false)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"capture_camera\") do |_, time_code|\r\n        cam = Sketchup.active_model.active_view.camera\r\n        thumb = capture_thumbnail\r\n        camera_data = {\r\n          time: time_code.to_f,\r\n          eye: cam.eye.to_a,\r\n          target: cam.target.to_a,\r\n          up: cam.up.to_a,\r\n          fov: cam.fov,\r\n          perspective: cam.perspective?,\r\n          thumb: thumb,\r\n          anchor: false\r\n        }\r\n        json_str = camera_data.to_json.gsub('\"', '\\\"')\r\n        @dialog.execute_script(\"captureVisionFromRuby(\\\"#{json_str}\\\")\")\r\n      end\r\n\r\n      @dialog.add_action_callback(\"goto_camera\") do |_, cam_json|\r\n        cam_data = JSON.parse(cam_json, symbolize_names: true)\r\n        cam = Sketchup::Camera.new(cam_data[:eye], cam_data[:target], cam_data[:up], cam_data[:perspective])\r\n        cam.fov = cam_data[:fov]\r\n        Sketchup.active_model.active_view.camera = cam\r\n      end\r\n\r\n      @dialog.add_action_callback(\"play_tour\") do |_, json_data, loop_enabled, inverse_mode, use_easing, start_index|\r\n        @camera_keys = JSON.parse(json_data, symbolize_names: true)\r\n        view = Sketchup.active_model.active_view\r\n        return if @camera_keys.length < 2\r\n        @camera_keys.sort_by! { |v| v[:time] }\r\n        @index = start_index.to_i\r\n        @direction = 1\r\n        @ping_pong = loop_enabled && inverse_mode\r\n\r\n        define_singleton_method(:ease_in_out_quad) do |t|\r\n          t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t\r\n        end\r\n\r\n        define_singleton_method(:catmull_rom) do |p0, p1, p2, p3, t|\r\n          t2 = t * t\r\n          t3 = t2 * t\r\n          [\r\n            0.5 * ((2 * p1[0]) + (-p0[0] + p2[0]) * t + (2*p0[0] - 5*p1[0] + 4*p2[0] - p3[0]) * t2 + (-p0[0] + 3*p1[0] - 3*p2[0] + p3[0]) * t3),\r\n            0.5 * ((2 * p1[1]) + (-p0[1] + p2[1]) * t + (2*p0[1] - 5*p1[1] + 4*p2[1] - p3[1]) * t2 + (-p0[1] + 3*p1[1] - 3*p2[1] + p3[1]) * t3),\r\n            0.5 * ((2 * p1[2]) + (-p0[2] + p2[2]) * t + (2*p0[2] - 5*p1[2] + 4*p2[2] - p3[2]) * t2 + (-p0[2] + 3*p1[2] - 3*p2[2] + p3[2]) * t3)\r\n          ]\r\n        end\r\n\r\n        define_singleton_method(:catmull_rom_1d) do |p0, p1, p2, p3, t|\r\n          t2 = t * t\r\n          t3 = t2 * t\r\n          0.5 * ((2 * p1) + (-p0 + p2) * t + (2*p0 - 5*p1 + 4*p2 - p3) * t2 + (-p0 + 3*p1 - 3*p2 + p3) * t3)\r\n        end\r\n\r\n        define_singleton_method(:play_transition) do\r\n          current = @camera_keys[@index]\r\n          next_index = @index + @direction\r\n\r\n          if next_index >= @camera_keys.size || next_index < 0\r\n            if loop_enabled\r\n               @index = 0\r\n               UI.start_timer(0.01) { play_transition }\r\n               return\r\n            else\r\n              @dialog.execute_script(\"pauseAtIndex(0)\")\r\n              return\r\n            end\r\n          end\r\n\r\n          next_cam = @camera_keys[next_index]\r\n          duration = (next_cam[:time] - current[:time]).abs\r\n          t_start = Time.now\r\n\r\n          p0 = @camera_keys[[@index - 1, 0].max]\r\n          p1 = current\r\n          p2 = next_cam\r\n          p3 = @camera_keys[[@index + 2, @camera_keys.size - 1].min]\r\n\r\n          @walk_shake = {\r\n            z_phase: rand * Math::PI * 2, x_phase: rand * Math::PI * 2,\r\n            z_amp: 0.8 + rand * 0.4, x_amp: 0.3 + rand * 0.4\r\n          }\r\n          playhead_counter = 0\r\n\r\n          @timer_id = UI.start_timer(0.03, true) do\r\n            t_elapsed = Time.now - t_start\r\n            t = duration.zero? ? 1.0 : [t_elapsed / duration, 1.0].min\r\n            t = use_easing ? ease_in_out_quad(t) : t\r\n\r\n            # Atualizar playhead na timeline (~a cada 0.09s)\r\n            playhead_counter += 1\r\n            if playhead_counter % 3 == 0\r\n              interpolated_time = current[:time] + t * (next_cam[:time] - current[:time])\r\n              @dialog.execute_script(\"updatePlayhead(#{interpolated_time.round(1)})\")\r\n            end\r\n\r\n            eye    = catmull_rom(p0[:eye],    p1[:eye],    p2[:eye],    p3[:eye],    t)\r\n            target = catmull_rom(p0[:target], p1[:target], p2[:target], p3[:target], t)\r\n            up     = catmull_rom(p0[:up],     p1[:up],     p2[:up],     p3[:up],     t)\r\n\r\n            # Interpolação Catmull-Rom para o FOV: suavidade total acompanhando a curva da câmera\r\n            fov = catmull_rom_1d(p0[:fov], p1[:fov], p2[:fov], p3[:fov], t)\r\n\r\n            if current[:walk]\r\n              eye[2] += Math.sin(t * Math::PI * 6 + @walk_shake[:z_phase]) * @walk_shake[:z_amp]\r\n              eye[0] += Math.sin(t * Math::PI * 3 + @walk_shake[:x_phase]) * @walk_shake[:x_amp]\r\n            end\r\n\r\n            cam = Sketchup::Camera.new(eye, target, up, current[:perspective])\r\n            cam.fov = fov\r\n            view.camera = cam\r\n            view.refresh\r\n\r\n            if t >= 1.0\r\n              UI.stop_timer(@timer_id)\r\n              @index = next_index\r\n              if @camera_keys[@index][:anchor] && @index > 0\r\n                @dialog.execute_script(\"pauseAtIndex(#{@index})\")\r\n              else\r\n                play_transition\r\n              end\r\n            end\r\n          end\r\n        end\r\n\r\n        play_transition\r\n      end\r\n\r\n      # Callback de exportação com presets de resolução\r\n      @dialog.add_action_callback(\"start_export_process\") do |_, json_data, use_easing, start_index, width, height, filename|\r\n        iniciar_processo_exportacao(json_data, use_easing, start_index, width.to_i, height.to_i, filename.to_s)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"start_export_project\") do |_, all_timelines_json, use_easing, active_tl_index, start_vision_index, width, height, filename|\r\n        iniciar_processo_exportacao_projeto(all_timelines_json, use_easing, active_tl_index.to_i, start_vision_index.to_i, width.to_i, height.to_i, filename.to_s)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"install_ffmpeg\") do |_|\r\n        eval(FFMPEG_INSTALL_SCRIPT)\r\n        UI.messagebox(obter_texto(:ffmpeg_instalado))\r\n      end\r\n\r\n      @dialog.add_action_callback(\"stop_tour\") do |_|\r\n        UI.stop_timer(@timer_id) if @timer_id\r\n        @dialog.execute_script(\"resetPlayButton()\")\r\n      end\r\n\r\n      @dialog.add_action_callback(\"show_export_preview\") do |_, width, height|\r\n        @preview_tool = ExportPreviewTool.new(width.to_i, height.to_i)\r\n        Sketchup.active_model.select_tool(@preview_tool)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"hide_export_preview\") do |_|\r\n        Sketchup.active_model.select_tool(nil)\r\n        @preview_tool = nil\r\n      end\r\n\r\n      @dialog.set_on_closed {\r\n        UI.stop_timer(@timer_id) if defined?(@timer_id) && @timer_id\r\n        stop_space_timer\r\n        if @preview_tool\r\n          Sketchup.active_model.select_tool(nil)\r\n          @preview_tool = nil\r\n        end\r\n      }\r\n\r\n      @dialog.show\r\n    end\r\n  end\r\nend\r\n\r\ndef self.executar\r\n  TourPlugin::CameraTimeline.start_ui\r\nend\r\n\r\nend # module TourVirtual\r\nend # module ScriptUpComunidade\r\n\r\nScriptUpComunidade::TourVirtual.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "tour-virtual-8ye5t",
    "title": {
      "pt": "Tour Virtual",
      "en": "Virtual Tour",
      "es": "Visita virtual"
    },
    "author": "Fábio Coutinho",
    "version": "2.9",
    "description": {
      "pt": "Permite criar e gerenciar a criação de cenas em linha de tempo, várias linhas de tempo, apresentar a transição entre elas de forma suave e sem impacto de troca de cena e exportação de vídeo com FFMPEG de forma rápida por captura de tela enquanto apresenta.",
      "en": "It allows you to create and manage timeline scenes, multiple timelines, present the transition between them smoothly and without scene change impact, and quickly export video with FFMPEG by screen capture while presenting.",
      "es": "Le permite crear y administrar escenas de línea de tiempo, múltiples líneas de tiempo, presentar la transición entre ellas sin problemas y sin impacto en el cambio de escena, y exportar rápidamente video con FFMPEG mediante captura de pantalla mientras se presenta."
    },
    "keywords": {
      "pt": [
        "tour",
        "apresentação",
        "vídeo"
      ],
      "en": [
        "tour",
        "presentation",
        "video"
      ],
      "es": [
        "recorrido",
        "presentación",
        "video"
      ]
    },
    "code": {
      "pt": "require 'json'\r\nrequire 'sketchup.rb'\r\nrequire 'base64'\r\nrequire 'tmpdir'\r\nrequire 'fiddle/import'\r\nrequire 'fileutils'\r\nrequire 'open3'\r\nrequire 'etc'\r\nrequire 'open-uri'\r\nif Sketchup.platform == :platform_win\r\n  require 'win32ole'\r\nend\r\n\r\nmodule ScriptUpComunidade\r\nmodule TourVirtual\r\n\r\n# --- Definições de Diretórios ---\r\nplugins_root = Sketchup.find_support_file(\"Plugins\")\r\nPLUGIN_DIR = if plugins_root\r\n               File.expand_path(File.join(plugins_root, 'ScriptUp'))\r\n             else\r\n               File.expand_path(File.dirname(__FILE__))\r\n             end unless defined?(PLUGIN_DIR)\r\n\r\nIDIOMAS ||= {\r\n  'pt-BR' => {\r\n    :status_clicar_arrastar  => \"CLIQUE E ARRASTE para definir a área de gravação do vídeo.\",\r\n    :area_pequena            => \"Área muito pequena. Tente novamente.\",\r\n    :selecionar_pasta        => \"Selecione a pasta para salvar\",\r\n    :ffmpeg_nao_encontrado   => \"FFmpeg não encontrado.\",\r\n    :erro_gravador           => \"Erro ao iniciar gravador: \",\r\n    :gravacao_finalizada     => \"Gravação finalizada!\\nSalvo em: \",\r\n    :ffmpeg_instalado        => \"FFmpeg instalado. Execute o Tour Virtual novamente.\",\r\n    :titulo_dialogo          => \"Tour Virtual\",\r\n    :ffmpeg_plugins_erro     => \"Não foi possível resolver a pasta Plugins automaticamente.\",\r\n    :ffmpeg_instalar_em      => \"Instalar FFmpeg em:\",\r\n    :ffmpeg_origem           => \"Origem:\",\r\n    :ffmpeg_continuar        => \"Continuar?\",\r\n    :ffmpeg_cancelada        => \"Instalação cancelada.\",\r\n    :ffmpeg_ja_existe        => \"Já existe:\",\r\n    :ffmpeg_sobrescrever     => \"Deseja sobrescrever?\",\r\n    :ffmpeg_falha_expand     => \"Falha no Expand-Archive (PowerShell).\",\r\n    :ffmpeg_falha_unzip      => \"Falha no unzip (macOS).\",\r\n    :ffmpeg_exe_nao_encontrado => \"Executável ffmpeg não encontrado no pacote baixado.\",\r\n    :ffmpeg_sucesso          => \"FFmpeg instalado com sucesso em:\",\r\n    :ffmpeg_falhou           => \"Falhou:\",\r\n    :ffmpeg_abrindo_nav      => \"Abrindo o link no navegador...\",\r\n    :titulo                  => \"Tour Virtual\",\r\n    :subtitulo               => \"Linha do Tempo\",\r\n    :total                   => \"Total:\",\r\n    :visao                   => \"Visão\",\r\n    :play                    => \"Play\",\r\n    :stop                    => \"Stop\",\r\n    :play_all                => \"Play All\",\r\n    :stop_all                => \"Stop All\",\r\n    :atalho                  => \"Atalho\",\r\n    :pressione               => \"Pressione...\",\r\n    :ok                      => \"Ok\",\r\n    :loop                    => \"Loop\",\r\n    :easing                  => \"Easing\",\r\n    :visoes_salvas           => \"Visões salvas\",\r\n    :gerenciar_timeline      => \"Gerenciar Time Line\",\r\n    :nova                    => \"Nova\",\r\n    :exportar_atual          => \"Exportar Atual\",\r\n    :exportar_projeto        => \"Exportar Projeto\",\r\n    :importar                => \"Importar\",\r\n    :exportar_video          => \"Exportar Vídeo\",\r\n    :selecione_formato       => \"Selecione o formato…\",\r\n    :largura                 => \"Largura\",\r\n    :altura                  => \"Altura\",\r\n    :gravar_projeto          => \"Gravar todo o projeto (todas as Time Lines)\",\r\n    :iniciar_quadro1         => \"Iniciar do quadro 1\",\r\n    :iniciar_gravacao        => \"Iniciar Gravação\",\r\n    :gravando                => \"Gravando...\",\r\n    :ffmpeg_necessario       => \"FFmpeg necessário para gravar vídeo.\",\r\n    :instalar_ffmpeg         => \"Instalar FFmpeg\",\r\n    :nome_arquivo            => \"Nome do arquivo\",\r\n    :extensao_mp4            => \"A extensão .mp4 será adicionada automaticamente.\",\r\n    :cancelar                => \"Cancelar\",\r\n    :salvar                  => \"Salvar\",\r\n    :viewport_atual          => \"Viewport atual:\",\r\n    :paisagem                => \"Paisagem\",\r\n    :retrato                 => \"Retrato\",\r\n    :quadrado                => \"Quadrado\",\r\n    :classico                => \"Clássico\",\r\n    :ultra_wide              => \"Ultra-wide\",\r\n    :viewport_inteira        => \"Viewport Inteira\",\r\n    :personalizado           => \"Personalizado\",\r\n    :nome_timeline           => \"Nome da Time Line:\",\r\n    :nenhuma_visao           => \"Nenhuma visão adicionada.\",\r\n    :dica_visao              => \"Posicione a câmera e clique em <b>+ Visão</b>.\",\r\n    :ancora                  => \"Âncora\",\r\n    :excluir                 => \"Excluir\",\r\n    :min_duas_visoes         => \"Adicione pelo menos duas visões.\",\r\n    :sem_tl_2mais            => \"Nenhuma Time Line com 2+ visões.\",\r\n    :sem_visoes_exportar     => \"Nenhuma visão para exportar.\",\r\n    :sem_tl_exportar         => \"Nenhuma Time Line para exportar.\",\r\n    :importada               => \"Importada\",\r\n    :formato_invalido        => \"Formato inválido.\",\r\n    :erro_importar           => \"Erro ao importar: \",\r\n    :visoes                  => \"visões\",\r\n    :nova_timeline           => \"Nome da nova Time Line:\",\r\n    :area_gravacao           => \"Área de gravação: \",\r\n    :sem_tl_min_duas         => \"Nenhuma Time Line com pelo menos duas visões.\",\r\n    :dims_invalidas          => \"Dimensões inválidas (mínimo 50 x 50 px).\",\r\n    :digite_nome             => \"Digite um nome para o arquivo.\",\r\n  },\r\n  'en-US' => {\r\n    :status_clicar_arrastar  => \"CLICK AND DRAG to define the video recording area.\",\r\n    :area_pequena            => \"Area too small. Try again.\",\r\n    :selecionar_pasta        => \"Select folder to save\",\r\n    :ffmpeg_nao_encontrado   => \"FFmpeg not found.\",\r\n    :erro_gravador           => \"Error starting recorder: \",\r\n    :gravacao_finalizada     => \"Recording finished!\\nSaved to: \",\r\n    :ffmpeg_instalado        => \"FFmpeg installed. Run Virtual Tour again.\",\r\n    :titulo_dialogo          => \"Virtual Tour\",\r\n    :ffmpeg_plugins_erro     => \"Could not resolve the Plugins folder automatically.\",\r\n    :ffmpeg_instalar_em      => \"Install FFmpeg to:\",\r\n    :ffmpeg_origem           => \"Source:\",\r\n    :ffmpeg_continuar        => \"Continue?\",\r\n    :ffmpeg_cancelada        => \"Installation cancelled.\",\r\n    :ffmpeg_ja_existe        => \"Already exists:\",\r\n    :ffmpeg_sobrescrever     => \"Overwrite?\",\r\n    :ffmpeg_falha_expand     => \"Expand-Archive failed (PowerShell).\",\r\n    :ffmpeg_falha_unzip      => \"unzip failed (macOS).\",\r\n    :ffmpeg_exe_nao_encontrado => \"FFmpeg executable not found in downloaded package.\",\r\n    :ffmpeg_sucesso          => \"FFmpeg successfully installed to:\",\r\n    :ffmpeg_falhou           => \"Failed:\",\r\n    :ffmpeg_abrindo_nav      => \"Opening the link in browser...\",\r\n    :titulo                  => \"Virtual Tour\",\r\n    :subtitulo               => \"Timeline\",\r\n    :total                   => \"Total:\",\r\n    :visao                   => \"Vision\",\r\n    :play                    => \"Play\",\r\n    :stop                    => \"Stop\",\r\n    :play_all                => \"Play All\",\r\n    :stop_all                => \"Stop All\",\r\n    :atalho                  => \"Hotkey\",\r\n    :pressione               => \"Press a key...\",\r\n    :ok                      => \"Ok\",\r\n    :loop                    => \"Loop\",\r\n    :easing                  => \"Easing\",\r\n    :visoes_salvas           => \"Saved visions\",\r\n    :gerenciar_timeline      => \"Manage Timeline\",\r\n    :nova                    => \"New\",\r\n    :exportar_atual          => \"Export Current\",\r\n    :exportar_projeto        => \"Export Project\",\r\n    :importar                => \"Import\",\r\n    :exportar_video          => \"Export Video\",\r\n    :selecione_formato       => \"Select format…\",\r\n    :largura                 => \"Width\",\r\n    :altura                  => \"Height\",\r\n    :gravar_projeto          => \"Record entire project (all Timelines)\",\r\n    :iniciar_quadro1         => \"Start from frame 1\",\r\n    :iniciar_gravacao        => \"Start Recording\",\r\n    :gravando                => \"Recording...\",\r\n    :ffmpeg_necessario       => \"FFmpeg is required to record video.\",\r\n    :instalar_ffmpeg         => \"Install FFmpeg\",\r\n    :nome_arquivo            => \"File name\",\r\n    :extensao_mp4            => \"The .mp4 extension will be added automatically.\",\r\n    :cancelar                => \"Cancel\",\r\n    :salvar                  => \"Save\",\r\n    :viewport_atual          => \"Current viewport:\",\r\n    :paisagem                => \"Landscape\",\r\n    :retrato                 => \"Portrait\",\r\n    :quadrado                => \"Square\",\r\n    :classico                => \"Classic\",\r\n    :ultra_wide              => \"Ultra-wide\",\r\n    :viewport_inteira        => \"Full Viewport\",\r\n    :personalizado           => \"Custom\",\r\n    :nome_timeline           => \"Timeline name:\",\r\n    :nenhuma_visao           => \"No visions added.\",\r\n    :dica_visao              => \"Position the camera and click <b>+ Vision</b>.\",\r\n    :ancora                  => \"Anchor\",\r\n    :excluir                 => \"Delete\",\r\n    :min_duas_visoes         => \"Add at least two visions.\",\r\n    :sem_tl_2mais            => \"No Timeline with 2+ visions.\",\r\n    :sem_visoes_exportar     => \"No visions to export.\",\r\n    :sem_tl_exportar         => \"No Timeline to export.\",\r\n    :importada               => \"Imported\",\r\n    :formato_invalido        => \"Invalid format.\",\r\n    :erro_importar           => \"Import error: \",\r\n    :visoes                  => \"visions\",\r\n    :nova_timeline           => \"New Timeline name:\",\r\n    :area_gravacao           => \"Recording area: \",\r\n    :sem_tl_min_duas         => \"No Timeline with at least two visions.\",\r\n    :dims_invalidas          => \"Invalid dimensions (minimum 50 x 50 px).\",\r\n    :digite_nome             => \"Enter a file name.\",\r\n  },\r\n  'es' => {\r\n    :status_clicar_arrastar  => \"HAZ CLIC Y ARRASTRA para definir el área de grabación del video.\",\r\n    :area_pequena            => \"Área demasiado pequeña. Inténtalo de nuevo.\",\r\n    :selecionar_pasta        => \"Selecciona la carpeta para guardar\",\r\n    :ffmpeg_nao_encontrado   => \"FFmpeg no encontrado.\",\r\n    :erro_gravador           => \"Error al iniciar grabador: \",\r\n    :gravacao_finalizada     => \"¡Grabación finalizada!\\nGuardado en: \",\r\n    :ffmpeg_instalado        => \"FFmpeg instalado. Ejecuta Tour Virtual de nuevo.\",\r\n    :titulo_dialogo          => \"Tour Virtual\",\r\n    :ffmpeg_plugins_erro     => \"No se pudo resolver la carpeta Plugins automáticamente.\",\r\n    :ffmpeg_instalar_em      => \"Instalar FFmpeg en:\",\r\n    :ffmpeg_origem           => \"Origen:\",\r\n    :ffmpeg_continuar        => \"¿Continuar?\",\r\n    :ffmpeg_cancelada        => \"Instalación cancelada.\",\r\n    :ffmpeg_ja_existe        => \"Ya existe:\",\r\n    :ffmpeg_sobrescrever     => \"¿Sobrescribir?\",\r\n    :ffmpeg_falha_expand     => \"Error en Expand-Archive (PowerShell).\",\r\n    :ffmpeg_falha_unzip      => \"Error en unzip (macOS).\",\r\n    :ffmpeg_exe_nao_encontrado => \"Ejecutable FFmpeg no encontrado en el paquete descargado.\",\r\n    :ffmpeg_sucesso          => \"FFmpeg instalado con éxito en:\",\r\n    :ffmpeg_falhou           => \"Falló:\",\r\n    :ffmpeg_abrindo_nav      => \"Abriendo el enlace en el navegador...\",\r\n    :titulo                  => \"Tour Virtual\",\r\n    :subtitulo               => \"Línea de Tiempo\",\r\n    :total                   => \"Total:\",\r\n    :visao                   => \"Visión\",\r\n    :play                    => \"Play\",\r\n    :stop                    => \"Stop\",\r\n    :play_all                => \"Play All\",\r\n    :stop_all                => \"Stop All\",\r\n    :atalho                  => \"Atajo\",\r\n    :pressione               => \"Presiona...\",\r\n    :ok                      => \"Ok\",\r\n    :loop                    => \"Loop\",\r\n    :easing                  => \"Easing\",\r\n    :visoes_salvas           => \"Visiones guardadas\",\r\n    :gerenciar_timeline      => \"Gestionar Línea de Tiempo\",\r\n    :nova                    => \"Nueva\",\r\n    :exportar_atual          => \"Exportar Actual\",\r\n    :exportar_projeto        => \"Exportar Proyecto\",\r\n    :importar                => \"Importar\",\r\n    :exportar_video          => \"Exportar Video\",\r\n    :selecione_formato       => \"Selecciona el formato…\",\r\n    :largura                 => \"Ancho\",\r\n    :altura                  => \"Alto\",\r\n    :gravar_projeto          => \"Grabar todo el proyecto (todas las Líneas de Tiempo)\",\r\n    :iniciar_quadro1         => \"Iniciar desde el cuadro 1\",\r\n    :iniciar_gravacao        => \"Iniciar Grabación\",\r\n    :gravando                => \"Grabando...\",\r\n    :ffmpeg_necessario       => \"FFmpeg necesario para grabar video.\",\r\n    :instalar_ffmpeg         => \"Instalar FFmpeg\",\r\n    :nome_arquivo            => \"Nombre del archivo\",\r\n    :extensao_mp4            => \"La extensión .mp4 se añadirá automáticamente.\",\r\n    :cancelar                => \"Cancelar\",\r\n    :salvar                  => \"Guardar\",\r\n    :viewport_atual          => \"Viewport actual:\",\r\n    :paisagem                => \"Paisaje\",\r\n    :retrato                 => \"Retrato\",\r\n    :quadrado                => \"Cuadrado\",\r\n    :classico                => \"Clásico\",\r\n    :ultra_wide              => \"Ultra-wide\",\r\n    :viewport_inteira        => \"Viewport Completa\",\r\n    :personalizado           => \"Personalizado\",\r\n    :nome_timeline           => \"Nombre de la Línea de Tiempo:\",\r\n    :nenhuma_visao           => \"Ninguna visión añadida.\",\r\n    :dica_visao              => \"Posiciona la cámara y haz clic en <b>+ Visión</b>.\",\r\n    :ancora                  => \"Ancla\",\r\n    :excluir                 => \"Eliminar\",\r\n    :min_duas_visoes         => \"Añade al menos dos visiones.\",\r\n    :sem_tl_2mais            => \"Ninguna Línea de Tiempo con 2+ visiones.\",\r\n    :sem_visoes_exportar     => \"Ninguna visión para exportar.\",\r\n    :sem_tl_exportar         => \"Ninguna Línea de Tiempo para exportar.\",\r\n    :importada               => \"Importada\",\r\n    :formato_invalido        => \"Formato inválido.\",\r\n    :erro_importar           => \"Error al importar: \",\r\n    :visoes                  => \"visiones\",\r\n    :nova_timeline           => \"Nombre de la nueva Línea de Tiempo:\",\r\n    :area_gravacao           => \"Área de grabación: \",\r\n    :sem_tl_min_duas         => \"Ninguna Línea de Tiempo con al menos dos visiones.\",\r\n    :dims_invalidas          => \"Dimensiones inválidas (mínimo 50 x 50 px).\",\r\n    :digite_nome             => \"Escribe un nombre para el archivo.\",\r\n  },\r\n}\r\n\r\ndef self.obter_texto(chave)\r\n  locale = Sketchup.get_locale\r\n  lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n  IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\nend\r\n\r\n# --- Script de Instalação do FFmpeg (Mantido) ---\r\nFFMPEG_INSTALL_SCRIPT ||= <<~'RUBY'\r\n  require 'sketchup'\r\n  require 'open-uri'\r\n  require 'fileutils'\r\n  require 'tmpdir'\r\n\r\n  URL_WIN ||= 'https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-master-latest-win64-gpl.zip'\r\n  URL_MAC ||= 'https://evermeet.cx/ffmpeg/getrelease/zip'\r\n\r\n  win = Sketchup.platform == :platform_win\r\n  major = Sketchup.version.to_s[/^\\d+/].to_i\r\n  sketchup_year = 2000 + major\r\n\r\n  plugins_dir = Sketchup.find_support_file('Plugins')\r\n  if !plugins_dir || plugins_dir.empty? || !Dir.exist?(plugins_dir)\r\n    if win\r\n      base = ENV['APPDATA'].to_s\r\n      plugins_dir = File.join(base, 'SketchUp', \"SketchUp #{sketchup_year}\", 'SketchUp', 'Plugins')\r\n    else\r\n      plugins_dir = File.expand_path(\"~/Library/Application Support/SketchUp #{sketchup_year}/SketchUp/Plugins\")\r\n    end\r\n  end\r\n\r\n  target_dir = File.join(plugins_dir, 'ScriptUp', 'ffmpeg')\r\n  target_exe = File.join(target_dir, win ? 'ffmpeg.exe' : 'ffmpeg')\r\n  url = win ? URL_WIN : URL_MAC\r\n  default_zip_name = win ? 'ffmpeg-win64-gpl-latest.zip' : 'ffmpeg-macos-release.zip'\r\n\r\n  proceed = true\r\n\r\n  unless plugins_dir && !plugins_dir.empty?\r\n    UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_plugins_erro))\r\n    proceed = false\r\n  end\r\n\r\n  if proceed\r\n    msg = \"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_instalar_em)}\\n#{target_dir}\\n\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_origem)}\\n#{url}\\n\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_continuar)}\"\r\n    if UI.messagebox(msg, MB_YESNO) != IDYES\r\n      UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_cancelada))\r\n      proceed = false\r\n    end\r\n  end\r\n\r\n  if proceed && File.exist?(target_exe)\r\n    overwrite = UI.messagebox(\"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_ja_existe)}\\n#{target_exe}\\n\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_sobrescrever)}\", MB_YESNO)\r\n    if overwrite != IDYES\r\n      UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_cancelada))\r\n      proceed = false\r\n    end\r\n  end\r\n\r\n  if proceed\r\n    Dir.mktmpdir('ffmpeg_dl_') do |tmp|\r\n      zip_path = File.join(tmp, default_zip_name)\r\n      extract_dir = File.join(tmp, 'unzipped')\r\n      begin\r\n        URI.open(url, 'rb') do |io|\r\n          File.open(zip_path, 'wb') { |f| IO.copy_stream(io, f) }\r\n        end\r\n        Dir.mkdir(extract_dir)\r\n        if win\r\n          ps = 'powershell -NoProfile -ExecutionPolicy Bypass -Command'\r\n          cmd = \"#{ps} \\\"Expand-Archive -LiteralPath '#{zip_path}' -DestinationPath '#{extract_dir}' -Force\\\"\"\r\n          ok = system(cmd)\r\n          raise ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_falha_expand) unless ok\r\n        else\r\n          ok = system(\"unzip -o -q '#{zip_path}' -d '#{extract_dir}'\")\r\n          raise ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_falha_unzip) unless ok\r\n        end\r\n\r\n        pattern = win ? '**/ffmpeg.exe' : '**/ffmpeg'\r\n        bin = Dir.glob(File.join(extract_dir, pattern)).find { |p| File.file?(p) }\r\n        raise ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_exe_nao_encontrado) unless bin\r\n\r\n        FileUtils.mkdir_p(target_dir) unless Dir.exist?(target_dir)\r\n        FileUtils.cp(bin, target_exe)\r\n        unless win\r\n          FileUtils.chmod(0o755, target_exe)\r\n          system(\"xattr -d com.apple.quarantine '#{target_exe}' 2>/dev/null\")\r\n        end\r\n\r\n        UI.messagebox(\"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_sucesso)}\\n#{target_exe}\")\r\n        puts \"OK: #{target_exe}\"\r\n      rescue => e\r\n        UI.messagebox(\"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_falhou)} #{e.message}\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_abrindo_nav)}\")\r\n        UI.openURL(url)\r\n      end\r\n    end\r\n  end\r\nRUBY\r\n\r\n# --- Módulo WindowUtils ---\r\nmodule WindowUtils\r\n  extend Fiddle::Importer\r\n  dlload 'user32.dll' if Sketchup.platform == :platform_win\r\n\r\n  if Sketchup.platform == :platform_win\r\n    typealias 'HWND', 'void*'\r\n    extern 'HWND GetActiveWindow()'\r\n    extern 'HWND GetForegroundWindow()'\r\n    extern 'HWND GetWindow(HWND, int)'\r\n    extern 'int GetWindowRect(HWND, void*)'\r\n    extern 'HWND GetParent(HWND)'\r\n    \r\n    GW_CHILD = 5 unless defined?(GW_CHILD)\r\n    GW_HWNDNEXT = 2 unless defined?(GW_HWNDNEXT)\r\n    Rect = struct ['long left', 'long top', 'long right', 'long bottom'] unless defined?(Rect)\r\n  end\r\n\r\n  def self.get_viewport_rect_deep(view)\r\n    return nil unless Sketchup.platform == :platform_win\r\n    \r\n    hwnd = GetForegroundWindow()\r\n    return nil if hwnd.nil? || hwnd == 0\r\n\r\n    vw = view.vpwidth\r\n    vh = view.vpheight\r\n    \r\n    found = find_recursive(hwnd, vw, vh)\r\n    return found if found\r\n\r\n    parent = GetParent(hwnd)\r\n    if parent && parent != 0\r\n      found = find_recursive(parent, vw, vh)\r\n      return found if found\r\n    end\r\n\r\n    nil\r\n  end\r\n\r\n  def self.find_recursive(parent_hwnd, target_w, target_h)\r\n    child = GetWindow(parent_hwnd, GW_CHILD)\r\n    while child && child.to_i != 0\r\n      rect = Rect.malloc\r\n      if GetWindowRect(child, rect) != 0\r\n        w = rect.right - rect.left\r\n        h = rect.bottom - rect.top\r\n        match = check_match(w, h, target_w, target_h, rect)\r\n        return match if match\r\n      end\r\n      found_in_child = find_recursive(child, target_w, target_h)\r\n      return found_in_child if found_in_child\r\n      child = GetWindow(child, GW_HWNDNEXT)\r\n    end\r\n    nil\r\n  end\r\n\r\n  def self.check_match(w, h, target_w, target_h, rect)\r\n    tol = 30\r\n    [1.0, 1.25, 1.5, 2.0].each do |scale|\r\n      if (w - target_w * scale).abs <= tol && (h - target_h * scale).abs <= tol\r\n        return { :x => rect.left, :y => rect.top, :w => w, :h => h, :scale => scale }\r\n      end\r\n    end\r\n    nil\r\n  end\r\nend\r\n\r\n# --- Módulo ScreenCapture (GDI32) ---\r\n# Captures the SketchUp viewport via Win32 GDI and produces a BMP thumbnail\r\n# encoded as Base64, suitable for embedding in an HTML <img> tag.\r\n#\r\n# Uses Fiddle::Importer (Ruby stdlib) to call gdi32.dll and user32.dll functions.\r\n# Also declares PrintWindow from user32.dll as a fallback for occluded windows.\r\n#\r\n# Fiddle type mapping reference (from fiddle/types.rb Win32Types):\r\n#   HANDLE / HDC / HWND / HBITMAP  ->  void*   (pointer-sized, correct for 32/64-bit)\r\n#   DWORD                          ->  unsigned long\r\n#   BOOL                           ->  int\r\n#   UINT                           ->  unsigned int\r\n#\r\n# The extern signatures below use 'void*' directly for all handle types\r\n# (HDC, HBITMAP, HGDIOBJ) so we do not need to include Fiddle::Win32Types\r\n# or add custom typealiases beyond what WindowUtils already defines.\r\nmodule ScreenCapture\r\n  extend Fiddle::Importer\r\n\r\n  if Sketchup.platform == :platform_win\r\n    dlload 'gdi32.dll', 'user32.dll'\r\n\r\n    # --- user32.dll functions ---\r\n    # HDC GetDC(HWND hWnd)\r\n    #   hWnd=NULL(0) returns DC for entire screen\r\n    extern 'void* GetDC(void*)'\r\n\r\n    # int ReleaseDC(HWND hWnd, HDC hDC)\r\n    extern 'int ReleaseDC(void*, void*)'\r\n\r\n    # BOOL PrintWindow(HWND hwnd, HDC hdcBlt, UINT nFlags)\r\n    #   Asks the window to paint itself into the given DC.\r\n    #   Works even when the window is partially occluded (unlike BitBlt from screen DC).\r\n    extern 'int PrintWindow(void*, void*, unsigned int)'\r\n\r\n    # --- gdi32.dll functions ---\r\n    # HDC CreateCompatibleDC(HDC hdc)\r\n    extern 'void* CreateCompatibleDC(void*)'\r\n\r\n    # HBITMAP CreateCompatibleBitmap(HDC hdc, int cx, int cy)\r\n    extern 'void* CreateCompatibleBitmap(void*, int, int)'\r\n\r\n    # HGDIOBJ SelectObject(HDC hdc, HGDIOBJ h)\r\n    extern 'void* SelectObject(void*, void*)'\r\n\r\n    # BOOL BitBlt(HDC hdc, int x, int y, int cx, int cy,\r\n    #             HDC hdcSrc, int x1, int y1, DWORD rop)\r\n    extern 'int BitBlt(void*, int, int, int, int, void*, int, int, unsigned long)'\r\n\r\n    # BOOL StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest,\r\n    #                 HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop)\r\n    extern 'int StretchBlt(void*, int, int, int, int, void*, int, int, int, int, unsigned long)'\r\n\r\n    # int SetStretchBltMode(HDC hdc, int mode)\r\n    extern 'int SetStretchBltMode(void*, int)'\r\n\r\n    # int GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines,\r\n    #               LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage)\r\n    #   lpvBits and lpbmi are both void* (raw pointers to caller-allocated buffers)\r\n    extern 'int GetDIBits(void*, void*, unsigned int, unsigned int, void*, void*, unsigned int)'\r\n\r\n    # BOOL DeleteDC(HDC hdc)\r\n    extern 'int DeleteDC(void*)'\r\n\r\n    # BOOL DeleteObject(HGDIOBJ ho)\r\n    extern 'int DeleteObject(void*)'\r\n\r\n    # --- Raster-operation and mode constants ---\r\n    SRCCOPY        = 0x00CC0020 unless defined?(SRCCOPY)\r\n    HALFTONE       = 4 unless defined?(HALFTONE)          # SetStretchBltMode mode for high-quality shrinking\r\n    DIB_RGB_COLORS = 0 unless defined?(DIB_RGB_COLORS)    # GetDIBits color table usage\r\n\r\n    # --- PrintWindow flags ---\r\n    PW_CLIENTONLY          = 0x00000001 unless defined?(PW_CLIENTONLY)          # capture client area only (no title bar)\r\n    PW_RENDERFULLCONTENT   = 0x00000002 unless defined?(PW_RENDERFULLCONTENT)  # Win 8.1+: captures DirectX/DWM content\r\n  end\r\n\r\n  # Build a 40-byte BITMAPINFOHEADER as a packed binary string.\r\n  #\r\n  # The BITMAPINFOHEADER struct layout (40 bytes total):\r\n  #   DWORD  biSize          (4 bytes, unsigned 32-bit LE)   = 40\r\n  #   LONG   biWidth         (4 bytes, signed   32-bit LE)\r\n  #   LONG   biHeight        (4 bytes, signed   32-bit LE)   negative = top-down DIB\r\n  #   WORD   biPlanes        (2 bytes, unsigned 16-bit LE)   = 1\r\n  #   WORD   biBitCount      (2 bytes, unsigned 16-bit LE)   = 24 for RGB\r\n  #   DWORD  biCompression   (4 bytes, unsigned 32-bit LE)   = 0 (BI_RGB)\r\n  #   DWORD  biSizeImage     (4 bytes, unsigned 32-bit LE)\r\n  #   LONG   biXPelsPerMeter (4 bytes, signed   32-bit LE)   = 0\r\n  #   LONG   biYPelsPerMeter (4 bytes, signed   32-bit LE)   = 0\r\n  #   DWORD  biClrUsed       (4 bytes, unsigned 32-bit LE)   = 0\r\n  #   DWORD  biClrImportant  (4 bytes, unsigned 32-bit LE)   = 0\r\n  #\r\n  # Pack template: 'L<' = uint32 LE, 'l<' = int32 LE, 'S<' = uint16 LE\r\n  # Combined: 'L< l< l< S< S< L< L< l< l< L< L<'  (spaces for clarity)\r\n  #\r\n  # Using negative biHeight produces a top-down DIB, which means:\r\n  #  - Row 0 in memory is the top row of the image\r\n  #  - No vertical flip is needed when writing the BMP file\r\n  #  - The BMP file header must also use the negative height to match\r\n  def self.pack_bitmapinfoheader(width, height, image_size)\r\n    [\r\n      40,           # biSize\r\n      width,        # biWidth\r\n      -height,      # biHeight (negative = top-down)\r\n      1,            # biPlanes\r\n      24,           # biBitCount (24-bit RGB)\r\n      0,            # biCompression (BI_RGB = uncompressed)\r\n      image_size,   # biSizeImage\r\n      0,            # biXPelsPerMeter\r\n      0,            # biYPelsPerMeter\r\n      0,            # biClrUsed\r\n      0             # biClrImportant\r\n    ].pack('L<l<l<S<S<L<L<l<l<L<L<')\r\n  end\r\n\r\n  # Build the 14-byte BMP file header (BITMAPFILEHEADER).\r\n  #\r\n  # Layout:\r\n  #   WORD   bfType      = 0x4D42 (\"BM\")\r\n  #   DWORD  bfSize      = total file size in bytes\r\n  #   WORD   bfReserved1 = 0\r\n  #   WORD   bfReserved2 = 0\r\n  #   DWORD  bfOffBits   = offset to pixel data = 14 + 40 = 54\r\n  #\r\n  # Pack template: 'S< L< S< S< L<'\r\n  def self.pack_bmp_file_header(pixel_data_size)\r\n    file_size = 14 + 40 + pixel_data_size\r\n    [\r\n      0x4D42,       # bfType (\"BM\")\r\n      file_size,    # bfSize\r\n      0,            # bfReserved1\r\n      0,            # bfReserved2\r\n      54            # bfOffBits (14-byte file header + 40-byte info header)\r\n    ].pack('S<L<S<S<L<')\r\n  end\r\n\r\n  # Capture the SketchUp viewport as a scaled-down BMP thumbnail and return\r\n  # a Base64-encoded string. Returns nil on failure (non-Windows, HWND not found, etc.).\r\n  #\r\n  # Strategy:\r\n  #   1. StretchBlt from screen DC (fast, works when viewport is visible)\r\n  #   2. If vp[:hwnd] is available, PrintWindow can be used as alternative\r\n  #\r\n  # Parameters:\r\n  #   view     - Sketchup::View instance\r\n  #   thumb_w  - desired thumbnail width  in pixels (default 96)\r\n  #   thumb_h  - desired thumbnail height in pixels (default 60)\r\n  #\r\n  # Returns: Base64-encoded BMP string, or nil on failure.\r\n  def self.capture_viewport(view, thumb_w = 96, thumb_h = 60)\r\n    return nil unless Sketchup.platform == :platform_win\r\n\r\n    vp = WindowUtils.get_viewport_rect_deep(view)\r\n    return nil unless vp\r\n\r\n    src_w = vp[:w]\r\n    src_h = vp[:h]\r\n\r\n    # Get screen DC -- needed for CreateCompatibleBitmap color depth\r\n    screen_dc = GetDC(0)\r\n    return nil if screen_dc.nil? || screen_dc.to_i == 0\r\n\r\n    begin\r\n      # Create a memory DC compatible with the screen\r\n      mem_dc = CreateCompatibleDC(screen_dc)\r\n      return nil if mem_dc.nil? || mem_dc.to_i == 0\r\n\r\n      begin\r\n        # Create a bitmap at the desired thumbnail size\r\n        bmp = CreateCompatibleBitmap(screen_dc, thumb_w, thumb_h)\r\n        return nil if bmp.nil? || bmp.to_i == 0\r\n\r\n        begin\r\n          old = SelectObject(mem_dc, bmp)\r\n          SetStretchBltMode(mem_dc, HALFTONE)\r\n\r\n          # StretchBlt from the screen DC directly into the thumbnail-sized bitmap.\r\n          # This both captures AND scales in a single operation.\r\n          ok = StretchBlt(\r\n            mem_dc, 0, 0, thumb_w, thumb_h,\r\n            screen_dc, vp[:x], vp[:y], src_w, src_h,\r\n            SRCCOPY\r\n          )\r\n          return nil if ok == 0\r\n\r\n          # IMPORTANT: Deselect the bitmap from the DC before calling GetDIBits.\r\n          # Per MSDN: \"The bitmap identified by hbmp must not be selected into\r\n          # a device context when the application calls this function.\"\r\n          SelectObject(mem_dc, old)\r\n          old = nil\r\n\r\n          # Calculate row stride (BMP rows must be padded to 4-byte boundaries)\r\n          stride     = ((thumb_w * 3 + 3) & ~3)\r\n          pixel_size = stride * thumb_h\r\n\r\n          # Pack the BITMAPINFOHEADER into a Fiddle::Pointer buffer.\r\n          # GetDIBits may modify the header (e.g., filling in biSizeImage),\r\n          # so we use a mutable native buffer rather than a Ruby String.\r\n          bmi_bytes = pack_bitmapinfoheader(thumb_w, thumb_h, pixel_size)\r\n          bmi_ptr   = Fiddle::Pointer.malloc(bmi_bytes.bytesize)\r\n          bmi_ptr[0, bmi_bytes.bytesize] = bmi_bytes\r\n\r\n          # Allocate the pixel data buffer\r\n          buf = Fiddle::Pointer.malloc(pixel_size)\r\n\r\n          begin\r\n            # GetDIBits(hdc, hbm, start, cLines, lpvBits, lpbmi, usage)\r\n            # hdc: a DC compatible with the bitmap (mem_dc works)\r\n            # hbm: the bitmap handle (NOT selected into any DC)\r\n            rows = GetDIBits(mem_dc, bmp, 0, thumb_h, buf, bmi_ptr, DIB_RGB_COLORS)\r\n            return nil if rows == 0\r\n\r\n            # Read the raw pixel bytes from the Fiddle::Pointer buffer.\r\n            # ptr[offset, length] returns a Ruby String (binary safe, works since Ruby 2.0).\r\n            pixel_data = buf[0, pixel_size]\r\n\r\n            # Assemble the complete BMP file: file header + info header + pixel data\r\n            file_hdr = pack_bmp_file_header(pixel_size)\r\n            info_hdr = pack_bitmapinfoheader(thumb_w, thumb_h, pixel_size)\r\n\r\n            Base64.strict_encode64(file_hdr + info_hdr + pixel_data)\r\n          ensure\r\n            Fiddle.free(bmi_ptr) if bmi_ptr\r\n            Fiddle.free(buf)     if buf\r\n          end\r\n        ensure\r\n          SelectObject(mem_dc, old) if old\r\n          DeleteObject(bmp)\r\n        end\r\n      ensure\r\n        DeleteDC(mem_dc)\r\n      end\r\n    ensure\r\n      ReleaseDC(0, screen_dc)\r\n    end\r\n  rescue => e\r\n    puts \"ScreenCapture error: #{e.message}\"\r\n    puts e.backtrace.first(5).join(\"\\n\")\r\n    nil\r\n  end\r\nend\r\n\r\nmodule TourPlugin\r\n  class AreaSelectorTool\r\n    def initialize(callback)\r\n      @callback = callback\r\n      @start_x = nil; @start_y = nil; @current_x = nil; @current_y = nil\r\n      @drawing = false\r\n    end\r\n\r\n    def activate\r\n      Sketchup.active_model.active_view.invalidate\r\n      Sketchup.status_text = ScriptUpComunidade::TourVirtual.obter_texto(:status_clicar_arrastar)\r\n    end\r\n\r\n    def onLButtonDown(flags, x, y, view)\r\n      @start_x = x; @start_y = y; @current_x = x; @current_y = y\r\n      @drawing = true\r\n    end\r\n\r\n    def onMouseMove(flags, x, y, view)\r\n      if @drawing\r\n        @current_x = x; @current_y = y\r\n        view.invalidate\r\n      end\r\n    end\r\n\r\n    def onLButtonUp(flags, x, y, view)\r\n      return unless @drawing\r\n      @drawing = false\r\n      x1 = [@start_x, @current_x].min\r\n      y1 = [@start_y, @current_y].min\r\n      x2 = [@start_x, @current_x].max\r\n      y2 = [@start_y, @current_y].max\r\n      width = x2 - x1\r\n      height = y2 - y1\r\n\r\n      if width < 50 || height < 50\r\n        UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:area_pequena))\r\n        Sketchup.active_model.select_tool(nil)\r\n        return\r\n      end\r\n\r\n      @callback.call({ :x => x1, :y => y1, :w => width, :h => height })\r\n      Sketchup.active_model.select_tool(nil) \r\n    end\r\n\r\n    def draw(view)\r\n      return unless @drawing && @start_x && @current_x\r\n      points = [\r\n        Geom::Point3d.new(@start_x, @start_y, 0),\r\n        Geom::Point3d.new(@current_x, @start_y, 0),\r\n        Geom::Point3d.new(@current_x, @current_y, 0),\r\n        Geom::Point3d.new(@start_x, @current_y, 0)\r\n      ]\r\n      view.line_width = 3\r\n      view.drawing_color = 'red'\r\n      view.draw2d(GL_LINE_LOOP, points)\r\n    end\r\n  end\r\n\r\n  class ExportPreviewTool\r\n    def initialize(target_w, target_h)\r\n      @target_w = target_w\r\n      @target_h = target_h\r\n    end\r\n\r\n    def activate\r\n      Sketchup.active_model.active_view.invalidate\r\n    end\r\n\r\n    def deactivate(view)\r\n      view.invalidate\r\n    end\r\n\r\n    def draw(view)\r\n      vw = view.vpwidth\r\n      vh = view.vpheight\r\n      ew = [@target_w, vw].min\r\n      eh = [@target_h, vh].min\r\n      ox = (vw - ew) / 2\r\n      oy = (vh - eh) / 2\r\n\r\n      # Escurecer áreas fora da gravação (letterbox/pillarbox)\r\n      view.drawing_color = Sketchup::Color.new(0, 0, 0, 120)\r\n      if oy > 0\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(0, 0, 0), Geom::Point3d.new(vw, 0, 0),\r\n          Geom::Point3d.new(vw, oy, 0), Geom::Point3d.new(0, oy, 0)\r\n        ])\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(0, oy + eh, 0), Geom::Point3d.new(vw, oy + eh, 0),\r\n          Geom::Point3d.new(vw, vh, 0), Geom::Point3d.new(0, vh, 0)\r\n        ])\r\n      end\r\n      if ox > 0\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(0, oy, 0), Geom::Point3d.new(ox, oy, 0),\r\n          Geom::Point3d.new(ox, oy + eh, 0), Geom::Point3d.new(0, oy + eh, 0)\r\n        ])\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(ox + ew, oy, 0), Geom::Point3d.new(vw, oy, 0),\r\n          Geom::Point3d.new(vw, oy + eh, 0), Geom::Point3d.new(ox + ew, oy + eh, 0)\r\n        ])\r\n      end\r\n\r\n      # Borda branca ao redor da área de gravação\r\n      view.line_width = 2\r\n      view.drawing_color = Sketchup::Color.new(255, 255, 255, 200)\r\n      view.draw2d(GL_LINE_LOOP, [\r\n        Geom::Point3d.new(ox, oy, 0), Geom::Point3d.new(ox + ew, oy, 0),\r\n        Geom::Point3d.new(ox + ew, oy + eh, 0), Geom::Point3d.new(ox, oy + eh, 0)\r\n      ])\r\n    end\r\n  end\r\n\r\n  module CameraTimeline\r\n    def self.obter_texto(chave)\r\n      ScriptUpComunidade::TourVirtual.obter_texto(chave)\r\n    end\r\n\r\n    module GlobalKey\r\n      extend Fiddle::Importer\r\n      if Sketchup.platform == :platform_win\r\n        dlload 'user32.dll'\r\n        extern 'short GetAsyncKeyState(int)'\r\n      else\r\n        dlload '/System/Library/Frameworks/ApplicationServices.framework/ApplicationServices'\r\n        extern 'bool CGEventSourceKeyState(int, int)'\r\n      end\r\n\r\n      DEFAULT_HOTKEY = (Sketchup.platform == :platform_win ? 0x6B : 69) unless defined?(DEFAULT_HOTKEY)\r\n      @key_code = Sketchup.read_default(\"TourVirtual\", \"Hotkey\", DEFAULT_HOTKEY).to_i\r\n      @ctrl = Sketchup.read_default(\"TourVirtual\", \"HotkeyCtrl\", false)\r\n      @alt = Sketchup.read_default(\"TourVirtual\", \"HotkeyAlt\", false)\r\n      @shift = Sketchup.read_default(\"TourVirtual\", \"HotkeyShift\", false)\r\n\r\n      # Windows virtual key codes for modifiers\r\n      VK_CONTROL = 0x11 unless defined?(VK_CONTROL)\r\n      VK_MENU    = 0x12 unless defined?(VK_MENU)\r\n      VK_SHIFT   = 0x10 unless defined?(VK_SHIFT)\r\n      # macOS key codes for modifiers\r\n      MAC_CTRL  = 59 unless defined?(MAC_CTRL)\r\n      MAC_SHIFT = 56 unless defined?(MAC_SHIFT)\r\n      MAC_ALT   = 58 unless defined?(MAC_ALT)\r\n\r\n      def self.set_hotkey(code, ctrl, alt, shift)\r\n        @key_code = code.to_i\r\n        @ctrl = ctrl\r\n        @alt = alt\r\n        @shift = shift\r\n      end\r\n\r\n      def self.key_code; @key_code; end\r\n      def self.ctrl; @ctrl; end\r\n      def self.alt; @alt; end\r\n      def self.shift; @shift; end\r\n\r\n      def self.key_pressed?(code)\r\n        if Sketchup.platform == :platform_win\r\n          GetAsyncKeyState(code) & 0x8000 != 0\r\n        else\r\n          CGEventSourceKeyState(0, code)\r\n        end\r\n      end\r\n\r\n      def self.space_pressed?\r\n        return false unless key_pressed?(@key_code)\r\n        if Sketchup.platform == :platform_win\r\n          return false if @ctrl && !key_pressed?(VK_CONTROL)\r\n          return false if @alt && !key_pressed?(VK_MENU)\r\n          return false if @shift && !key_pressed?(VK_SHIFT)\r\n        else\r\n          return false if @ctrl && !key_pressed?(MAC_CTRL)\r\n          return false if @alt && !key_pressed?(MAC_ALT)\r\n          return false if @shift && !key_pressed?(MAC_SHIFT)\r\n        end\r\n        true\r\n      end\r\n    end\r\n\r\n    def self.start_space_timer\r\n      return if defined?(@space_timer) && @space_timer\r\n      @space_down = false\r\n      @space_timer = UI.start_timer(0.1, true) do\r\n        if GlobalKey.space_pressed?\r\n          unless @space_down\r\n            @space_down = true\r\n            @dialog.execute_script('triggerSpaceFromRuby()')\r\n          end\r\n        else\r\n          @space_down = false\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.stop_space_timer\r\n      if defined?(@space_timer) && @space_timer\r\n        UI.stop_timer(@space_timer)\r\n        @space_timer = nil\r\n      end\r\n    end\r\n\r\n    def self.capture_thumbnail\r\n      view = Sketchup.active_model.active_view\r\n      # Tentar screen capture instantâneo via GDI32 (Windows)\r\n      result = ScreenCapture.capture_viewport(view, 96, 60) rescue nil\r\n      return result if result && result.length > 0\r\n      # Fallback: write_image (lento, mas funciona em qualquer plataforma)\r\n      path = File.join(Dir.tmpdir, \"thumb_#{Time.now.to_i}.jpg\")\r\n      view.write_image(path, 96, 60, false, 0.5)\r\n      encoded = Base64.strict_encode64(File.binread(path))\r\n      File.delete(path) if File.exist?(path)\r\n      encoded\r\n    end\r\n\r\n    # --- Lógica de Exportação ---\r\n    def self.calcular_rect_gravacao(export_width, export_height)\r\n      view = Sketchup.active_model.active_view\r\n      viewport_global = WindowUtils.get_viewport_rect_deep(view)\r\n\r\n      unless viewport_global\r\n        viewport_global = { :x => 0, :y => 0, :w => view.vpwidth, :h => view.vpheight, :scale => 1.0 }\r\n      end\r\n\r\n      vp_w = viewport_global[:w]\r\n      vp_h = viewport_global[:h]\r\n\r\n      final_w = [export_width.to_i, vp_w].min\r\n      final_h = [export_height.to_i, vp_h].min\r\n\r\n      offset_x = viewport_global[:x] + ((vp_w - final_w) / 2).to_i\r\n      offset_y = viewport_global[:y] + ((vp_h - final_h) / 2).to_i\r\n\r\n      final_w -= 1 if final_w.odd?\r\n      final_h -= 1 if final_h.odd?\r\n\r\n      { :x => offset_x, :y => offset_y, :w => final_w, :h => final_h }\r\n    end\r\n\r\n    def self.iniciar_processo_exportacao(json_data, use_easing, start_index_from_js, export_width, export_height, filename)\r\n      effective_index = start_index_from_js.to_i\r\n\r\n      if effective_index == 0\r\n        @dialog.execute_script(\"currentIndex = 0; updateTime(0); sketchup.goto_camera(JSON.stringify(visoes[0]));\")\r\n        sleep(0.5)\r\n      end\r\n\r\n      rect = calcular_rect_gravacao(export_width, export_height)\r\n      executar_gravacao_ffmpeg(json_data, use_easing, rect, effective_index, filename)\r\n    end\r\n\r\n    def self.iniciar_processo_exportacao_projeto(all_timelines_json, use_easing, active_tl_index, start_vision_index, export_width, export_height, filename)\r\n      timelines = JSON.parse(all_timelines_json, symbolize_names: true)\r\n      rect = calcular_rect_gravacao(export_width, export_height)\r\n\r\n      start_tl = active_tl_index.to_i\r\n      start_vision = start_vision_index.to_i\r\n\r\n      # Calcular duração total a partir do ponto de início\r\n      total_time = 0.0\r\n      timelines.each_with_index do |tl, i|\r\n        next if i < start_tl\r\n        next unless tl[:visoes] && tl[:visoes].length >= 2\r\n        sorted = tl[:visoes].sort_by { |v| v[:time] }\r\n        first_v = (i == start_tl && start_vision > 0 && start_vision < sorted.length) ? start_vision : 0\r\n        if first_v < sorted.length - 1\r\n          total_time += sorted.last[:time] - sorted[first_v][:time]\r\n          total_time += 0.5\r\n        end\r\n      end\r\n\r\n      play_cmd = \"startRecordingPlayAll(#{start_tl}, #{start_vision})\"\r\n      executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, play_cmd)\r\n    end\r\n\r\n    def self.executar_gravacao_ffmpeg(json_data, use_easing, rect, start_index, filename)\r\n      camera_keys = JSON.parse(json_data, symbolize_names: true)\r\n      camera_keys.sort_by! { |v| v[:time] }\r\n\r\n      total_time = 0\r\n      if start_index < camera_keys.length - 1\r\n        relevant_keys = camera_keys[start_index..-1]\r\n        relevant_keys.each_cons(2) { |c, n| total_time += (n[:time] - c[:time]).abs }\r\n      end\r\n\r\n      executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, \"triggerSpaceFromRuby()\")\r\n    end\r\n\r\n    def self.executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, play_command)\r\n      folder = UI.select_directory(title: obter_texto(:selecionar_pasta))\r\n      return unless folder\r\n\r\n      output_path = File.join(folder, \"#{filename}.mp4\")\r\n\r\n      is_win = Sketchup.platform == :platform_win\r\n      ffmpeg_path = File.join(PLUGIN_DIR, 'ffmpeg', is_win ? 'ffmpeg.exe' : 'ffmpeg')\r\n\r\n      unless File.exist?(ffmpeg_path)\r\n        UI.messagebox(obter_texto(:ffmpeg_nao_encontrado))\r\n        return\r\n      end\r\n\r\n      duration_padding = 4.0\r\n      recording_duration = total_time + duration_padding\r\n\r\n      input_format = is_win ? 'gdigrab' : 'avfoundation'\r\n      input_source = is_win ? 'desktop' : '1:none'\r\n\r\n      cmd_array = [\r\n        \"\\\"#{ffmpeg_path}\\\"\",\r\n        '-y',\r\n        '-f', input_format,\r\n        '-framerate', '30',\r\n        '-t', recording_duration.to_s\r\n      ]\r\n\r\n      if is_win\r\n        cmd_array.concat([\r\n          '-draw_mouse', '0',\r\n          '-offset_x', rect[:x].to_s,\r\n          '-offset_y', rect[:y].to_s,\r\n          '-video_size', \"#{rect[:w]}x#{rect[:h]}\",\r\n          '-i', input_source\r\n        ])\r\n      else\r\n        cmd_array.concat([\r\n          '-i', input_source,\r\n          '-vf', \"crop=#{rect[:w]}:#{rect[:h]}:#{rect[:x]}:#{rect[:y]}\"\r\n        ])\r\n      end\r\n\r\n      cmd_array.concat([\r\n        '-c:v', 'libx264',\r\n        '-preset', 'ultrafast',\r\n        '-pix_fmt', 'yuv420p',\r\n        \"\\\"#{output_path}\\\"\"\r\n      ])\r\n\r\n      cmd = cmd_array.join(' ')\r\n\r\n      begin\r\n        if is_win\r\n           WIN32OLE.new('WScript.Shell').Run(cmd, 0, false)\r\n        else\r\n           pid = spawn(cmd)\r\n           Process.detach(pid)\r\n        end\r\n      rescue => e\r\n        UI.messagebox(\"#{obter_texto(:erro_gravador)}#{e.message}\")\r\n        return\r\n      end\r\n\r\n      sleep(1.5)\r\n\r\n      @dialog.execute_script(\"showRecordingIndicator()\")\r\n      @dialog.execute_script(play_command)\r\n\r\n      UI.start_timer(recording_duration + 1.0, false) do\r\n        @dialog.execute_script(\"hideRecordingIndicator()\")\r\n        UI.messagebox(\"#{obter_texto(:gravacao_finalizada)}#{output_path}\")\r\n        @dialog.execute_script(\"resetPlayButton(); resetPlayAll();\")\r\n      end\r\n    end\r\n\r\n    def self.start_ui\r\n      current_hotkey = GlobalKey.key_code\r\n      hotkey_ctrl = GlobalKey.ctrl ? 'true' : 'false'\r\n      hotkey_alt = GlobalKey.alt ? 'true' : 'false'\r\n      hotkey_shift = GlobalKey.shift ? 'true' : 'false'\r\n      ffmpeg_path = File.join(PLUGIN_DIR, 'ffmpeg', Sketchup.platform == :platform_win ? 'ffmpeg.exe' : 'ffmpeg')\r\n      \r\n      has_ffmpeg = File.exist?(ffmpeg_path)\r\n\r\n      view = Sketchup.active_model.active_view\r\n      vp_width = view.vpwidth\r\n      vp_height = view.vpheight\r\n\r\n      js_i18n_hash = {}\r\n      IDIOMAS[IDIOMAS.key?(Sketchup.get_locale) ? Sketchup.get_locale : 'en-US'].each { |k, v| js_i18n_hash[k] = v }\r\n      js_i18n_json = js_i18n_hash.to_json\r\n\r\n      html = <<-HTML\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n  <meta charset=\"utf-8\">\r\n  <title>#{obter_texto(:titulo)}</title>\r\n  <style>\r\n    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }\r\n    body {\r\n      font-family: system-ui, -apple-system, 'Segoe UI', sans-serif;\r\n      background: #f5f5f5; color: #333; font-size: 13px;\r\n      padding: 16px; line-height: 1.4;\r\n    }\r\n\r\n    /* Header */\r\n    .header {\r\n      display: flex; align-items: center; gap: 10px;\r\n      padding-bottom: 14px; border-bottom: 2px solid #0066cc;\r\n      margin-bottom: 16px;\r\n    }\r\n    .header svg { flex-shrink: 0; }\r\n    .header h1 { font-size: 17px; font-weight: 700; color: #1a1a1a; }\r\n    .header .subtitle { font-size: 11px; color: #888; font-weight: 400; }\r\n\r\n    /* Cards */\r\n    .card {\r\n      background: #fff; border: 1px solid #e0e0e0; border-radius: 8px;\r\n      box-shadow: 0 1px 3px rgba(0,0,0,0.06); margin-bottom: 12px;\r\n      overflow: hidden;\r\n    }\r\n    .card-header {\r\n      display: flex; align-items: center; justify-content: space-between;\r\n      padding: 10px 14px; background: #fafafa; border-bottom: 1px solid #eee;\r\n      cursor: pointer; user-select: none;\r\n    }\r\n    .card-header h2 { font-size: 13px; font-weight: 600; color: #444; }\r\n    .card-header .toggle-icon { font-size: 11px; color: #999; transition: transform 0.2s; }\r\n    .card-header.collapsed .toggle-icon { transform: rotate(-90deg); }\r\n    .card-body { padding: 14px; }\r\n    .card-body.collapsed { display: none; }\r\n\r\n    /* Timeline */\r\n    .timeline-wrapper { position: relative; padding: 8px 0 20px; }\r\n    .timeline-track {\r\n      position: absolute; top: 20px; left: 6px; right: 6px; height: 4px;\r\n      background: #ddd; border-radius: 2px; z-index: 0;\r\n    }\r\n    #timeline_range {\r\n      -webkit-appearance: none; appearance: none; width: 100%;\r\n      height: 6px; background: transparent; outline: none;\r\n      position: relative; z-index: 2; cursor: pointer;\r\n    }\r\n    #timeline_range::-webkit-slider-runnable-track {\r\n      height: 6px; background: linear-gradient(90deg, #0066cc 0%, #4da6ff 100%);\r\n      border-radius: 3px;\r\n    }\r\n    #timeline_range::-webkit-slider-thumb {\r\n      -webkit-appearance: none; width: 16px; height: 16px;\r\n      background: #0066cc; border: 2px solid #fff; border-radius: 50%;\r\n      margin-top: -5px; cursor: grab; box-shadow: 0 1px 4px rgba(0,0,0,0.2);\r\n    }\r\n    #timeline_range::-webkit-slider-thumb:active { cursor: grabbing; transform: scale(1.15); }\r\n    #markers_layer {\r\n      position: absolute; top: 0; left: 0; width: 100%; height: 40px;\r\n      pointer-events: none; z-index: 3;\r\n    }\r\n    .marker {\r\n      position: absolute; top: 26px; width: 14px; height: 14px;\r\n      background: #0066cc; border-radius: 50%; border: 2px solid #fff;\r\n      transform: translateX(-50%); pointer-events: auto; cursor: pointer;\r\n      box-shadow: 0 1px 3px rgba(0,0,0,0.15); transition: transform 0.15s, background 0.15s;\r\n    }\r\n    .marker:hover { transform: translateX(-50%) scale(1.25); }\r\n    .marker.anchor { background: #dc3545; }\r\n    .marker .marker-tooltip {\r\n      position: absolute; bottom: 18px; left: 50%; transform: translateX(-50%);\r\n      background: #333; color: #fff; font-size: 10px; padding: 2px 6px;\r\n      border-radius: 3px; white-space: nowrap; opacity: 0;\r\n      pointer-events: none; transition: opacity 0.15s;\r\n    }\r\n    .marker:hover .marker-tooltip { opacity: 1; }\r\n    .time-row {\r\n      display: flex; align-items: center; justify-content: space-between;\r\n      margin-top: 8px; gap: 12px;\r\n    }\r\n    .time-display { font-size: 20px; font-weight: 700; color: #0066cc; font-variant-numeric: tabular-nums; }\r\n    .time-display small { font-size: 12px; color: #888; font-weight: 400; }\r\n    .time-input-group { display: flex; align-items: center; gap: 6px; }\r\n    .time-input-group label { font-size: 11px; color: #666; }\r\n\r\n    /* Buttons */\r\n    .btn {\r\n      display: inline-flex; align-items: center; justify-content: center; gap: 6px;\r\n      padding: 7px 14px; border: 1px solid transparent; border-radius: 6px;\r\n      font-size: 12px; font-weight: 500; cursor: pointer;\r\n      transition: all 0.15s; outline: none; font-family: inherit;\r\n    }\r\n    .btn:active { transform: scale(0.97); }\r\n    .btn-primary { background: #0066cc; color: #fff; }\r\n    .btn-primary:hover { background: #0052a3; }\r\n    .btn-success { background: #28a745; color: #fff; }\r\n    .btn-success:hover { background: #218838; }\r\n    .btn-danger { background: #dc3545; color: #fff; }\r\n    .btn-danger:hover { background: #c82333; }\r\n    .btn-outline { background: transparent; border: 1px solid #ccc; color: #555; }\r\n    .btn-outline:hover { background: #f0f0f0; border-color: #aaa; }\r\n    .btn-sm { padding: 4px 10px; font-size: 11px; }\r\n    .btn-record { background: #dc3545; color: #fff; padding: 10px 20px; font-size: 13px; font-weight: 600; }\r\n    .btn-record:hover { background: #c82333; }\r\n    .btn-record:disabled { background: #ccc; color: #888; cursor: not-allowed; }\r\n\r\n    .btn-group { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }\r\n\r\n    /* Checkboxes */\r\n    .check-group { display: flex; align-items: center; gap: 16px; margin-top: 10px; }\r\n    .check-item { display: flex; align-items: center; gap: 5px; }\r\n    .check-item input[type=\"checkbox\"] {\r\n      width: 15px; height: 15px; accent-color: #0066cc; cursor: pointer;\r\n    }\r\n    .check-item label { font-size: 12px; color: #555; cursor: pointer; }\r\n\r\n    /* Hotkey */\r\n    .hotkey-editor {\r\n      display: none; align-items: center; gap: 6px;\r\n      background: #f9f9f9; padding: 6px 10px; border-radius: 6px; border: 1px solid #ddd;\r\n    }\r\n    .hotkey-editor.visible { display: inline-flex; }\r\n    .hotkey-editor input {\r\n      width: 100px; padding: 4px 8px; border: 1px solid #ccc;\r\n      border-radius: 4px; font-size: 12px; font-family: monospace;\r\n      outline: none;\r\n    }\r\n    .hotkey-editor input:focus { border-color: #0066cc; }\r\n\r\n    /* Vision List */\r\n    .vision-list { max-height: 350px; overflow-y: auto; }\r\n    .vision-list::-webkit-scrollbar { width: 6px; }\r\n    .vision-list::-webkit-scrollbar-track { background: #f0f0f0; border-radius: 3px; }\r\n    .vision-list::-webkit-scrollbar-thumb { background: #ccc; border-radius: 3px; }\r\n    .vision-list::-webkit-scrollbar-thumb:hover { background: #aaa; }\r\n    .vision-item {\r\n      display: flex; align-items: center; gap: 10px; padding: 8px 10px;\r\n      border-bottom: 1px solid #f0f0f0; cursor: pointer;\r\n      transition: background 0.12s;\r\n    }\r\n    .vision-item:hover { background: #f7faff; }\r\n    .vision-item:last-child { border-bottom: none; }\r\n    .vision-item .vision-num {\r\n      font-size: 11px; font-weight: 700; color: #999; width: 20px;\r\n      text-align: center; flex-shrink: 0;\r\n    }\r\n    .vision-item img {\r\n      width: 72px; height: 45px; object-fit: cover; border-radius: 4px;\r\n      border: 1px solid #ddd; flex-shrink: 0;\r\n    }\r\n    .vision-item img.thumb-placeholder {\r\n      background: linear-gradient(135deg, #e0e0e0 0%, #c0c0c0 100%);\r\n      animation: pulse-placeholder 1s ease-in-out infinite alternate;\r\n    }\r\n    @keyframes pulse-placeholder {\r\n      from { opacity: 0.6; }\r\n      to { opacity: 1.0; }\r\n    }\r\n    .vision-item .vision-info { flex: 1; min-width: 0; }\r\n    .vision-item .vision-time-input {\r\n      width: 58px; padding: 3px 6px; border: 1px solid #ddd; border-radius: 4px;\r\n      font-size: 12px; text-align: center; outline: none; font-family: inherit;\r\n    }\r\n    .vision-item .vision-time-input:focus { border-color: #0066cc; }\r\n    .vision-item .vision-time-input:disabled { background: #f5f5f5; color: #999; }\r\n    .vision-actions { display: flex; align-items: center; gap: 6px; flex-shrink: 0; }\r\n    .anchor-toggle {\r\n      width: 26px; height: 26px; border-radius: 50%; border: 2px solid #ddd;\r\n      background: transparent; cursor: pointer; display: flex;\r\n      align-items: center; justify-content: center; transition: all 0.15s;\r\n      font-size: 12px; color: #ccc;\r\n    }\r\n    .anchor-toggle:hover { border-color: #dc3545; color: #dc3545; }\r\n    .anchor-toggle.active { background: #dc3545; border-color: #dc3545; color: #fff; }\r\n    .delete-btn {\r\n      width: 26px; height: 26px; border-radius: 50%; border: 1px solid #eee;\r\n      background: transparent; cursor: pointer; display: flex;\r\n      align-items: center; justify-content: center; transition: all 0.15s;\r\n      font-size: 14px; color: #ccc;\r\n    }\r\n    .delete-btn:hover { background: #fee; border-color: #dc3545; color: #dc3545; }\r\n    .empty-state {\r\n      text-align: center; padding: 30px 16px; color: #aaa;\r\n    }\r\n    .empty-state svg { margin-bottom: 8px; opacity: 0.4; }\r\n    .empty-state p { font-size: 12px; }\r\n\r\n    /* Export Section */\r\n    .preset-select {\r\n      width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px;\r\n      font-size: 12px; font-family: inherit; outline: none; background: #fff;\r\n      cursor: pointer; color: #333;\r\n    }\r\n    .preset-select:focus { border-color: #0066cc; }\r\n    .preset-preview {\r\n      display: flex; align-items: center; justify-content: center;\r\n      padding: 8px; margin-top: 8px; background: #f7faff;\r\n      border: 1px dashed #b3d4fc; border-radius: 6px;\r\n      font-size: 12px; color: #0066cc; font-weight: 600;\r\n    }\r\n    .custom-dims {\r\n      display: none; gap: 8px; align-items: center; margin-top: 8px;\r\n    }\r\n    .custom-dims.visible { display: flex; }\r\n    .custom-dims input {\r\n      width: 80px; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px;\r\n      font-size: 12px; text-align: center; outline: none; font-family: inherit;\r\n    }\r\n    .custom-dims input:focus { border-color: #0066cc; }\r\n    .custom-dims span { color: #999; font-weight: 600; }\r\n\r\n    /* Recording indicator */\r\n    .recording-bar {\r\n      display: none; align-items: center; gap: 8px; padding: 10px 14px;\r\n      background: #fff5f5; border: 1px solid #f5c6cb; border-radius: 6px;\r\n      margin-top: 10px;\r\n    }\r\n    .recording-bar.active { display: flex; }\r\n    .recording-dot {\r\n      width: 10px; height: 10px; background: #dc3545; border-radius: 50%;\r\n      animation: pulse 1s infinite;\r\n    }\r\n    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }\r\n    .recording-bar span { font-size: 12px; color: #dc3545; font-weight: 600; }\r\n\r\n    /* Playing overlay */\r\n    body.playing .card { opacity: 0.6; pointer-events: none; }\r\n    body.playing .card.playback-card { opacity: 1; pointer-events: auto; }\r\n    body.playing .card.playback-card .btn:not(#play_button):not(#play_all_button) { pointer-events: none; opacity: 0.4; }\r\n    body.playing #play_button, body.playing #play_all_button { pointer-events: auto !important; opacity: 1 !important; }\r\n\r\n    /* Input base */\r\n    input[type=\"number\"] {\r\n      -moz-appearance: textfield;\r\n    }\r\n    input[type=\"number\"]::-webkit-inner-spin-button {\r\n      -webkit-appearance: none;\r\n    }\r\n\r\n    /* Draggable markers */\r\n    .marker { cursor: grab; }\r\n    .marker.dragging {\r\n      transform: translateX(-50%) scale(1.3);\r\n      z-index: 20;\r\n      cursor: grabbing;\r\n    }\r\n    .marker.no-drag { cursor: default; }\r\n\r\n    /* Saved timelines list */\r\n    .saved-timelines-list { margin-top: 10px; }\r\n    .saved-timelines-list:empty { display: none; }\r\n    .tl-item {\r\n      display: flex; align-items: center; gap: 8px;\r\n      padding: 6px 10px; border-bottom: 1px solid #f0f0f0;\r\n      cursor: pointer; transition: background 0.12s; font-size: 12px;\r\n    }\r\n    .tl-item:hover { background: #f7faff; }\r\n    .tl-item:last-child { border-bottom: none; }\r\n    .tl-item .tl-indicator {\r\n      width: 8px; height: 8px; border-radius: 50%;\r\n      background: #ccc; flex-shrink: 0;\r\n    }\r\n    .tl-item.active .tl-indicator { background: #0066cc; }\r\n    .tl-item .tl-name { flex: 1; font-weight: 500; color: #333; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }\r\n    .tl-item .tl-count { color: #999; font-size: 11px; flex-shrink: 0; }\r\n    .tl-item .tl-delete {\r\n      width: 20px; height: 20px; border-radius: 50%; border: 1px solid #eee;\r\n      background: transparent; cursor: pointer; display: flex;\r\n      align-items: center; justify-content: center; font-size: 12px; color: #ccc;\r\n      flex-shrink: 0; transition: all 0.15s;\r\n    }\r\n    .tl-item .tl-delete:hover { background: #fee; border-color: #dc3545; color: #dc3545; }\r\n\r\n    /* Drag-and-drop for timeline reordering */\r\n    .tl-drag-handle {\r\n      cursor: grab; flex-shrink: 0; color: #ccc; font-size: 14px;\r\n      padding: 0 4px; user-select: none;\r\n    }\r\n    .tl-drag-handle:active { cursor: grabbing; }\r\n    .tl-item.dragging { opacity: 0.4; }\r\n    .tl-item.drag-over-top { border-top: 2px solid #0066cc; }\r\n    .tl-item.drag-over-bottom { border-bottom: 2px solid #0066cc; }\r\n\r\n    /* Viewport info */\r\n    .viewport-info {\r\n      font-size: 11px; color: #666; margin-bottom: 10px;\r\n      padding: 6px 10px; background: #f9f9f9; border-radius: 4px; border: 1px solid #eee;\r\n    }\r\n\r\n    /* Misc */\r\n    .hidden { display: none !important; }\r\n    .mt-8 { margin-top: 8px; }\r\n  </style>\r\n</head>\r\n<body>\r\n\r\n<!-- Header -->\r\n<div class=\"header\">\r\n  <svg width=\"28\" height=\"28\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"#0066cc\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <path d=\"M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z\"/>\r\n    <circle cx=\"12\" cy=\"13\" r=\"4\"/>\r\n  </svg>\r\n  <div>\r\n    <h1>#{obter_texto(:titulo)}</h1>\r\n    <span class=\"subtitle\">#{obter_texto(:subtitulo)}</span>\r\n  </div>\r\n</div>\r\n\r\n<!-- Timeline Card -->\r\n<div class=\"card\">\r\n  <div class=\"card-body\">\r\n    <div class=\"timeline-wrapper\">\r\n      <div class=\"timeline-track\"></div>\r\n      <input type=\"range\" min=\"0\" max=\"60\" step=\"0.1\" value=\"0\" id=\"timeline_range\" oninput=\"updateTime(this.value)\">\r\n      <div id=\"markers_layer\"></div>\r\n    </div>\r\n    <div class=\"time-row\">\r\n      <div class=\"time-display\"><span id=\"current_time\">0.0</span><small>s</small></div>\r\n      <div class=\"time-input-group\">\r\n        <label>#{obter_texto(:total)}</label>\r\n        <input id=\"max_time\" type=\"number\" step=\"1\" value=\"60\" min=\"1\" onchange=\"atualizarTempoTotal()\"\r\n          style=\"width:65px; padding:4px 8px; border:1px solid #ddd; border-radius:4px; font-size:12px; text-align:center; outline:none; font-family:inherit;\">\r\n        <small style=\"color:#888;\">s</small>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Playback Controls Card -->\r\n<div class=\"card playback-card\">\r\n  <div class=\"card-body\">\r\n    <div class=\"btn-group\">\r\n      <button class=\"btn btn-primary\" onclick=\"addVision()\">\r\n        <svg width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2.5\"><line x1=\"12\" y1=\"5\" x2=\"12\" y2=\"19\"/><line x1=\"5\" y1=\"12\" x2=\"19\" y2=\"12\"/></svg>\r\n        #{obter_texto(:visao)}\r\n      </button>\r\n      <button id=\"play_button\" class=\"btn btn-success\" onclick=\"togglePlay()\">&#9654; #{obter_texto(:play)}</button>\r\n      <button id=\"play_all_button\" class=\"btn btn-outline btn-sm hidden\" onclick=\"togglePlayAll()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><polygon points=\"5 3 19 12 5 21 5 3\"/><line x1=\"19\" y1=\"3\" x2=\"19\" y2=\"21\"/></svg>\r\n        #{obter_texto(:play_all)}\r\n      </button>\r\n      <button class=\"btn btn-outline btn-sm\" onclick=\"mostrarCampoAtalho()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><rect x=\"2\" y=\"4\" width=\"20\" height=\"16\" rx=\"2\"/><line x1=\"6\" y1=\"8\" x2=\"6\" y2=\"8\"/><line x1=\"10\" y1=\"8\" x2=\"10\" y2=\"8\"/><line x1=\"14\" y1=\"8\" x2=\"14\" y2=\"8\"/><line x1=\"18\" y1=\"8\" x2=\"18\" y2=\"8\"/><line x1=\"8\" y1=\"16\" x2=\"16\" y2=\"16\"/></svg>\r\n        #{obter_texto(:atalho)}\r\n      </button>\r\n      <span id=\"hotkey_edit\" class=\"hotkey-editor\">\r\n        <input id=\"hotkey_input\" type=\"text\" placeholder=\"#{obter_texto(:pressione)}\" onkeydown=\"capturarAtalhoInput(event)\">\r\n        <button class=\"btn btn-primary btn-sm\" onclick=\"confirmarAtalho()\">#{obter_texto(:ok)}</button>\r\n      </span>\r\n    </div>\r\n    <div class=\"check-group\">\r\n      <div class=\"check-item\">\r\n        <input type=\"checkbox\" id=\"loop_checkbox\">\r\n        <label for=\"loop_checkbox\">#{obter_texto(:loop)}</label>\r\n      </div>\r\n      <div class=\"check-item\">\r\n        <input type=\"checkbox\" id=\"easing_checkbox\">\r\n        <label for=\"easing_checkbox\">#{obter_texto(:easing)}</label>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Visions Card -->\r\n<div class=\"card\">\r\n  <div class=\"card-header\" onclick=\"toggleSection('visions')\">\r\n    <h2>#{obter_texto(:visoes_salvas)} <span id=\"vision_count\" style=\"color:#999; font-weight:400;\"></span></h2>\r\n    <span class=\"toggle-icon\" id=\"visions_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body\" id=\"visions_body\">\r\n    <div class=\"vision-list\" id=\"lista_visoes\"></div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Gerenciar Time Line Card -->\r\n<div class=\"card\">\r\n  <div class=\"card-header\" onclick=\"toggleSection('timeline_mgr')\">\r\n    <h2>#{obter_texto(:gerenciar_timeline)}</h2>\r\n    <span class=\"toggle-icon\" id=\"timeline_mgr_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body\" id=\"timeline_mgr_body\">\r\n    <div class=\"btn-group\">\r\n      <button class=\"btn btn-outline\" onclick=\"novaTimeline()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z\"/><polyline points=\"14 2 14 8 20 8\"/><line x1=\"12\" y1=\"18\" x2=\"12\" y2=\"12\"/><line x1=\"9\" y1=\"15\" x2=\"15\" y2=\"15\"/></svg>\r\n        #{obter_texto(:nova)}\r\n      </button>\r\n      <button class=\"btn btn-outline\" onclick=\"exportarTimeline()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\"/><polyline points=\"7 10 12 15 17 10\"/><line x1=\"12\" y1=\"15\" x2=\"12\" y2=\"3\"/></svg>\r\n        #{obter_texto(:exportar_atual)}\r\n      </button>\r\n      <button class=\"btn btn-outline\" onclick=\"exportarProjeto()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z\"/><polyline points=\"9 14 12 17 15 14\"/><line x1=\"12\" y1=\"17\" x2=\"12\" y2=\"10\"/></svg>\r\n        #{obter_texto(:exportar_projeto)}\r\n      </button>\r\n      <input type=\"file\" id=\"import_file\" class=\"hidden\" accept=\".json\" onchange=\"importarTimeline(this)\">\r\n      <button class=\"btn btn-outline\" onclick=\"document.getElementById('import_file').click()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\"/><polyline points=\"17 8 12 3 7 8\"/><line x1=\"12\" y1=\"3\" x2=\"12\" y2=\"15\"/></svg>\r\n        #{obter_texto(:importar)}\r\n      </button>\r\n    </div>\r\n    <div id=\"saved_timelines_list\" class=\"saved-timelines-list\"></div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Exportar Vídeo Card (colapsado por padrão) -->\r\n<div class=\"card\">\r\n  <div class=\"card-header collapsed\" onclick=\"toggleSection('export')\">\r\n    <h2>#{obter_texto(:exportar_video)}</h2>\r\n    <span class=\"toggle-icon\" id=\"export_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body collapsed\" id=\"export_body\">\r\n    <div id=\"ffmpeg_section\" class=\"#{has_ffmpeg ? '' : 'hidden'}\">\r\n      <div class=\"viewport-info\">\r\n        #{obter_texto(:viewport_atual)} <strong>#{vp_width} x #{vp_height} px</strong>\r\n      </div>\r\n\r\n      <select id=\"preset_select\" class=\"preset-select\" onchange=\"onPresetChange()\">\r\n        <option value=\"\" disabled selected>#{obter_texto(:selecione_formato)}</option>\r\n      </select>\r\n\r\n      <div class=\"custom-dims\" id=\"custom_dims\">\r\n        <input type=\"number\" id=\"custom_w\" min=\"50\" placeholder=\"#{obter_texto(:largura)}\" value=\"1280\">\r\n        <span>x</span>\r\n        <input type=\"number\" id=\"custom_h\" min=\"50\" placeholder=\"#{obter_texto(:altura)}\" value=\"720\">\r\n        <small style=\"color:#888;\">px</small>\r\n      </div>\r\n\r\n      <div class=\"preset-preview\" id=\"preset_preview\" style=\"display:none;\"></div>\r\n\r\n      <div class=\"check-group\" style=\"margin-top:12px; flex-direction:column; align-items:flex-start; gap:8px;\">\r\n        <div class=\"check-item\">\r\n          <input type=\"checkbox\" id=\"rec_projeto\">\r\n          <label for=\"rec_projeto\">#{obter_texto(:gravar_projeto)}</label>\r\n        </div>\r\n        <div class=\"check-item\">\r\n          <input type=\"checkbox\" id=\"rec_inicio\" checked>\r\n          <label for=\"rec_inicio\">#{obter_texto(:iniciar_quadro1)}</label>\r\n        </div>\r\n      </div>\r\n\r\n      <button class=\"btn btn-record mt-8\" id=\"btn_record\" onclick=\"iniciarGravacao()\" disabled style=\"width:100%; margin-top:12px;\">\r\n        <svg width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><circle cx=\"12\" cy=\"12\" r=\"4\" fill=\"currentColor\"/></svg>\r\n        #{obter_texto(:iniciar_gravacao)}\r\n      </button>\r\n\r\n      <div class=\"recording-bar\" id=\"recording_bar\">\r\n        <div class=\"recording-dot\"></div>\r\n        <span>#{obter_texto(:gravando)}</span>\r\n      </div>\r\n    </div>\r\n\r\n    <div id=\"ffmpeg_install\" class=\"#{has_ffmpeg ? 'hidden' : ''}\" style=\"text-align:center; padding:12px 0;\">\r\n      <p style=\"color:#888; font-size:12px; margin-bottom:10px;\">#{obter_texto(:ffmpeg_necessario)}</p>\r\n      <button class=\"btn btn-primary\" onclick=\"instalarExportacao()\">#{obter_texto(:instalar_ffmpeg)}</button>\r\n    </div>\r\n\r\n    <!-- Modal de nome do arquivo -->\r\n    <div id=\"filename_modal\" style=\"display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.4);z-index:100;align-items:center;justify-content:center;\">\r\n      <div style=\"background:#fff;border-radius:10px;padding:24px;width:320px;box-shadow:0 8px 30px rgba(0,0,0,0.2);\">\r\n        <h3 style=\"font-size:14px;font-weight:600;color:#333;margin-bottom:12px;\">#{obter_texto(:nome_arquivo)}</h3>\r\n        <input id=\"filename_input\" type=\"text\" value=\"tour_final\" style=\"width:100%;padding:8px 12px;border:1px solid #ddd;border-radius:6px;font-size:13px;font-family:inherit;outline:none;margin-bottom:6px;\">\r\n        <small style=\"color:#888;\">#{obter_texto(:extensao_mp4)}</small>\r\n        <div style=\"display:flex;gap:8px;margin-top:16px;justify-content:flex-end;\">\r\n          <button class=\"btn btn-outline btn-sm\" onclick=\"fecharModalFilename()\">#{obter_texto(:cancelar)}</button>\r\n          <button class=\"btn btn-primary btn-sm\" onclick=\"confirmarFilename()\">#{obter_texto(:salvar)}</button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Modal de nome da timeline -->\r\n<div id=\"timeline_name_modal\" style=\"display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.4);z-index:100;align-items:center;justify-content:center;\">\r\n  <div style=\"background:#fff;border-radius:10px;padding:24px;width:320px;box-shadow:0 8px 30px rgba(0,0,0,0.2);\">\r\n    <h3 id=\"timeline_name_title\" style=\"font-size:14px;font-weight:600;color:#333;margin-bottom:12px;\"></h3>\r\n    <input id=\"timeline_name_input\" type=\"text\" onkeydown=\"if(event.keyCode===13){confirmarModalTimeline();}\" style=\"width:100%;padding:8px 12px;border:1px solid #ddd;border-radius:6px;font-size:13px;font-family:inherit;outline:none;margin-bottom:6px;\">\r\n    <div style=\"display:flex;gap:8px;margin-top:16px;justify-content:flex-end;\">\r\n      <button class=\"btn btn-outline btn-sm\" onclick=\"fecharModalTimeline()\">#{obter_texto(:cancelar)}</button>\r\n      <button class=\"btn btn-primary btn-sm\" onclick=\"confirmarModalTimeline()\">#{obter_texto(:ok)}</button>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<script>\r\n    const I18N = #{js_i18n_json};\r\n    let visoes = [], playing = false, currentIndex = 0;\r\n    let hotkey = { keyCode: #{current_hotkey}, ctrl: #{hotkey_ctrl}, alt: #{hotkey_alt}, shift: #{hotkey_shift} };\r\n    let capturingHotkey = false, pendingHotkey = null;\r\n    let savedTimelines = [];\r\n    let activeTimelineIndex = -1;\r\n    let playingAll = false, playAllQueue = [], playAllCurrentIdx = 0;\r\n    var viewportW = #{vp_width}, viewportH = #{vp_height};\r\n\r\n    if (window.sketchup) { window.sketchup.set_hotkey(hotkey.keyCode, hotkey.ctrl, hotkey.alt, hotkey.shift); }\r\n\r\n    /* --- Export Formats (aspect ratios) --- */\r\n    const EXPORT_FORMATS = [\r\n      { label: '16:9 ' + I18N.paisagem, ratio: [16, 9] },\r\n      { label: '9:16 ' + I18N.retrato, ratio: [9, 16] },\r\n      { label: '1:1 ' + I18N.quadrado, ratio: [1, 1] },\r\n      { label: '4:3 ' + I18N.classico, ratio: [4, 3] },\r\n      { label: '21:9 ' + I18N.ultra_wide, ratio: [21, 9] },\r\n      { label: I18N.viewport_inteira, ratio: null },\r\n      { label: I18N.personalizado, ratio: null, custom: true }\r\n    ];\r\n\r\n    function calcEffectiveDims(ratioW, ratioH, vpW, vpH) {\r\n      const scaleW = vpW / ratioW;\r\n      const scaleH = vpH / ratioH;\r\n      const scale = Math.min(scaleW, scaleH);\r\n      let w = Math.floor(ratioW * scale);\r\n      let h = Math.floor(ratioH * scale);\r\n      w = w % 2 === 0 ? w : w - 1;\r\n      h = h % 2 === 0 ? h : h - 1;\r\n      return { w: w, h: h };\r\n    }\r\n\r\n    function populatePresets() {\r\n      const sel = document.getElementById(\"preset_select\");\r\n      sel.innerHTML = '<option value=\"\" disabled selected>' + I18N.selecione_formato + '</option>';\r\n      EXPORT_FORMATS.forEach((fmt, i) => {\r\n        const opt = document.createElement(\"option\");\r\n        opt.value = i.toString();\r\n        if (fmt.custom) {\r\n          opt.textContent = fmt.label;\r\n        } else if (fmt.ratio) {\r\n          const dims = calcEffectiveDims(fmt.ratio[0], fmt.ratio[1], viewportW, viewportH);\r\n          opt.textContent = fmt.label + \" (\" + dims.w + \" x \" + dims.h + \" px)\";\r\n        } else {\r\n          let w = viewportW % 2 === 0 ? viewportW : viewportW - 1;\r\n          let h = viewportH % 2 === 0 ? viewportH : viewportH - 1;\r\n          opt.textContent = fmt.label + \" (\" + w + \" x \" + h + \" px)\";\r\n        }\r\n        sel.appendChild(opt);\r\n      });\r\n    }\r\n\r\n    /* --- Section Toggle --- */\r\n    function toggleSection(name) {\r\n      const body = document.getElementById(name + '_body');\r\n      const icon = document.getElementById(name + '_toggle');\r\n      const header = icon.parentElement;\r\n      const wasCollapsed = body.classList.contains('collapsed');\r\n      if (wasCollapsed) {\r\n        body.classList.remove('collapsed');\r\n        header.classList.remove('collapsed');\r\n      } else {\r\n        body.classList.add('collapsed');\r\n        header.classList.add('collapsed');\r\n      }\r\n      /* Hide viewport preview when closing export card */\r\n      if (name === 'export' && !wasCollapsed) {\r\n        if (window.sketchup) window.sketchup.hide_export_preview();\r\n      }\r\n    }\r\n\r\n    /* --- Timeline --- */\r\n    function updateTime(val) {\r\n      document.getElementById(\"current_time\").innerText = parseFloat(val).toFixed(1);\r\n    }\r\n\r\n    function atualizarTempoTotal() {\r\n      const novoMax = parseFloat(document.getElementById(\"max_time\").value);\r\n      if (isNaN(novoMax) || novoMax <= 0) return;\r\n      document.getElementById(\"timeline_range\").max = novoMax;\r\n      visoes.forEach(v => { if (v.time > novoMax) v.time = novoMax - 0.1; });\r\n      renderMarkers();\r\n    }\r\n\r\n    /* --- Timeline Name Modal --- */\r\n    var _timelineModalCallback = null;\r\n\r\n    function abrirModalTimeline(titulo, valorPadrao, callback) {\r\n      _timelineModalCallback = callback;\r\n      document.getElementById(\"timeline_name_title\").textContent = titulo;\r\n      var input = document.getElementById(\"timeline_name_input\");\r\n      input.value = valorPadrao;\r\n      var modal = document.getElementById(\"timeline_name_modal\");\r\n      modal.style.display = \"flex\";\r\n      setTimeout(function() { input.focus(); input.select(); }, 50);\r\n    }\r\n\r\n    function fecharModalTimeline() {\r\n      document.getElementById(\"timeline_name_modal\").style.display = \"none\";\r\n      _timelineModalCallback = null;\r\n    }\r\n\r\n    function confirmarModalTimeline() {\r\n      var name = document.getElementById(\"timeline_name_input\").value.trim();\r\n      if (!name) return;\r\n      document.getElementById(\"timeline_name_modal\").style.display = \"none\";\r\n      if (_timelineModalCallback) {\r\n        _timelineModalCallback(name);\r\n        _timelineModalCallback = null;\r\n      }\r\n    }\r\n\r\n    /* --- Visions --- */\r\n    function addVision() {\r\n      if (savedTimelines.length === 0 && visoes.length === 0) {\r\n        abrirModalTimeline(I18N.nome_timeline, \"Time Line 1\", function(name) {\r\n          savedTimelines.push({ name: name, visoes: [], maxTime: 60 });\r\n          activeTimelineIndex = 0;\r\n          renderSavedTimelines();\r\n          var time = parseFloat(document.getElementById(\"timeline_range\").value);\r\n          sketchup.capture_camera(time);\r\n        });\r\n        return;\r\n      }\r\n      var time = parseFloat(document.getElementById(\"timeline_range\").value);\r\n      sketchup.capture_camera(time);\r\n    }\r\n\r\n    function captureVisionFromRuby(camJson) {\r\n      const obj = JSON.parse(camJson);\r\n      obj.walk = false; obj.anchor = false;\r\n      visoes = visoes.filter(v => v.time !== obj.time);\r\n      visoes.push(obj);\r\n      visoes.sort((a, b) => a.time - b.time);\r\n      visoes[0].time = 0.0;\r\n      syncActiveTimeline();\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    /* --- Draggable markers --- */\r\n    function setupMarkerDrag(marker, visionIndex, slider, maxTime) {\r\n      if (visionIndex === 0) {\r\n        marker.classList.add(\"no-drag\");\r\n        return;\r\n      }\r\n      marker.addEventListener(\"mousedown\", function(e) {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        marker.classList.add(\"dragging\");\r\n        const sliderPadding = 8;\r\n\r\n        function onMove(ev) {\r\n          const sliderRect = slider.getBoundingClientRect();\r\n          const usableWidth = sliderRect.width - sliderPadding * 2;\r\n          const relativeX = Math.max(0, Math.min(ev.clientX - sliderRect.left - sliderPadding, usableWidth));\r\n          const newTime = parseFloat(((relativeX / usableWidth) * maxTime).toFixed(1));\r\n          marker.style.left = (relativeX + sliderPadding) + \"px\";\r\n          const tooltip = marker.querySelector(\".marker-tooltip\");\r\n          if (tooltip) tooltip.textContent = newTime.toFixed(1) + \"s\";\r\n        }\r\n\r\n        function onUp(ev) {\r\n          marker.classList.remove(\"dragging\");\r\n          document.removeEventListener(\"mousemove\", onMove);\r\n          document.removeEventListener(\"mouseup\", onUp);\r\n          const sliderRect = slider.getBoundingClientRect();\r\n          const usableWidth = sliderRect.width - sliderPadding * 2;\r\n          const relativeX = Math.max(0, Math.min(ev.clientX - sliderRect.left - sliderPadding, usableWidth));\r\n          const newTime = parseFloat(((relativeX / usableWidth) * maxTime).toFixed(1));\r\n          visoes[visionIndex].time = Math.max(0.1, newTime);\r\n          visoes.sort((a, b) => a.time - b.time);\r\n          if (visoes.length > 0) visoes[0].time = 0.0;\r\n          renderMarkers();\r\n        }\r\n\r\n        document.addEventListener(\"mousemove\", onMove);\r\n        document.addEventListener(\"mouseup\", onUp);\r\n      });\r\n    }\r\n\r\n    function syncActiveTimeline() {\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n    }\r\n\r\n    function renderMarkers() {\r\n      const layer = document.getElementById(\"markers_layer\");\r\n      const lista = document.getElementById(\"lista_visoes\");\r\n      const slider = document.getElementById(\"timeline_range\");\r\n      const max = parseFloat(slider.max);\r\n      const width = slider.offsetWidth;\r\n      const countEl = document.getElementById(\"vision_count\");\r\n\r\n      layer.innerHTML = \"\"; lista.innerHTML = \"\";\r\n      countEl.textContent = visoes.length > 0 ? \"(\" + visoes.length + \")\" : \"\";\r\n\r\n      if (visoes.length === 0) {\r\n        lista.innerHTML = '<div class=\"empty-state\">' +\r\n          '<svg width=\"36\" height=\"36\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"#ccc\" stroke-width=\"1.5\"><path d=\"M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z\"/><circle cx=\"12\" cy=\"13\" r=\"4\"/></svg>' +\r\n          '<p>' + I18N.nenhuma_visao + '<br>' + I18N.dica_visao + '</p></div>';\r\n        return;\r\n      }\r\n\r\n      visoes.forEach((v, i) => {\r\n        /* Marker on timeline */\r\n        const percent = max > 0 ? v.time / max : 0;\r\n        const marker = document.createElement(\"div\");\r\n        marker.className = \"marker\" + (v.anchor ? \" anchor\" : \"\");\r\n        const sliderPadding = 8;\r\n        const usableWidth = width - sliderPadding * 2;\r\n        marker.style.left = (percent * usableWidth + sliderPadding) + \"px\";\r\n        const tooltip = document.createElement(\"span\");\r\n        tooltip.className = \"marker-tooltip\";\r\n        tooltip.textContent = v.time.toFixed(1) + \"s\";\r\n        marker.appendChild(tooltip);\r\n        marker.onclick = () => {\r\n          slider.value = v.time; updateTime(v.time); currentIndex = i;\r\n          resetPlayButton(); sketchup.goto_camera(JSON.stringify(v));\r\n        };\r\n        /* Draggable */\r\n        setupMarkerDrag(marker, i, slider, max);\r\n        layer.appendChild(marker);\r\n\r\n        /* Vision list item */\r\n        const item = document.createElement(\"div\");\r\n        item.className = \"vision-item\";\r\n        item.onclick = () => {\r\n          slider.value = v.time; updateTime(v.time); currentIndex = i;\r\n          resetPlayButton(); sketchup.goto_camera(JSON.stringify(v));\r\n        };\r\n\r\n        const num = document.createElement(\"span\");\r\n        num.className = \"vision-num\";\r\n        num.textContent = (i + 1);\r\n\r\n        const img = document.createElement(\"img\");\r\n        if (v.thumb && v.thumb.length > 0) {\r\n          const mime = v.thumb.startsWith(\"/9j/\") ? \"image/jpeg\" : \"image/bmp\";\r\n          img.src = \"data:\" + mime + \";base64,\" + v.thumb;\r\n        } else {\r\n          img.src = \"\";\r\n          img.className = \"thumb-placeholder\";\r\n        }\r\n\r\n        const info = document.createElement(\"div\");\r\n        info.className = \"vision-info\";\r\n        const timeInput = document.createElement(\"input\");\r\n        timeInput.type = \"number\"; timeInput.step = \"0.1\";\r\n        timeInput.value = v.time.toFixed(1);\r\n        timeInput.className = \"vision-time-input\";\r\n        timeInput.disabled = (i === 0);\r\n        timeInput.onclick = (e) => e.stopPropagation();\r\n        timeInput.onchange = () => {\r\n          v.time = parseFloat(timeInput.value);\r\n          visoes.sort((a, b) => a.time - b.time);\r\n          renderMarkers();\r\n        };\r\n        info.appendChild(timeInput);\r\n\r\n        const actions = document.createElement(\"div\");\r\n        actions.className = \"vision-actions\";\r\n\r\n        const anchorBtn = document.createElement(\"button\");\r\n        anchorBtn.className = \"anchor-toggle\" + (v.anchor ? \" active\" : \"\");\r\n        anchorBtn.innerHTML = \"&#9875;\";\r\n        anchorBtn.title = I18N.ancora;\r\n        anchorBtn.onclick = (e) => {\r\n          e.stopPropagation();\r\n          v.anchor = !v.anchor;\r\n          renderMarkers();\r\n        };\r\n        actions.appendChild(anchorBtn);\r\n\r\n        const delBtn = document.createElement(\"button\");\r\n        delBtn.className = \"delete-btn\";\r\n        delBtn.innerHTML = \"&times;\";\r\n        delBtn.title = I18N.excluir;\r\n        delBtn.onclick = (e) => {\r\n          e.stopPropagation();\r\n          visoes.splice(i, 1);\r\n          if (visoes.length > 0) visoes[0].time = 0.0;\r\n          syncActiveTimeline();\r\n          renderMarkers();\r\n          renderSavedTimelines();\r\n        };\r\n        actions.appendChild(delBtn);\r\n\r\n        item.appendChild(num);\r\n        item.appendChild(img);\r\n        item.appendChild(info);\r\n        item.appendChild(actions);\r\n        lista.appendChild(item);\r\n      });\r\n    }\r\n\r\n    /* --- Playback --- */\r\n    function togglePlay() {\r\n      if (!playing) {\r\n        if (visoes.length < 2) return alert(I18N.min_duas_visoes);\r\n        if (currentIndex >= visoes.length - 1) currentIndex = 0;\r\n        playing = true;\r\n        document.body.classList.add(\"playing\");\r\n        document.getElementById(\"play_button\").innerHTML = \"&#9724; \" + I18N.stop;\r\n        document.getElementById(\"play_button\").className = \"btn btn-danger\";\r\n        sketchup.play_tour(JSON.stringify(visoes), document.getElementById(\"loop_checkbox\").checked, false, document.getElementById(\"easing_checkbox\").checked, currentIndex);\r\n      } else {\r\n        resetPlayButton();\r\n        sketchup.stop_tour();\r\n      }\r\n    }\r\n\r\n    function resetPlayButton() {\r\n      playing = false;\r\n      document.body.classList.remove(\"playing\");\r\n      document.getElementById(\"play_button\").innerHTML = \"&#9654; \" + I18N.play;\r\n      document.getElementById(\"play_button\").className = \"btn btn-success\";\r\n    }\r\n\r\n    function togglePlayAll() {\r\n      if (playingAll) {\r\n        resetPlayAll();\r\n        sketchup.stop_tour();\r\n        return;\r\n      }\r\n      if (savedTimelines.length < 2) return;\r\n      /* Save current timeline state */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n      /* Build queue of timelines with 2+ visions */\r\n      playAllQueue = savedTimelines.map(function(tl, i) { return i; }).filter(function(i) { return savedTimelines[i].visoes.length >= 2; });\r\n      if (playAllQueue.length < 1) { alert(I18N.sem_tl_2mais); return; }\r\n      playingAll = true;\r\n      playAllCurrentIdx = 0;\r\n      document.body.classList.add(\"playing\");\r\n      document.getElementById(\"play_all_button\").innerHTML = \"&#9724; \" + I18N.stop_all;\r\n      document.getElementById(\"play_all_button\").className = \"btn btn-danger btn-sm\";\r\n      playTimelineAtQueueIndex(0);\r\n    }\r\n\r\n    function playTimelineAtQueueIndex(qIdx) {\r\n      var tlIdx = playAllQueue[qIdx];\r\n      var tl = savedTimelines[tlIdx];\r\n      visoes = JSON.parse(JSON.stringify(tl.visoes));\r\n      document.getElementById(\"max_time\").value = tl.maxTime;\r\n      document.getElementById(\"timeline_range\").max = tl.maxTime;\r\n      activeTimelineIndex = tlIdx;\r\n      currentIndex = 0;\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n      sketchup.play_tour(\r\n        JSON.stringify(visoes),\r\n        false,\r\n        false,\r\n        document.getElementById(\"easing_checkbox\").checked,\r\n        0\r\n      );\r\n    }\r\n\r\n    function resetPlayAll() {\r\n      playingAll = false;\r\n      playAllQueue = [];\r\n      playAllCurrentIdx = 0;\r\n      document.body.classList.remove(\"playing\");\r\n      var btn = document.getElementById(\"play_all_button\");\r\n      btn.innerHTML = '<svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><polygon points=\"5 3 19 12 5 21 5 3\"/><line x1=\"19\" y1=\"3\" x2=\"19\" y2=\"21\"/></svg> ' + I18N.play_all;\r\n      btn.className = \"btn btn-outline btn-sm\";\r\n      playing = false;\r\n      document.getElementById(\"play_button\").innerHTML = \"&#9654; \" + I18N.play;\r\n      document.getElementById(\"play_button\").className = \"btn btn-success\";\r\n    }\r\n\r\n    function startRecordingPlayAll(startTlIdx, startVisionIdx) {\r\n      syncActiveTimeline();\r\n      /* Montar fila de timelines com 2+ visões, a partir de startTlIdx */\r\n      playAllQueue = [];\r\n      for (var i = startTlIdx; i < savedTimelines.length; i++) {\r\n        if (savedTimelines[i].visoes.length >= 2) playAllQueue.push(i);\r\n      }\r\n      if (playAllQueue.length === 0) return;\r\n\r\n      playingAll = true;\r\n      playAllCurrentIdx = 0;\r\n      playing = true;\r\n      document.body.classList.add(\"playing\");\r\n      document.getElementById(\"play_button\").innerHTML = \"&#9724; \" + I18N.stop;\r\n      document.getElementById(\"play_button\").className = \"btn btn-danger\";\r\n\r\n      /* Carregar a primeira timeline da fila */\r\n      var firstTlIdx = playAllQueue[0];\r\n      var tl = savedTimelines[firstTlIdx];\r\n      visoes = JSON.parse(JSON.stringify(tl.visoes));\r\n      document.getElementById(\"max_time\").value = tl.maxTime;\r\n      document.getElementById(\"timeline_range\").max = tl.maxTime;\r\n      activeTimelineIndex = firstTlIdx;\r\n      currentIndex = startVisionIdx;\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n\r\n      sketchup.play_tour(\r\n        JSON.stringify(visoes),\r\n        false,\r\n        false,\r\n        document.getElementById(\"easing_checkbox\").checked,\r\n        startVisionIdx\r\n      );\r\n    }\r\n\r\n    function updatePlayAllButton() {\r\n      var btn = document.getElementById(\"play_all_button\");\r\n      if (savedTimelines.length > 1) {\r\n        btn.classList.remove(\"hidden\");\r\n      } else {\r\n        btn.classList.add(\"hidden\");\r\n      }\r\n    }\r\n\r\n    function pauseAtIndex(idx) {\r\n      currentIndex = idx;\r\n      if (playingAll) {\r\n        playAllCurrentIdx++;\r\n        if (playAllCurrentIdx < playAllQueue.length) {\r\n          playTimelineAtQueueIndex(playAllCurrentIdx);\r\n          return;\r\n        } else {\r\n          resetPlayAll();\r\n          return;\r\n        }\r\n      }\r\n      resetPlayButton();\r\n    }\r\n    function triggerSpaceFromRuby() { togglePlay(); }\r\n    function updatePlayhead(time) {\r\n      var slider = document.getElementById(\"timeline_range\");\r\n      slider.value = time;\r\n      document.getElementById(\"current_time\").innerText = parseFloat(time).toFixed(1);\r\n    }\r\n\r\n    /* --- Timeline Management --- */\r\n    function exportarTimeline() {\r\n      if (visoes.length === 0) { alert(I18N.sem_visoes_exportar); return; }\r\n      var tlName = (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length)\r\n        ? savedTimelines[activeTimelineIndex].name : \"Time Line\";\r\n      /* Download JSON */\r\n      var dataStr = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(visoes, null, 2));\r\n      var a = document.createElement(\"a\");\r\n      a.setAttribute(\"href\", dataStr);\r\n      a.setAttribute(\"download\", tlName.replace(/[^a-zA-Z0-9_-]/g, \"_\") + \".json\");\r\n      document.body.appendChild(a); a.click(); a.remove();\r\n      /* Salvar na lista */\r\n      saveCurrentToTimelines(tlName);\r\n    }\r\n\r\n    function exportarProjeto() {\r\n      syncActiveTimeline();\r\n      if (savedTimelines.length === 0) { alert(I18N.sem_tl_exportar); return; }\r\n      var projeto = { type: \"tour_virtual_project\", timelines: savedTimelines };\r\n      var dataStr = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(projeto, null, 2));\r\n      var a = document.createElement(\"a\");\r\n      a.setAttribute(\"href\", dataStr);\r\n      a.setAttribute(\"download\", \"projeto_tour_virtual.json\");\r\n      document.body.appendChild(a); a.click(); a.remove();\r\n    }\r\n\r\n    function saveCurrentToTimelines(name) {\r\n      var maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      var entry = { name: name, visoes: JSON.parse(JSON.stringify(visoes)), maxTime: maxTime };\r\n      /* Atualizar existente se ativo, senão adicionar novo */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex] = entry;\r\n      } else {\r\n        savedTimelines.push(entry);\r\n        activeTimelineIndex = savedTimelines.length - 1;\r\n      }\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    function importarTimeline(input) {\r\n      var file = input.files[0];\r\n      if (!file) return;\r\n      var reader = new FileReader();\r\n      reader.onload = function(e) {\r\n        try {\r\n          var imported = JSON.parse(e.target.result);\r\n          /* Detectar se é um projeto completo */\r\n          if (imported && imported.type === \"tour_virtual_project\" && Array.isArray(imported.timelines)) {\r\n            syncActiveTimeline();\r\n            imported.timelines.forEach(function(tl) {\r\n              if (tl.visoes) {\r\n                tl.visoes.sort(function(a, b) { return a.time - b.time; });\r\n                if (tl.visoes.length > 0) tl.visoes[0].time = 0.0;\r\n              }\r\n              savedTimelines.push({ name: tl.name || I18N.importada, visoes: tl.visoes || [], maxTime: tl.maxTime || 60 });\r\n            });\r\n            if (savedTimelines.length > 0 && activeTimelineIndex < 0) {\r\n              activeTimelineIndex = 0;\r\n              var first = savedTimelines[0];\r\n              visoes = JSON.parse(JSON.stringify(first.visoes));\r\n              document.getElementById(\"max_time\").value = first.maxTime;\r\n              document.getElementById(\"timeline_range\").max = first.maxTime;\r\n              renderMarkers();\r\n            }\r\n            renderSavedTimelines();\r\n            return;\r\n          }\r\n          /* Time Line única */\r\n          if (!Array.isArray(imported)) throw I18N.formato_invalido;\r\n          imported.sort(function(a, b) { return a.time - b.time; });\r\n          if (imported.length > 0) imported[0].time = 0.0;\r\n          var maxTime = imported.length > 0 ? Math.ceil(imported[imported.length - 1].time + 1) : 60;\r\n          var name = file.name.replace(/\\\\.json$/i, \"\");\r\n          savedTimelines.push({ name: name, visoes: imported, maxTime: maxTime });\r\n          renderSavedTimelines();\r\n        } catch (err) { alert(I18N.erro_importar + err); }\r\n      };\r\n      reader.readAsText(file);\r\n      input.value = \"\";\r\n    }\r\n\r\n    function switchTimeline(index) {\r\n      if (index === activeTimelineIndex) return;\r\n      /* Save current state if there's an active timeline */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n      /* Load selected timeline */\r\n      const tl = savedTimelines[index];\r\n      visoes = JSON.parse(JSON.stringify(tl.visoes));\r\n      document.getElementById(\"max_time\").value = tl.maxTime;\r\n      document.getElementById(\"timeline_range\").max = tl.maxTime;\r\n      activeTimelineIndex = index;\r\n      currentIndex = 0;\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    function deleteTimeline(index) {\r\n      if (index === activeTimelineIndex) return;\r\n      savedTimelines.splice(index, 1);\r\n      if (activeTimelineIndex > index) activeTimelineIndex--;\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    function renderSavedTimelines() {\r\n      var container = document.getElementById(\"saved_timelines_list\");\r\n      container.innerHTML = \"\";\r\n      if (savedTimelines.length === 0) { updatePlayAllButton(); return; }\r\n      var dragSrcIndex = null;\r\n\r\n      savedTimelines.forEach(function(tl, i) {\r\n        var item = document.createElement(\"div\");\r\n        item.className = \"tl-item\" + (i === activeTimelineIndex ? \" active\" : \"\");\r\n        item.draggable = true;\r\n        item.dataset.index = i;\r\n\r\n        /* Drag handle */\r\n        var handle = document.createElement(\"span\");\r\n        handle.className = \"tl-drag-handle\";\r\n        handle.innerHTML = \"&#9776;\";\r\n        item.appendChild(handle);\r\n\r\n        /* Drag events */\r\n        item.addEventListener(\"dragstart\", function(e) {\r\n          dragSrcIndex = i;\r\n          item.classList.add(\"dragging\");\r\n          e.dataTransfer.effectAllowed = \"move\";\r\n        });\r\n        item.addEventListener(\"dragover\", function(e) {\r\n          e.preventDefault();\r\n          e.dataTransfer.dropEffect = \"move\";\r\n          var rect = item.getBoundingClientRect();\r\n          var midY = rect.top + rect.height / 2;\r\n          item.classList.remove(\"drag-over-top\", \"drag-over-bottom\");\r\n          item.classList.add(e.clientY < midY ? \"drag-over-top\" : \"drag-over-bottom\");\r\n        });\r\n        item.addEventListener(\"dragleave\", function() {\r\n          item.classList.remove(\"drag-over-top\", \"drag-over-bottom\");\r\n        });\r\n        item.addEventListener(\"drop\", function(e) {\r\n          e.preventDefault();\r\n          item.classList.remove(\"drag-over-top\", \"drag-over-bottom\");\r\n          if (dragSrcIndex === null || dragSrcIndex === i) return;\r\n          var rect = item.getBoundingClientRect();\r\n          var midY = rect.top + rect.height / 2;\r\n          var targetIndex = e.clientY < midY ? i : i + 1;\r\n          if (dragSrcIndex < targetIndex) targetIndex--;\r\n          var moved = savedTimelines.splice(dragSrcIndex, 1)[0];\r\n          savedTimelines.splice(targetIndex, 0, moved);\r\n          if (activeTimelineIndex === dragSrcIndex) {\r\n            activeTimelineIndex = targetIndex;\r\n          } else if (dragSrcIndex < activeTimelineIndex && targetIndex >= activeTimelineIndex) {\r\n            activeTimelineIndex--;\r\n          } else if (dragSrcIndex > activeTimelineIndex && targetIndex <= activeTimelineIndex) {\r\n            activeTimelineIndex++;\r\n          }\r\n          renderSavedTimelines();\r\n        });\r\n        item.addEventListener(\"dragend\", function() {\r\n          item.classList.remove(\"dragging\");\r\n          dragSrcIndex = null;\r\n        });\r\n\r\n        item.onclick = function() { switchTimeline(i); };\r\n\r\n        var indicator = document.createElement(\"span\");\r\n        indicator.className = \"tl-indicator\";\r\n        item.appendChild(indicator);\r\n\r\n        var nameEl = document.createElement(\"span\");\r\n        nameEl.className = \"tl-name\";\r\n        nameEl.textContent = tl.name;\r\n        item.appendChild(nameEl);\r\n\r\n        var count = document.createElement(\"span\");\r\n        count.className = \"tl-count\";\r\n        count.textContent = tl.visoes.length + \" \" + I18N.visoes;\r\n        item.appendChild(count);\r\n\r\n        if (i !== activeTimelineIndex) {\r\n          var del = document.createElement(\"button\");\r\n          del.className = \"tl-delete\";\r\n          del.innerHTML = \"&times;\";\r\n          del.title = I18N.excluir;\r\n          del.onclick = function(e) { e.stopPropagation(); deleteTimeline(i); };\r\n          item.appendChild(del);\r\n        }\r\n\r\n        container.appendChild(item);\r\n      });\r\n\r\n      updatePlayAllButton();\r\n    }\r\n\r\n    function novaTimeline() {\r\n      abrirModalTimeline(I18N.nova_timeline, \"Time Line \" + (savedTimelines.length + 1), function(name) {\r\n        /* Salvar timeline atual na lista se pertencer a uma timeline salva */\r\n        if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n          savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n          savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n        }\r\n        /* Criar nova timeline vazia e adicioná-la à lista */\r\n        savedTimelines.push({ name: name, visoes: [], maxTime: 60 });\r\n        activeTimelineIndex = savedTimelines.length - 1;\r\n        /* Limpar estado */\r\n        visoes = [];\r\n        currentIndex = 0;\r\n        document.getElementById(\"max_time\").value = 60;\r\n        document.getElementById(\"timeline_range\").max = 60;\r\n        document.getElementById(\"timeline_range\").value = 0;\r\n        updateTime(0);\r\n        renderMarkers();\r\n        renderSavedTimelines();\r\n      });\r\n    }\r\n\r\n    /* --- Video Export with Proportional Presets --- */\r\n    function onPresetChange() {\r\n      const sel = document.getElementById(\"preset_select\");\r\n      const preview = document.getElementById(\"preset_preview\");\r\n      const customDims = document.getElementById(\"custom_dims\");\r\n      const btnRecord = document.getElementById(\"btn_record\");\r\n      const idx = parseInt(sel.value);\r\n\r\n      if (isNaN(idx)) {\r\n        customDims.classList.remove(\"visible\");\r\n        preview.style.display = \"none\";\r\n        btnRecord.disabled = true;\r\n        if (window.sketchup) window.sketchup.hide_export_preview();\r\n        return;\r\n      }\r\n\r\n      const fmt = EXPORT_FORMATS[idx];\r\n      btnRecord.disabled = false;\r\n\r\n      if (fmt.custom) {\r\n        customDims.classList.add(\"visible\");\r\n        preview.style.display = \"none\";\r\n        if (window.sketchup) window.sketchup.hide_export_preview();\r\n      } else {\r\n        customDims.classList.remove(\"visible\");\r\n        let dims;\r\n        if (fmt.ratio) {\r\n          dims = calcEffectiveDims(fmt.ratio[0], fmt.ratio[1], viewportW, viewportH);\r\n        } else {\r\n          dims = { w: viewportW % 2 === 0 ? viewportW : viewportW - 1, h: viewportH % 2 === 0 ? viewportH : viewportH - 1 };\r\n        }\r\n        preview.textContent = I18N.area_gravacao + dims.w + \" x \" + dims.h + \" px\";\r\n        preview.style.display = \"flex\";\r\n        /* Show preview overlay in viewport */\r\n        if (window.sketchup) window.sketchup.show_export_preview(dims.w, dims.h);\r\n      }\r\n    }\r\n\r\n    function getExportDimensions() {\r\n      const sel = document.getElementById(\"preset_select\");\r\n      const idx = parseInt(sel.value);\r\n      if (isNaN(idx)) return null;\r\n      const fmt = EXPORT_FORMATS[idx];\r\n      if (fmt.custom) {\r\n        return {\r\n          w: parseInt(document.getElementById(\"custom_w\").value) || 1280,\r\n          h: parseInt(document.getElementById(\"custom_h\").value) || 720\r\n        };\r\n      }\r\n      if (fmt.ratio) {\r\n        return calcEffectiveDims(fmt.ratio[0], fmt.ratio[1], viewportW, viewportH);\r\n      }\r\n      return { w: viewportW % 2 === 0 ? viewportW : viewportW - 1, h: viewportH % 2 === 0 ? viewportH : viewportH - 1 };\r\n    }\r\n\r\n    function iniciarGravacao() {\r\n      var gravarProjeto = document.getElementById(\"rec_projeto\").checked;\r\n      var desdeInicio = document.getElementById(\"rec_inicio\").checked;\r\n\r\n      if (gravarProjeto) {\r\n        syncActiveTimeline();\r\n        var temVisoes = savedTimelines.some(function(tl) { return tl.visoes.length >= 2; });\r\n        if (!temVisoes) { alert(I18N.sem_tl_min_duas); return; }\r\n      } else {\r\n        if (visoes.length < 2) { alert(I18N.min_duas_visoes); return; }\r\n      }\r\n      var dims = getExportDimensions();\r\n      if (!dims || dims.w < 50 || dims.h < 50) { alert(I18N.dims_invalidas); return; }\r\n\r\n      /* Mostrar modal de nome */\r\n      document.getElementById(\"filename_input\").value = gravarProjeto ? \"projeto_tour\" : \"tour_final\";\r\n      document.getElementById(\"filename_modal\").style.display = \"flex\";\r\n      document.getElementById(\"filename_input\").focus();\r\n      document.getElementById(\"filename_input\").select();\r\n    }\r\n\r\n    function fecharModalFilename() {\r\n      document.getElementById(\"filename_modal\").style.display = \"none\";\r\n    }\r\n\r\n    function confirmarFilename() {\r\n      var nome = document.getElementById(\"filename_input\").value.trim();\r\n      if (!nome) { alert(I18N.digite_nome); return; }\r\n      document.getElementById(\"filename_modal\").style.display = \"none\";\r\n\r\n      var gravarProjeto = document.getElementById(\"rec_projeto\").checked;\r\n      var desdeInicio = document.getElementById(\"rec_inicio\").checked;\r\n      var dims = getExportDimensions();\r\n      var startIdx = desdeInicio ? 0 : currentIndex;\r\n\r\n      if (window.sketchup) window.sketchup.hide_export_preview();\r\n\r\n      if (gravarProjeto) {\r\n        syncActiveTimeline();\r\n        var allTimelines = JSON.stringify(savedTimelines);\r\n        var startTl = desdeInicio ? 0 : activeTimelineIndex;\r\n        var startVision = desdeInicio ? 0 : currentIndex;\r\n        if (window.sketchup) {\r\n          window.sketchup.start_export_project(\r\n            allTimelines,\r\n            document.getElementById(\"easing_checkbox\").checked,\r\n            startTl,\r\n            startVision,\r\n            dims.w,\r\n            dims.h,\r\n            nome\r\n          );\r\n        }\r\n      } else {\r\n        if (window.sketchup) {\r\n          window.sketchup.start_export_process(\r\n            JSON.stringify(visoes),\r\n            document.getElementById(\"easing_checkbox\").checked,\r\n            startIdx,\r\n            dims.w,\r\n            dims.h,\r\n            nome\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    function showRecordingIndicator() {\r\n      document.getElementById(\"recording_bar\").classList.add(\"active\");\r\n    }\r\n    function hideRecordingIndicator() {\r\n      document.getElementById(\"recording_bar\").classList.remove(\"active\");\r\n    }\r\n\r\n    function instalarExportacao() {\r\n      if (window.sketchup) { window.sketchup.install_ffmpeg(); }\r\n    }\r\n\r\n    /* --- Hotkey --- */\r\n    function mostrarCampoAtalho() {\r\n      capturingHotkey = true; pendingHotkey = null;\r\n      document.getElementById(\"hotkey_input\").value = \"\";\r\n      document.getElementById(\"hotkey_edit\").classList.add(\"visible\");\r\n      document.getElementById(\"hotkey_input\").focus();\r\n    }\r\n    function capturarAtalhoInput(e) {\r\n      e.preventDefault();\r\n      /* Ignorar teclas modificadoras sozinhas */\r\n      if ([16, 17, 18, 91, 93].includes(e.keyCode)) return;\r\n      pendingHotkey = {\r\n        keyCode: e.keyCode,\r\n        ctrl: e.ctrlKey,\r\n        alt: e.altKey,\r\n        shift: e.shiftKey\r\n      };\r\n      /* Montar label legivel */\r\n      var parts = [];\r\n      if (e.ctrlKey) parts.push(\"Ctrl\");\r\n      if (e.altKey) parts.push(\"Alt\");\r\n      if (e.shiftKey) parts.push(\"Shift\");\r\n      parts.push(e.code.replace(\"Key\", \"\").replace(\"Digit\", \"\"));\r\n      document.getElementById(\"hotkey_input\").value = parts.join(\" + \");\r\n    }\r\n    function confirmarAtalho() {\r\n      if (pendingHotkey !== null) {\r\n        hotkey = pendingHotkey;\r\n        if (window.sketchup) {\r\n          window.sketchup.set_hotkey(hotkey.keyCode, hotkey.ctrl, hotkey.alt, hotkey.shift);\r\n        }\r\n      }\r\n      capturingHotkey = false;\r\n      document.getElementById(\"hotkey_edit\").classList.remove(\"visible\");\r\n    }\r\n\r\n    /* --- Global bindings --- */\r\n    window.captureVisionFromRuby = captureVisionFromRuby;\r\n    window.resetPlayButton = resetPlayButton;\r\n    window.pauseAtIndex = pauseAtIndex;\r\n    window.triggerSpaceFromRuby = triggerSpaceFromRuby;\r\n    window.showRecordingIndicator = showRecordingIndicator;\r\n    window.hideRecordingIndicator = hideRecordingIndicator;\r\n    window.updatePlayhead = updatePlayhead;\r\n    window.resetPlayAll = resetPlayAll;\r\n    window.startRecordingPlayAll = startRecordingPlayAll;\r\n    window.addEventListener(\"resize\", () => { renderMarkers(); });\r\n\r\n    document.addEventListener(\"keydown\", (e) => {\r\n      if (!capturingHotkey &&\r\n          e.keyCode === hotkey.keyCode &&\r\n          e.ctrlKey === hotkey.ctrl &&\r\n          e.altKey === hotkey.alt &&\r\n          e.shiftKey === hotkey.shift &&\r\n          ![\"INPUT\", \"TEXTAREA\"].includes(e.target.tagName)) {\r\n        e.preventDefault(); togglePlay();\r\n      }\r\n    });\r\n\r\n    /* Init */\r\n    populatePresets();\r\n    renderMarkers();\r\n</script>\r\n</body>\r\n</html>\r\nHTML\r\n\r\n      @dialog ||= UI::HtmlDialog.new({\r\n        :dialog_title => obter_texto(:titulo_dialogo),\r\n        :preferences_key => \"com.example.tour\",\r\n        :scrollable => true,\r\n        :resizable => true,\r\n        :width => 430,\r\n        :height => 790,\r\n        :style => UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n\r\n      @dialog.set_html(html)\r\n      start_space_timer\r\n\r\n      @dialog.add_action_callback(\"set_hotkey\") do |_, key_code, ctrl, alt, shift|\r\n        GlobalKey.set_hotkey(key_code.to_i, ctrl, alt, shift)\r\n        Sketchup.write_default(\"TourVirtual\", \"Hotkey\", key_code.to_i)\r\n        Sketchup.write_default(\"TourVirtual\", \"HotkeyCtrl\", ctrl ? true : false)\r\n        Sketchup.write_default(\"TourVirtual\", \"HotkeyAlt\", alt ? true : false)\r\n        Sketchup.write_default(\"TourVirtual\", \"HotkeyShift\", shift ? true : false)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"capture_camera\") do |_, time_code|\r\n        cam = Sketchup.active_model.active_view.camera\r\n        thumb = capture_thumbnail\r\n        camera_data = {\r\n          time: time_code.to_f,\r\n          eye: cam.eye.to_a,\r\n          target: cam.target.to_a,\r\n          up: cam.up.to_a,\r\n          fov: cam.fov,\r\n          perspective: cam.perspective?,\r\n          thumb: thumb,\r\n          anchor: false\r\n        }\r\n        json_str = camera_data.to_json.gsub('\"', '\\\"')\r\n        @dialog.execute_script(\"captureVisionFromRuby(\\\"#{json_str}\\\")\")\r\n      end\r\n\r\n      @dialog.add_action_callback(\"goto_camera\") do |_, cam_json|\r\n        cam_data = JSON.parse(cam_json, symbolize_names: true)\r\n        cam = Sketchup::Camera.new(cam_data[:eye], cam_data[:target], cam_data[:up], cam_data[:perspective])\r\n        cam.fov = cam_data[:fov]\r\n        Sketchup.active_model.active_view.camera = cam\r\n      end\r\n\r\n      @dialog.add_action_callback(\"play_tour\") do |_, json_data, loop_enabled, inverse_mode, use_easing, start_index|\r\n        @camera_keys = JSON.parse(json_data, symbolize_names: true)\r\n        view = Sketchup.active_model.active_view\r\n        return if @camera_keys.length < 2\r\n        @camera_keys.sort_by! { |v| v[:time] }\r\n        @index = start_index.to_i\r\n        @direction = 1\r\n        @ping_pong = loop_enabled && inverse_mode\r\n\r\n        define_singleton_method(:ease_in_out_quad) do |t|\r\n          t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t\r\n        end\r\n\r\n        define_singleton_method(:catmull_rom) do |p0, p1, p2, p3, t|\r\n          t2 = t * t\r\n          t3 = t2 * t\r\n          [\r\n            0.5 * ((2 * p1[0]) + (-p0[0] + p2[0]) * t + (2*p0[0] - 5*p1[0] + 4*p2[0] - p3[0]) * t2 + (-p0[0] + 3*p1[0] - 3*p2[0] + p3[0]) * t3),\r\n            0.5 * ((2 * p1[1]) + (-p0[1] + p2[1]) * t + (2*p0[1] - 5*p1[1] + 4*p2[1] - p3[1]) * t2 + (-p0[1] + 3*p1[1] - 3*p2[1] + p3[1]) * t3),\r\n            0.5 * ((2 * p1[2]) + (-p0[2] + p2[2]) * t + (2*p0[2] - 5*p1[2] + 4*p2[2] - p3[2]) * t2 + (-p0[2] + 3*p1[2] - 3*p2[2] + p3[2]) * t3)\r\n          ]\r\n        end\r\n\r\n        define_singleton_method(:catmull_rom_1d) do |p0, p1, p2, p3, t|\r\n          t2 = t * t\r\n          t3 = t2 * t\r\n          0.5 * ((2 * p1) + (-p0 + p2) * t + (2*p0 - 5*p1 + 4*p2 - p3) * t2 + (-p0 + 3*p1 - 3*p2 + p3) * t3)\r\n        end\r\n\r\n        define_singleton_method(:play_transition) do\r\n          current = @camera_keys[@index]\r\n          next_index = @index + @direction\r\n\r\n          if next_index >= @camera_keys.size || next_index < 0\r\n            if loop_enabled\r\n               @index = 0\r\n               UI.start_timer(0.01) { play_transition }\r\n               return\r\n            else\r\n              @dialog.execute_script(\"pauseAtIndex(0)\")\r\n              return\r\n            end\r\n          end\r\n\r\n          next_cam = @camera_keys[next_index]\r\n          duration = (next_cam[:time] - current[:time]).abs\r\n          t_start = Time.now\r\n\r\n          p0 = @camera_keys[[@index - 1, 0].max]\r\n          p1 = current\r\n          p2 = next_cam\r\n          p3 = @camera_keys[[@index + 2, @camera_keys.size - 1].min]\r\n\r\n          @walk_shake = {\r\n            z_phase: rand * Math::PI * 2, x_phase: rand * Math::PI * 2,\r\n            z_amp: 0.8 + rand * 0.4, x_amp: 0.3 + rand * 0.4\r\n          }\r\n          playhead_counter = 0\r\n\r\n          @timer_id = UI.start_timer(0.03, true) do\r\n            t_elapsed = Time.now - t_start\r\n            t = duration.zero? ? 1.0 : [t_elapsed / duration, 1.0].min\r\n            t = use_easing ? ease_in_out_quad(t) : t\r\n\r\n            # Atualizar playhead na timeline (~a cada 0.09s)\r\n            playhead_counter += 1\r\n            if playhead_counter % 3 == 0\r\n              interpolated_time = current[:time] + t * (next_cam[:time] - current[:time])\r\n              @dialog.execute_script(\"updatePlayhead(#{interpolated_time.round(1)})\")\r\n            end\r\n\r\n            eye    = catmull_rom(p0[:eye],    p1[:eye],    p2[:eye],    p3[:eye],    t)\r\n            target = catmull_rom(p0[:target], p1[:target], p2[:target], p3[:target], t)\r\n            up     = catmull_rom(p0[:up],     p1[:up],     p2[:up],     p3[:up],     t)\r\n\r\n            # Interpolação Catmull-Rom para o FOV: suavidade total acompanhando a curva da câmera\r\n            fov = catmull_rom_1d(p0[:fov], p1[:fov], p2[:fov], p3[:fov], t)\r\n\r\n            if current[:walk]\r\n              eye[2] += Math.sin(t * Math::PI * 6 + @walk_shake[:z_phase]) * @walk_shake[:z_amp]\r\n              eye[0] += Math.sin(t * Math::PI * 3 + @walk_shake[:x_phase]) * @walk_shake[:x_amp]\r\n            end\r\n\r\n            cam = Sketchup::Camera.new(eye, target, up, current[:perspective])\r\n            cam.fov = fov\r\n            view.camera = cam\r\n            view.refresh\r\n\r\n            if t >= 1.0\r\n              UI.stop_timer(@timer_id)\r\n              @index = next_index\r\n              if @camera_keys[@index][:anchor] && @index > 0\r\n                @dialog.execute_script(\"pauseAtIndex(#{@index})\")\r\n              else\r\n                play_transition\r\n              end\r\n            end\r\n          end\r\n        end\r\n\r\n        play_transition\r\n      end\r\n\r\n      # Callback de exportação com presets de resolução\r\n      @dialog.add_action_callback(\"start_export_process\") do |_, json_data, use_easing, start_index, width, height, filename|\r\n        iniciar_processo_exportacao(json_data, use_easing, start_index, width.to_i, height.to_i, filename.to_s)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"start_export_project\") do |_, all_timelines_json, use_easing, active_tl_index, start_vision_index, width, height, filename|\r\n        iniciar_processo_exportacao_projeto(all_timelines_json, use_easing, active_tl_index.to_i, start_vision_index.to_i, width.to_i, height.to_i, filename.to_s)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"install_ffmpeg\") do |_|\r\n        eval(FFMPEG_INSTALL_SCRIPT)\r\n        UI.messagebox(obter_texto(:ffmpeg_instalado))\r\n      end\r\n\r\n      @dialog.add_action_callback(\"stop_tour\") do |_|\r\n        UI.stop_timer(@timer_id) if @timer_id\r\n        @dialog.execute_script(\"resetPlayButton()\")\r\n      end\r\n\r\n      @dialog.add_action_callback(\"show_export_preview\") do |_, width, height|\r\n        @preview_tool = ExportPreviewTool.new(width.to_i, height.to_i)\r\n        Sketchup.active_model.select_tool(@preview_tool)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"hide_export_preview\") do |_|\r\n        Sketchup.active_model.select_tool(nil)\r\n        @preview_tool = nil\r\n      end\r\n\r\n      @dialog.set_on_closed {\r\n        UI.stop_timer(@timer_id) if defined?(@timer_id) && @timer_id\r\n        stop_space_timer\r\n        if @preview_tool\r\n          Sketchup.active_model.select_tool(nil)\r\n          @preview_tool = nil\r\n        end\r\n      }\r\n\r\n      @dialog.show\r\n    end\r\n  end\r\nend\r\n\r\ndef self.executar\r\n  TourPlugin::CameraTimeline.start_ui\r\nend\r\n\r\nend # module TourVirtual\r\nend # module ScriptUpComunidade\r\n\r\nScriptUpComunidade::TourVirtual.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "achatar-94oqx",
    "title": {
      "pt": "Achatar",
      "en": "Flatten",
      "es": "Aplanar"
    },
    "author": "Henrique Barsa",
    "version": "1.0",
    "description": {
      "pt": "Nivela todos os elementos no eixo Z = 0",
      "en": "Level all elements on the Z = 0 axis.",
      "es": "Nivele todos los elementos en el eje Z = 0."
    },
    "keywords": {
      "pt": [
        "flatten",
        "achatar",
        "aplanar"
      ],
      "en": [
        "flatten",
        "flatten",
        "flatten"
      ],
      "es": [
        "aplanar",
        "aplanar",
        "aplanar"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module AchatarModelo\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :pergunta_modelo  => \"Nenhum objeto selecionado. Deseja achatar o modelo inteiro?\",\r\n        :msg_sucesso_full => \"Foram achatados %d objetos no modelo inteiro.\",\r\n        :cancelado        => \"Operação cancelada.\",\r\n        :msg_sucesso_sel  => \"Foram achatados %d objetos na seleção.\",\r\n        :op_nome          => \"Achatar\"\r\n      },\r\n      'en-US' => {\r\n        :pergunta_modelo  => \"No objects selected. Do you want to flatten the entire model?\",\r\n        :msg_sucesso_full => \"%d objects were flattened in the entire model.\",\r\n        :cancelado        => \"Operation canceled.\",\r\n        :msg_sucesso_sel  => \"%d objects were flattened in the selection.\",\r\n        :op_nome          => \"Flatten\"\r\n      },\r\n      'es' => {\r\n        :pergunta_modelo  => \"¿Ningún objeto seleccionado. Desea aplanar el modelo completo?\",\r\n        :msg_sucesso_full => \"Se aplanaron %d objetos en el modelo completo.\",\r\n        :cancelado        => \"Operación cancelada.\",\r\n        :msg_sucesso_sel  => \"Se aplanaron %d objetos en la selección.\",\r\n        :op_nome          => \"Aplanar\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    # Método principal que decide se vai achatar a seleção ou o modelo inteiro\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n      \r\n      if selection.empty?\r\n        # Pergunta se deseja processar o modelo inteiro\r\n        resposta = UI.messagebox(obter_texto(:pergunta_modelo), MB_YESNO)\r\n        if resposta == IDYES\r\n          stats = flatten_entities(model.entities)\r\n          UI.messagebox(obter_texto(:msg_sucesso_full) % stats)\r\n        else\r\n          UI.messagebox(obter_texto(:cancelado))\r\n          model.abort_operation\r\n          return\r\n        end\r\n      else\r\n        stats = flatten_entities(selection)\r\n        UI.messagebox(obter_texto(:msg_sucesso_sel) % stats)\r\n      end\r\n\r\n      model.commit_operation\r\n    end\r\n\r\n    # Método recursivo para achatar as entidades\r\n    def self.flatten_entities(ents)\r\n      stats = 0\r\n      vertices = []\r\n\r\n      ents.each do |e|\r\n        if e.is_a?(Sketchup::ComponentInstance) || e.is_a?(Sketchup::Group)\r\n          # Processa recursivamente as entidades da definição do componente ou grupo\r\n          stats += flatten_entities(Instance.definition(e).entities)\r\n          # Move a instância para z=0\r\n          p = e.transformation.origin.clone\r\n          p.z = 0\r\n          v = e.transformation.origin.vector_to(p)\r\n          e.transform!(Geom::Transformation.new(v))\r\n        end\r\n\r\n        vertices << e if e.is_a?(Sketchup::ConstructionPoint)\r\n        vertices << e.vertices if e.respond_to?(:vertices)\r\n        e.explode_curve if e.is_a?(Sketchup::Edge)\r\n      end\r\n\r\n      vertices.flatten!\r\n      vertices.uniq!\r\n\r\n      entities = []\r\n      vectors = []\r\n\r\n      # Ajusta todos os vértices para o nível z=0\r\n      vertices.each do |v|\r\n        point = v.position\r\n        next if point.z == 0\r\n        entities << v\r\n        point.z = 0\r\n        vectors << v.position.vector_to(point)\r\n      end\r\n\r\n      if ents.is_a?(Sketchup::Selection)\r\n        ents.model.active_entities.transform_by_vectors(entities, vectors)\r\n      else\r\n        ents.transform_by_vectors(entities, vectors)\r\n      end\r\n\r\n      return entities.length + stats\r\n    end\r\n\r\n    # Módulo auxiliar para tratar definições de grupos e componentes\r\n    module Instance\r\n      def self.definition(instance)\r\n        if instance.respond_to?(:definition)\r\n          begin\r\n            return instance.definition\r\n          rescue\r\n            # Em caso de erro, prossegue para a busca manual\r\n          end\r\n        end\r\n\r\n        if instance.is_a?(Sketchup::Group)\r\n          if instance.entities.parent.instances.include?(instance)\r\n            return instance.entities.parent\r\n          else\r\n            Sketchup.active_model.definitions.each do |definition|\r\n              return definition if definition.instances.include?(instance)\r\n            end\r\n          end\r\n        elsif instance.is_a?(Sketchup::Image)\r\n          Sketchup.active_model.definitions.each do |definition|\r\n            if definition.image? && definition.instances.include?(instance)\r\n              return definition\r\n            end\r\n          end\r\n        end\r\n\r\n        return nil\r\n      end\r\n\r\n      def self.is?(entity)\r\n        entity.is_a?(Sketchup::Group) || entity.is_a?(Sketchup::ComponentInstance)\r\n      end\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::AchatarModelo.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "ajustar-escala-da-definicao-94qzr",
    "title": {
      "pt": "Ajustar Escala da Definição",
      "en": "Adjust Definition Scale",
      "es": "Ajustar escala de definición"
    },
    "author": "Fábio Coutinho",
    "version": "1.2",
    "description": {
      "pt": "Ajusta a escala da definição fazendo com que as texturas aplicadas nos grupos e componentes assumam suas proporções corretas para não ficarem distorcidas. Essa versão consegue promover o ajuste em grupos e componentes em qualquer nível de aninhamento.",
      "en": "Adjusts the scaling of the definition so that the textures applied to groups and components assume their correct proportions and do not become distorted. This version can adjust groups and components at any nesting level.",
      "es": "Ajusta la escala de la definición para que las texturas aplicadas a grupos y componentes adquieran las proporciones correctas y no se distorsionen. Esta versión permite ajustar grupos y componentes en cualquier nivel de anidamiento."
    },
    "keywords": {
      "pt": [
        "escala da definição",
        "ajustar texturas"
      ],
      "en": [
        "scale of definition",
        "adjust textures"
      ],
      "es": [
        "escala de definición",
        "ajustar texturas"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module NormalizarEscala\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :selecao_vazia    => \"Nenhum elemento selecionado.\",\r\n        :ja_processado    => \"Definição já processada, ignorando: \",\r\n        :escala_ajustada  => \"A escala foi normalizada para 1 no elemento: \",\r\n        :escala_correta   => \"O elemento já está com escala normalizada: \",\r\n        :elemento_ignorado => \"Elemento ignorado, não é um componente ou grupo válido: \",\r\n        :op_nome          => \"Normalizar Escala\",\r\n        :concluido        => \"Processo concluído.\"\r\n      },\r\n      'en-US' => {\r\n        :selecao_vazia    => \"No elements selected.\",\r\n        :ja_processado    => \"Definition already processed, skipping: \",\r\n        :escala_ajustada  => \"Scale was normalized to 1 for element: \",\r\n        :escala_correta   => \"Element already has normalized scale: \",\r\n        :elemento_ignorado => \"Element ignored, not a valid component or group: \",\r\n        :op_nome          => \"Normalize Scale\",\r\n        :concluido        => \"Process completed.\"\r\n      },\r\n      'es' => {\r\n        :selecao_vazia    => \"Ningún elemento seleccionado.\",\r\n        :ja_processado    => \"Definición ya procesada, ignorando: \",\r\n        :escala_ajustada  => \"La escala fue normalizada a 1 en el elemento: \",\r\n        :escala_correta   => \"El elemento ya tiene la escala normalizada: \",\r\n        :elemento_ignorado => \"Elemento ignorado, no es un componente o grupo válido: \",\r\n        :op_nome          => \"Normalizar Escala\",\r\n        :concluido        => \"Proceso completado.\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      if selection.empty?\r\n        puts obter_texto(:selecao_vazia)\r\n      else\r\n        processed_definitions = []\r\n\r\n        model.start_operation(obter_texto(:op_nome), true)\r\n\r\n        selection.each do |entity|\r\n          normalize_scale_recursively(entity, processed_definitions)\r\n        end\r\n\r\n        model.commit_operation\r\n        puts obter_texto(:concluido)\r\n      end\r\n    end\r\n\r\n    def self.normalize_scale_recursively(entity, processed_definitions)\r\n      if entity.is_a?(Sketchup::ComponentInstance) || entity.is_a?(Sketchup::Group)\r\n        entity.make_unique if entity.is_a?(Sketchup::ComponentInstance)\r\n\r\n        definition = entity.is_a?(Sketchup::ComponentInstance) ? entity.definition : nil\r\n        entities = definition ? definition.entities : entity.entities\r\n\r\n        if definition && processed_definitions.include?(definition)\r\n          puts \"#{obter_texto(:ja_processado)}#{entity}\"\r\n          return\r\n        end\r\n\r\n        processed_definitions << definition if definition\r\n\r\n        transform = entity.transformation\r\n        scale_x = transform.xscale\r\n        scale_y = transform.yscale\r\n        scale_z = transform.zscale\r\n\r\n        if scale_x != 1 || scale_y != 1 || scale_z != 1\r\n          scaling_transform = Geom::Transformation.scaling(scale_x, scale_y, scale_z)\r\n          entities.transform_entities(scaling_transform, entities.to_a)\r\n\r\n          origin = transform.origin\r\n          xaxis = transform.xaxis\r\n          yaxis = transform.yaxis\r\n          zaxis = transform.zaxis\r\n\r\n          normalized_transform = Geom::Transformation.axes(origin, xaxis, yaxis, zaxis)\r\n          entity.transformation = normalized_transform\r\n\r\n          puts \"#{obter_texto(:escala_ajustada)}#{entity}\"\r\n\r\n          temp_group = entities.add_group\r\n          temp_face = temp_group.entities.add_face([0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0])\r\n          temp_group.erase! if temp_face\r\n        else\r\n          puts \"#{obter_texto(:escala_correta)}#{entity}\"\r\n        end\r\n\r\n        entities.grep(Sketchup::ComponentInstance).each do |child_entity|\r\n          normalize_scale_recursively(child_entity, processed_definitions)\r\n        end\r\n        entities.grep(Sketchup::Group).each do |child_group|\r\n          normalize_scale_recursively(child_group, processed_definitions)\r\n        end\r\n      else\r\n        puts \"#{obter_texto(:elemento_ignorado)}#{entity}\"\r\n      end\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::NormalizarEscala.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "cortar-com-secao-94tdf",
    "title": {
      "pt": "Cortar com Seção",
      "en": "Cut with Section",
      "es": "Corte con sección"
    },
    "author": "Henrique Barsa",
    "version": "1.0",
    "description": {
      "pt": "Use o Plano de Seção para cortar o que você quiser.",
      "en": "Use the Section Plan to cut out whatever you want.",
      "es": "Utilice el plano de sección para cortar lo que desee."
    },
    "keywords": {
      "pt": [
        "cortar",
        "seção"
      ],
      "en": [
        "cut",
        "section"
      ],
      "es": [
        "cortar",
        "sección"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module CortarPlanoSecao\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :status_cortando   => \"Cortando %s...\",\r\n        :status_excluindo  => \"Excluindo entidades atrás do plano para %s...\",\r\n        :status_preparando => \"Tornando componentes únicos, excluindo grupos e componentes atrás do plano de seção...\",\r\n        :op_nome           => \"Corte via SectionPlane\",\r\n        :sucesso           => \"Corte via SectionPlane concluído.\",\r\n        :erro_selecao      => \"Selecione uma SectionPlane para cortar o modelo.\"\r\n      },\r\n      'en-US' => {\r\n        :status_cortando   => \"Slicing %s...\",\r\n        :status_excluindo  => \"Deleting entities behind plane for %s...\",\r\n        :status_preparando => \"Making components unique, deleting groups and components behind section plane...\",\r\n        :op_nome           => \"Slice at Section Plane\",\r\n        :sucesso           => \"Slice at Section Plane completed.\",\r\n        :erro_selecao      => \"Select a SectionPlane to slice the model.\"\r\n      },\r\n      'es' => {\r\n        :status_cortando   => \"Cortando %s...\",\r\n        :status_excluindo  => \"Eliminando entidades detrás del plano para %s...\",\r\n        :status_preparando => \"Haciendo componentes únicos, eliminando grupos y componentes detrás del plano de sección...\",\r\n        :op_nome           => \"Corte por Plano de Sección\",\r\n        :sucesso           => \"Corte por Plano de Sección completado.\",\r\n        :erro_selecao      => \"Seleccione un SectionPlane para cortar el modelo.\"\r\n      }\r\n    }\r\n\r\n    $helper_group = nil\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.get_entities(object)\r\n      if object.is_a?(Sketchup::Model)\r\n        object.entities\r\n      elsif object.is_a?(Sketchup::Group)\r\n        object.entities\r\n      elsif object.is_a?(Sketchup::ComponentInstance)\r\n        object.definition.entities\r\n      elsif object.is_a?(Sketchup::ComponentDefinition)\r\n        object.entities\r\n      else\r\n        nil\r\n      end\r\n    end\r\n\r\n    def self.bounds_intersects_plane?(inst1, t1, plane)\r\n      bounds = inst1.bounds\r\n      bmin = bounds.min\r\n      bmax = bounds.max\r\n      pts = [\r\n        Geom::Point3d.new(bmin.x, bmin.y, bmin.z),\r\n        Geom::Point3d.new(bmax.x, bmin.y, bmin.z),\r\n        Geom::Point3d.new(bmin.x, bmin.y, bmax.z),\r\n        Geom::Point3d.new(bmax.x, bmin.y, bmax.z),\r\n        Geom::Point3d.new(bmin.x, bmax.y, bmax.z),\r\n        Geom::Point3d.new(bmax.x, bmax.y, bmax.z),\r\n        Geom::Point3d.new(bmin.x, bmax.y, bmin.z),\r\n        Geom::Point3d.new(bmax.x, bmax.y, bmin.z)\r\n      ]\r\n      pts = pts.map { |p| p.transform(t1) }\r\n\r\n      behind = pts.find { |p| (plane[0]*p.x + plane[1]*p.y + plane[2]*p.z + plane[3]) < -0.001 }\r\n      in_front = pts.find { |p| (plane[0]*p.x + plane[1]*p.y + plane[2]*p.z + plane[3]) > 0.001 }\r\n\r\n      if behind && in_front\r\n        0\r\n      elsif behind && !in_front\r\n        -1\r\n      elsif !behind && in_front\r\n        1\r\n      end\r\n    end\r\n\r\n    def self.make_unique_section_cut(ents, t1, plane)\r\n      delete = []\r\n      ents.each do |e|\r\n        next unless e.valid? && e.visible?\r\n        if e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance)\r\n          res = bounds_intersects_plane?(e, t1, plane)\r\n          if res == 0\r\n            e.make_unique\r\n            make_unique_section_cut(get_entities(e), t1 * e.transformation, plane)\r\n          elsif res == -1\r\n            delete << e\r\n          end\r\n        end\r\n      end\r\n      ents.erase_entities(delete) unless delete.empty?\r\n    end\r\n\r\n    def self.create_face_from_section(section)\r\n      plane = section.get_plane\r\n      bounds = Sketchup.active_model.bounds\r\n      entities = Sketchup.active_model.active_entities\r\n      bmin = bounds.min\r\n      bmax = bounds.max\r\n\r\n      newgroup = entities.add_group\r\n      newgroupentities = newgroup.entities\r\n\r\n      c1 = [bmin.x, bmin.y, bmin.z]\r\n      c2 = [bmax.x, bmin.y, bmin.z]\r\n      c3 = [bmin.x, bmin.y, bmax.z]\r\n      c4 = [bmax.x, bmin.y, bmax.z]\r\n      c5 = [bmin.x, bmax.y, bmax.z]\r\n      c6 = [bmax.x, bmax.y, bmax.z]\r\n      c7 = [bmin.x, bmax.y, bmin.z]\r\n      c8 = [bmax.x, bmax.y, bmin.z]\r\n\r\n      e1 = newgroupentities.add_edges(c1, c2)\r\n      e2 = newgroupentities.add_edges(c3, c4)\r\n      e3 = newgroupentities.add_edges(c5, c6)\r\n      e4 = newgroupentities.add_edges(c7, c8)\r\n      e5 = newgroupentities.add_edges(c1, c3)\r\n      e6 = newgroupentities.add_edges(c2, c4)\r\n      e7 = newgroupentities.add_edges(c7, c5)\r\n      e8 = newgroupentities.add_edges(c8, c6)\r\n      e9 = newgroupentities.add_edges(c1, c7)\r\n      e10 = newgroupentities.add_edges(c3, c5)\r\n      e11 = newgroupentities.add_edges(c4, c6)\r\n      e12 = newgroupentities.add_edges(c2, c8)\r\n\r\n      lines = [e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12].map{|arr| arr[0]}\r\n      line_objs = lines.map(&:line)\r\n      lines.each(&:erase!)\r\n\r\n      pts_intersect = line_objs.map { |l| Geom.intersect_line_plane(l, plane) }.compact\r\n      \r\n      # Lógica simplificada para gerar a face de corte baseada nos pontos de interseção do bounding box\r\n      if pts_intersect.length >= 3\r\n        newgroupentities.add_face(pts_intersect) rescue nil\r\n      end\r\n\r\n      return newgroup\r\n    end\r\n\r\n    def self.nested_slash(first, t1, second, t2)\r\n      ents = get_entities(first)\r\n      ents.each do |e|\r\n        if e.valid? && e.visible? && (e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance))\r\n          Sketchup.set_status_text(obter_texto(:status_cortando) % get_entities(e).parent.name)\r\n          nested_slash(e, t1 * e.transformation, second, t2)\r\n        end\r\n      end\r\n      slash(first, t1, second, t2)\r\n    end\r\n\r\n    def self.slash(inst1, t1, inst2, t2)\r\n      if intersects_plane?(inst1, t1, inst2, t2)\r\n        ents1 = get_entities(inst1)\r\n        ents1.intersect_with(false, t1, ents1, t1, false, [inst2])\r\n      end\r\n    end\r\n\r\n    def self.intersects_plane?(inst1, t1, plane_group, t2)\r\n      if $helper_group.nil? || !$helper_group.valid?\r\n        $helper_group = Sketchup.active_model.active_entities.add_group\r\n        $helper_group.entities.add_cpoint([0,0,0])\r\n      end\r\n      ents1 = get_entities(inst1)\r\n      ents2 = $helper_group.entities\r\n      new_edges = ents1.intersect_with(false, t1, ents2, $helper_group.transformation, false, [plane_group])\r\n      new_edges.length > 0\r\n    end\r\n\r\n    def self.delete_model_behind_plane(first, t1, plane)\r\n      ents = get_entities(first)\r\n      ents.each do |e|\r\n        if e.valid? && e.visible? && (e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance))\r\n          Sketchup.set_status_text(obter_texto(:status_excluindo) % get_entities(e).parent.name)\r\n          delete_model_behind_plane(e, t1 * e.transformation, plane)\r\n        end\r\n      end\r\n      delete_ents_behind_plane(first, t1, plane)\r\n    end\r\n\r\n    def self.delete_ents_behind_plane(first, t1, plane)\r\n      ents = get_entities(first)\r\n      deletar = []\r\n      ents.each do |e|\r\n        next unless e.valid?\r\n        if e.is_a?(Sketchup::Face)\r\n          cent = e.bounds.center.transform(t1)\r\n          result = plane[0]*cent.x + plane[1]*cent.y + plane[2]*cent.z + plane[3]\r\n          deletar << e if result < -0.001\r\n        elsif e.is_a?(Sketchup::Edge)\r\n          p1 = e.start.position.transform(t1)\r\n          p2 = e.end.position.transform(t1)\r\n          cent = Geom::Point3d.new((p1.x+p2.x)/2.0, (p1.y+p2.y)/2.0, (p1.z+p2.z)/2.0)\r\n          result = plane[0]*cent.x + plane[1]*cent.y + plane[2]*cent.z + plane[3]\r\n          deletar << e if result < -0.001 && cent.distance_to_plane(plane) > 0.001\r\n        end\r\n      end\r\n      ents.erase_entities(deletar) unless deletar.empty?\r\n    end\r\n\r\n    def self.delete_helpers\r\n      if $helper_group && $helper_group.valid?\r\n        Sketchup.active_model.active_entities.erase_entities($helper_group)\r\n      end\r\n      $helper_group = nil\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      section = model.selection.first\r\n      \r\n      unless section.is_a?(Sketchup::SectionPlane)\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n\r\n      plane = section.get_plane\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n\r\n      ents = model.active_entities\r\n      Sketchup.set_status_text(obter_texto(:status_preparando))\r\n\r\n      make_unique_section_cut(ents, Geom::Transformation.new, plane)\r\n      knife_group = create_face_from_section(section)\r\n      \r\n      nested_slash(ents.parent, Geom::Transformation.new, knife_group, knife_group.transformation)\r\n      \r\n      ents.erase_entities(knife_group) if knife_group.valid?\r\n      delete_model_behind_plane(ents.parent, Geom::Transformation.new, plane)\r\n      delete_helpers()\r\n\r\n      model.commit_operation\r\n      UI.messagebox(obter_texto(:sucesso))\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::CortarPlanoSecao.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "cria-cena-com-elementos-isolados-94vse",
    "title": {
      "pt": "Cria Cena com Elementos Isolados",
      "en": "Create a Scene with Isolated Elements",
      "es": "Crear una escena con elementos aislados"
    },
    "author": "José Ricardo",
    "version": "1.0",
    "description": {
      "pt": "Isola os elementos selecionados ocultando os demais e criando uma cena com os elementos em seleção de zoom.",
      "en": "Isolate the selected elements, hiding the others and creating a scene with the zoomed-in selection of the elements.",
      "es": "Aísla los elementos seleccionados, ocultando los demás y creando una escena con la selección ampliada de los elementos."
    },
    "keywords": {
      "pt": [
        "isola elemento",
        "cena com seleção"
      ],
      "en": [
        "isolates element",
        "scene with selection"
      ],
      "es": [
        "elemento aislado",
        "escena con selección"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module CriarCenaFiltrada\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao    => \"Nenhuma entidade selecionada. Por favor, selecione objetos para manter visíveis.\",\r\n        :label_cena      => \"Nome da Cena:\",\r\n        :default_cena    => \"Cena Filtrada\",\r\n        :titulo_input    => \"Criar Nova Cena\",\r\n        :cancelado       => \"Operação cancelada pelo usuário.\",\r\n        :op_nome         => \"Ocultar Não Selecionados e Criar Cena\",\r\n        :sucesso         => \"Cena '%s' criada com sucesso, com zoom na seleção e entidades ocultas.\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao    => \"No entities selected. Please select objects to keep visible.\",\r\n        :label_cena      => \"Scene Name:\",\r\n        :default_cena    => \"Filtered Scene\",\r\n        :titulo_input    => \"Create New Scene\",\r\n        :cancelado       => \"Operation canceled by user.\",\r\n        :op_nome         => \"Hide Unselected and Create Scene\",\r\n        :sucesso         => \"Scene '%s' successfully created with zoom on selection and hidden entities.\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao    => \"Ninguna entidad seleccionada. Por favor, seleccione objetos para mantener visibles.\",\r\n        :label_cena      => \"Nombre de la Escena:\",\r\n        :default_cena    => \"Escena Filtrada\",\r\n        :titulo_input    => \"Crear Nueva Escena\",\r\n        :cancelado       => \"Operación cancelada por el usuario.\",\r\n        :op_nome         => \"Ocultar no seleccionados y Crear Escena\",\r\n        :sucesso         => \"Escena '%s' creada con éxito, con zoom en la selección y entidades ocultas.\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      entities = model.active_entities\r\n      selection = model.selection\r\n\r\n      if selection.empty?\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n      else\r\n        # Solicita o nome da nova cena\r\n        prompts = [obter_texto(:label_cena)]\r\n        defaults = [obter_texto(:default_cena)]\r\n        input = UI.inputbox(prompts, defaults, obter_texto(:titulo_input))\r\n        \r\n        unless input\r\n          puts obter_texto(:cancelado)\r\n          return\r\n        end\r\n\r\n        scene_name = input[0]\r\n\r\n        # Inicia operação\r\n        model.start_operation(obter_texto(:op_nome), true)\r\n\r\n        # Oculta entidades não selecionadas (e ocultáveis)\r\n        entities.each do |ent|\r\n          next if selection.include?(ent)\r\n          ent.hidden = true if ent.respond_to?(:hidden=)\r\n        end\r\n\r\n        # Faz zoom na seleção\r\n        Sketchup.send_action(\"viewZoomToSelection:\")\r\n\r\n        # Aguarda um pequeno tempo para garantir o zoom e cria a cena\r\n        UI.start_timer(0.2, false) {\r\n          page = model.pages.add(scene_name)\r\n          page.use_camera = true\r\n\r\n          model.commit_operation\r\n          UI.messagebox(obter_texto(:sucesso) % scene_name)\r\n        }\r\n      end\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::CriarCenaFiltrada.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "cria-cenas-do-modelo-isolado-em-projecao-94y26",
    "title": {
      "pt": "Cria Cenas do Modelo Isolado em Projeção Paralela",
      "en": "Creates Scenes of the Isolated Model in Parallel Projection",
      "es": "Crea escenas del modelo aislado en proyección paralela"
    },
    "author": "André Silva",
    "version": "1.3",
    "description": {
      "pt": "Cria todas as exibições padrões, em projeção paralela, do(s) elemento(s) selecionado(s) de forma isolada, ou seja, ocultando o restante do modelo. As cenas são criadas usando no nome o prefixo que você informar.",
      "en": "Creates all standard views, in parallel projection, of the selected element(s) in isolation, that is, hiding the rest of the model. Scenes are created using the prefix you specify in the name.",
      "es": "Crea todas las vistas estándar, en proyección paralela, de los elementos seleccionados de forma aislada, es decir, ocultando el resto del modelo. Las escenas se crean con el prefijo especificado en el nombre."
    },
    "keywords": {
      "pt": [
        "cenas",
        "projeção paralela"
      ],
      "en": [
        "scenes",
        "parallel projection"
      ],
      "es": [
        "escenas",
        "proyección paralela"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module CriarVistasPadrao\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :label_prefixo => \"Prefixo das cenas:\",\r\n        :titulo_input  => \"Prefixo para os nomes das cenas\",\r\n        :op_nome       => \"Isolar Seleção para Cenas\",\r\n        :superior      => \"Superior\",\r\n        :inferior      => \"Inferior\",\r\n        :direita       => \"Direita\",\r\n        :esquerda      => \"Esquerda\",\r\n        :posterior     => \"Posterior\",\r\n        :frontal       => \"Frontal\",\r\n        :iso           => \"ISO\"\r\n      },\r\n      'en-US' => {\r\n        :label_prefixo => \"Scene prefix:\",\r\n        :titulo_input  => \"Prefix for scene names\",\r\n        :op_nome       => \"Isolate Selection for Scenes\",\r\n        :superior      => \"Top\",\r\n        :inferior      => \"Bottom\",\r\n        :direita       => \"Right\",\r\n        :esquerda      => \"Left\",\r\n        :posterior     => \"Back\",\r\n        :frontal       => \"Front\",\r\n        :iso           => \"ISO\"\r\n      },\r\n      'es' => {\r\n        :label_prefixo => \"Prefijo de las escenas:\",\r\n        :titulo_input  => \"Prefijo para los nombres de las escenas\",\r\n        :op_nome       => \"Aislar Selección para Escenas\",\r\n        :superior      => \"Superior\",\r\n        :inferior      => \"Inferior\",\r\n        :direita       => \"Derecha\",\r\n        :esquerda      => \"Izquierda\",\r\n        :posterior     => \"Posterior\",\r\n        :frontal       => \"Frontal\",\r\n        :iso           => \"ISO\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      entities = model.active_entities\r\n      views = model.pages\r\n      view = model.active_view\r\n      selection = model.selection\r\n\r\n      # Pergunta o prefixo\r\n      res = UI.inputbox([obter_texto(:label_prefixo)], [\"\"], obter_texto(:titulo_input))\r\n\r\n      if res # Só continua se não cancelou\r\n        prefixo = res[0].strip\r\n        prefixo += \" - \" unless prefixo.empty?\r\n\r\n        # Oculta tudo menos a seleção\r\n        model.start_operation(obter_texto(:op_nome), true)\r\n        entities.each do |e|\r\n          next if selection.include?(e)\r\n          e.visible = false if e.respond_to?(:visible=)\r\n        end\r\n\r\n        # Obter centro do modelo\r\n        bounding_box = model.bounds\r\n        centro = bounding_box.center\r\n\r\n        # Dicionário de vistas corrigido\r\n        vistas = {\r\n          obter_texto(:superior)  => { dir: Geom::Vector3d.new(0, 0, -1),  up: Geom::Vector3d.new(0, -1, 0) },\r\n          obter_texto(:inferior)  => { dir: Geom::Vector3d.new(0, 0, 1),   up: Geom::Vector3d.new(0, 1, 0) },\r\n          obter_texto(:direita)   => { dir: Geom::Vector3d.new(-1, 0, 0),  up: Geom::Vector3d.new(0, 0, 1) },\r\n          obter_texto(:esquerda)  => { dir: Geom::Vector3d.new(1, 0, 0),   up: Geom::Vector3d.new(0, 0, 1) },\r\n          obter_texto(:posterior) => { dir: Geom::Vector3d.new(0, -1, 0),  up: Geom::Vector3d.new(0, 0, 1) },\r\n          obter_texto(:frontal)   => { dir: Geom::Vector3d.new(0, 1, 0),   up: Geom::Vector3d.new(0, 0, 1) },\r\n          obter_texto(:iso)       => { dir: Geom::Vector3d.new(1, 1, -1),  up: Geom::Vector3d.new(0, 0, 1) }\r\n        }\r\n\r\n        # Criar cada cena\r\n        vistas.each do |nome, dados|\r\n          dir = dados[:dir].clone.normalize!\r\n          up  = dados[:up]\r\n\r\n          from_point = centro.offset(dir.reverse!.transform(300))\r\n          to_point = centro\r\n\r\n          camera = Sketchup::Camera.new(from_point, to_point, up)\r\n          camera.perspective = false  # Projeção paralela\r\n\r\n          view.camera = camera\r\n          view.zoom_extents\r\n\r\n          # Criar cena com prefixo\r\n          page = views.add(\"#{prefixo}#{nome}\")\r\n          page.use_camera = true\r\n        end\r\n\r\n        model.commit_operation\r\n      end\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::CriarVistasPadrao.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "criar-faces-94zyu",
    "title": {
      "pt": "Criar Faces",
      "en": "Create Faces",
      "es": "Crear caras"
    },
    "author": "Henrique Barsa",
    "version": "1.0",
    "description": {
      "pt": "Faz o preenchimento de superfícies.",
      "en": "It fills surfaces.",
      "es": "Rellena superficies."
    },
    "keywords": {
      "pt": [
        "faces",
        "buracos"
      ],
      "en": [
        "faces",
        "holes"
      ],
      "es": [
        "caras",
        "agujeros"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module BarsaFace\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :aviso_selecao => \"Nenhuma seleção encontrada. Deseja processar todo o modelo? Essa operação pode demorar.\",\r\n        :op_nome       => \"Criar Faces\"\r\n      },\r\n      'en-US' => {\r\n        :aviso_selecao => \"No selection found. Do you want to process the entire model? This operation may take some time.\",\r\n        :op_nome       => \"Create Faces\"\r\n      },\r\n      'es' => {\r\n        :aviso_selecao => \"No se encontró ninguna selección. ¿Desea procesar todo el modelo? Esta operación puede tardar.\",\r\n        :op_nome       => \"Crear Caras\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n\r\n      if model.selection.empty?\r\n        response = UI.messagebox(obter_texto(:aviso_selecao), MB_YESNO)\r\n        return if response != IDYES\r\n        entities = model.active_entities\r\n      else\r\n        entities = model.selection\r\n      end\r\n\r\n      entities_array = entities.to_a\r\n\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n      create_faces_recursive(entities_array)\r\n      model.commit_operation\r\n    end\r\n\r\n    def self.create_faces_recursive(entities)\r\n      entities.each do |entity|\r\n        case entity\r\n        when Sketchup::Edge\r\n          faces_before = entity.faces.to_a\r\n          entity.find_faces\r\n          new_faces = entity.faces.to_a - faces_before\r\n          new_faces.each do |face|\r\n            correct_face_orientation(face)\r\n          end\r\n        when Sketchup::Group\r\n          create_faces_recursive(entity.entities)\r\n        when Sketchup::ComponentInstance\r\n          create_faces_recursive(entity.definition.entities)\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.correct_face_orientation(face)\r\n      # Define um vetor \"cima\", pode ser Z global\r\n      up = Z_AXIS\r\n      # Se a face estiver voltada para baixo (comparado ao eixo Z)\r\n      if face.normal.angle_between(up) > 90.degrees\r\n        face.reverse!\r\n      end\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::BarsaFace.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "desbloquear-tudo-95252",
    "title": {
      "pt": "Desbloquear Tudo",
      "en": "Unlock Everything",
      "es": "Desbloquea todo"
    },
    "author": "Fábio Coutinho",
    "version": "1.0",
    "description": {
      "pt": "Script para desbloquear tudo, na seleção ou no modelo. Aninhados ou não.",
      "en": "Script to unlock everything, in the selection or in the model. Nested or not.",
      "es": "Script para desbloquear todo, en la selección o en el modelo. Anidado o no."
    },
    "keywords": {
      "pt": [
        "desbloquear",
        "unlock"
      ],
      "en": [
        "unlock",
        "unlock"
      ],
      "es": [
        "descubrir",
        "descubrir"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module DesbloquearElementos\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :pergunta_modo => \"Deseja desbloquear apenas os elementos selecionados? (Sim para Seleção, Não para Todo o Modelo)\",\r\n        :op_nome       => \"Desbloquear Elementos\",\r\n        :sucesso       => \"Todos os grupos e componentes foram desbloqueados!\"\r\n      },\r\n      'en-US' => {\r\n        :pergunta_modo => \"Do you want to unlock only the selected elements? (Yes for Selection, No for Entire Model)\",\r\n        :op_nome       => \"Unlock Elements\",\r\n        :sucesso       => \"All groups and components have been unlocked!\"\r\n      },\r\n      'es' => {\r\n        :pergunta_modo => \"¿Desea desbloquear solo los elementos seleccionados? (Sí para Selección, No para todo el Modelo)\",\r\n        :op_nome       => \"Desbloquear Elementos\",\r\n        :sucesso       => \"¡Todos los grupos y componentes han sido desbloqueados!\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.ask_user(question)\r\n      result = UI.messagebox(question, MB_YESNO)\r\n      result == IDYES\r\n    end\r\n\r\n    def self.unlock_entities(entities)\r\n      # Primeiro, desbloqueia os grupos e componentes no nível atual\r\n      entities.each do |entity|\r\n        if entity.is_a?(Sketchup::Group) || entity.is_a?(Sketchup::ComponentInstance)\r\n          if entity.locked?\r\n            entity.locked = false\r\n          end\r\n        end\r\n      end\r\n\r\n      # Depois, entra nos grupos/componentes desbloqueados para desbloquear os aninhados\r\n      entities.each do |entity|\r\n        if entity.is_a?(Sketchup::Group) || entity.is_a?(Sketchup::ComponentInstance)\r\n          unlock_entities(entity.definition.entities) # Recursão para desbloquear subgrupos/subcomponentes\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      # Perguntar se deseja agir na seleção ou no modelo inteiro\r\n      use_selection = ask_user(obter_texto(:pergunta_modo))\r\n\r\n      entities = use_selection && !selection.empty? ? selection : model.active_entities\r\n\r\n      # Processar os elementos\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n\r\n      # Desbloquear todos os grupos e componentes recursivamente\r\n      unlock_entities(entities)\r\n\r\n      model.commit_operation\r\n\r\n      UI.messagebox(obter_texto(:sucesso))\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::DesbloquearElementos.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "descer-objetos-954rn",
    "title": {
      "pt": "Descer Objetos",
      "en": "Lower Objects",
      "es": "Objetos inferiores"
    },
    "author": "Henrique Barsa",
    "version": "1.0",
    "description": {
      "pt": "Desce o objeto até o abaixo dele.",
      "en": "Lower the object to the one below it.",
      "es": "Baja el objeto hasta el que está debajo de él."
    },
    "keywords": {
      "pt": [
        "drop",
        "descer"
      ],
      "en": [
        "drop",
        "to descend"
      ],
      "es": [
        "gota",
        "descender"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module ProjetarNoChao\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao => \"Nenhum objeto selecionado. Selecione ao menos um grupo ou componente.\",\r\n        :erro_raytest => \"Nenhuma geometria foi encontrada abaixo de %s para a interseção.\",\r\n        :op_nome      => \"Projetar no Solo\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao => \"No objects selected. Please select at least one group or component.\",\r\n        :erro_raytest => \"No geometry was found below %s for intersection.\",\r\n        :op_nome      => \"Drop to Ground\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao => \"Ningún objeto seleccionado. Seleccione al menos un grupo o componente.\",\r\n        :erro_raytest => \"No se encontró geometría debajo de %s para la intersección.\",\r\n        :op_nome      => \"Proyectar al Suelo\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      ss = model.selection\r\n      \r\n      # Verifica se há algo selecionado\r\n      if ss.empty?\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n\r\n      dir = [0, 0, -1] # vetor para baixo (Z negativo)\r\n\r\n      ss.each do |entity|\r\n        next unless entity.respond_to?(:transformation)\r\n        \r\n        position = entity.transformation.origin\r\n        # Retorna [Geom::Point3d, entidade_intersectada]\r\n        rt = model.raytest(position, dir)\r\n\r\n        if rt.nil?\r\n          UI.messagebox(obter_texto(:erro_raytest) % entity.to_s)\r\n        else\r\n          intersect_pt = rt[0]\r\n          new_z = intersect_pt.z\r\n          \r\n          # Aplica a transformação mantendo X e Y, alterando apenas Z\r\n          tr = entity.transformation.to_a\r\n          tr[14] = new_z\r\n          entity.transformation = tr\r\n        end\r\n      end\r\n\r\n      model.commit_operation\r\n      \r\n      # Força uma atualização visual\r\n      model.active_view.invalidate\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::ProjetarNoChao.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "escala-por-eixo-mantendo-proporcao-9579v",
    "title": {
      "pt": "Escala por Eixo Mantendo Proporção",
      "en": "Scaling by Axis Maintaining Proportion",
      "es": "Escalado por eje manteniendo la proporción"
    },
    "author": "Ludimila Siqueira",
    "version": "1.0",
    "description": {
      "pt": "Altera a escala por eixo com possibilidade de manter a proporção nos demais eixos.",
      "en": "Changes the scale on each axis while maintaining the aspect ratio on the other axes.",
      "es": "Cambia la escala en cada eje mientras mantiene la relación de aspecto en los otros ejes."
    },
    "keywords": {
      "pt": [
        "escala por eixo",
        "proporção"
      ],
      "en": [
        "scale by axis",
        "proportion"
      ],
      "es": [
        "escala por eje",
        "proporción"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module EscalarPorEixo\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :titulo_janela    => \"Escalar Componente por Eixo\",\r\n        :label_eixo       => \"Eixo de referência:\",\r\n        :label_comprimento => \"Comprimento desejado:\",\r\n        :label_proporcao  => \"Manter proporção\",\r\n        :btn_aplicar      => \"Aplicar Escala\",\r\n        :erro_selecao     => \"Selecione um único componente ou grupo.\",\r\n        :erro_eixo        => \"Eixo inválido. Use X, Y ou Z.\",\r\n        :erro_dimensao    => \"A dimensão atual no eixo %s é zero.\",\r\n        :op_nome          => \"Escalar por eixo\"\r\n      },\r\n      'en-US' => {\r\n        :titulo_janela    => \"Scale Component by Axis\",\r\n        :label_eixo       => \"Reference axis:\",\r\n        :label_comprimento => \"Desired length:\",\r\n        :label_proporcao  => \"Maintain proportion\",\r\n        :btn_aplicar      => \"Apply Scale\",\r\n        :erro_selecao     => \"Select a single component or group.\",\r\n        :erro_eixo        => \"Invalid axis. Use X, Y or Z.\",\r\n        :erro_dimensao    => \"The current dimension on axis %s is zero.\",\r\n        :op_nome          => \"Scale by axis\"\r\n      },\r\n      'es' => {\r\n        :titulo_janela    => \"Escalar Componente por Eje\",\r\n        :label_eixo       => \"Eje de referencia:\",\r\n        :label_comprimento => \"Longitud deseada:\",\r\n        :label_proporcao  => \"Mantener proporción\",\r\n        :btn_aplicar      => \"Aplicar Escala\",\r\n        :erro_selecao     => \"Seleccione un solo componente o grupo.\",\r\n        :erro_eixo        => \"Eje inválido. Use X, Y o Z.\",\r\n        :erro_dimensao    => \"La dimensión actual en el eje %s es cero.\",\r\n        :op_nome          => \"Escalar por eje\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.show_ui\r\n      dlg = UI::HtmlDialog.new({\r\n        dialog_title: obter_texto(:titulo_janela),\r\n        preferences_key: \"scale_by_axis\",\r\n        scrollable: true,\r\n        resizable: false,\r\n        width: 320,\r\n        height: 260,\r\n        style: UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n\r\n      html = <<-HTML\r\n        <!DOCTYPE html>\r\n        <html>\r\n        <body style=\"font-family: sans-serif; margin: 10px;\">\r\n          <label for=\"axis\">#{obter_texto(:label_eixo)}</label><br>\r\n          <select id=\"axis\">\r\n            <option value=\"X\">X</option>\r\n            <option value=\"Y\">Y</option>\r\n            <option value=\"Z\">Z</option>\r\n          </select><br><br>\r\n\r\n          <label for=\"length\">#{obter_texto(:label_comprimento)}</label><br>\r\n          <input type=\"number\" id=\"length\" value=\"100\" />\r\n          <select id=\"unit\">\r\n            <option value=\"cm\" selected>cm</option>\r\n            <option value=\"m\">m</option>\r\n            <option value=\"mm\">mm</option>\r\n          </select><br><br>\r\n\r\n          <input type=\"checkbox\" id=\"proportional\" checked />\r\n          <label for=\"proportional\">#{obter_texto(:label_proporcao)}</label><br><br>\r\n\r\n          <button onclick=\"applyScale()\">#{obter_texto(:btn_aplicar)}</button>\r\n\r\n          <script>\r\n            function applyScale() {\r\n              const axis = document.getElementById('axis').value;\r\n              const length = parseFloat(document.getElementById('length').value);\r\n              const unit = document.getElementById('unit').value;\r\n              const proportional = document.getElementById('proportional').checked;\r\n              window.sketchup.apply_scale(axis, length, proportional, unit);\r\n            }\r\n          </script>\r\n        </body>\r\n        </html>\r\n      HTML\r\n\r\n      dlg.set_html(html)\r\n\r\n      dlg.add_action_callback(\"apply_scale\") do |_, axis, length, proportional, unit|\r\n        apply_scale(axis, length.to_f, proportional == true || proportional == \"true\", unit)\r\n      end\r\n\r\n      dlg.show\r\n    end\r\n\r\n    def self.apply_scale(axis, target_length, keep_proportion, unit)\r\n      model = Sketchup.active_model\r\n      sel = model.selection\r\n\r\n      unless sel.length == 1 && (sel.first.is_a?(Sketchup::ComponentInstance) || sel.first.is_a?(Sketchup::Group))\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n\r\n      instance = sel.first\r\n      bbox = instance.bounds\r\n\r\n      current_size = case axis\r\n      when 'X' then bbox.width\r\n      when 'Y' then bbox.height\r\n      when 'Z' then bbox.depth\r\n      else\r\n        UI.messagebox(obter_texto(:erro_eixo))\r\n        return\r\n      end\r\n\r\n      if current_size <= 0\r\n        UI.messagebox(obter_texto(:erro_dimensao) % axis)\r\n        return\r\n      end\r\n\r\n      length_inches = case unit\r\n      when 'cm' then target_length.cm\r\n      when 'm'  then target_length.m\r\n      when 'mm' then target_length.mm\r\n      else target_length.cm\r\n      end\r\n\r\n      scale_factor = length_inches / current_size\r\n\r\n      x_scale = (keep_proportion || axis == 'X') ? scale_factor : 1.0\r\n      y_scale = (keep_proportion || axis == 'Y') ? scale_factor : 1.0\r\n      z_scale = (keep_proportion || axis == 'Z') ? scale_factor : 1.0\r\n\r\n      t = Geom::Transformation.scaling(instance.transformation.origin, x_scale, y_scale, z_scale)\r\n\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n      instance.transform!(t)\r\n      model.commit_operation\r\n    end\r\n  end\r\nend\r\n\r\nScriptUpComunidade::EscalarPorEixo.show_ui"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "mapeamento-uv-em-malha-curva-9593a",
    "title": {
      "pt": "Mapeamento UV em Malha Curva",
      "en": "UV Mapping on Curved Mesh",
      "es": "Mapeo UV en malla curva"
    },
    "author": "Fábio Coutinho",
    "version": "1.6",
    "description": {
      "pt": "Promove o mapeamento UV de texturas aplicadas em superfície curva.",
      "en": "It promotes UV mapping of textures applied to curved surfaces.",
      "es": "Promueve el mapeo UV de texturas aplicadas a superficies curvas."
    },
    "keywords": {
      "pt": [
        "uv map"
      ],
      "en": [
        "uv map"
      ],
      "es": [
        "mapa uv"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module MapeadorUV\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :ativar_msg      => \"🖱️ Clique em uma face com textura aplicada (ou com material aplicado em grupo acima).\",\r\n        :status_inicio   => \"Mova o mouse sobre a malha para escolher a face e o ponto inicial.\",\r\n        :erro_face       => \"❌ Clique em uma face válida com textura aplicada ou grupo com material.\",\r\n        :status_erro     => \"❌ Nenhuma face válida foi selecionada. Clique em uma face com textura.\",\r\n        :ponto1_capt     => \"📌 Ponto 1 capturado: %s\",\r\n        :msg_ponto2      => \"🖱️ Mova o mouse e clique no segundo ponto para ajustar a direção do mapeamento.\",\r\n        :status_ponto2   => \"Agora clique em um segundo ponto na face para definir o sentido do mapeamento.\",\r\n        :op_nome         => \"Mapeamento UV Dinâmico\",\r\n        :ponto2_capt     => \"📌 Ponto 2 capturado: %s\",\r\n        :finalizado      => \"✅ Mapeamento finalizado. Clique em nova face ou mude de ferramenta para sair.\",\r\n        :status_final    => \"Mapeamento aplicado! Clique em nova face ou mude de ferramenta.\",\r\n        :erro_dinamico   => \"⚠️ Erro durante mapeamento dinâmico: %s\",\r\n        :erro_material   => \"❌ Nenhum material com textura encontrado na hierarquia. Aplique um material primeiro.\",\r\n        :aviso_triang    => \"🔺 Face com mais de 4 vértices — mapeando via triangulação inicial\",\r\n        :aviso_limitacao => \"⚠️ Face com mais de 4 vértices – aplicando apenas nos 4 primeiros vértices para evitar erro.\",\r\n        :erro_sketchup   => \"⚠️ Face ignorada (SketchUp): %s\",\r\n        :insuficiente    => \"⛔ Mapeamento insuficiente em face adjacente, ignorada.\"\r\n      },\r\n      'en-US' => {\r\n        :ativar_msg      => \"🖱️ Click on a face with texture applied (or material applied to a group above).\",\r\n        :status_inicio   => \"Move mouse over the mesh to choose face and start point.\",\r\n        :erro_face       => \"❌ Click on a valid face with texture or group with material.\",\r\n        :status_erro     => \"❌ No valid face selected. Click on a face with texture.\",\r\n        :ponto1_capt     => \"📌 Point 1 captured: %s\",\r\n        :msg_ponto2      => \"🖱️ Move mouse and click on second point to adjust mapping direction.\",\r\n        :status_ponto2   => \"Now click a second point on the face to define mapping direction.\",\r\n        :op_nome         => \"Dynamic UV Mapping\",\r\n        :ponto2_capt     => \"📌 Point 2 captured: %s\",\r\n        :finalizado      => \"✅ Mapping finished. Click a new face or change tool to exit.\",\r\n        :status_final    => \"Mapping applied! Click a new face or change tool.\",\r\n        :erro_dinamico   => \"⚠️ Error during dynamic mapping: %s\",\r\n        :erro_material   => \"❌ No textured material found in hierarchy. Apply a material first.\",\r\n        :aviso_triang    => \"🔺 Face with more than 4 vertices — mapping via initial triangulation\",\r\n        :aviso_limitacao => \"⚠️ Face with more than 4 vertices – applying only to first 4 vertices to avoid error.\",\r\n        :erro_sketchup   => \"⚠️ Face ignored (SketchUp): %s\",\r\n        :insuficiente    => \"⛔ Insufficient mapping on adjacent face, ignored.\"\r\n      },\r\n      'es' => {\r\n        :ativar_msg      => \"🖱️ Haga clic en una cara con textura aplicada (o material aplicado en grupo superior).\",\r\n        :status_inicio   => \"Mueva el ratón sobre la malla para elegir la cara y el punto inicial.\",\r\n        :erro_face       => \"❌ Haga clic en una cara válida con textura o grupo con material.\",\r\n        :status_erro     => \"❌ No se seleccionó ninguna cara válida. Haga clic en una cara con textura.\",\r\n        :ponto1_capt     => \"📌 Punto 1 capturado: %s\",\r\n        :msg_ponto2      => \"🖱️ Mueva el ratón y haga clic en el segundo punto para ajustar la dirección.\",\r\n        :status_ponto2   => \"Ahora haga clic en un segundo punto en la cara para definir el sentido del mapeo.\",\r\n        :op_nome         => \"Mapeo UV Dinámico\",\r\n        :ponto2_capt     => \"📌 Punto 2 capturado: %s\",\r\n        :finalizado      => \"✅ Mapeo finalizado. Haga clic en una nueva cara o cambie de herramienta para salir.\",\r\n        :status_final    => \"¡Mapeo aplicado! Haga clic en una nueva cara o cambie de herramienta.\",\r\n        :erro_dinamico   => \"⚠️ Error durante el mapeo dinámico: %s\",\r\n        :erro_material   => \"❌ No se encontró material con textura en la jerarquía. Aplique un material primero.\",\r\n        :aviso_triang    => \"🔺 Cara con más de 4 vértices — mapeando vía triangulación inicial\",\r\n        :aviso_limitacao => \"⚠️ Cara con más de 4 vértices – aplicando solo a los primeros 4 para evitar errores.\",\r\n        :erro_sketchup   => \"⚠️ Cara ignorada (SketchUp): %s\",\r\n        :insuficiente    => \"⛔ Mapeo insuficiente en cara adyacente, ignorada.\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    TOLERANCE = 0.001 unless defined?(TOLERANCE)\r\n\r\n    class DynamicDirectionTool\r\n      def initialize\r\n        reset\r\n      end\r\n\r\n      def reset\r\n        @state = 0\r\n        @picked_face = nil\r\n        @input1 = Sketchup::InputPoint.new\r\n        @input2 = Sketchup::InputPoint.new\r\n        @ip_temp = Sketchup::InputPoint.new\r\n        @last_vector = nil\r\n      end\r\n\r\n      def activate\r\n        puts MapeadorUV.obter_texto(:ativar_msg)\r\n        Sketchup.set_status_text(MapeadorUV.obter_texto(:status_inicio), SB_PROMPT)\r\n      end\r\n\r\n      def onMouseMove(flags, x, y, view)\r\n        if @state == 0\r\n          @ip_temp.pick(view, x, y)\r\n          view.invalidate\r\n        elsif @state == 1\r\n          @input2.pick(view, x, y, @input1)\r\n          view.invalidate\r\n\r\n          return unless @input2.valid?\r\n\r\n          new_vec = @input2.position - @input1.position\r\n          return if new_vec.length < 1e-4\r\n\r\n          unless @last_vector && MapeadorUV.safe_samedirection?(@last_vector, new_vec)\r\n            @last_vector = new_vec\r\n            begin\r\n              success = MapeadorUV.reapply_mapping_on_face(@picked_face, @input1.position, @input2.position, @input1)\r\n              MapeadorUV.propagate_uv_using_uvhelper(@picked_face) if success\r\n            rescue => e\r\n              puts MapeadorUV.obter_texto(:erro_dinamico) % e.message\r\n            end\r\n          end\r\n        end\r\n      end\r\n\r\n      def onLButtonDown(flags, x, y, view)\r\n        model = Sketchup.active_model\r\n\r\n        if @state == 0\r\n          @input1.pick(view, x, y)\r\n          if !@input1.face\r\n            puts MapeadorUV.obter_texto(:erro_face)\r\n            Sketchup.set_status_text(MapeadorUV.obter_texto(:status_erro), SB_PROMPT)\r\n            return\r\n          end\r\n          @picked_face = @input1.face\r\n          puts MapeadorUV.obter_texto(:ponto1_capt) % @input1.position.to_s\r\n          puts MapeadorUV.obter_texto(:msg_ponto2)\r\n          Sketchup.set_status_text(MapeadorUV.obter_texto(:status_ponto2), SB_PROMPT)\r\n          model.start_operation(MapeadorUV.obter_texto(:op_nome), true)\r\n          @state = 1\r\n        elsif @state == 1\r\n          @input2.pick(view, x, y, @input1)\r\n          puts MapeadorUV.obter_texto(:ponto2_capt) % @input2.position.to_s\r\n          model.commit_operation\r\n          reset\r\n          puts MapeadorUV.obter_texto(:finalizado)\r\n          Sketchup.set_status_text(MapeadorUV.obter_texto(:status_final), SB_PROMPT)\r\n        end\r\n      end\r\n\r\n      def draw(view)\r\n        if @state == 0 && @ip_temp.valid? && @ip_temp.face\r\n          path = @ip_temp.instance_path\r\n          trans = path ? path.transformation : IDENTITY\r\n          view.drawing_color = 'red'\r\n          points = @ip_temp.face.outer_loop.vertices.map { |v| v.position.transform(trans) }\r\n          view.draw(GL_LINE_LOOP, points)\r\n        end\r\n\r\n        if @input1.valid?\r\n          view.drawing_color = 'green'\r\n          view.draw_points([@input1.position], 10, 3)\r\n        end\r\n\r\n        if @input2.valid?\r\n          view.drawing_color = 'green'\r\n          view.draw_points([@input2.position], 10, 3)\r\n          view.drawing_color = 'red'\r\n          view.draw_line(@input1.position, @input2.position)\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      Sketchup.active_model.tools.push_tool(DynamicDirectionTool.new)\r\n      true\r\n    end\r\n\r\n    def self.safe_samedirection?(vec1, vec2)\r\n      return false unless vec1.is_a?(Geom::Vector3d) && vec2.is_a?(Geom::Vector3d)\r\n      return false if vec1.length < 1e-4 || vec2.length < 1e-4\r\n      vec1.samedirection?(vec2)\r\n    rescue\r\n      false\r\n    end\r\n\r\n    def self.find_material_in_path(input_point)\r\n      return nil unless input_point\r\n      path = input_point.instance_path\r\n      return nil unless path\r\n      path.reverse_each do |entity|\r\n        next unless entity.respond_to?(:material)\r\n        mat = entity.material\r\n        return mat if mat && mat.texture\r\n      end\r\n      nil\r\n    end\r\n\r\n    def self.reapply_mapping_on_face(face, pt1, pt2, input_point)\r\n      material = face.material\r\n      material ||= find_material_in_path(input_point)\r\n\r\n      unless material && material.texture\r\n        puts obter_texto(:erro_material)\r\n        return false\r\n      end\r\n\r\n      return false if pt1.distance(pt2) < 1e-4\r\n\r\n      tex = material.texture\r\n      tex_w = tex.width.to_f\r\n      tex_h = tex.height.to_f\r\n\r\n      u_axis = (pt2 - pt1).normalize\r\n      z_axis = face.normal\r\n      v_axis = z_axis.cross(u_axis)\r\n      return false if v_axis.length < 1e-6\r\n      v_axis.normalize!\r\n      origin = pt1\r\n\r\n      if face.vertices.size > 4\r\n        puts obter_texto(:aviso_triang)\r\n        mesh = face.mesh(7)\r\n        points = mesh.points\r\n        uv_by_point = {}\r\n\r\n        points.each do |pos|\r\n          vec = pos - origin\r\n          u = vec.dot(u_axis) / tex_w\r\n          v = vec.dot(v_axis) / tex_h\r\n          uv_by_point[pos] = Geom::Point3d.new(u, v, 0)\r\n        end\r\n\r\n        triangles = mesh.polygons.map do |indices|\r\n          indices = indices.map { |i| i.abs - 1 }\r\n          [points[indices[0]], points[indices[1]], points[indices[2]]]\r\n        end\r\n\r\n        ents = face.parent.entities\r\n        ents.erase_entities(face)\r\n\r\n        triangles.each do |tri_pts|\r\n          new_face = ents.add_face(tri_pts)\r\n          next unless new_face && new_face.valid?\r\n          new_face.material = material\r\n\r\n          mapping = tri_pts.map { |pt| [pt, uv_by_point[pt]] }.flatten\r\n          begin\r\n            new_face.position_material(material, mapping, true)\r\n          rescue => e\r\n            puts \"⚠️ Erro: #{e.message}\"\r\n          end\r\n\r\n          new_face.edges.each do |edge|\r\n            edge.soft = true\r\n            edge.smooth = true\r\n            edge.hidden = false\r\n          end\r\n        end\r\n        return true\r\n      end\r\n\r\n      mapping = []\r\n      face.vertices.each do |v|\r\n        pos = v.position\r\n        vec = pos - origin\r\n        u = vec.dot(u_axis) / tex_w\r\n        v = vec.dot(v_axis) / tex_h\r\n        mapping << pos\r\n        mapping << Geom::Point3d.new(u, v, 0)\r\n      end\r\n\r\n      mapping = mapping[0, 8] if mapping.size > 8\r\n      face.material = material\r\n      face.position_material(material, mapping, true)\r\n      true\r\n    rescue => e\r\n      puts \"⚠️ Erro: #{e.message}\"\r\n      false\r\n    end\r\n\r\n    def self.propagate_uv_using_uvhelper(start_face)\r\n      material = start_face.material || find_material_in_path(Sketchup::InputPoint.new.tap { |ip| ip.pick(start_face.vertices.first.position) })\r\n      return unless material && material.texture\r\n\r\n      visited = {}\r\n      queue = [start_face]\r\n      visited[start_face] = true\r\n\r\n      while !queue.empty?\r\n        current_face = queue.shift\r\n        current_face.material = material\r\n\r\n        tw = Sketchup.create_texture_writer\r\n        tw.load(current_face, true)\r\n        uv_helper = current_face.get_UVHelper(true, true, tw)\r\n\r\n        current_face.edges.each do |edge|\r\n          next unless edge.soft?\r\n          edge.faces.each do |adj_face|\r\n            next if adj_face == current_face || visited[adj_face]\r\n            visited[adj_face] = true\r\n            shared_vertices = adj_face.vertices.select { |v1|\r\n              current_face.vertices.any? { |v2| v1.position.distance(v2.position) < TOLERANCE }\r\n            }\r\n            next if shared_vertices.size < 2\r\n\r\n            if adj_face.vertices.size <= 4\r\n              mapping_array = adj_face.vertices.map do |v|\r\n                pos = v.position\r\n                uvq = uv_helper.get_front_UVQ(pos)\r\n                (uvq && uvq.z != 0) ? [pos, Geom::Point3d.new(uvq.x / uvq.z, uvq.y / uvq.z, 0)] : nil\r\n              end.compact.flatten\r\n\r\n              if mapping_array.size > 8\r\n                puts obter_texto(:aviso_limitacao)\r\n                mapping_array = mapping_array[0, 8]\r\n              end\r\n\r\n              if mapping_array.size >= 6\r\n                begin\r\n                  adj_face.material = material\r\n                  adj_face.position_material(material, mapping_array, true)\r\n                  queue << adj_face\r\n                rescue ArgumentError => e\r\n                  puts obter_texto(:erro_sketchup) % e.message\r\n                end\r\n              else\r\n                puts obter_texto(:insuficiente)\r\n              end\r\n            else\r\n              triangulate_and_map_face(adj_face, uv_helper, material)\r\n            end\r\n          end\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.triangulate_and_map_face(face, uv_helper, material)\r\n      mesh = face.mesh(7)\r\n      ents = face.parent.entities\r\n      points = mesh.points\r\n      uv_by_point = {}\r\n      points.each do |pt|\r\n        uvq = uv_helper.get_front_UVQ(pt)\r\n        uv = (uvq && uvq.z != 0) ? Geom::Point3d.new(uvq.x / uvq.z, uvq.y / uvq.z, 0) : Geom::Point3d.new(0, 0, 0)\r\n        uv_by_point[pt] = uv\r\n      end\r\n      model_edges_before = ents.grep(Sketchup::Edge).to_set\r\n      ents.erase_entities(face)\r\n      mesh.polygons.each do |indices|\r\n        tri_pts = indices.map { |i| points[i.abs - 1] }\r\n        new_face = ents.add_face(tri_pts)\r\n        next unless new_face && new_face.valid?\r\n        new_face.material = material\r\n        mapping = tri_pts.map { |pt| [pt, uv_by_point[pt]] }.flatten\r\n        begin\r\n          new_face.position_material(material, mapping, true)\r\n        rescue => e\r\n          puts \"⚠️ Erro: #{e.message}\"\r\n        end\r\n        new_face.edges.each do |edge|\r\n          unless model_edges_before.include?(edge)\r\n            edge.soft = true\r\n            edge.smooth = true\r\n            edge.hidden = false\r\n          end\r\n        end\r\n      end\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::MapeadorUV.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "nivelador-de-grupos-e-componentes-95bb3",
    "title": {
      "pt": "Nivelador de Grupos e Componentes",
      "en": "Group and Component Leveler",
      "es": "Nivelador de grupos y componentes"
    },
    "author": "Irene Magalhães",
    "version": "1.0",
    "description": {
      "pt": "Define o nível (altura Z) de grupos e componentes respeitando a unidade do modelo. Inspirado no drop of level.",
      "en": "Defines the level (Z-height) of groups and components while respecting the model's unity. Inspired by the drop-of-level principle.",
      "es": "Define el nivel (altura Z) de grupos y componentes, respetando la unidad del modelo. Inspirado en el principio de caída de nivel."
    },
    "keywords": {
      "pt": [
        "altura",
        "nível"
      ],
      "en": [
        "height",
        "level"
      ],
      "es": [
        "altura",
        "nivel"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module DefinirNivel\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :label_altura  => \"Altura (na unidade do modelo):\",\r\n        :titulo_input  => \"Definir Nível do Objeto\",\r\n        :erro_selecao  => \"Por favor, selecione pelo menos um elemento.\",\r\n        :op_nome       => \"Ajustar Nível\",\r\n        :log_info      => \"Comando 'Nível' executado por Irene Magalhães │ arq – v1.00\"\r\n      },\r\n      'en-US' => {\r\n        :label_altura  => \"Height (model unit):\",\r\n        :titulo_input  => \"Set Object Level\",\r\n        :erro_selecao  => \"Please select at least one element.\",\r\n        :op_nome       => \"Adjust Level\",\r\n        :log_info      => \"Command 'Level' executed by Irene Magalhães │ arq – v1.00\"\r\n      },\r\n      'es' => {\r\n        :label_altura  => \"Altura (unidad del modelo):\",\r\n        :titulo_input  => \"Definir Nivel del Objeto\",\r\n        :erro_selecao  => \"Por favor, seleccione al menos un elemento.\",\r\n        :op_nome       => \"Ajustar Nivel\",\r\n        :log_info      => \"Comando 'Nivel' ejecutado por Irene Magalhães │ arq – v1.00\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.get_height_from_user\r\n      prompts = [obter_texto(:label_altura)]\r\n      defaults = [\"0\"]\r\n      input = UI.inputbox(prompts, defaults, obter_texto(:titulo_input))\r\n      return nil unless input\r\n      input[0].to_l\r\n    end\r\n\r\n    def self.validate_selection\r\n      selection = Sketchup.active_model.selection\r\n      if selection.empty?\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return false\r\n      end\r\n      true\r\n    end\r\n\r\n    def self.perform_drop(entity, height)\r\n      case entity\r\n      when Sketchup::Group, Sketchup::ComponentInstance\r\n        current_z = entity.transformation.origin.z\r\n        delta_z = height - current_z\r\n        entity.transform!(Geom::Transformation.translation([0, 0, delta_z]))\r\n      when Sketchup::Edge\r\n        entity.vertices.each do |vertex|\r\n          pos = vertex.position\r\n          vertex.position = Geom::Point3d.new(pos.x, pos.y, height)\r\n        end\r\n      when Sketchup::Face\r\n        # Usando o centro do bounding box para faces para determinar o deslocamento Z\r\n        current_z = entity.bounds.center.z\r\n        delta_z = height - current_z\r\n        entity.transform!(Geom::Transformation.translation([0, 0, delta_z]))\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      return unless validate_selection\r\n\r\n      height = get_height_from_user\r\n      return unless height\r\n\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n      \r\n      selection = model.selection\r\n      selection.each { |entity| perform_drop(entity, height) }\r\n\r\n      model.commit_operation\r\n      model.active_view.invalidate\r\n\r\n      puts obter_texto(:log_info)\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::DefinirNivel.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "ocultar-linhas-do-bloco-95crg",
    "title": {
      "pt": "Ocultar Linhas do Bloco",
      "en": "Hide Block Lines",
      "es": "Ocultar líneas de bloque"
    },
    "author": "Matheus Narita",
    "version": "1.0",
    "description": {
      "pt": "Oculta todas as arestas dentro dos grupos e componentes selecionados, incluindo os aninhados.",
      "en": "Hides all edges within the selected groups and components, including nested ones.",
      "es": "Oculta todos los bordes dentro de los grupos y componentes seleccionados, incluidos los anidados."
    },
    "keywords": {
      "pt": [
        "ocultar linhas"
      ],
      "en": [
        "hide lines"
      ],
      "es": [
        "ocultar líneas"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module OcultarLinhasBlocos\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :op_nome => \"Ocultar Linhas do Bloco\",\r\n        :sucesso => \"Linhas ocultadas dentro dos blocos selecionados!\"\r\n      },\r\n      'en-US' => {\r\n        :op_nome => \"Hide Block Edges\",\r\n        :sucesso => \"Edges hidden inside selected blocks!\"\r\n      },\r\n      'es' => {\r\n        :op_nome => \"Ocultar Líneas del Bloque\",\r\n        :sucesso => \"¡Líneas ocultadas dentro de los bloques seleccionados!\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.ocultar_linhas(entities)\r\n      entities.grep(Sketchup::Edge).each do |edge|\r\n        edge.hidden = true\r\n      end\r\n\r\n      # Percorrer grupos e componentes aninhados também\r\n      entities.grep(Sketchup::Group).each { |group| ocultar_linhas(group.entities) }\r\n      entities.grep(Sketchup::ComponentInstance).each { |comp| ocultar_linhas(comp.definition.entities) }\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n\r\n      selection.each do |entity|\r\n        if entity.is_a?(Sketchup::Group)\r\n          ocultar_linhas(entity.entities)\r\n        elsif entity.is_a?(Sketchup::ComponentInstance)\r\n          ocultar_linhas(entity.definition.entities)\r\n        end\r\n      end\r\n\r\n      model.commit_operation\r\n\r\n      puts obter_texto(:sucesso)\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::OcultarLinhasBlocos.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "orbitar-360-95ffh",
    "title": {
      "pt": "Orbitar 360º",
      "en": "Orbit 360º",
      "es": "Órbita 360º"
    },
    "author": "Fábio Couitnho",
    "version": "1.0",
    "description": {
      "pt": "Orbita, de forma contínua, 360º ao redor de um elemento selecionado, podendo controlar a velorcidade, ângulo de observação e distância do objetivo.",
      "en": "It orbits continuously 360º around a selected element, allowing control over speed, viewing angle, and distance from the target.",
      "es": "Orbita continuamente 360º alrededor de un elemento seleccionado, lo que permite controlar la velocidad, el ángulo de visión y la distancia al objetivo."
    },
    "keywords": {
      "pt": [
        "orbitar 360"
      ],
      "en": [
        "orbit 360"
      ],
      "es": [
        "órbita 360"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module VisualizacaoOrbital\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao   => \"❌ Selecione algum elemento antes de executar.\",\r\n        :erro_volume    => \"❌ Nenhum elemento com volume visível foi encontrado na seleção.\",\r\n        :titulo_janela  => \"Visualização Orbital Contínua\",\r\n        :label_rpm      => \"Velocidade (voltas por minuto):\",\r\n        :label_pitch    => \"Inclinação (ângulo vertical):\",\r\n        :label_dist     => \"Distância do observador:\",\r\n        :btn_encerrar   => \"🛑 Encerrar Visualização\",\r\n        :msg_encerrado  => \"⏹️ Visualização orbital encerrada.\",\r\n        :op_nome        => \"Órbita de Câmera\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao   => \"❌ Select an element before running.\",\r\n        :erro_volume    => \"❌ No visible elements with volume found in selection.\",\r\n        :titulo_janela  => \"Continuous Orbit View\",\r\n        :label_rpm      => \"Speed (rotations per minute):\",\r\n        :label_pitch    => \"Pitch (vertical angle):\",\r\n        :label_dist     => \"Observer distance:\",\r\n        :btn_encerrar   => \"🛑 Stop Visualization\",\r\n        :msg_encerrado  => \"⏹️ Orbital visualization stopped.\",\r\n        :op_nome        => \"Camera Orbit\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao   => \"❌ Seleccione algún elemento antes de ejecutar.\",\r\n        :erro_volume    => \"❌ No se encontraron elementos con volumen visible en la selección.\",\r\n        :titulo_janela  => \"Visualización Orbital Continua\",\r\n        :label_rpm      => \"Velocidad (vueltas por minuto):\",\r\n        :label_pitch    => \"Inclinación (ángulo vertical):\",\r\n        :label_dist     => \"Distancia del observador:\",\r\n        :btn_encerrar   => \"🛑 Finalizar Visualización\",\r\n        :msg_encerrado  => \"⏹️ Visualización orbital finalizada.\",\r\n        :op_nome        => \"Órbita de Cámara\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.rpm_to_rad_per_frame(rpm)\r\n      (rpm * 2 * Math::PI) / 60.0 / 60.0\r\n    end\r\n\r\n    def self.deg_to_rad(deg)\r\n      deg * Math::PI / 180.0\r\n    end\r\n\r\n    def self.update_camera_orbit\r\n      view = Sketchup.active_model.active_view\r\n      camera = view.camera\r\n\r\n      $orbita_angle += rpm_to_rad_per_frame($orbita_rpm)\r\n      radius = $orbita_base_radius * $orbita_radius_multiplier\r\n      pitch_rad = deg_to_rad($orbita_pitch_deg)\r\n\r\n      x = radius * Math.cos($orbita_angle)\r\n      y = radius * Math.sin($orbita_angle)\r\n      horizontal_distance = Math.sqrt(x**2 + y**2)\r\n      dz = Math.tan(pitch_rad) * horizontal_distance\r\n      z = $orbita_center.z + dz\r\n\r\n      eye = Geom::Point3d.new($orbita_center.x + x, $orbita_center.y + y, z)\r\n      target = $orbita_center\r\n\r\n      direction = target - eye\r\n      z_axis = Geom::Vector3d.new(0, 0, 1)\r\n      right = direction.cross(z_axis).normalize\r\n      up = right.cross(direction).normalize\r\n\r\n      camera.set(eye, target, up)\r\n      view.camera = camera\r\n      view.refresh\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      if selection.empty?\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n\r\n      bounds = Geom::BoundingBox.new\r\n      tem_bounds = false\r\n\r\n      selection.each do |e|\r\n        if e.respond_to?(:bounds)\r\n          bounds.add(e.bounds)\r\n          tem_bounds = true\r\n        end\r\n      end\r\n\r\n      if !tem_bounds\r\n        UI.messagebox(obter_texto(:erro_volume))\r\n        return\r\n      end\r\n\r\n      $orbita_center = bounds.center\r\n      model.selection.clear\r\n      $orbita_base_radius = bounds.diagonal * 1.5\r\n\r\n      $orbita_angle = 0.0\r\n      $orbita_rpm = 2.0\r\n      $orbita_pitch_deg = 15.0\r\n      $orbita_radius_multiplier = 1.0\r\n\r\n      $orbita_timer = UI.start_timer(0.016, true) { update_camera_orbit }\r\n\r\n      html = <<-HTML\r\n      <html>\r\n        <body style=\"font-family:system-ui; margin:16px; background:#f9f9f9;\">\r\n          <h2>🎥 #{obter_texto(:titulo_janela)}</h2>\r\n\r\n          <label for=\"rpm\"><b>#{obter_texto(:label_rpm)}</b></label><br>\r\n          <input type=\"range\" id=\"rpm\" min=\"0.1\" max=\"20\" step=\"0.1\" value=\"#{$orbita_rpm}\" style=\"width:100%;\">\r\n          <div><span id=\"rpm_val\">#{$orbita_rpm.round(1)}</span> RPM</div>\r\n\r\n          <label for=\"pitch\"><b>#{obter_texto(:label_pitch)}</b></label><br>\r\n          <input type=\"range\" id=\"pitch\" min=\"-60\" max=\"60\" step=\"1\" value=\"#{$orbita_pitch_deg}\" style=\"width:100%;\">\r\n          <div><span id=\"pitch_val\">#{$orbita_pitch_deg.round(1)}</span>°</div>\r\n\r\n          <label for=\"dist\"><b>#{obter_texto(:label_dist)}</b></label><br>\r\n          <input type=\"range\" id=\"dist\" min=\"0.5\" max=\"5\" step=\"0.1\" value=\"#{$orbita_radius_multiplier}\" style=\"width:100%;\">\r\n          <div><span id=\"dist_val\">#{$orbita_radius_multiplier.round(1)}</span>x</div>\r\n\r\n          <hr style=\"margin:16px 0;\">\r\n          <button onclick=\"window.location='skp:stop_orbit@'\" style=\"padding:8px 16px; font-weight:bold; background:#d33; color:#fff; border:none; border-radius:4px; cursor:pointer;\">\r\n            #{obter_texto(:btn_encerrar)}\r\n          </button>\r\n\r\n          <script>\r\n            function bindSlider(id, callback) {\r\n              const slider = document.getElementById(id);\r\n              const valSpan = document.getElementById(id + \"_val\");\r\n              slider.addEventListener(\"input\", () => {\r\n                valSpan.innerText = slider.value;\r\n                window.location = 'skp:' + callback + '@' + slider.value;\r\n              });\r\n            }\r\n\r\n            bindSlider(\"rpm\", \"update_rpm\");\r\n            bindSlider(\"pitch\", \"update_pitch\");\r\n            bindSlider(\"dist\", \"update_distance\");\r\n          </script>\r\n        </body>\r\n      </html>\r\n      HTML\r\n\r\n      dlg = UI::HtmlDialog.new({\r\n        dialog_title: obter_texto(:titulo_janela),\r\n        preferences_key: \"orbita_dinamica_gui\",\r\n        resizable: false,\r\n        width: 360,\r\n        height: 420,\r\n        style: UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n\r\n      dlg.set_html(html)\r\n\r\n      dlg.set_on_closed {\r\n        UI.stop_timer($orbita_timer) if $orbita_timer\r\n        $orbita_timer = nil\r\n        puts obter_texto(:msg_encerrado)\r\n      }\r\n\r\n      dlg.add_action_callback(\"update_rpm\") { |_, val| $orbita_rpm = val.to_f }\r\n      dlg.add_action_callback(\"update_pitch\") { |_, val| $orbita_pitch_deg = val.to_f }\r\n      dlg.add_action_callback(\"update_distance\") { |_, val| $orbita_radius_multiplier = val.to_f }\r\n\r\n      dlg.add_action_callback(\"stop_orbit\") do |_|\r\n        UI.stop_timer($orbita_timer) if $orbita_timer\r\n        $orbita_timer = nil\r\n        dlg.close\r\n      end\r\n\r\n      dlg.show\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::VisualizacaoOrbital.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "gerenciador-de-pavimentos-95gx5",
    "title": {
      "pt": "Gerenciador de Pavimentos",
      "en": "Floor Manager",
      "es": "Gerente de piso"
    },
    "author": "Kalylla | Arquiteta",
    "version": "1.0",
    "description": {
      "pt": "Permite criar seções de planta-baixa, forro e cortes automaticamente de acordo com configurações de quantidade de pavimentos e alturas personalizadas pelo usuário.",
      "en": "Allows you to automatically create floor plan, ceiling, and section plans according to user-customized settings for the number of floors and heights.",
      "es": "Le permite crear automáticamente planos de planta, techo y secciones según la configuración personalizada del usuario para la cantidad de pisos y alturas."
    },
    "keywords": {
      "pt": [
        "pavimentos"
      ],
      "en": [
        "floors"
      ],
      "es": [
        "pisos"
      ]
    },
    "code": {
      "pt": "# -------------------------------------------------------------\r\n# # Script: Gerenciador de Pavimentos\r\n# Autor: Kalylla | Arquiteta\r\n# Inspiracao: 5D Auto\r\n# Versao: v1.00\r\n# Idiomas: PT/BR | EN | ES\r\n# Descricao: Permite criar secoes de planta-baixa, forro e cortes\r\n# automaticamente de acordo com configuracoes de quantidade de\r\n# pavimentos e alturas personalizadas pelo usuario.\r\n# -------------------------------------------------------------\r\n\r\nmodule ScriptUpComunidade\r\n  module GerenciadorPavimentos\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :titulo                      => \"Gerenciador de Niveis\",\r\n        :selecionar_pavimento        => \"-- Selecione um pavimento --\",\r\n        :editar_pavimento            => \"Editar Pavimento:\",\r\n        :selecionar_unidade          => \"Unidade de Medida:\",\r\n        :nome_pavimento              => \"Nome do Pavimento:\",\r\n        :placeholder_nome            => \"Digite o nome do pavimento\",\r\n        :nivel_pavimento             => \"Nivel do Pavimento:\",\r\n        :altura_pavimento            => \"Altura do Pavimento:\",\r\n        :planta_baixa_altura         => \"Planta Baixa (altura):\",\r\n        :botao_salvar                => \"Salvar edicoes\",\r\n        :botao_criar                 => \"Criar Pavimento\",\r\n        :titulo_niveis               => \"Niveis no Projeto:\",\r\n        :carregar_dados              => \"Carregar dados\",\r\n        :botao_excluir               => \"Excluir\",\r\n        :botao_salvar_dados          => \"Salvar\",\r\n        :secoes_forro                => \"Secoes Forro\",\r\n        :secoes_planta               => \"Secoes Planta\",\r\n        :secoes_corte                => \"Secoes Corte\",\r\n        :corte_extra_x               => \"Corte Extra X\",\r\n        :corte_extra_y               => \"Corte Extra Y\",\r\n        :idioma                      => \"Idioma\",\r\n        :tema_claro                  => \"Tema Claro\",\r\n        :tema_escuro                 => \"Tema Escuro\",\r\n        :sem_geometria               => \"Nenhuma geometria encontrada para posicionar os cortes!\",\r\n        :confirmar_exclusao_titulo   => \"Deseja excluir os pavimentos selecionados?\",\r\n        :confirmar_exclusao_mensagem => \"Esta acao e irreversivel e ira apagar toda a configuracao dos pavimentos selecionados.\",\r\n        :botao_cancelar              => \"Cancelar\",\r\n        :botao_confirmar             => \"Confirmar\",\r\n        :titulo_alerta               => \"Atencao\",\r\n        :numero_invalido             => \"Por favor, insira valores numericos validos\",\r\n        :nenhum_selecionado          => \"Selecione pelo menos um pavimento\",\r\n        :dados_salvos                => \"Dados salvos com sucesso em:\",\r\n        :erro                        => \"Erro\",\r\n        :secao_frente                => \"Frente\",\r\n        :secao_tras                  => \"Tras\",\r\n        :secao_direita               => \"Direita\",\r\n        :secao_esquerda              => \"Esquerda\",\r\n        :secao                       => \"Secao\",\r\n        :nome_duplicado              => \"Ja existe um pavimento com este nome, escolha um nome exclusivo para o novo pavimento\",\r\n        :nivel_duplicado             => \"A cota do pavimento ja existe, verifique na tabela para nao criar pavimentos duplicados\",\r\n        :criar_secoes_primeiro       => \"Crie as secoes verticais primeiro ou verifique se ha geometria visivel!\",\r\n        :arquivo_invalido            => \"Arquivo invalido\",\r\n        :cabecalho_nome              => \"Pavimento\",\r\n        :cabecalho_nivel             => \"Nivel\",\r\n        :cabecalho_altura            => \"Altura\",\r\n        :cabecalho_planta            => \"Planta Baixa\",\r\n        :cabecalho_planta_z          => \"PB(z)\",\r\n        :unit_metros                 => \"Metros\",\r\n        :unit_centimetros            => \"Centimetros\",\r\n        :unit_milimetros             => \"Milimetros\",\r\n        :unit_polegadas              => \"Polegadas\",\r\n        :unit_jardas                 => \"Jardas\",\r\n        :unit_pes                    => \"Pes\"\r\n      },\r\n      'en-US' => {\r\n        :titulo                      => \"Sections Management\",\r\n        :selecionar_pavimento        => \"-- Select a floor --\",\r\n        :editar_pavimento            => \"Edit Floor:\",\r\n        :selecionar_unidade          => \"Measurement Unit:\",\r\n        :nome_pavimento              => \"Floor Name:\",\r\n        :placeholder_nome            => \"Enter floor name\",\r\n        :nivel_pavimento             => \"Floor Elevation:\",\r\n        :altura_pavimento            => \"Floor Height:\",\r\n        :planta_baixa_altura         => \"Floor Plan (height):\",\r\n        :botao_salvar                => \"Save changes\",\r\n        :botao_criar                 => \"Create Floor\",\r\n        :titulo_niveis               => \"Floors:\",\r\n        :carregar_dados              => \"Load data\",\r\n        :botao_excluir               => \"Delete\",\r\n        :botao_salvar_dados          => \"Save\",\r\n        :secoes_forro                => \"Ceiling Sections\",\r\n        :secoes_planta               => \"Plan Sections\",\r\n        :secoes_corte                => \"Sections\",\r\n        :corte_extra_x               => \"Extra Cut X\",\r\n        :corte_extra_y               => \"Extra Cut Y\",\r\n        :idioma                      => \"Language\",\r\n        :tema_claro                  => \"Light Theme\",\r\n        :tema_escuro                 => \"Dark Theme\",\r\n        :sem_geometria               => \"No geometry found to place cuts!\",\r\n        :confirmar_exclusao_titulo   => \"Do you want to delete selected floors?\",\r\n        :confirmar_exclusao_mensagem => \"This action is irreversible and will delete all configuration for selected floors.\",\r\n        :botao_cancelar              => \"Cancel\",\r\n        :botao_confirmar             => \"Confirm\",\r\n        :titulo_alerta               => \"Warning\",\r\n        :numero_invalido             => \"Please enter valid numeric values\",\r\n        :nenhum_selecionado          => \"Select at least one floor\",\r\n        :dados_salvos                => \"Data successfully saved at:\",\r\n        :erro                        => \"Error\",\r\n        :secao_frente                => \"Front\",\r\n        :secao_tras                  => \"Back\",\r\n        :secao_direita               => \"Right\",\r\n        :secao_esquerda              => \"Left\",\r\n        :secao                       => \"Section\",\r\n        :nome_duplicado              => \"A floor with this name already exists, please choose a unique name\",\r\n        :nivel_duplicado             => \"Floor elevation already exists, check the table to avoid duplicate floors\",\r\n        :criar_secoes_primeiro       => \"Create vertical sections first or check if there is visible geometry!\",\r\n        :arquivo_invalido            => \"Invalid file\",\r\n        :cabecalho_nome              => \"Floor Name\",\r\n        :cabecalho_nivel             => \"Elevation\",\r\n        :cabecalho_altura            => \"Height\",\r\n        :cabecalho_planta            => \"Floor Plan\",\r\n        :cabecalho_planta_z          => \"FP(z)\",\r\n        :unit_metros                 => \"Meters\",\r\n        :unit_centimetros            => \"Centimeters\",\r\n        :unit_milimetros             => \"Millimeters\",\r\n        :unit_polegadas              => \"Inches\",\r\n        :unit_jardas                 => \"Yards\",\r\n        :unit_pes                    => \"Feet\"\r\n      },\r\n      'es' => {\r\n        :titulo                      => \"Gestor de Pisos\",\r\n        :selecionar_pavimento        => \"-- Seleccione un piso --\",\r\n        :editar_pavimento            => \"Editar Piso:\",\r\n        :selecionar_unidade          => \"Unidad de Medida:\",\r\n        :nome_pavimento              => \"Nombre del Piso:\",\r\n        :placeholder_nome            => \"Ingrese nombre del piso\",\r\n        :nivel_pavimento             => \"Elevacion del Piso:\",\r\n        :altura_pavimento            => \"Altura del Piso:\",\r\n        :planta_baixa_altura         => \"Plano de Planta (altura):\",\r\n        :botao_salvar                => \"Guardar cambios\",\r\n        :botao_criar                 => \"Crear Piso\",\r\n        :titulo_niveis               => \"Pisos en el Proyecto:\",\r\n        :carregar_dados              => \"Cargar datos\",\r\n        :botao_excluir               => \"Eliminar\",\r\n        :botao_salvar_dados          => \"Guardar\",\r\n        :secoes_forro                => \"Secciones de Techo\",\r\n        :secoes_planta               => \"Secciones de Planta\",\r\n        :secoes_corte                => \"Secciones\",\r\n        :corte_extra_x               => \"Corte Extra X\",\r\n        :corte_extra_y               => \"Corte Extra Y\",\r\n        :idioma                      => \"Idioma\",\r\n        :tema_claro                  => \"Tema Claro\",\r\n        :tema_escuro                 => \"Tema Oscuro\",\r\n        :sem_geometria               => \"No se encontro geometria para colocar cortes!\",\r\n        :confirmar_exclusao_titulo   => \"Desea eliminar los pisos seleccionados?\",\r\n        :confirmar_exclusao_mensagem => \"Esta accion es irreversible y eliminara toda la configuracion de los pisos seleccionados.\",\r\n        :botao_cancelar              => \"Cancelar\",\r\n        :botao_confirmar             => \"Confirmar\",\r\n        :titulo_alerta               => \"Atencion\",\r\n        :numero_invalido             => \"Por favor ingrese valores numericos validos\",\r\n        :nenhum_selecionado          => \"Seleccione al menos un piso\",\r\n        :dados_salvos                => \"Datos guardados exitosamente en:\",\r\n        :erro                        => \"Error\",\r\n        :secao_frente                => \"Frente\",\r\n        :secao_tras                  => \"Atras\",\r\n        :secao_direita               => \"Derecha\",\r\n        :secao_esquerda              => \"Izquierda\",\r\n        :secao                       => \"Seccion\",\r\n        :nome_duplicado              => \"Ya existe un piso con este nombre, elija un nombre unico para el nuevo piso\",\r\n        :nivel_duplicado             => \"La elevacion del piso ya existe, verifique en la tabla para no crear pisos duplicados\",\r\n        :criar_secoes_primeiro       => \"Cree las secciones verticales primero o verifique si hay geometria visible!\",\r\n        :arquivo_invalido            => \"Archivo invalido\",\r\n        :cabecalho_nome              => \"Piso\",\r\n        :cabecalho_nivel             => \"Elevacion\",\r\n        :cabecalho_altura            => \"Altura\",\r\n        :cabecalho_planta            => \"Plano de Planta\",\r\n        :cabecalho_planta_z          => \"PL(z)\",\r\n        :unit_metros                 => \"Metros\",\r\n        :unit_centimetros            => \"Centimetros\",\r\n        :unit_milimetros             => \"Milimetros\",\r\n        :unit_polegadas              => \"Pulgadas\",\r\n        :unit_jardas                 => \"Yardas\",\r\n        :unit_pes                    => \"Pies\"\r\n      }\r\n    }\r\n\r\n    LANG_MAP = { 'pt' => 'pt-BR', 'en' => 'en-US', 'es' => 'es' }\r\n    LANG_SHORT = { 'pt-BR' => 'pt', 'en-US' => 'en', 'es' => 'es' }\r\n\r\n    UNIT_KEYS = [\r\n      ['metros',      :unit_metros],\r\n      ['centimetros', :unit_centimetros],\r\n      ['milimetros',  :unit_milimetros],\r\n      ['polegadas',   :unit_polegadas],\r\n      ['jardas',      :unit_jardas],\r\n      ['pes',         :unit_pes]\r\n    ]\r\n\r\n    # Inicializa variaveis de classe\r\n    @levels = []\r\n    @dialog = nil\r\n    @current_unit = 'metros'\r\n    @current_theme = Sketchup.read_default(\"level_manager\", \"theme\", \"day\")\r\n    @levels_mutex = Mutex.new\r\n\r\n    # Detecta idioma inicial via Sketchup.get_locale ou preferencia salva\r\n    saved_lang = Sketchup.read_default(\"level_manager\", \"language\", nil)\r\n    if saved_lang && IDIOMAS.key?(saved_lang)\r\n      @current_language = saved_lang\r\n    elsif saved_lang && LANG_MAP.key?(saved_lang)\r\n      @current_language = LANG_MAP[saved_lang]\r\n    else\r\n      locale = Sketchup.get_locale\r\n      @current_language = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n    end\r\n\r\n    def self.obter_texto(chave)\r\n      lang = @current_language || begin\r\n        locale = Sketchup.get_locale\r\n        IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      end\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    # Metodo principal para criar a interface\r\n    def self.criar_interface_niveis\r\n      begin\r\n        # Fecha o dialogo existente se estiver aberto\r\n        @dialog.close if @dialog && @dialog.visible?\r\n\r\n        options = {\r\n          :dialog_title => obter_texto(:titulo),\r\n          :preferences_key => 'com.example.levelmanager',\r\n          :width => 650,\r\n          :height => 580,\r\n          :resizable => true,\r\n          :style => UI::HtmlDialog::STYLE_DIALOG,\r\n          :min_width => 650,\r\n          :min_height => 580\r\n        }\r\n\r\n        @dialog = UI::HtmlDialog.new(options)\r\n\r\n        unit_options = UNIT_KEYS.map { |val, key| \"<option value='#{val}'>#{obter_texto(key)}</option>\" }.join\r\n        short_lang = LANG_SHORT[@current_language] || 'en'\r\n\r\n        html = <<-HTML\r\n          <!DOCTYPE html>\r\n          <html>\r\n          <head>\r\n            <meta charset=\"UTF-8\">\r\n            <style>\r\n              /* ====== ESTILOS GERAIS ====== */\r\n              body {\r\n                font-family: Arial, sans-serif;\r\n                padding: 10px;\r\n                margin: 0;\r\n                height: 100%;\r\n                box-sizing: border-box;\r\n                background-color: #ffffff;\r\n                color: #000000;\r\n              }\r\n\r\n              /* Tema noturno */\r\n              body.night {\r\n                background-color: #000000;\r\n                color: #ffffff;\r\n              }\r\n\r\n              /* ====== LAYOUT PRINCIPAL ====== */\r\n              #main-container {\r\n                display: flex;\r\n                flex-direction: column;\r\n                height: 100%;\r\n              }\r\n\r\n              /* Container da tabela */\r\n              #table-container {\r\n                flex-grow: 1;\r\n                overflow-y: auto;\r\n                margin-bottom: 10px;\r\n              }\r\n\r\n              /* ====== CABECALHOS E TITULOS ====== */\r\n              h3 {\r\n                margin-top: 0;\r\n              }\r\n\r\n              h4 {\r\n                margin-bottom: 5px;\r\n                display: flex;\r\n                align-items: center;\r\n              }\r\n\r\n              /* ====== FORMULARIOS E INPUTS ====== */\r\n              /* Grupos de inputs */\r\n              .input-group {\r\n                margin-bottom: 12px;\r\n              }\r\n\r\n              .name-input-group {\r\n                margin-top: 8px;\r\n                margin-bottom: 15px;\r\n              }\r\n\r\n              /* Linhas de inputs */\r\n              .input-row {\r\n                display: flex;\r\n                justify-content: space-between;\r\n                margin-bottom: 12px;\r\n              }\r\n\r\n              .selector-row {\r\n                display: flex;\r\n                justify-content: space-between;\r\n                margin-bottom: 15px;\r\n              }\r\n\r\n              /* Seletor de idioma */\r\n              .language-selector {\r\n                position: absolute;\r\n                top: 10px;\r\n                right: 60px;\r\n                display: flex;\r\n                align-items: center;\r\n                gap: 5px;\r\n                font-size: 9pt;\r\n              }\r\n\r\n              .language-selector select {\r\n                padding: 2px;\r\n                font-size: 9pt;\r\n              }\r\n\r\n              /* Campos individuais */\r\n              .input-field {\r\n                width: 30%;\r\n              }\r\n\r\n              .unit-selector,\r\n              .level-selector {\r\n                width: 48%;\r\n              }\r\n\r\n              /* Labels */\r\n              .input-label {\r\n                font-size: 10pt;\r\n                margin-bottom: 2px;\r\n              }\r\n\r\n              .input-field label {\r\n                font-size: 10pt;\r\n                display: block;\r\n                margin-bottom: 2px;\r\n              }\r\n\r\n              /* Inputs e selects */\r\n              .input-field input,\r\n              select,\r\n              #level_name {\r\n                width: 100%;\r\n                padding: 4px;\r\n                font-size: 11pt;\r\n                box-sizing: border-box;\r\n                background-color: #ffffff;\r\n                color: #000000;\r\n                border: 1px solid #ddd;\r\n              }\r\n\r\n              /* Input de nome do nivel */\r\n              #level_name {\r\n                width: 100%;\r\n              }\r\n\r\n              /* ====== TABELA DE NIVEIS ====== */\r\n              table {\r\n                width: 100%;\r\n                border-collapse: collapse;\r\n                margin-top: 8px;\r\n                font-size: 11pt;\r\n                table-layout: fixed;\r\n              }\r\n\r\n              th, td {\r\n                border: 1px solid #ddd;\r\n                padding: 6px;\r\n                text-align: left;\r\n                overflow: hidden;\r\n              }\r\n\r\n              th {\r\n                background-color: #f2f2f2;\r\n                font-size: 10pt;\r\n                white-space: nowrap;\r\n              }\r\n\r\n              /* Celulas editaveis */\r\n              .editable-cell {\r\n                cursor: pointer;\r\n                white-space: nowrap;\r\n                overflow: hidden;\r\n                text-overflow: ellipsis;\r\n              }\r\n\r\n              .editable-cell:hover {\r\n                background-color: #f5f5f5;\r\n              }\r\n\r\n              /* Checkbox na tabela */\r\n              .checkbox-column {\r\n                width: 30px;\r\n                text-align: center;\r\n              }\r\n\r\n              /* Input dentro da tabela */\r\n              .table-input {\r\n                width: 100%;\r\n                border: none;\r\n                padding: 0;\r\n                margin: 0;\r\n                font-size: 11pt;\r\n                background: transparent;\r\n                color: inherit;\r\n              }\r\n\r\n              /* ====== BOTOES ====== */\r\n              /* Containers de botoes */\r\n              .button-container {\r\n                display: flex;\r\n                justify-content: space-between;\r\n                margin-top: 15px;\r\n                margin-bottom: 10px;\r\n              }\r\n\r\n              .button-row {\r\n                display: flex;\r\n                justify-content: space-between;\r\n                margin-top: 10px;\r\n              }\r\n\r\n              .delete-save-container {\r\n                display: flex;\r\n                gap: 5px;\r\n              }\r\n\r\n              /* Estilo base para todos os botoes */\r\n              button {\r\n                padding: 5px 12px;\r\n                margin: 3px;\r\n                font-size: 11pt;\r\n                cursor: pointer;\r\n                border: none;\r\n                border-radius: 8px;\r\n              }\r\n\r\n              /* Cores especificas para botoes */\r\n              .delete-btn {\r\n                background-color: #f44336;\r\n                color: white;\r\n              }\r\n\r\n              .create-btn {\r\n                background-color: #2196F3;\r\n                color: white;\r\n              }\r\n\r\n              .save-btn {\r\n                background-color: #4CAF50;\r\n                color: white;\r\n              }\r\n\r\n              .section-btn {\r\n                background-color: #2196F3;\r\n                color: white;\r\n              }\r\n\r\n              .cut-btn {\r\n                background-color: #42A5F5;\r\n                color: white;\r\n              }\r\n\r\n              .load-btn {\r\n                background-color: #9E9E9E;\r\n                color: white;\r\n                padding: 3px 8px;\r\n                font-size: 10pt;\r\n                height: 24px;\r\n                margin-left: 5px;\r\n              }\r\n\r\n              /* ====== SECOES ESPECIFICAS ====== */\r\n              /* Seletor de tema */\r\n              .theme-switcher {\r\n                position: absolute;\r\n                top: 10px;\r\n                right: 10px;\r\n                display: flex;\r\n                gap: 0;\r\n              }\r\n\r\n              .theme-btn {\r\n                width: 24px;\r\n                height: 24px;\r\n                padding: 0;\r\n                margin: 0;\r\n                display: flex;\r\n                align-items: center;\r\n                justify-content: center;\r\n                border: 1px solid #ccc;\r\n                background-color: #f0f0f0;\r\n                border-radius: 0;\r\n                color: #000;\r\n              }\r\n\r\n              .theme-btn:first-child {\r\n                border-top-left-radius: 3px;\r\n                border-bottom-left-radius: 3px;\r\n              }\r\n\r\n              .theme-btn:last-child {\r\n                border-top-right-radius: 3px;\r\n                border-bottom-right-radius: 3px;\r\n              }\r\n\r\n              .theme-btn.active {\r\n                background-color: #ddd;\r\n                border: 1px solid #999;\r\n                box-shadow: inset 0 2px 3px rgba(0,0,0,0.2);\r\n              }\r\n\r\n              /* ====== DIALOGOS PERSONALIZADOS ====== */\r\n              .custom-dialog {\r\n                position: fixed;\r\n                top: 50%;\r\n                left: 50%;\r\n                transform: translate(-50%, -50%);\r\n                background-color: white;\r\n                padding: 20px;\r\n                border-radius: 5px;\r\n                box-shadow: 0 4px 8px rgba(0,0,0,0.2);\r\n                z-index: 1000;\r\n                width: 400px;\r\n                max-width: 90%;\r\n              }\r\n\r\n              .custom-dialog-title {\r\n                font-weight: bold;\r\n                margin-bottom: 15px;\r\n                font-size: 14pt;\r\n              }\r\n\r\n              .custom-dialog-message {\r\n                margin-bottom: 20px;\r\n              }\r\n\r\n              .custom-dialog-buttons {\r\n                display: flex;\r\n                justify-content: flex-end;\r\n                gap: 10px;\r\n              }\r\n\r\n              .custom-dialog-button {\r\n                padding: 8px 16px;\r\n                border: none;\r\n                border-radius: 4px;\r\n                cursor: pointer;\r\n                font-size: 11pt;\r\n              }\r\n\r\n              .custom-dialog-confirm {\r\n                background-color: #f44336;\r\n                color: white;\r\n              }\r\n\r\n              .custom-dialog-cancel {\r\n                background-color: #e0e0e0;\r\n              }\r\n\r\n              /* ====== TEMA NOTURNO ====== */\r\n              body.night .input-field input,\r\n              body.night select,\r\n              body.night #level_name,\r\n              body.night .table-input {\r\n                background-color: #333333;\r\n                color: #ffffff;\r\n                border-color: #555;\r\n              }\r\n\r\n              body.night th,\r\n              body.night td {\r\n                border-color: #555;\r\n              }\r\n\r\n              body.night th {\r\n                background-color: #333;\r\n              }\r\n\r\n              body.night .editable-cell:hover {\r\n                background-color: #333;\r\n              }\r\n\r\n              body.night .theme-btn {\r\n                background-color: #333;\r\n                border-color: #555;\r\n                color: #fff;\r\n              }\r\n\r\n              body.night .theme-btn.active {\r\n                background-color: #555;\r\n                border-color: #777;\r\n              }\r\n\r\n              body.night .custom-dialog {\r\n                background-color: #222;\r\n                color: white;\r\n              }\r\n\r\n              body.night .custom-dialog-cancel {\r\n                background-color: #444;\r\n                color: white;\r\n              }\r\n            </style>\r\n          </head>\r\n          <body class=\"#{@current_theme}\">\r\n            <div class=\"language-selector\">\r\n              <label>#{obter_texto(:idioma)}:</label>\r\n              <select id=\"language_selector\" onchange=\"changeLanguage()\">\r\n                <option value=\"pt\" #{@current_language == 'pt-BR' ? 'selected' : ''}>Portugu&#234;s</option>\r\n                <option value=\"en\" #{@current_language == 'en-US' ? 'selected' : ''}>English</option>\r\n                <option value=\"es\" #{@current_language == 'es' ? 'selected' : ''}>Espa&#241;ol</option>\r\n              </select>\r\n            </div>\r\n\r\n            <div class=\"theme-switcher\">\r\n              <button id=\"day-theme\" class=\"theme-btn #{@current_theme == 'day' ? 'active' : ''}\" onclick=\"setTheme('day')\" title=\"#{obter_texto(:tema_claro)}\">&#128262;</button>\r\n              <button id=\"night-theme\" class=\"theme-btn #{@current_theme == 'night' ? 'active' : ''}\" onclick=\"setTheme('night')\" title=\"#{obter_texto(:tema_escuro)}\">&#127769;</button>\r\n            </div>\r\n\r\n            <div id='main-container'>\r\n              <h3>#{obter_texto(:titulo)}</h3>\r\n\r\n              <div class='selector-row'>\r\n                <div class='level-selector'>\r\n                  <label class='input-label'>#{obter_texto(:editar_pavimento)}</label>\r\n                  <select id='level_selector' onchange='levelSelected()'>\r\n                    <option value=''>#{obter_texto(:selecionar_pavimento)}</option>\r\n                  </select>\r\n                </div>\r\n                <div class='unit-selector'>\r\n                  <label class='input-label'>#{obter_texto(:selecionar_unidade)}</label>\r\n                  <select id='unit_selector' onchange='unitChanged()'>\r\n                    #{unit_options}\r\n                  </select>\r\n                </div>\r\n              </div>\r\n\r\n              <div class='name-input-group'>\r\n                <label class='input-label'>#{obter_texto(:nome_pavimento)}</label>\r\n                <input type='text' id='level_name' placeholder=\"#{obter_texto(:placeholder_nome)}\" onkeypress=\"handleKeyPress(event)\">\r\n              </div>\r\n\r\n              <div class='input-row'>\r\n                <div class='input-field'>\r\n                  <label class='input-label'>#{obter_texto(:nivel_pavimento)}</label>\r\n                  <input type='text' id='base_level' value='0,00' onfocus=\"this.select();\" onkeypress=\"handleKeyPress(event)\">\r\n                </div>\r\n                <div class='input-field'>\r\n                  <label class='input-label'>#{obter_texto(:altura_pavimento)}</label>\r\n                  <input type='text' id='level_height' value='3,00' onfocus=\"this.select();\" onkeypress=\"handleKeyPress(event)\">\r\n                </div>\r\n                <div class='input-field'>\r\n                  <label class='input-label'>#{obter_texto(:planta_baixa_altura)}</label>\r\n                  <input type='text' id='plan_height' value='1,50' onfocus=\"this.select();\" onkeypress=\"handleKeyPress(event)\">\r\n                </div>\r\n              </div>\r\n\r\n              <div class='button-row'>\r\n                <button onclick='saveLevel()' class='save-btn'>#{obter_texto(:botao_salvar)}</button>\r\n                <button onclick='addLevel()' class='create-btn'>#{obter_texto(:botao_criar)}</button>\r\n              </div>\r\n\r\n              <div id='table-container'>\r\n                <h4>#{obter_texto(:titulo_niveis)}<button class='load-btn' onclick='loadData()'>#{obter_texto(:carregar_dados)}</button></h4>\r\n                <table id='levels_table'>\r\n                  <thead>\r\n                    <tr>\r\n                      <th class='checkbox-column'><input type='checkbox' id='select_all' onclick='toggleSelectAll()'></th>\r\n                      <th width='25%'>#{obter_texto(:cabecalho_nome)}</th>\r\n                      <th width='15%'>#{obter_texto(:cabecalho_nivel)}</th>\r\n                      <th width='15%'>#{obter_texto(:cabecalho_altura)}</th>\r\n                      <th width='15%'>#{obter_texto(:cabecalho_planta)}</th>\r\n                      <th width='15%'>#{obter_texto(:cabecalho_planta_z)}</th>\r\n                    </tr>\r\n                  </thead>\r\n                  <tbody id='levels_list'>\r\n                  </tbody>\r\n                </table>\r\n              </div>\r\n\r\n              <div class='button-container'>\r\n                  <div class='delete-save-container'>\r\n                      <button onclick='showDeleteConfirmation()' class='delete-btn'>#{obter_texto(:botao_excluir)}</button>\r\n                      <button onclick='saveData()' class='save-btn'>#{obter_texto(:botao_salvar_dados)}</button>\r\n                  </div>\r\n\r\n                  <div class='horizontal-sections'>\r\n                      <button onclick='createCeilingSections()' class='section-btn'>#{obter_texto(:secoes_forro)}</button>\r\n                      <button onclick='createSections()' class='section-btn'>#{obter_texto(:secoes_planta)}</button>\r\n                  </div>\r\n              </div>\r\n\r\n              <div class='button-container'>\r\n                  <div style='width: 100%; display: flex; justify-content: flex-end; gap: 5px;'>\r\n                      <button onclick='createExtraCutX()' class='section-btn'>#{obter_texto(:corte_extra_x)}</button>\r\n                      <button onclick='createExtraCutY()' class='section-btn'>#{obter_texto(:corte_extra_y)}</button>\r\n                      <button onclick='createVerticalSections()' class='section-btn cut-main-btn'>#{obter_texto(:secoes_corte)}</button>\r\n                  </div>\r\n              </div>\r\n\r\n            <script>\r\n              function validateNumber(input) {\r\n                const num = parseFloat(input.replace(',', '.'));\r\n                return !isNaN(num) && isFinite(num);\r\n              }\r\n\r\n              function formatNumber(value) {\r\n                return parseFloat(value).toFixed(2).replace('.', ',');\r\n              }\r\n\r\n              function handleKeyPress(e) {\r\n                if (e.key === 'Enter') {\r\n                  e.preventDefault();\r\n                  const levelSelector = document.getElementById('level_selector');\r\n                  if (levelSelector.value) {\r\n                    saveLevel();\r\n                  } else {\r\n                    addLevel();\r\n                  }\r\n                }\r\n              }\r\n\r\n              function toggleSelectAll() {\r\n                const selectAll = document.getElementById('select_all');\r\n                const checkboxes = document.querySelectorAll('#levels_list input[type=\"checkbox\"]');\r\n                checkboxes.forEach(checkbox => {\r\n                  checkbox.checked = selectAll.checked;\r\n                });\r\n              }\r\n\r\n              function editLevelField(levelId, field, value) {\r\n                sketchup.editLevelField(levelId, field, value);\r\n              }\r\n\r\n              function setTheme(theme) {\r\n                document.body.className = theme;\r\n                document.getElementById('day-theme').className = theme === 'day' ? 'theme-btn active' : 'theme-btn';\r\n                document.getElementById('night-theme').className = theme === 'night' ? 'theme-btn active' : 'theme-btn';\r\n                sketchup.setCurrentTheme(theme);\r\n              }\r\n\r\n              function changeLanguage() {\r\n                const langSelector = document.getElementById('language_selector');\r\n                sketchup.changeLanguage(langSelector.value);\r\n              }\r\n\r\n              function addLevel() {\r\n                const name = document.getElementById('level_name').value.trim();\r\n                if (!name) {\r\n                  showAlert('#{obter_texto(:titulo_alerta)}', '#{obter_texto(:placeholder_nome)}');\r\n                  return;\r\n                }\r\n\r\n                const baseZ = document.getElementById('base_level').value;\r\n                const height = document.getElementById('level_height').value;\r\n                const planHeight = document.getElementById('plan_height').value;\r\n\r\n                if (!validateNumber(baseZ) || !validateNumber(height) || !validateNumber(planHeight)) {\r\n                  showAlert('#{obter_texto(:titulo_alerta)}', '#{obter_texto(:numero_invalido)}');\r\n                  return;\r\n                }\r\n\r\n                sketchup.addLevel(name, baseZ.replace(',', '.'), height.replace(',', '.'), planHeight.replace(',', '.'));\r\n              }\r\n\r\n              function saveLevel() {\r\n                const levelId = document.getElementById('level_selector').value;\r\n                if (!levelId) {\r\n                  showAlert('#{obter_texto(:titulo_alerta)}', '#{obter_texto(:selecionar_pavimento)}');\r\n                  return;\r\n                }\r\n\r\n                const name = document.getElementById('level_name').value.trim();\r\n                const baseZ = document.getElementById('base_level').value;\r\n                const height = document.getElementById('level_height').value;\r\n                const planHeight = document.getElementById('plan_height').value;\r\n\r\n                if (!validateNumber(baseZ) || !validateNumber(height) || !validateNumber(planHeight)) {\r\n                  showAlert('#{obter_texto(:titulo_alerta)}', '#{obter_texto(:numero_invalido)}');\r\n                  return;\r\n                }\r\n\r\n                sketchup.saveLevel(levelId, name, baseZ.replace(',', '.'), height.replace(',', '.'), planHeight.replace(',', '.'));\r\n              }\r\n\r\n              function createSections() {\r\n                const checkboxes = document.querySelectorAll('#levels_list input[type=\"checkbox\"]:checked');\r\n                if (checkboxes.length === 0) {\r\n                  showAlert('#{obter_texto(:titulo_alerta)}', '#{obter_texto(:nenhum_selecionado)}');\r\n                  return;\r\n                }\r\n                const levelsToCreate = Array.from(checkboxes).map(cb => {\r\n                  return {\r\n                    id: cb.getAttribute('data-id'),\r\n                    height: parseFloat(cb.closest('tr').querySelector('td:nth-child(6)').textContent.replace('m', '').replace(',', '.'))\r\n                  };\r\n                });\r\n                sketchup.createSections(levelsToCreate);\r\n              }\r\n\r\n              function showAlert(title, message) {\r\n                const dialog = document.createElement('div');\r\n                dialog.className = 'custom-dialog';\r\n                dialog.innerHTML = `\r\n                  <div class=\"custom-dialog-title\">${title}</div>\r\n                  <div class=\"custom-dialog-message\">${message}</div>\r\n                  <div class=\"custom-dialog-buttons\">\r\n                    <button class=\"custom-dialog-button custom-dialog-cancel\" onclick=\"this.parentNode.parentNode.remove()\">#{obter_texto(:botao_cancelar)}</button>\r\n                  </div>\r\n                `;\r\n                document.body.appendChild(dialog);\r\n              }\r\n\r\n              function showDeleteConfirmation() {\r\n                const checkboxes = document.querySelectorAll('#levels_list input[type=\"checkbox\"]:checked');\r\n                if (checkboxes.length === 0) {\r\n                  showAlert('#{obter_texto(:titulo_alerta)}', '#{obter_texto(:nenhum_selecionado)}');\r\n                  return;\r\n                }\r\n\r\n                const dialog = document.createElement('div');\r\n                dialog.className = 'custom-dialog';\r\n                dialog.innerHTML = `\r\n                  <div class=\"custom-dialog-title\">#{obter_texto(:confirmar_exclusao_titulo)}</div>\r\n                  <div class=\"custom-dialog-message\">#{obter_texto(:confirmar_exclusao_mensagem)}</div>\r\n                  <div class=\"custom-dialog-buttons\">\r\n                    <button class=\"custom-dialog-button custom-dialog-cancel\" onclick=\"this.parentNode.parentNode.remove()\">#{obter_texto(:botao_cancelar)}</button>\r\n                    <button class=\"custom-dialog-button custom-dialog-confirm\" onclick=\"confirmDelete()\">#{obter_texto(:botao_confirmar)}</button>\r\n                  </div>\r\n                `;\r\n\r\n                document.body.appendChild(dialog);\r\n\r\n                window.confirmDelete = function() {\r\n                  const levelsToDelete = Array.from(checkboxes).map(cb => cb.getAttribute('data-id'));\r\n                  sketchup.deleteLevels(levelsToDelete);\r\n                  dialog.remove();\r\n                };\r\n              }\r\n\r\n              function levelSelected() {\r\n                const selector = document.getElementById('level_selector');\r\n                if (selector.value) {\r\n                  sketchup.loadLevel(selector.value);\r\n                }\r\n              }\r\n\r\n              function unitChanged() {\r\n                const unitSelector = document.getElementById('unit_selector');\r\n                sketchup.setCurrentUnit(unitSelector.value);\r\n              }\r\n\r\n              function updateUI() {\r\n                sketchup.updateUI();\r\n              }\r\n\r\n              function editCell(cell, levelId, field, isText = false) {\r\n                const currentValue = cell.textContent.replace('m', '').trim();\r\n                const input = document.createElement('input');\r\n                input.type = 'text';\r\n                input.className = 'table-input';\r\n                input.value = currentValue;\r\n\r\n                input.onblur = function() {\r\n                  if (input.value !== currentValue) {\r\n                    if (!isText && !validateNumber(input.value)) {\r\n                      showAlert('#{obter_texto(:titulo_alerta)}', '#{obter_texto(:numero_invalido)}');\r\n                      return;\r\n                    }\r\n                    sketchup.editLevelField(levelId, field, isText ? input.value : input.value.replace(',', '.'));\r\n                  }\r\n                  cell.textContent = isText ? input.value : formatNumber(parseFloat(input.value.replace(',', '.'))) + 'm';\r\n                };\r\n\r\n                input.onkeypress = function(e) {\r\n                  if (e.key === 'Enter') {\r\n                    input.blur();\r\n                  }\r\n                };\r\n\r\n                cell.innerHTML = '';\r\n                cell.appendChild(input);\r\n                input.focus();\r\n\r\n                setTimeout(() => {\r\n                  input.selectionStart = input.selectionEnd = input.value.length;\r\n                }, 0);\r\n              }\r\n\r\n              function loadData() {\r\n                sketchup.loadData();\r\n              }\r\n\r\n              function saveData() {\r\n                sketchup.saveData();\r\n              }\r\n\r\n              function createCeilingSections() {\r\n                const checkboxes = document.querySelectorAll('#levels_list input[type=\"checkbox\"]:checked');\r\n                if (checkboxes.length === 0) {\r\n                  showAlert('#{obter_texto(:titulo_alerta)}', '#{obter_texto(:nenhum_selecionado)}');\r\n                  return;\r\n                }\r\n                const levelsToCreate = Array.from(checkboxes).map(cb => {\r\n                  return {\r\n                    id: cb.getAttribute('data-id'),\r\n                    height: parseFloat(cb.closest('tr').querySelector('td:nth-child(6)').textContent.replace('m', '').replace(',', '.'))\r\n                  };\r\n                });\r\n                sketchup.createCeilingSections(levelsToCreate);\r\n              }\r\n\r\n              function createVerticalSections() {\r\n                sketchup.createVerticalSections();\r\n              }\r\n\r\n              function createExtraCutX() {\r\n                sketchup.createExtraCutX();\r\n              }\r\n\r\n              function createExtraCutY() {\r\n                sketchup.createExtraCutY();\r\n              }\r\n            </script>\r\n          </body>\r\n          </html>\r\n        HTML\r\n\r\n        @dialog.set_html(html)\r\n\r\n        # Callbacks\r\n        @dialog.add_action_callback('addLevel') do |action_context, name, base_z, height, plan_height|\r\n          begin\r\n            @levels_mutex.synchronize do\r\n              if @levels.any? { |l| l[:name].casecmp(name.downcase) == 0 }\r\n                show_alert(obter_texto(:titulo_alerta), obter_texto(:nome_duplicado))\r\n                next\r\n              end\r\n\r\n              if @levels.any? { |l| (l[:base_z] - base_z.to_f).abs < 0.001 }\r\n                show_alert(obter_texto(:titulo_alerta), obter_texto(:nivel_duplicado))\r\n                next\r\n              end\r\n\r\n              add_level(name, base_z.to_f, height.to_f, plan_height.to_f)\r\n            end\r\n          rescue => e\r\n            puts \"Error adding level: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('saveLevel') do |action_context, level_id, name, base_z, height, plan_height|\r\n          begin\r\n            @levels_mutex.synchronize do\r\n              save_level(level_id, name, base_z.to_f, height.to_f, plan_height.to_f)\r\n            end\r\n          rescue => e\r\n            puts \"Error saving level: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('createSections') do |action_context, levels_data|\r\n          begin\r\n            create_sections(levels_data)\r\n          rescue => e\r\n            puts \"Error creating sections: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('createVerticalSections') do |action_context|\r\n          begin\r\n            create_vertical_sections\r\n          rescue => e\r\n            puts \"Error creating vertical sections: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('createExtraCutX') do |action_context|\r\n          begin\r\n            create_extra_cut_x\r\n          rescue => e\r\n            puts \"Error creating extra cut X: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('createExtraCutY') do |action_context|\r\n          begin\r\n            create_extra_cut_y\r\n          rescue => e\r\n            puts \"Error creating extra cut Y: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('deleteLevels') do |action_context, level_ids|\r\n          begin\r\n            @levels_mutex.synchronize do\r\n              delete_levels(level_ids)\r\n            end\r\n          rescue => e\r\n            puts \"Error deleting levels: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('loadLevel') do |action_context, level_id|\r\n          begin\r\n            load_level(level_id.to_i)\r\n          rescue => e\r\n            puts \"Error loading level: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('setCurrentUnit') do |action_context, unit|\r\n          @current_unit = unit\r\n        end\r\n\r\n        @dialog.add_action_callback('updateUI') do\r\n          begin\r\n            update_ui\r\n          rescue => e\r\n            puts \"Error updating UI: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('editLevelField') do |action_context, level_id, field, value|\r\n          begin\r\n            @levels_mutex.synchronize do\r\n              edit_level_field(level_id, field, value)\r\n            end\r\n          rescue => e\r\n            puts \"Error editing field: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('setCurrentTheme') do |action_context, theme|\r\n          @current_theme = theme\r\n          Sketchup.write_default(\"level_manager\", \"theme\", theme)\r\n        end\r\n\r\n        @dialog.add_action_callback('loadData') do |action_context|\r\n          begin\r\n            load_data_from_file\r\n          rescue => e\r\n            puts \"Error loading data: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('saveData') do |action_context|\r\n          begin\r\n            save_data_to_file\r\n          rescue => e\r\n            puts \"Error saving data: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('createCeilingSections') do |action_context, levels_data|\r\n          begin\r\n            create_ceiling_sections(levels_data)\r\n          rescue => e\r\n            puts \"Error creating ceiling sections: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('changeLanguage') do |action_context, lang|\r\n          @current_language = LANG_MAP[lang] || 'en-US'\r\n          Sketchup.write_default(\"level_manager\", \"language\", @current_language)\r\n          criar_interface_niveis\r\n        end\r\n\r\n        # Configuracao inicial\r\n        @dialog.execute_script(\"document.getElementById('language_selector').value = '#{short_lang}';\")\r\n        @dialog.execute_script(\"document.getElementById('unit_selector').value = '#{@current_unit}';\")\r\n        @dialog.execute_script(\"document.body.className = '#{@current_theme}';\")\r\n\r\n        @dialog.show\r\n      rescue => e\r\n        puts \"Error creating interface: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n        UI.messagebox(\"#{obter_texto(:erro)}: #{e.message}\")\r\n      end\r\n    end\r\n\r\n    # Metodos auxiliares\r\n    def self.show_alert(title, message)\r\n      js = <<-JS\r\n        showAlert(#{title.to_json}, #{message.to_json});\r\n      JS\r\n      @dialog.execute_script(js)\r\n    rescue\r\n      UI.messagebox(\"#{title}: #{message}\")\r\n    end\r\n\r\n    def self.add_level(name, base_z, height, plan_height)\r\n      model = Sketchup.active_model\r\n      return unless model.valid?\r\n\r\n      model.start_operation(\"#{obter_texto(:botao_criar)} #{name}\", true)\r\n\r\n      level = {\r\n        id: Time.now.to_i,\r\n        name: name,\r\n        base_z: base_z,\r\n        height: height,\r\n        plan_height: plan_height,\r\n        created_at: Time.now\r\n      }\r\n\r\n      @levels << level\r\n      @levels.sort_by! { |l| l[:base_z] }\r\n\r\n      model.commit_operation\r\n\r\n      update_ui\r\n    end\r\n\r\n    def self.save_level(level_id, name, base_z, height, plan_height)\r\n      model = Sketchup.active_model\r\n      return unless model.valid?\r\n\r\n      model.start_operation(\"#{obter_texto(:botao_salvar)} #{name}\", true)\r\n\r\n      level = @levels.find { |l| l[:id].to_s == level_id }\r\n      return unless level\r\n\r\n      if name != level[:name] && @levels.any? { |l| l[:name].casecmp(name.downcase) == 0 }\r\n        show_alert(obter_texto(:titulo_alerta), obter_texto(:nome_duplicado))\r\n        return\r\n      end\r\n\r\n      level[:name] = name unless name.empty?\r\n      level[:base_z] = base_z\r\n      level[:height] = height\r\n      level[:plan_height] = plan_height\r\n\r\n      @levels.sort_by! { |l| l[:base_z] }\r\n\r\n      model.commit_operation\r\n\r\n      update_ui\r\n    end\r\n\r\n    def self.edit_level_field(level_id, field, value)\r\n      model = Sketchup.active_model\r\n      return unless model.valid?\r\n\r\n      model.start_operation(\"#{obter_texto(:editar_pavimento)}\", true)\r\n\r\n      level = @levels.find { |l| l[:id].to_s == level_id }\r\n      return unless level\r\n\r\n      case field\r\n      when 'name'\r\n        level[:name] = value.to_s\r\n      when 'base_z'\r\n        level[:base_z] = value.to_s.gsub(',', '.').to_f\r\n        @levels.sort_by! { |l| l[:base_z] }\r\n      when 'height'\r\n        level[:height] = value.to_s.gsub(',', '.').to_f\r\n      when 'plan_height'\r\n        level[:plan_height] = value.to_s.gsub(',', '.').to_f\r\n      end\r\n\r\n      model.commit_operation\r\n\r\n      update_ui\r\n    end\r\n\r\n    def self.create_sections(levels_data)\r\n      model = Sketchup.active_model\r\n      return unless model.valid?\r\n\r\n      model.start_operation(obter_texto(:secoes_planta), true)\r\n\r\n      layers = model.layers\r\n      section_layer = layers.add(obter_texto(:secoes_planta)) unless layers[obter_texto(:secoes_planta)]\r\n      section_layer ||= layers[obter_texto(:secoes_planta)]\r\n\r\n      model.entities.grep(Sketchup::SectionPlane) do |e|\r\n        e.erase! if e.layer == section_layer\r\n      end\r\n\r\n      created = 0\r\n      levels_data.each do |level_data|\r\n        level = @levels.find { |l| l[:id].to_s == level_data['id'] }\r\n        next unless level\r\n\r\n        begin\r\n          z_position = level[:base_z] + level[:plan_height]\r\n\r\n          z_position_in_inches = case @current_unit\r\n            when 'metros' then z_position.m\r\n            when 'centimetros' then (z_position * 100).cm\r\n            when 'milimetros' then (z_position * 1000).mm\r\n            when 'polegadas' then z_position.inch\r\n            when 'jardas' then z_position.yd\r\n            when 'pes' then z_position.ft\r\n            else z_position.m\r\n          end\r\n\r\n          plane = [0, 0, -1, z_position_in_inches]\r\n          section = model.entities.add_section_plane(plane)\r\n          section.name = \"#{level[:name]} - #{obter_texto(:secoes_planta)}\"\r\n          section.layer = section_layer\r\n          section.visible = true\r\n\r\n          if section.respond_to?(:cutting_plane_visible=)\r\n            section.cutting_plane_visible = true\r\n          end\r\n\r\n          created += 1\r\n        rescue => e\r\n          puts \"Error creating section for level #{level[:name]}: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n          show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n        end\r\n      end\r\n\r\n      model.commit_operation\r\n    end\r\n\r\n    def self.create_ceiling_sections(levels_data)\r\n      model = Sketchup.active_model\r\n      return unless model.valid?\r\n\r\n      model.start_operation(obter_texto(:secoes_forro), true)\r\n\r\n      layers = model.layers\r\n      section_layer = layers.add(obter_texto(:secoes_forro)) unless layers[obter_texto(:secoes_forro)]\r\n      section_layer ||= layers[obter_texto(:secoes_forro)]\r\n\r\n      model.entities.grep(Sketchup::SectionPlane) do |e|\r\n        e.erase! if e.layer == section_layer\r\n      end\r\n\r\n      created = 0\r\n      levels_data.each do |level_data|\r\n        level = @levels.find { |l| l[:id].to_s == level_data['id'] }\r\n        next unless level\r\n\r\n        begin\r\n          z_position = level[:base_z] + level[:plan_height]\r\n\r\n          z_position_in_inches = case @current_unit\r\n            when 'metros' then z_position.m\r\n            when 'centimetros' then (z_position * 100).cm\r\n            when 'milimetros' then (z_position * 1000).mm\r\n            when 'polegadas' then z_position.inch\r\n            when 'jardas' then z_position.yd\r\n            when 'pes' then z_position.ft\r\n            else z_position.m\r\n          end\r\n\r\n          plane = [0, 0, 1, -z_position_in_inches]\r\n          section = model.entities.add_section_plane(plane)\r\n          section.name = \"#{level[:name]} - #{obter_texto(:secoes_forro)}\"\r\n          section.layer = section_layer\r\n          section.visible = true\r\n\r\n          if section.respond_to?(:cutting_plane_visible=)\r\n            section.cutting_plane_visible = true\r\n          end\r\n\r\n          created += 1\r\n        rescue => e\r\n          puts \"Error creating ceiling section for level #{level[:name]}: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n          show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n        end\r\n      end\r\n\r\n      model.commit_operation\r\n    end\r\n\r\n   def self.create_vertical_sections\r\n    model = Sketchup.active_model\r\n    return unless model.valid?\r\n\r\n    model.start_operation(obter_texto(:secoes_corte), true)\r\n\r\n    # Abordagem HIBRIDA: primeiro tenta o metodo rapido, depois fallback para metodo completo\r\n    bounding_box = Geom::BoundingBox.new\r\n\r\n    # 1. Tenta o metodo rapido primeiro (funciona na maioria dos casos)\r\n    quick_bb = model.bounds\r\n    unless quick_bb.empty?\r\n      bounding_box.add(quick_bb)\r\n    else\r\n      # 2. Fallback: metodo manual otimizado para XRefs\r\n      model.entities.each do |entity|\r\n        next unless entity.visible?\r\n\r\n        if entity.is_a?(Sketchup::Face)\r\n          entity.vertices.each { |v| bounding_box.add(v.position) }\r\n        elsif entity.is_a?(Sketchup::Group) && entity.visible?\r\n          entity.bounds.each { |point| bounding_box.add(point.transform(entity.transformation)) }\r\n        elsif entity.is_a?(Sketchup::ComponentInstance) && entity.visible?\r\n          # Para componentes e XRefs, usa a bounding box transformada\r\n          entity.bounds.each { |point| bounding_box.add(point.transform(entity.transformation)) }\r\n        end\r\n      end\r\n    end\r\n\r\n    if bounding_box.empty?\r\n      UI.messagebox(obter_texto(:sem_geometria))\r\n      model.abort_operation\r\n      return\r\n    end\r\n\r\n    min_point = bounding_box.min\r\n    max_point = bounding_box.max\r\n\r\n    # Calcula o centro REAL da geometria\r\n    center_x = (min_point.x + max_point.x) / 2.0\r\n    center_y = (min_point.y + max_point.y) / 2.0\r\n\r\n    # Offset a partir do centro (em metros)\r\n    offset = @section_offset || 1.0.m\r\n\r\n    layers = model.layers\r\n    section_layer = layers.add(obter_texto(:secoes_corte)) unless layers[obter_texto(:secoes_corte)]\r\n    section_layer ||= layers[obter_texto(:secoes_corte)]\r\n\r\n    # Remove secoes existentes apenas desta camada\r\n    model.entities.grep(Sketchup::SectionPlane) do |e|\r\n      e.erase! if e.layer == section_layer\r\n    end\r\n\r\n    # Cortes posicionados com offset A PARTIR DO CENTRO\r\n    # Secoes no eixo Y (frente/tras) - offset a partir do centro Y\r\n    create_section_plane([0, 1, 0, -(center_y - offset)], \"#{obter_texto(:secao)} #{obter_texto(:secao_frente)}\", section_layer)\r\n    create_section_plane([0, -1, 0, center_y + offset], \"#{obter_texto(:secao)} #{obter_texto(:secao_tras)}\", section_layer)\r\n\r\n    # Secoes no eixo X (direita/esquerda) - offset a partir do centro X\r\n    create_section_plane([1, 0, 0, -(center_x - offset)], \"#{obter_texto(:secao)} #{obter_texto(:secao_direita)}\", section_layer)\r\n    create_section_plane([-1, 0, 0, center_x + offset], \"#{obter_texto(:secao)} #{obter_texto(:secao_esquerda)}\", section_layer)\r\n\r\n    model.commit_operation\r\n   end\r\n\r\n   def self.create_extra_cut_x\r\n    model = Sketchup.active_model\r\n    return unless model.valid?\r\n\r\n    model.start_operation(obter_texto(:corte_extra_x), true)\r\n\r\n    # Metodo otimizado para cortes extras\r\n    bounding_box = Geom::BoundingBox.new\r\n    quick_bb = model.bounds\r\n\r\n    unless quick_bb.empty?\r\n      bounding_box.add(quick_bb)\r\n    else\r\n      # Fallback manual\r\n      model.entities.grep(Sketchup::ComponentInstance) do |instance|\r\n        next unless instance.visible?\r\n        instance.bounds.each { |point| bounding_box.add(point.transform(instance.transformation)) }\r\n      end\r\n    end\r\n\r\n    if bounding_box.empty?\r\n      UI.messagebox(obter_texto(:criar_secoes_primeiro))\r\n      model.abort_operation\r\n      return\r\n    end\r\n\r\n    center_x = (bounding_box.min.x + bounding_box.max.x) / 2.0\r\n\r\n    layers = model.layers\r\n    section_layer = layers[obter_texto(:secoes_corte)] || layers.add(obter_texto(:secoes_corte))\r\n\r\n    # Cria o corte extra exatamente no centro do eixo X\r\n    create_section_plane([0, 1, 0, -center_x], \"#{obter_texto(:secao)} #{obter_texto(:corte_extra_x)}\", section_layer)\r\n\r\n    model.commit_operation\r\n   end\r\n\r\n   def self.create_extra_cut_y\r\n    model = Sketchup.active_model\r\n    return unless model.valid?\r\n\r\n    model.start_operation(obter_texto(:corte_extra_y), true)\r\n\r\n    # Metodo otimizado para cortes extras\r\n    bounding_box = Geom::BoundingBox.new\r\n    quick_bb = model.bounds\r\n\r\n    unless quick_bb.empty?\r\n      bounding_box.add(quick_bb)\r\n    else\r\n      # Fallback manual\r\n      model.entities.grep(Sketchup::ComponentInstance) do |instance|\r\n        next unless instance.visible?\r\n        instance.bounds.each { |point| bounding_box.add(point.transform(instance.transformation)) }\r\n      end\r\n    end\r\n\r\n    if bounding_box.empty?\r\n      UI.messagebox(obter_texto(:criar_secoes_primeiro))\r\n      model.abort_operation\r\n      return\r\n    end\r\n\r\n    center_y = (bounding_box.min.y + bounding_box.max.y) / 2.0\r\n\r\n    layers = model.layers\r\n    section_layer = layers[obter_texto(:secoes_corte)] || layers.add(obter_texto(:secoes_corte))\r\n\r\n    # Cria o corte extra exatamente no centro do eixo Y\r\n    create_section_plane([1, 0, 0, -center_y], \"#{obter_texto(:secao)} #{obter_texto(:corte_extra_y)}\", section_layer)\r\n\r\n    model.commit_operation\r\n   end\r\n\r\n    def self.create_section_plane(plane_equation, name, layer)\r\n      section = Sketchup.active_model.entities.add_section_plane(plane_equation)\r\n      section.name = name\r\n      section.layer = layer\r\n      section.visible = true\r\n      if section.respond_to?(:cutting_plane_visible=)\r\n        section.cutting_plane_visible = true\r\n      end\r\n      section\r\n    end\r\n\r\n    def self.delete_levels(level_ids)\r\n      model = Sketchup.active_model\r\n      return unless model.valid?\r\n\r\n      model.start_operation(obter_texto(:botao_excluir), true)\r\n\r\n      @levels.delete_if { |l| level_ids.include?(l[:id].to_s) }\r\n\r\n      update_ui\r\n      model.commit_operation\r\n    end\r\n\r\n    def self.load_level(level_id)\r\n      level = @levels.find { |l| l[:id] == level_id.to_i }\r\n      return unless level\r\n\r\n      js = <<-JS\r\n        try {\r\n          document.getElementById('level_name').value = #{level[:name].to_json};\r\n          document.getElementById('base_level').value = #{'%.2f' % level[:base_z]}.replace('.', ',');\r\n          document.getElementById('level_height').value = #{'%.2f' % level[:height]}.replace('.', ',');\r\n          document.getElementById('plan_height').value = #{'%.2f' % level[:plan_height]}.replace('.', ',');\r\n        } catch(e) { console.error(e); }\r\n      JS\r\n\r\n      @dialog.execute_script(js)\r\n    rescue => e\r\n      puts \"Error loading level: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n    end\r\n\r\n    def self.update_ui\r\n      js = <<-JS\r\n        try {\r\n          const levelsList = document.getElementById('levels_list');\r\n          const levelSelector = document.getElementById('level_selector');\r\n          const unitSelector = document.getElementById('unit_selector');\r\n\r\n          levelsList.innerHTML = '';\r\n          levelSelector.innerHTML = '<option value=\"\">#{obter_texto(:selecionar_pavimento)}</option>';\r\n\r\n          unitSelector.value = #{@current_unit.to_json};\r\n\r\n          #{@levels.sort_by { |l| l[:base_z] }.map do |level|\r\n            pb_z = level[:base_z] + level[:plan_height]\r\n\r\n            <<-JS\r\n              var option = document.createElement('option');\r\n              option.value = '#{level[:id]}';\r\n              option.text = #{level[:name].to_json};\r\n              levelSelector.appendChild(option);\r\n\r\n              var row = document.createElement('tr');\r\n              row.innerHTML = `\r\n                <td class=\"checkbox-column\"><input type=\"checkbox\" data-id=\"#{level[:id]}\"></td>\r\n                <td class=\"editable-cell\" onclick=\"editCell(this, '#{level[:id]}', 'name', true)\">#{level[:name]}</td>\r\n                <td class=\"editable-cell\" onclick=\"editCell(this, '#{level[:id]}', 'base_z')\">#{'%.2f' % level[:base_z]}m</td>\r\n                <td class=\"editable-cell\" onclick=\"editCell(this, '#{level[:id]}', 'height')\">#{'%.2f' % level[:height]}m</td>\r\n                <td class=\"editable-cell\" onclick=\"editCell(this, '#{level[:id]}', 'plan_height')\">#{'%.2f' % level[:plan_height]}m</td>\r\n                <td>#{'%.2f' % pb_z}m</td>\r\n              `;\r\n              levelsList.appendChild(row);\r\n            JS\r\n          end.join}\r\n        } catch(e) { console.error(e); }\r\n      JS\r\n\r\n      @dialog.execute_script(js)\r\n    rescue => e\r\n      puts \"Error updating UI: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n    end\r\n\r\n    def self.load_data_from_file\r\n      path = UI.openpanel(obter_texto(:carregar_dados), \"\", \"JSON Files|*.json||\")\r\n      return unless path && File.exist?(path)\r\n\r\n      unless File.extname(path).downcase == '.json'\r\n        show_alert(obter_texto(:erro), obter_texto(:arquivo_invalido))\r\n        return\r\n      end\r\n\r\n      model = Sketchup.active_model\r\n      return unless model.valid?\r\n\r\n      model.start_operation(obter_texto(:carregar_dados), true)\r\n\r\n      json_data = File.read(path)\r\n      data = JSON.parse(json_data)\r\n\r\n      @levels = data.map do |level|\r\n        {\r\n          id: level['id'] || Time.now.to_i,\r\n          name: level['name'],\r\n          base_z: level['base_z'].to_f,\r\n          height: level['height'].to_f,\r\n          plan_height: level['plan_height'].to_f,\r\n          created_at: level['created_at'] ? Time.parse(level['created_at']) : Time.now\r\n        }\r\n      end\r\n\r\n      @levels.sort_by! { |l| l[:base_z] }\r\n\r\n      if data.first && data.first['preferences']\r\n        prefs = data.first['preferences']\r\n        @current_unit = prefs['unit'] if prefs['unit']\r\n        @current_theme = prefs['theme'] if prefs['theme']\r\n        @current_language = prefs['language'] if prefs['language']\r\n      end\r\n\r\n      model.commit_operation\r\n      update_ui\r\n    rescue => e\r\n      model.abort_operation if model\r\n      show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n    end\r\n\r\n    def self.save_data_to_file\r\n      return if @levels.empty?\r\n\r\n      path = UI.savepanel(obter_texto(:botao_salvar_dados), \"\", \"niveis_pavimentos.json\", \"JSON Files|*.json||\")\r\n      return unless path\r\n\r\n      path += \".json\" unless path.downcase.end_with?('.json')\r\n\r\n      data = @levels.map do |level|\r\n        {\r\n          id: level[:id],\r\n          name: level[:name],\r\n          base_z: level[:base_z],\r\n          height: level[:height],\r\n          plan_height: level[:plan_height],\r\n          created_at: level[:created_at].to_s\r\n        }\r\n      end\r\n\r\n      data.first[:preferences] = {\r\n        unit: @current_unit,\r\n        theme: @current_theme,\r\n        language: @current_language.to_s\r\n      }\r\n\r\n      File.open(path, 'w') { |f| f.write(JSON.pretty_generate(data)) }\r\n\r\n      show_alert(obter_texto(:dados_salvos), path)\r\n    rescue => e\r\n      show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n    end\r\n\r\n    def self.executar\r\n      criar_interface_niveis\r\n    end\r\n\r\n    unless file_loaded?(__FILE__)\r\n      UI.menu('Plugins').add_item(obter_texto(:titulo)) { executar }\r\n      file_loaded(__FILE__)\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::GerenciadorPavimentos.executar"
    },
    "enabled": false,
    "execute": true,
    "video": "https://youtu.be/LO2alFq6e0Y"
  },
  {
    "id": "posiciona-ou-centraliza-95jbh",
    "title": {
      "pt": "Posiciona ou Centraliza",
      "en": "Position or Center",
      "es": "Posición o Centro"
    },
    "author": "Comunidade ScriptUp",
    "version": "1.9",
    "description": {
      "pt": "Posiciona ou centraliza um ou vários grupos/componentes de acordo com referência selecionadas no modelo. Use as setas para direita ou para esquerda para rotacionar. Você também pode digitar quantos graus deseja rotacionar por clique.",
      "en": "Positions or centers one or more groups/components according to selected references in the model. Use the right or left arrows to rotate. You can also type how many degrees you want to rotate per click.",
      "es": "Posiciona o centra uno o más grupos/componentes según las referencias seleccionadas en el modelo. Usa las flechas derecha o izquierda para rotar. También puedes indicar cuántos grados quieres rotar por clic."
    },
    "keywords": {
      "pt": [
        "centralizar;posicionar"
      ],
      "en": [
        "center; position"
      ],
      "es": [
        "centro; posición"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module CentralizadorInterativo\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao => \"Selecione um ou mais grupos ou componentes para centralizar.\",\r\n        :modo_centralizar => \"Centralizar\",\r\n        :modo_posicionar => \"Posicionar\",\r\n        :status_texto => \"Modo: %s. Clique em referências. CTRL alterna modo. ←/→ rotaciona. VCB define ângulo.\",\r\n        :op_nome => \"Reposicionar bloco\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao => \"Select one or more groups or components to center.\",\r\n        :modo_centralizar => \"Center\",\r\n        :modo_posicionar => \"Position\",\r\n        :status_texto => \"Mode: %s. Click references. CTRL toggles mode. ←/→ rotates. VCB sets angle.\",\r\n        :op_nome => \"Reposition block\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao => \"Seleccione uno o más grupos o componentes para centrar.\",\r\n        :modo_centralizar => \"Centrar\",\r\n        :modo_posicionar => \"Posicionar\",\r\n        :status_texto => \"Modo: %s. Clic en referencias. CTRL cambia modo. ←/→ rota. VCB define ángulo.\",\r\n        :op_nome => \"Reposicionar bloque\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    VK_LEFT     = 0x25\r\n    VK_RIGHT    = 0x27\r\n    VK_CONTROL  = 0x11\r\n\r\n    class CentralizadorTool\r\n      def initialize(alvo)\r\n        @alvo = alvo\r\n        @ref1 = nil\r\n        @ref2 = nil\r\n        @tmp_refs = []\r\n        @context = Sketchup.active_model.active_entities\r\n        @hover_preview_inst = nil\r\n        @ref1_ent = nil\r\n        @ref2_ent = nil\r\n        @modo = :centralizar\r\n        @angulo_input = 90.degrees\r\n        atualizar_mensagem_padrao\r\n      end\r\n\r\n      def atualizar_status(msg)\r\n        Sketchup.set_status_text(msg)\r\n      end\r\n\r\n      def atualizar_mensagem_padrao\r\n        modo_str = @modo == :centralizar ? CentralizadorInterativo.obter_texto(:modo_centralizar) : CentralizadorInterativo.obter_texto(:modo_posicionar)\r\n        msg = sprintf(CentralizadorInterativo.obter_texto(:status_texto), modo_str)\r\n        atualizar_status(msg)\r\n      end\r\n\r\n      def resume(view); atualizar_mensagem_padrao; end\r\n      def onResume(view); atualizar_mensagem_padrao; end\r\n      def activate; atualizar_mensagem_padrao; end\r\n\r\n      def onUserText(text, view)\r\n        valor = text.to_f\r\n        @angulo_input = valor.degrees if valor.abs > 0\r\n      end\r\n\r\n      def onKeyDown(key, repeat, flags, view)\r\n        case key\r\n        when VK_CONTROL\r\n          @modo = (@modo == :centralizar ? :posicionar : :centralizar)\r\n          atualizar_mensagem_padrao\r\n          view.invalidate\r\n        when VK_LEFT\r\n          aplicar_rotacao(-@angulo_input)\r\n        when VK_RIGHT\r\n          aplicar_rotacao(@angulo_input)\r\n        end\r\n      end\r\n\r\n      def aplicar_rotacao(angulo)\r\n        centro = bounding_box_global(@alvo).center\r\n        transform = Geom::Transformation.rotation(centro, [0, 0, 1], angulo)\r\n        @alvo.each { |ent| ent.transform!(transform) }\r\n      end\r\n\r\n      def limpar_temporarios\r\n        @tmp_refs.each { |inst| inst.erase! if inst.valid? }\r\n        @tmp_refs.clear\r\n        limpar_preview\r\n      end\r\n\r\n      def onMouseMove(flags, x, y, view)\r\n        ph = view.pick_helper\r\n        ph.do_pick(x, y)\r\n        path = ph.path_at(0)\r\n        ent = path&.reverse&.find { |e| e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance) }\r\n\r\n        if ent && !@alvo.include?(ent) && ent.valid?\r\n          limpar_preview\r\n          transf = path.reduce(Geom::Transformation.new) { |acc, e| acc *= e.transformation if e.respond_to?(:transformation); acc }\r\n          defn = ent.definition\r\n          @hover_preview_inst = @context.add_instance(defn, transf)\r\n          @hover_preview_inst.hidden = true\r\n        else\r\n          limpar_preview\r\n        end\r\n        view.invalidate\r\n      end\r\n\r\n      def draw(view)\r\n        return unless @hover_preview_inst && @hover_preview_inst.valid?\r\n        view.line_width = 3\r\n        view.drawing_color = 'red'\r\n        defn_bounds = @hover_preview_inst.definition.bounds\r\n        transf = @hover_preview_inst.transformation\r\n        corners = (0..7).map { |i| defn_bounds.corner(i).transform(transf) }\r\n        arestas = [[0,1],[1,3],[3,2],[2,0],[4,5],[5,7],[7,6],[6,4],[0,4],[1,5],[2,6],[3,7]]\r\n        linhas = arestas.flat_map { |i,j| [corners[i], corners[j]] }\r\n        view.draw(GL_LINES, *linhas)\r\n      end\r\n\r\n      def limpar_preview\r\n        @hover_preview_inst.erase! if @hover_preview_inst&.valid?\r\n        @hover_preview_inst = nil\r\n      end\r\n\r\n      def onLButtonDown(flags, x, y, view)\r\n        ph = view.pick_helper\r\n        ph.do_pick(x, y)\r\n        path = ph.path_at(0)\r\n        return unless path && !path.empty?\r\n\r\n        ref_ent = path.reverse.find { |e| e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance) }\r\n        return unless ref_ent\r\n        return if @alvo.include?(ref_ent)\r\n\r\n        ref_tmp = criar_instancia_temporaria(ref_ent, path)\r\n        return unless ref_tmp\r\n\r\n        if @modo == :posicionar\r\n          centralizar_entre(ref_tmp, ref_tmp, true)\r\n          atualizar_mensagem_padrao\r\n          return\r\n        end\r\n\r\n        if @ref1 && @ref2\r\n          @ref1 = nil\r\n          @ref2 = nil\r\n        end\r\n\r\n        if @ref1.nil?\r\n          @ref1 = ref_tmp\r\n          @ref1_ent = ref_ent\r\n        elsif @ref2.nil?\r\n          @ref2 = ref_tmp\r\n          @ref2_ent = ref_ent\r\n          mesmas_instancias = @ref1_ent == @ref2_ent && @ref1_ent.transformation == @ref2_ent.transformation\r\n          centralizar_entre(@ref1, @ref2, mesmas_instancias)\r\n          @ref1 = nil\r\n          @ref2 = nil\r\n        end\r\n\r\n        atualizar_mensagem_padrao\r\n        view.invalidate\r\n      end\r\n\r\n      def criar_instancia_temporaria(orig_ent, path)\r\n        transf_global = path.reduce(Geom::Transformation.new) { |acc, ent| acc *= ent.transformation if ent.respond_to?(:transformation); acc }\r\n        defn = orig_ent.definition\r\n        inst = @context.add_instance(defn, transf_global)\r\n        inst.hidden = true\r\n        @tmp_refs << inst\r\n        inst\r\n      end\r\n\r\n      def centralizar_entre(ref1, ref2, mesmas_entidades)\r\n        model = Sketchup.active_model\r\n        model.start_operation(CentralizadorInterativo.obter_texto(:op_nome), true)\r\n\r\n        bounds_ref = bounding_box_global(ref1)\r\n        bounds_bloco = bounding_box_global(@alvo)\r\n        centro_ref = bounds_ref.center\r\n        centro_bloco = bounds_bloco.center\r\n\r\n        deslocamento = if mesmas_entidades\r\n          eixo = detectar_eixo_de_maior_separacao(bounds_bloco, bounds_ref)\r\n          case eixo\r\n          when :x\r\n            dx = centro_bloco.x < centro_ref.x ? bounds_ref.min.x - bounds_bloco.max.x : bounds_ref.max.x - bounds_bloco.min.x\r\n            Geom::Vector3d.new(dx, 0, 0)\r\n          when :y\r\n            dy = centro_bloco.y < centro_ref.y ? bounds_ref.min.y - bounds_bloco.max.y : bounds_ref.max.y - bounds_bloco.min.y\r\n            Geom::Vector3d.new(0, dy, 0)\r\n          when :z\r\n            dz = centro_bloco.z < centro_ref.z ? bounds_ref.min.z - bounds_bloco.max.z : bounds_ref.max.z - bounds_bloco.min.z\r\n            Geom::Vector3d.new(0, 0, dz)\r\n          end\r\n        else\r\n          bb1 = bounding_box_global(ref1)\r\n          bb2 = bounding_box_global(ref2)\r\n          bb_bloco = bounding_box_global(@alvo)\r\n          eixo = detectar_eixo_de_maior_separacao(bb1, bb2)\r\n          min1, max1 = bb1.min.send(eixo), bb1.max.send(eixo)\r\n          min2, max2 = bb2.min.send(eixo), bb2.max.send(eixo)\r\n          min_face = [min1, min2].max\r\n          max_face = [max1, max2].min\r\n          centro_alvo = bb_bloco.center\r\n          meio = (min_face + max_face) / 2.0\r\n          distancia = meio - centro_alvo.send(eixo)\r\n          case eixo\r\n          when :x then Geom::Vector3d.new(distancia, 0, 0)\r\n          when :y then Geom::Vector3d.new(0, distancia, 0)\r\n          when :z then Geom::Vector3d.new(0, 0, distancia)\r\n          end\r\n        end\r\n\r\n        @alvo.each { |ent| ent.transform!(Geom::Transformation.translation(deslocamento)) }\r\n        limpar_temporarios\r\n        model.commit_operation\r\n      end\r\n\r\n      def detectar_eixo_de_maior_separacao(bounds1, bounds2)\r\n        dx = [bounds1.min.x - bounds2.max.x, bounds2.min.x - bounds1.max.x].max\r\n        dy = [bounds1.min.y - bounds2.max.y, bounds2.min.y - bounds1.max.y].max\r\n        dz = [bounds1.min.z - bounds2.max.z, bounds2.min.z - bounds1.max.z].max\r\n        return :x if dx >= dy && dx >= dz\r\n        return :y if dy >= dz\r\n        :z\r\n      end\r\n\r\n      def bounding_box_global(entidades)\r\n        bb = Geom::BoundingBox.new\r\n        if entidades.respond_to?(:each)\r\n          entidades.each do |e|\r\n            (0..7).each { |i| bb.add(e.definition.bounds.corner(i).transform(e.transformation)) }\r\n          end\r\n        else\r\n          (0..7).each { |i| bb.add(entidades.definition.bounds.corner(i).transform(entidades.transformation)) }\r\n        end\r\n        bb\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      if selection.empty? || !selection.all? { |e| e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance) }\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n\r\n      alvo = selection.to_a\r\n      model.select_tool(CentralizadorTool.new(alvo))\r\n    end\r\n  end\r\nend\r\n\r\nScriptUpComunidade::CentralizadorInterativo.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "puxar-linhas-95lcr",
    "title": {
      "pt": "Puxar Linhas",
      "en": "Pull Lines",
      "es": "Líneas de tracción"
    },
    "author": "Henrique Barsa",
    "version": "1.0",
    "description": {
      "pt": "Você consegue dar Push/Pull em linhas. Selecione uma ou mais linhas, rode o Script e puxe ela para onde quiser. Use o Shift para travar no eixo.",
      "en": "You can push/pull lines. Select one or more lines, run the script, and drag it to where you want. Use Shift to lock it to the axis.",
      "es": "Puedes mover o arrastrar líneas. Selecciona una o más líneas, ejecuta el script y arrástralo a donde quieras. Usa Mayús para bloquearlo en el eje."
    },
    "keywords": {
      "pt": [
        "linhas",
        "extrusão",
        "puxar"
      ],
      "en": [
        "lines",
        "extrusion",
        "to pull"
      ],
      "es": [
        "pauta",
        "extrusión",
        "tirar"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module ExtrusaoDeArestas\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao => \"Selecione ao menos uma aresta antes de executar.\",\r\n        :status_p1    => \"Extrude: clique no primeiro ponto\",\r\n        :status_p2    => \"Extrude: clique no segundo ponto ou digite distância\",\r\n        :erro_vcb     => \"Não foi possível converter “%s” em comprimento.\",\r\n        :op_nome      => \"Extrudar Arestas\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao => \"Select at least one edge before running.\",\r\n        :status_p1    => \"Extrude: click on the first point\",\r\n        :status_p2    => \"Extrude: click on the second point or type distance\",\r\n        :erro_vcb     => \"Could not convert “%s” into length.\",\r\n        :op_nome      => \"Extrude Edges\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao => \"Seleccione al menos una arista antes de ejecutar.\",\r\n        :status_p1    => \"Extruir: haga clic en el primer punto\",\r\n        :status_p2    => \"Extruir: haga clic en el segundo punto o escriba la distancia\",\r\n        :erro_vcb     => \"No se pudo convertir “%s” en longitud.\",\r\n        :op_nome      => \"Extruir Aristas\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    class ExtrudeLineTool\r\n      CURSOR_MOVE ||= 641\r\n\r\n      def initialize\r\n        @ip1 = Sketchup::InputPoint.new\r\n        @ip2 = Sketchup::InputPoint.new\r\n        @state = 0\r\n        @dragging = false\r\n        @xdown = @ydown = 0\r\n      end\r\n\r\n      def activate\r\n        @edges = Sketchup.active_model.selection.grep(Sketchup::Edge)\r\n        if @edges.empty?\r\n          UI.messagebox(ExtrusaoDeArestas.obter_texto(:erro_selecao))\r\n          Skup.send_action(\"selectSelectionTool:\")\r\n          return\r\n        end\r\n        Sketchup.set_status_text(ExtrusaoDeArestas.obter_texto(:status_p1), SB_PROMPT)\r\n      end\r\n\r\n      def deactivate(view)\r\n        view.invalidate if @state != 0\r\n      end\r\n\r\n      def onSetCursor\r\n        UI.set_cursor(CURSOR_MOVE)\r\n        true\r\n      end\r\n\r\n      def onMouseMove(flags, x, y, view)\r\n        if @state.zero?\r\n          @ip1.pick(view, x, y)\r\n          view.invalidate if @ip1.valid?\r\n          view.tooltip = @ip1.tooltip\r\n        else\r\n          @ip2.pick(view, x, y, @ip1)\r\n          view.invalidate\r\n          Sketchup.set_status_text(@ip1.position.distance(@ip2.position).to_s, SB_VCB_VALUE) if @ip2.valid?\r\n          @dragging = true if (x - @xdown).abs > 5 || (y - @ydown).abs > 5\r\n        end\r\n      end\r\n\r\n      def onLButtonDown(flags, x, y, view)\r\n        if @state.zero?\r\n          @ip1.pick(view, x, y)\r\n          if @ip1.valid?\r\n            @state = 1\r\n            Sketchup.set_status_text(ExtrusaoDeArestas.obter_texto(:status_p2), SB_PROMPT)\r\n            @xdown, @ydown = x, y\r\n          end\r\n        else\r\n          finish_extrude if @ip2.valid?\r\n        end\r\n        view.lock_inference\r\n      end\r\n\r\n      def onLButtonUp(flags, x, y, view)\r\n        finish_extrude if @dragging && @ip2.valid?\r\n      end\r\n\r\n      def onUserText(text, view)\r\n        return unless @state == 1 && @ip2.valid?\r\n        length = text.to_l rescue nil\r\n        unless length\r\n          UI.beep\r\n          UI.messagebox(ExtrusaoDeArestas.obter_texto(:erro_vcb) % text)\r\n          return\r\n        end\r\n        vec = @ip2.position - @ip1.position\r\n        vec.length = length\r\n        finish_extrude(@ip1.position, @ip1.position.offset(vec))\r\n      end\r\n\r\n      def draw(view)\r\n        if @ip1.valid?\r\n          @ip1.draw(view)\r\n          view.draw_points(@ip1.position, 8, 1, \"red\")\r\n        end\r\n        if @ip2.valid?\r\n          @ip2.draw(view)\r\n          view.set_color_from_line(@ip1, @ip2) rescue view.drawing_color = \"black\"\r\n          view.draw_line(@ip1.position, @ip2.position)\r\n          view.draw_points(@ip2.position, 8, 1, \"red\")\r\n\r\n          vector = @ip1.position.vector_to(@ip2.position)\r\n          preview = Sketchup::Color.new(200,200,200,128)\r\n          view.drawing_color = preview\r\n          @edges.each do |edge|\r\n            a = edge.start.position\r\n            b = edge.end.position\r\n            a2 = a.offset(vector)\r\n            b2 = b.offset(vector)\r\n            view.draw(GL_QUADS, [a, b, b2, a2])\r\n            view.draw(GL_LINE_LOOP, [a, b, b2, a2])\r\n          end\r\n          view.drawing_color = \"black\"\r\n        end\r\n      end\r\n\r\n      private\r\n\r\n      def finish_extrude(pt1=@ip1.position, pt2=@ip2.position)\r\n        create_geometry(pt1, pt2)\r\n        Sketchup.send_action(\"selectSelectionTool:\")\r\n      end\r\n\r\n      def create_geometry(p1, p2)\r\n        model = Sketchup.active_model\r\n        model.start_operation(ExtrusaoDeArestas.obter_texto(:op_nome), true)\r\n        vector = p1.vector_to(p2)\r\n        group = model.active_entities.add_group\r\n        ents = group.entities\r\n\r\n        @edges.each do |edge|\r\n          a, b = edge.start.position, edge.end.position\r\n          ents.add_line(a, b)\r\n          ents.add_line(a.offset(vector), b.offset(vector))\r\n          ents.add_line(a, a.offset(vector))\r\n          ents.add_line(b, b.offset(vector))\r\n          ents.add_face(a, b, b.offset(vector), a.offset(vector)) rescue nil\r\n        end\r\n\r\n        group.entities.grep(Sketchup::Face).each { |f| f.reverse! if f.normal.z < 0 }\r\n        model.commit_operation\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      Sketchup.active_model.select_tool(ExtrudeLineTool.new)\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::ExtrusaoDeArestas.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "reexibe-arestas-selecionadas-95n6x",
    "title": {
      "pt": "Reexibe Arestas Selecionadas",
      "en": "Re-display Selected Edges",
      "es": "Volver a mostrar los bordes seleccionados"
    },
    "author": "Fábio Coutinho",
    "version": "1.1",
    "description": {
      "pt": "Reexibe as arestas selecionadas independente se elas estão suavizadas ou ocultas.",
      "en": "Redisplays the selected edges regardless of whether they are smoothed or hidden.",
      "es": "Vuelve a mostrar los bordes seleccionados independientemente de si están suavizados u ocultos."
    },
    "keywords": {
      "pt": [
        "reexibir arestas"
      ],
      "en": [
        "redisplay edges"
      ],
      "es": [
        "volver a mostrar los bordes"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module RemoverSuavizacao\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao => \"Nenhuma entidade selecionada.\",\r\n        :op_nome      => \"Remover Suavização\",\r\n        :concluido    => \"Processo concluído: suavização removida e arestas reexibidas.\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao => \"No entities selected.\",\r\n        :op_nome      => \"Remove Smoothing\",\r\n        :concluido    => \"Process completed: smoothing removed and edges unhidden.\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao => \"Ninguna entidad seleccionada.\",\r\n        :op_nome      => \"Eliminar Suavizado\",\r\n        :concluido    => \"Proceso completado: suavizado eliminado y aristas mostradas.\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      if selection.empty?\r\n        puts obter_texto(:erro_selecao)\r\n      else\r\n        model.start_operation(obter_texto(:op_nome), true)\r\n\r\n        # Trata arestas diretamente na seleção\r\n        selection.grep(Sketchup::Edge).each do |edge|\r\n          processar_aresta(edge)\r\n        end\r\n\r\n        # Itera pelas faces para garantir que arestas conectadas sejam tratadas\r\n        model.active_entities.grep(Sketchup::Face).each do |face|\r\n          face.edges.each do |edge|\r\n            if selection.include?(edge)\r\n              processar_aresta(edge)\r\n            end\r\n          end\r\n        end\r\n\r\n        model.commit_operation\r\n        puts obter_texto(:concluido)\r\n      end\r\n    end\r\n\r\n    def self.processar_aresta(edge)\r\n      # Reexibe se estiver oculta\r\n      edge.hidden = false\r\n      \r\n      # Remove soft e smooth\r\n      edge.soft = false\r\n      edge.smooth = false\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::RemoverSuavizacao.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "reexibir-tudo-95p9z",
    "title": {
      "pt": "Reexibir tudo",
      "en": "Show all again",
      "es": "Mostrar todo de nuevo"
    },
    "author": "Fábio Coutinho",
    "version": "1.0",
    "description": {
      "pt": "Script para reexibir tudo, na seleção ou no modelo. Grupos, componentes, faces e arestas. Aninhados ou não.",
      "en": "Script to redisplay everything, in the selection or in the model. Groups, components, faces, and edges. Nested or not.",
      "es": "Script para volver a mostrar todo, en la selección o en el modelo. Grupos, componentes, caras y aristas. Anidados o no."
    },
    "keywords": {
      "pt": [
        "reexibir",
        "unhide"
      ],
      "en": [
        "re-air",
        "unhide"
      ],
      "es": [
        "re-emisión",
        "mostrar"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module DesocultarElementos\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :pergunta_modo   => \"Deseja desocultar apenas os elementos selecionados? (Sim para Seleção, Não para Todo o Modelo)\",\r\n        :pergunta_groups => \"Deseja desocultar Grupos e Componentes?\",\r\n        :pergunta_faces  => \"Deseja desocultar Linhas e Faces?\",\r\n        :op_nome         => \"Desocultar Elementos\",\r\n        :sucesso         => \"Todos os elementos selecionados foram desocultados!\"\r\n      },\r\n      'en-US' => {\r\n        :pergunta_modo   => \"Do you want to unhide only the selected elements? (Yes for Selection, No for Entire Model)\",\r\n        :pergunta_groups => \"Do you want to unhide Groups and Components?\",\r\n        :pergunta_faces  => \"Do you want to unhide Edges and Faces?\",\r\n        :op_nome         => \"Unhide Elements\",\r\n        :sucesso         => \"All selected elements have been unhidden!\"\r\n      },\r\n      'es' => {\r\n        :pergunta_modo   => \"¿Desea desocultar solo los elementos seleccionados? (Sí para Selección, No para todo el Modelo)\",\r\n        :pergunta_groups => \"¿Desea desocultar Grupos y Componentes?\",\r\n        :pergunta_faces  => \"¿Desea desocultar Líneas y Caras?\",\r\n        :op_nome         => \"Desocultar Elementos\",\r\n        :sucesso         => \"¡Todos los elementos seleccionados han sido desocultados!\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.ask_user(question)\r\n      result = UI.messagebox(question, MB_YESNO)\r\n      result == IDYES\r\n    end\r\n\r\n    def self.unhide_groups_and_components(entities)\r\n      entities.each do |entity|\r\n        if entity.is_a?(Sketchup::Group) || entity.is_a?(Sketchup::ComponentInstance)\r\n          entity.hidden = false\r\n          unhide_groups_and_components(entity.definition.entities)\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.unhide_faces_and_edges(entities)\r\n      entities.each do |entity|\r\n        if entity.is_a?(Sketchup::Edge) || entity.is_a?(Sketchup::Face)\r\n          entity.hidden = false\r\n        elsif entity.is_a?(Sketchup::Group) || entity.is_a?(Sketchup::ComponentInstance)\r\n          # Percorre dentro de grupos/componentes já desocultados\r\n          unhide_faces_and_edges(entity.definition.entities)\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      # Perguntar se deseja agir na seleção ou no modelo inteiro\r\n      use_selection = ask_user(obter_texto(:pergunta_modo))\r\n\r\n      entities = use_selection && !selection.empty? ? selection : model.active_entities\r\n\r\n      # Perguntar se quer desocultar grupos e componentes\r\n      unhide_groups = ask_user(obter_texto(:pergunta_groups))\r\n      \r\n      # Perguntar se quer desocultar arestas e faces\r\n      unhide_faces = ask_user(obter_texto(:pergunta_faces))\r\n\r\n      # Processar os elementos\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n\r\n      # Primeiro, desocultar grupos e componentes, se permitido\r\n      unhide_groups_and_components(entities) if unhide_groups\r\n\r\n      # Depois, garantir que arestas e faces sejam desocultadas\r\n      unhide_faces_and_edges(entities) if unhide_faces\r\n\r\n      model.commit_operation\r\n\r\n      UI.messagebox(obter_texto(:sucesso))\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::DesocultarElementos.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "remover-elementos-ocultos-95rnh",
    "title": {
      "pt": "Remover Elementos Ocultos",
      "en": "Remove Hidden Elements",
      "es": "Eliminar elementos ocultos"
    },
    "author": "Fábio Coutinho",
    "version": "1.0",
    "description": {
      "pt": "Apaga todos os grupos ou componentes ocultos em qualquer nível de aninhamento, estejam eles dentro de grupos ou componentes boqueados ou não.",
      "en": "Deletes all hidden groups or components at any nesting level, whether they are inside locked groups or components or not.",
      "es": "Elimina todos los grupos o componentes ocultos en cualquier nivel de anidamiento, ya sea que estén dentro de grupos o componentes bloqueados o no."
    },
    "keywords": {
      "pt": [
        "remover ocultos",
        "apagar ocultos",
        "limpar ocultos"
      ],
      "en": [
        "remove hidden",
        "delete hidden",
        "clear hidden"
      ],
      "es": [
        "eliminar oculto",
        "eliminar oculto",
        "claro oculto"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module ApagarOcultosRecursivo\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao => \"Por favor, selecione um componente ou grupo para continuar.\",\r\n        :erro_tipo    => \"A seleção contém itens que não são componentes ou grupos.\",\r\n        :op_nome      => \"Apagar Componentes Ocultos\",\r\n        :concluido    => \"Limpeza concluída: componentes ocultos foram removidos.\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao => \"Please select a component or group to continue.\",\r\n        :erro_tipo    => \"The selection contains items that are not components or groups.\",\r\n        :op_nome      => \"Delete Hidden Components\",\r\n        :concluido    => \"Cleanup complete: hidden components have been removed.\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao => \"Por favor, seleccione un componente o grupo para continuar.\",\r\n        :erro_tipo    => \"La selección contiene elementos que no son componentes o grupos.\",\r\n        :op_nome      => \"Eliminar Componentes Ocultos\",\r\n        :concluido    => \"Limpieza completada: los componentes ocultos han sido eliminados.\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.delete_hidden_entities_recursively(parent_entity)\r\n      # Obtém as entidades da definição (funciona para Grupo e ComponentInstance)\r\n      entities = parent_entity.is_a?(Sketchup::ComponentInstance) ? parent_entity.definition.entities : parent_entity.entities\r\n      \r\n      entities.to_a.each do |entity|\r\n        next unless entity.valid?\r\n        # Verifica se a entidade é um componente ou grupo\r\n        if entity.is_a?(Sketchup::ComponentInstance) || entity.is_a?(Sketchup::Group)\r\n          # Remove o componente se ele estiver oculto\r\n          if entity.hidden?\r\n            entity.erase!\r\n          else\r\n            # Se não estiver oculto, verifica recursivamente\r\n            delete_hidden_entities_recursively(entity)\r\n          end\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      if selection.empty?\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n\r\n      selection.each do |entity|\r\n        if entity.is_a?(Sketchup::ComponentInstance) || entity.is_a?(Sketchup::Group)\r\n          delete_hidden_entities_recursively(entity)\r\n        else\r\n          puts obter_texto(:erro_tipo)\r\n        end\r\n      end\r\n\r\n      model.commit_operation\r\n      puts obter_texto(:concluido)\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::ApagarOcultosRecursivo.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "retirar-tarjas-pretas-v-ray-95t06",
    "title": {
      "pt": "Retirar Tarjas Pretas V-Ray",
      "en": "Remove Black Bars from V-Ray",
      "es": "Eliminar barras negras de V-Ray"
    },
    "author": "Henrique Barsa",
    "version": "1.0",
    "description": {
      "pt": "Retirar as tarjas pretas (safe frame) da visualização.",
      "en": "Remove the black bars (safe frame) from the display.",
      "es": "Retire las barras negras (marco seguro) de la pantalla."
    },
    "keywords": {
      "pt": [
        "vray"
      ],
      "en": [
        "v-ray"
      ],
      "es": [
        "v-ray"
      ]
    },
    "code": {
      "pt": "# Obter o modelo ativo e a câmera ativa\r\nmodel = Sketchup.active_model\r\ncamera = model.active_view.camera\r\n\r\n# Definir o valor L/A (aspect_ratio) para 0\r\ncamera.aspect_ratio = 0\r\n\r\n# Atualizar a vista para aplicar as alterações da câmera\r\nmodel.active_view.camera = camera\r\nmodel.active_view.refresh\r\n\r\n"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "rotacionar-visao-95utc",
    "title": {
      "pt": "Rotacionar Visão",
      "en": "Rotate View",
      "es": "Girar vista"
    },
    "author": "Fábio Coutinho",
    "version": "1.3",
    "description": {
      "pt": "Permite rotacionar a visão usando as setas do teclado ou digitando um ângulo.",
      "en": "Allows you to rotate the view using the keyboard arrows or by typing an angle.",
      "es": "Le permite rotar la vista usando las flechas del teclado o escribiendo un ángulo."
    },
    "keywords": {
      "pt": [
        "rotacionar visão",
        "arfagem",
        "pitch",
        "rolagem"
      ],
      "en": [
        "rotate view",
        "panting",
        "pitch",
        "scrolling"
      ],
      "es": [
        "rotar vista",
        "jadeo",
        "paso",
        "desplazamiento"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module FerramentaGirarVista\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :desativada      => \"Ferramenta de rotação desativada.\",\r\n        :instrucoes      => \"← → ↑ ↓ para girar. Ctrl alterna entre 1° e 90°. Modo atual: %{modo}. Digite ângulo + Enter. ESC para sair.\",\r\n        :modo_1          => \"1°\",\r\n        :modo_90         => \"90°\"\r\n      },\r\n      'en-US' => {\r\n        :desativada      => \"Rotation tool deactivated.\",\r\n        :instrucoes      => \"← → ↑ ↓ to rotate. Ctrl toggles 1°/90°. Current mode: %{modo}. Type angle + Enter. ESC to exit.\",\r\n        :modo_1          => \"1°\",\r\n        :modo_90         => \"90°\"\r\n      },\r\n      'es' => {\r\n        :desativada      => \"Herramienta de rotación desactivada.\",\r\n        :instrucoes      => \"← → ↑ ↓ para girar. Ctrl alterna entre 1° y 90°. Modo actual: %{modo}. Escriba ángulo + Enter. ESC para salir.\",\r\n        :modo_1          => \"1°\",\r\n        :modo_90         => \"90°\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave, variaveis = {})\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      texto  = IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n      \r\n      variaveis.each { |k, v| texto = texto.gsub(\"%{#{k}}\", v.to_s) }\r\n      texto\r\n    end\r\n\r\n    class Tool\r\n      VK_LEFT    = 37 unless defined?(VK_LEFT)\r\n      VK_UP      = 38 unless defined?(VK_UP)\r\n      VK_RIGHT   = 39 unless defined?(VK_RIGHT)\r\n      VK_DOWN    = 40 unless defined?(VK_DOWN)\r\n      VK_ESCAPE  = 27 unless defined?(VK_ESCAPE)\r\n      VK_CONTROL = 17 unless defined?(VK_CONTROL)\r\n\r\n      BASE_ROTATE_SPEED  = 1   unless defined?(BASE_ROTATE_SPEED)\r\n      BOOST_ROTATE_SPEED = 90  unless defined?(BOOST_ROTATE_SPEED)\r\n      TIMER_INTERVAL     = 0.016 unless defined?(TIMER_INTERVAL)\r\n      CURSOR_ID          = 643 unless defined?(CURSOR_ID)\r\n\r\n      def initialize\r\n        @rotate_left = false\r\n        @rotate_right = false\r\n        @rotate_up = false\r\n        @rotate_down = false\r\n        @use_boost = false\r\n        @timer_id = nil\r\n        start_rotation_timer\r\n      end\r\n\r\n      def activate\r\n        update_status_text\r\n      end\r\n\r\n      def deactivate(view)\r\n        stop_rotation_timer\r\n        Sketchup.status_text = FerramentaGirarVista.obter_texto(:desativada)\r\n      end\r\n\r\n      def getCursor\r\n        CURSOR_ID\r\n      end\r\n\r\n      def onKeyDown(key, repeat, flags, view)\r\n        case key\r\n        when VK_LEFT\r\n          if @use_boost\r\n            rotate_view(-BOOST_ROTATE_SPEED, :roll)\r\n          else\r\n            @rotate_left = true\r\n          end\r\n        when VK_RIGHT\r\n          if @use_boost\r\n            rotate_view(+BOOST_ROTATE_SPEED, :roll)\r\n          else\r\n            @rotate_right = true\r\n          end\r\n        when VK_UP\r\n          if @use_boost\r\n            rotate_view(+BOOST_ROTATE_SPEED, :tilt)\r\n          else\r\n            @rotate_up = true\r\n          end\r\n        when VK_DOWN\r\n          if @use_boost\r\n            rotate_view(-BOOST_ROTATE_SPEED, :tilt)\r\n          else\r\n            @rotate_down = true\r\n          end\r\n        when VK_CONTROL\r\n          @use_boost = !@use_boost\r\n          update_status_text\r\n        when VK_ESCAPE\r\n          Sketchup.active_model.tools.pop_tool\r\n        end\r\n      end\r\n\r\n      def onKeyUp(key, repeat, flags, view)\r\n        case key\r\n        when VK_LEFT    then @rotate_left = false\r\n        when VK_RIGHT   then @rotate_right = false\r\n        when VK_UP      then @rotate_up = false\r\n        when VK_DOWN    then @rotate_down = false\r\n        end\r\n      end\r\n\r\n      def onUserText(text, view)\r\n        if text.strip == \"0\"\r\n          reset_view_orientation\r\n        else\r\n          angle = text.to_f\r\n          rotate_view(angle, :roll) if angle != 0\r\n        end\r\n      end\r\n\r\n      def onCancel(reason, view)\r\n        Sketchup.active_model.tools.pop_tool\r\n      end\r\n\r\n      private\r\n\r\n      def update_status_text\r\n        modo_str = @use_boost ? FerramentaGirarVista.obter_texto(:modo_90) : FerramentaGirarVista.obter_texto(:modo_1)\r\n        Sketchup.status_text = FerramentaGirarVista.obter_texto(:instrucoes, { modo: modo_str })\r\n      end\r\n\r\n      def start_rotation_timer\r\n        @timer_id = UI.start_timer(TIMER_INTERVAL, true) {\r\n          next if @use_boost  # no modo 90°, não repetir rotação automática\r\n          speed = BASE_ROTATE_SPEED\r\n          rotate_view(-speed, :roll) if @rotate_left\r\n          rotate_view(+speed, :roll) if @rotate_right\r\n          rotate_view(+speed, :tilt) if @rotate_up\r\n          rotate_view(-speed, :tilt) if @rotate_down\r\n        }\r\n      end\r\n\r\n      def stop_rotation_timer\r\n        UI.stop_timer(@timer_id) if @timer_id\r\n        @timer_id = nil\r\n      end\r\n\r\n      def rotate_view(degrees, mode = :roll)\r\n        return if degrees == 0\r\n        cam = Sketchup.active_model.active_view.camera\r\n        eye = cam.eye\r\n        target = cam.target\r\n        up = cam.up\r\n        direction = target - eye\r\n        radians = degrees.degrees\r\n\r\n        case mode\r\n        when :roll\r\n          new_up = up.transform(Geom::Transformation.rotation(eye, direction, radians))\r\n          return if invalid_camera?(direction, new_up)\r\n          cam.set(eye, target, new_up)\r\n        when :tilt\r\n          axis = direction * up  # eixo lateral\r\n          t = Geom::Transformation.rotation(eye, axis, radians)\r\n          new_target = target.transform(t)\r\n          new_up = up.transform(t)\r\n          new_direction = new_target - eye\r\n          return if invalid_camera?(new_direction, new_up)\r\n          cam.set(eye, new_target, new_up)\r\n        end\r\n      end\r\n\r\n      def invalid_camera?(direction, up)\r\n        dot = direction.normalize.dot(up.normalize).abs\r\n        dot > 0.999\r\n      end\r\n\r\n      def reset_view_orientation\r\n        cam = Sketchup.active_model.active_view.camera\r\n        eye = cam.eye\r\n        target = cam.target\r\n        cam.set(eye, target, Z_AXIS)\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      Sketchup.active_model.tools.push_tool(Tool.new)\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::FerramentaGirarVista.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "selecao-de-elemento-profundo-95whk",
    "title": {
      "pt": "Seleção de Elemento Profundo",
      "en": "Deep Element Selection",
      "es": "Selección de elementos profundos"
    },
    "author": "Fábio Coutinho",
    "version": "1.9",
    "description": {
      "pt": "Ferramenta de seleção de grupo/componente ou face em níveis mais profundos de aninhamento de forma direta. Caso esteja com segmentos de arestas selecionados, você pode enviá-lo diretamente para a face profunda com dois cliques. Isso permite planejar cortes para faces internas.",
      "en": "This tool allows you to select groups/components or faces directly at deeper nesting levels. If you have edge segments selected, you can send them directly to the deep face with two clicks. This allows you to plan cuts for internal faces.",
      "es": "Esta herramienta permite seleccionar grupos/componentes o caras directamente en niveles de anidamiento más profundos. Si tiene segmentos de arista seleccionados, puede enviarlos directamente a la cara profunda con dos clics. Esto le permite planificar cortes para caras internas."
    },
    "keywords": {
      "pt": [
        "seleção de nível",
        "selecionar subgrupo"
      ],
      "en": [
        "level selection",
        "select subgroup"
      ],
      "es": [
        "selección de nivel",
        "seleccionar subgrupo"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module SelecaoHierarquia\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :msg_copiar      => \"Deseja usar o segmento selecionado para copiar?\",\r\n        :modo_gp_comp    => \"Modo: Grupo/Componente\",\r\n        :modo_face_edge  => \"Modo: Face/Aresta\",\r\n        :status_gp_comp  => \"Grupo/Componente\",\r\n        :status_face_ed  => \"Face/Aresta\",\r\n        :prompt_status   => \"Modo atual: %{mode} | Ctrl para alternar modo | Duplo clique ou Enter para entrar no contexto | Esc para voltar ao nível do modelo\",\r\n        :op_colar        => \"Colar no local (desagrupado)\"\r\n      },\r\n      'en-US' => {\r\n        :msg_copiar      => \"Do you want to use the selected segment to copy?\",\r\n        :modo_gp_comp    => \"Mode: Group/Component\",\r\n        :modo_face_edge  => \"Mode: Face/Edge\",\r\n        :status_gp_comp  => \"Group/Component\",\r\n        :status_face_ed  => \"Face/Edge\",\r\n        :prompt_status   => \"Current mode: %{mode} | Ctrl to toggle mode | Double click or Enter to enter context | Esc to return to model level\",\r\n        :op_colar        => \"Paste in place (exploded)\"\r\n      },\r\n      'es' => {\r\n        :msg_copiar      => \"¿Desea utilizar el segmento seleccionado para copiar?\",\r\n        :modo_gp_comp    => \"Modo: Grupo/Componente\",\r\n        :modo_face_edge  => \"Modo: Cara/Arista\",\r\n        :status_gp_comp  => \"Grupo/Componente\",\r\n        :status_face_ed  => \"Cara/Arista\",\r\n        :prompt_status   => \"Modo actual: %{mode} | Ctrl para cambiar modo | Doble clic o Enter para entrar en el contexto | Esc para volver al nivel del modelo\",\r\n        :op_colar        => \"Pegar en su lugar (desagrupado)\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave, variaveis = {})\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      texto  = IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n      \r\n      variaveis.each { |k, v| texto = texto.gsub(\"%{#{k}}\", v.to_s) }\r\n      texto\r\n    end\r\n\r\n    class HoverSelectionTool\r\n      VK_RETURN  ||= 13\r\n      VK_CONTROL ||= 17\r\n      VK_ESCAPE  ||= 27\r\n\r\n      def initialize(ctrl_locked: false, post_enter_action: nil, clipboard_group: nil)\r\n        @model = Sketchup.active_model\r\n        @view = @model.active_view\r\n        @selection_mode = ctrl_locked ? :face_edge : :group_component\r\n        @ctrl_locked = ctrl_locked\r\n        @post_enter_action = post_enter_action\r\n        @clipboard_group = clipboard_group\r\n        @selected_entity = nil\r\n        @selected_instance_path = nil\r\n        @last_mouse_x = nil\r\n        @last_mouse_y = nil\r\n      end\r\n\r\n      def activate\r\n        update_status_text\r\n      end\r\n\r\n      def resume(view)\r\n        update_status_text\r\n        view.invalidate\r\n      end\r\n\r\n      def onMouseMove(flags, x, y, view)\r\n        @last_mouse_x = x\r\n        @last_mouse_y = y\r\n        update_selection(x, y, view)\r\n        highlight_entity(view)\r\n        view.invalidate\r\n      end\r\n\r\n      def onKeyDown(key, repeat, flags, view)\r\n        case key\r\n        when VK_CONTROL\r\n          toggle_selection_mode(view) unless @ctrl_locked\r\n        when VK_RETURN\r\n          refresh_selection_from_last_position(view)\r\n          enter_parent_context(view)\r\n        when VK_ESCAPE\r\n          exit_to_model_level\r\n        end\r\n      end\r\n\r\n      def onLButtonDoubleClick(flags, x, y, view)\r\n        refresh_selection_from_last_position(view)\r\n        enter_parent_context(view)\r\n      end\r\n\r\n      def refresh_selection_from_last_position(view)\r\n        return unless @last_mouse_x && @last_mouse_y\r\n        update_selection(@last_mouse_x, @last_mouse_y, view)\r\n        highlight_entity(view)\r\n      end\r\n\r\n      def update_selection(x, y, view)\r\n        ph = view.pick_helper\r\n        ph.do_pick(x, y)\r\n\r\n        case @selection_mode\r\n        when :group_component\r\n          @selected_entity, @selected_instance_path = find_deepest_group_or_component(ph)\r\n        when :face_edge\r\n          @selected_entity, @selected_instance_path = find_deepest_face_or_edge(ph)\r\n        end\r\n      end\r\n\r\n      def find_deepest_group_or_component(pick_helper)\r\n        path = pick_helper.path_at(0)\r\n        return nil, nil if path.nil?\r\n        entity = path.reverse.find { |e| e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance) }\r\n        return entity, build_instance_path(path) if entity\r\n        return nil, nil\r\n      end\r\n\r\n      def find_deepest_face_or_edge(pick_helper)\r\n        path = pick_helper.path_at(0)\r\n        return nil, nil if path.nil?\r\n        entity = path.reverse.find { |e| e.is_a?(Sketchup::Face) || e.is_a?(Sketchup::Edge) }\r\n        return entity, build_instance_path(path) if entity\r\n        return nil, nil\r\n      end\r\n\r\n      def toggle_selection_mode(view = nil)\r\n        @selection_mode = @selection_mode == :group_component ? :face_edge : :group_component\r\n        update_status_text\r\n        view&.invalidate\r\n      end\r\n\r\n      def onReturn(view)\r\n        refresh_selection_from_last_position(view)\r\n        enter_parent_context(view)\r\n      end\r\n\r\n      def enter_parent_context(view = nil)\r\n        return unless @selected_instance_path\r\n\r\n        target_path = target_instance_path_for_enter\r\n        return unless target_path\r\n\r\n        @model.active_path = target_path\r\n\r\n        if @post_enter_action == :paste_in_place && @clipboard_group\r\n          model = Sketchup.active_model\r\n          target_entities = model.active_entities\r\n          tr = @clipboard_group.transformation\r\n          group_def = @clipboard_group.definition\r\n\r\n          model.start_operation(SelecaoHierarquia.obter_texto(:op_colar), true)\r\n\r\n          temp_group_instance = target_entities.add_instance(group_def, tr)\r\n          exploded = temp_group_instance.explode\r\n          @clipboard_group.erase!\r\n          valid_classes = [\r\n            Sketchup::Edge,\r\n            Sketchup::Face,\r\n            Sketchup::Group,\r\n            Sketchup::ComponentInstance,\r\n            Sketchup::ConstructionLine,\r\n            Sketchup::ConstructionPoint,\r\n            Sketchup::Image\r\n          ]\r\n\r\n          safe_selection = Array(exploded).flatten.compact.select { |e|\r\n            valid_classes.include?(e.class) \r\n          }\r\n\r\n          model.selection.clear\r\n          model.selection.add(safe_selection) unless safe_selection.empty?\r\n          model.commit_operation\r\n        end\r\n\r\n        Sketchup.active_model.select_tool(nil)\r\n      end\r\n\r\n      def onCancel(reason, view)\r\n        exit_to_model_level\r\n      end\r\n\r\n      def draw(view)\r\n        return unless @last_mouse_x && @last_mouse_y\r\n\r\n        mode_text = @selection_mode == :group_component ? \r\n          SelecaoHierarquia.obter_texto(:modo_gp_comp) : \r\n          SelecaoHierarquia.obter_texto(:modo_face_edge)\r\n        \r\n        offset_x = 14\r\n        offset_y = 18\r\n\r\n        screen_point = Geom::Point3d.new(@last_mouse_x + offset_x, @last_mouse_y + offset_y, 0)\r\n\r\n        view.draw_text(\r\n          Geom::Point3d.new(screen_point.x + 1, screen_point.y + 1, 0),\r\n          mode_text,\r\n          color: Sketchup::Color.new(0, 0, 0),\r\n          size: 12\r\n        )\r\n\r\n        view.draw_text(\r\n          screen_point,\r\n          mode_text,\r\n          color: Sketchup::Color.new(230, 30, 30),\r\n          size: 12\r\n        )\r\n      end\r\n\r\n      private\r\n\r\n      def build_instance_path(path)\r\n        instance_entities = path.select { |e| e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance) }\r\n        return nil if instance_entities.empty?\r\n\r\n        active_prefix = @model.active_path ? @model.active_path.to_a : []\r\n\r\n        if !active_prefix.empty? && instance_entities.first == active_prefix.last\r\n          instance_entities = instance_entities[1..] || []\r\n        end\r\n\r\n        return nil if active_prefix.empty? && instance_entities.empty?\r\n        Sketchup::InstancePath.new(active_prefix + instance_entities)\r\n      end\r\n\r\n      def exit_to_model_level\r\n        @model.active_path = nil if @model.active_path\r\n        @model.selection.clear\r\n        @view.invalidate\r\n        Sketchup.active_model.select_tool(nil)\r\n      end\r\n\r\n      def target_instance_path_for_enter\r\n        case @selection_mode\r\n        when :group_component\r\n          entities = @selected_instance_path.to_a.select do |e|\r\n            e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance)\r\n          end\r\n          return nil if entities.size <= 1\r\n          Sketchup::InstancePath.new(entities[0...-1])\r\n        else\r\n          @selected_instance_path\r\n        end\r\n      end\r\n\r\n      def update_status_text\r\n        mode_label = @selection_mode == :group_component ? \r\n          SelecaoHierarquia.obter_texto(:status_gp_comp) : \r\n          SelecaoHierarquia.obter_texto(:status_face_ed)\r\n        \r\n        status = SelecaoHierarquia.obter_texto(:prompt_status, { mode: mode_label })\r\n        Sketchup::set_status_text(status, SB_PROMPT)\r\n      end\r\n\r\n      def highlight_entity(view)\r\n        return unless @selected_entity\r\n        view.model.selection.clear\r\n        view.model.selection.add(@selected_entity)\r\n        view.invalidate\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      if !selection.empty? && selection.all? { |e| e.is_a?(Sketchup::Edge) }\r\n        result = UI.messagebox(obter_texto(:msg_copiar), MB_YESNO)\r\n        if result == IDYES\r\n          clipboard_group = model.active_entities.add_group(selection.to_a)\r\n          clipboard_group.name = \"TEMP_CLIPBOARD_GROUP\"\r\n          model.active_entities.erase_entities(selection.to_a)\r\n\r\n          tool = HoverSelectionTool.new(ctrl_locked: true, post_enter_action: :paste_in_place, clipboard_group: clipboard_group)\r\n          model.select_tool(tool)\r\n          tool.activate\r\n          return\r\n        end\r\n      end\r\n\r\n      tool = HoverSelectionTool.new\r\n      model.select_tool(tool)\r\n      tool.activate\r\n    end\r\n  end\r\nend\r\n\r\nScriptUpComunidade::SelecaoHierarquia.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "selecao-de-sequencia-de-arestas-95ylz",
    "title": {
      "pt": "Seleção de Sequência de Arestas",
      "en": "Edge Sequence Selection",
      "es": "Selección de secuencia de aristas"
    },
    "author": "Fábio Coutinho",
    "version": "1.2",
    "description": {
      "pt": "Seleciona uma sequência de arestas a partir da seleção e de acordo com o ângulo informado.",
      "en": "Selects a sequence of edges from the selection and according to the specified angle.",
      "es": "Selecciona una secuencia de bordes de la selección y de acuerdo con el ángulo especificado."
    },
    "keywords": {
      "pt": [
        "seleção de arestas"
      ],
      "en": [
        "edge selection"
      ],
      "es": [
        "selección de bordes"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module SelecaoPorAngulo\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :titulo_janela   => \"Seleção de Arestas por Ângulo\",\r\n        :cabecalho       => \"Selecionar Arestas por Ângulo\",\r\n        :label_slider    => \"Ângulo Máximo (0º a 180º)\",\r\n        :botao_atualizar => \"Atualizar Seleção Base\",\r\n        :erro_selecao    => \"Selecione ao menos uma aresta.\",\r\n        :sucesso_base    => \"Nova seleção base atualizada.\"\r\n      },\r\n      'en-US' => {\r\n        :titulo_janela   => \"Select Edges by Angle\",\r\n        :cabecalho       => \"Select Edges by Angle\",\r\n        :label_slider    => \"Maximum Angle (0º to 180º)\",\r\n        :botao_atualizar => \"Update Base Selection\",\r\n        :erro_selecao    => \"Please select at least one edge.\",\r\n        :sucesso_base    => \"New base selection updated.\"\r\n      },\r\n      'es' => {\r\n        :titulo_janela   => \"Selección de Aristas por Ángulo\",\r\n        :cabecalho       => \"Seleccionar Aristas por Ángulo\",\r\n        :label_slider    => \"Ángulo Máximo (0º a 180º)\",\r\n        :botao_atualizar => \"Actualizar Selección Base\",\r\n        :erro_selecao    => \"Seleccione al menos una arista.\",\r\n        :sucesso_base    => \"Nueva selección base actualizada.\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n      $stored_edges = selection.grep(Sketchup::Edge)\r\n\r\n      dlg = UI::HtmlDialog.new(\r\n        dialog_title: obter_texto(:titulo_janela),\r\n        scrollable: true,\r\n        resizable: true,\r\n        width: 400,\r\n        height: 300,\r\n        style: UI::HtmlDialog::STYLE_DIALOG\r\n      )\r\n\r\n      html = <<-HTML\r\n      <!DOCTYPE html>\r\n      <html>\r\n      <head>\r\n        <meta charset=\"UTF-8\">\r\n        <style>\r\n          body {\r\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\r\n            margin: 20px;\r\n          }\r\n          h2 {\r\n            font-size: 18px;\r\n            margin-bottom: 10px;\r\n            color: #323232;\r\n          }\r\n          .form-group {\r\n            margin-bottom: 15px;\r\n          }\r\n          .form-label {\r\n            margin-bottom: 5px;\r\n            font-weight: 600;\r\n          }\r\n          input[type=range] {\r\n            width: 100%;\r\n          }\r\n          .value-display {\r\n            text-align: center;\r\n            font-size: 16px;\r\n            margin-top: 10px;\r\n            font-weight: bold;\r\n          }\r\n          button {\r\n            margin-top: 20px;\r\n            width: 100%;\r\n            padding: 10px;\r\n            background-color: #0078d4;\r\n            color: white;\r\n            border: none;\r\n            border-radius: 4px;\r\n            font-weight: bold;\r\n            cursor: pointer;\r\n          }\r\n          button:hover {\r\n            background-color: #005a9e;\r\n          }\r\n        </style>\r\n      </head>\r\n      <body>\r\n        <h2>#{obter_texto(:cabecalho)}</h2>\r\n        <div class=\"form-group\">\r\n          <label class=\"form-label\" for=\"angleRange\">#{obter_texto(:label_slider)}</label>\r\n          <input type=\"range\" min=\"0\" max=\"180\" value=\"25\" id=\"angleRange\" />\r\n          <div class=\"value-display\" id=\"angleValue\">25°</div>\r\n        </div>\r\n        <button onclick=\"updateBase()\">#{obter_texto(:botao_atualizar)}</button>\r\n\r\n        <script>\r\n          const slider = document.getElementById('angleRange');\r\n          const display = document.getElementById('angleValue');\r\n\r\n          slider.oninput = function() {\r\n            const value = parseInt(this.value);\r\n            display.innerText = value + '°';\r\n            sketchup.update_angle(value);\r\n          };\r\n\r\n          function updateBase() {\r\n            sketchup.update_selection();\r\n          }\r\n        </script>\r\n      </body>\r\n      </html>\r\n      HTML\r\n\r\n      dlg.set_html(html)\r\n\r\n      dlg.add_action_callback(\"update_angle\") do |dialog, value|\r\n        angle = value.to_f\r\n        max_angle_rad = angle * Math::PI / 180.0\r\n        final_edges = []\r\n\r\n        if $stored_edges\r\n          $stored_edges.each { |edge|\r\n            [edge.start, edge.end].each { |start_vertex|\r\n              current_edge = edge\r\n              current_vertex = start_vertex\r\n              chain = [current_edge]\r\n\r\n              loop do\r\n                other_vertex = current_edge.other_vertex(current_vertex)\r\n                connected_edges = other_vertex.edges - [current_edge] - chain\r\n\r\n                min_angle = nil\r\n                next_edge = nil\r\n\r\n                connected_edges.each { |e|\r\n                  vec1 = current_vertex.position.vector_to(other_vertex.position)\r\n                  vec2 = e.start == other_vertex ? e.start.position.vector_to(e.end.position) : e.end.position.vector_to(e.start.position)\r\n                  ang = vec1.angle_between(vec2)\r\n\r\n                  if ang <= max_angle_rad && (min_angle.nil? || ang < min_angle)\r\n                    min_angle = ang\r\n                    next_edge = e\r\n                  end\r\n                }\r\n\r\n                break unless next_edge\r\n                chain << next_edge\r\n                current_vertex = other_vertex\r\n                current_edge = next_edge\r\n              end\r\n\r\n              final_edges.concat(chain)\r\n            }\r\n          }\r\n\r\n          model.selection.clear\r\n          model.selection.add(final_edges.uniq)\r\n        end\r\n      end\r\n\r\n      dlg.add_action_callback(\"update_selection\") do |dialog, _|\r\n        new_edges = model.selection.grep(Sketchup::Edge)\r\n        if new_edges.empty?\r\n          UI.messagebox(obter_texto(:erro_selecao))\r\n        else\r\n          $stored_edges = new_edges\r\n          UI.messagebox(obter_texto(:sucesso_base))\r\n        end\r\n      end\r\n\r\n      dlg.show\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::SelecaoPorAngulo.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "suavizar-arestas-por-angulo-96110",
    "title": {
      "pt": "Suavizar Arestas por Ângulo",
      "en": "Smooth Edges by Angle",
      "es": "Bordes suaves por ángulo"
    },
    "author": "Fábio Coutinho",
    "version": "1.0",
    "description": {
      "pt": "Navega por todos os grupos e componentes aninhados dentro da seleção, aplicando suavização automática nas arestas entre faces adjacentes. A suavização só é aplicada se o ângulo entre as faces for menor ou igual ao valor definido pelo usuário.",
      "en": "Navigates through all nested groups and components within the selection, applying automatic smoothing to the edges between adjacent faces. Smoothing is only applied if the angle between the faces is less than or equal to the value defined by the user.",
      "es": "Navega por todos los grupos y componentes anidados de la selección, aplicando suavizado automático a los bordes entre caras adyacentes. El suavizado solo se aplica si el ángulo entre las caras es menor o igual al valor definido por el usuario."
    },
    "keywords": {
      "pt": [
        "suavizar",
        "arestas",
        "suavização automática"
      ],
      "en": [
        "soften",
        "edges",
        "automatic smoothing"
      ],
      "es": [
        "ablandar",
        "bordes",
        "suavizado automático"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module SuavizarArestasInterativo\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao    => \"Selecione um único grupo ou componente para aplicar o suavizador.\",\r\n        :op_suavizar     => \"Suavizar Arestas\",\r\n        :titulo_janela   => \"Suavizar Arestas Interativo\",\r\n        :label_angulo    => \"Ângulo Máximo para Suavização\",\r\n        :btn_fechar      => \"Fechar\",\r\n        :btn_aplicar     => \"Aplicar\",\r\n        :status_concluido => \"Concluído\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao    => \"Select a single group or component to apply the smoother.\",\r\n        :op_suavizar     => \"Soften Edges\",\r\n        :titulo_janela   => \"Interactive Soften Edges\",\r\n        :label_angulo    => \"Maximum Angle for Softening\",\r\n        :btn_fechar      => \"Close\",\r\n        :btn_aplicar     => \"Apply\",\r\n        :status_concluido => \"Done\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao    => \"Seleccione un solo grupo o componente para aplicar el suavizador.\",\r\n        :op_suavizar     => \"Suavizar Aristas\",\r\n        :titulo_janela   => \"Suavizar Aristas Interactivo\",\r\n        :label_angulo    => \"Ángulo Máximo para Suavización\",\r\n        :btn_fechar      => \"Cerrar\",\r\n        :btn_aplicar     => \"Aplicar\",\r\n        :status_concluido => \"Concluido\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.iniciar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      unless selection.length == 1 && (selection.first.is_a?(Sketchup::Group) || selection.first.is_a?(Sketchup::ComponentInstance))\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n\r\n      @entidade_raiz = selection.first\r\n      @transformacao_raiz = @entidade_raiz.transformation\r\n\r\n      mostrar_interface\r\n    end\r\n\r\n    def self.aplicar_suavizacao(angulo_graus)\r\n      model = Sketchup.active_model\r\n      view = model.active_view\r\n      model.start_operation(obter_texto(:op_suavizar), true)\r\n\r\n      @dialog.execute_script(\"atualizar_progresso(0)\")\r\n      angulo_radianos = angulo_graus.to_f.degrees\r\n\r\n      contar_total = contar_arestas(@entidade_raiz)\r\n      @processadas = 0\r\n      @total_arestas = contar_total\r\n\r\n      suavizar_entidade(@entidade_raiz, @transformacao_raiz, angulo_radianos)\r\n\r\n      @dialog.execute_script(\"atualizar_progresso(100)\")\r\n      model.commit_operation\r\n      view.invalidate\r\n    end\r\n\r\n    def self.contar_arestas(entidade)\r\n      total = 0\r\n      if entidade.is_a?(Sketchup::Group) || entidade.is_a?(Sketchup::ComponentInstance)\r\n        definicao = entidade.definition\r\n        definicao.entities.each do |e|\r\n          if e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance)\r\n            total += contar_arestas(e)\r\n          elsif e.is_a?(Sketchup::Edge) && e.faces.length == 2\r\n            total += 1\r\n          end\r\n        end\r\n      end\r\n      total\r\n    end\r\n\r\n    def self.suavizar_entidade(entidade, tr_global, angulo_maximo)\r\n      if entidade.is_a?(Sketchup::Group) || entidade.is_a?(Sketchup::ComponentInstance)\r\n        definicao = entidade.definition\r\n        tr_local = entidade.transformation\r\n        nova_tr = tr_global * tr_local\r\n\r\n        definicao.entities.each do |e|\r\n          if e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance)\r\n            suavizar_entidade(e, nova_tr, angulo_maximo)\r\n          elsif e.is_a?(Sketchup::Edge) && e.faces.length == 2\r\n            suavizar_ou_nao(e, angulo_maximo)\r\n          end\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.suavizar_ou_nao(aresta, angulo_maximo)\r\n      faces = aresta.faces\r\n      return unless faces.length == 2\r\n\r\n      normal1 = faces[0].normal\r\n      normal2 = faces[1].normal\r\n      return unless normal1 && normal2\r\n\r\n      angulo = normal1.angle_between(normal2)\r\n\r\n      if angulo <= angulo_maximo\r\n        aresta.soft = true\r\n        aresta.smooth = true\r\n      else\r\n        aresta.soft = false\r\n        aresta.smooth = false\r\n      end\r\n\r\n      @processadas += 1\r\n      if @processadas % 100 == 0 || @processadas == @total_arestas\r\n        progresso = ((@processadas.to_f / @total_arestas) * 100).round\r\n        @dialog.execute_script(\"atualizar_progresso(#{progresso})\")\r\n      end\r\n    end\r\n\r\n    def self.mostrar_interface\r\n      @dialog = UI::HtmlDialog.new({\r\n        dialog_title: obter_texto(:titulo_janela),\r\n        width: 500,\r\n        height: 260,\r\n        style: UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n\r\n      html = <<-HTML\r\n        <!DOCTYPE html>\r\n        <html>\r\n        <head>\r\n          <meta charset=\"UTF-8\">\r\n          <style>\r\n            body { font-family: \"Segoe UI\", Tahoma, sans-serif; padding: 20px; margin: 0; background-color: #f9f9f9; color: #333; }\r\n            h5 { margin-bottom: 16px; font-size: 16px; font-weight: 600; }\r\n            .slider-container { position: relative; width: 100%; padding-top: 24px; }\r\n            input[type=\"range\"] { width: 100%; margin: 0; }\r\n            .tooltip { position: absolute; top: 0; transform: translateX(-50%); background: #0053a0; color: white; padding: 4px 10px; border-radius: 6px; font-size: 13px; white-space: nowrap; }\r\n            .progresso-indicador { margin-top: 24px; text-align: center; font-size: 14px; font-weight: bold; color: #0053a0; }\r\n            .button-container { text-align: center; margin-top: 24px; }\r\n            button { min-width: 140px; padding: 8px 20px; font-weight: 600; font-size: 14px; border: none; border-radius: 6px; cursor: pointer; color: white; }\r\n            .btn-primary { background-color: #0053a0; }\r\n            .btn-success { background-color: #2e8540; }\r\n            .btn-primary:hover { background-color: #003d7a; }\r\n            .btn-success:hover { background-color: #256e34; }\r\n          </style>\r\n        </head>\r\n        <body>\r\n          <h5>#{obter_texto(:label_angulo)}</h5>\r\n          <div class=\"slider-container\">\r\n            <div id=\"tooltip\" class=\"tooltip\">85°</div>\r\n            <input id=\"slider\" type=\"range\" min=\"0\" max=\"180\" step=\"1\" value=\"85\" oninput=\"onSliderChange(this.value)\">\r\n          </div>\r\n          <div id=\"progresso_texto\" class=\"progresso-indicador\">0%</div>\r\n          <div class=\"button-container\">\r\n            <button id=\"actionButton\" class=\"btn-primary\" onclick=\"botaoAcao()\">#{obter_texto(:btn_fechar)}</button>\r\n          </div>\r\n          <script>\r\n            const slider = document.getElementById(\"slider\");\r\n            const tooltip = document.getElementById(\"tooltip\");\r\n            const button = document.getElementById(\"actionButton\");\r\n            const txt_fechar = \"#{obter_texto(:btn_fechar)}\";\r\n            const txt_aplicar = \"#{obter_texto(:btn_aplicar)}\";\r\n            const txt_concluido = \"#{obter_texto(:status_concluido)}\";\r\n            let valorAplicado = \"85\";\r\n\r\n            function onSliderChange(valor) {\r\n              tooltip.innerText = valor + \"°\";\r\n              atualizarTooltip();\r\n              if (valor !== valorAplicado) {\r\n                button.innerText = txt_aplicar;\r\n                button.className = \"btn-success\";\r\n              } else {\r\n                button.innerText = txt_fechar;\r\n                button.className = \"btn-primary\";\r\n              }\r\n            }\r\n\r\n            function botaoAcao() {\r\n              const valorAtual = slider.value;\r\n              if (button.innerText === txt_aplicar) {\r\n                atualizar_progresso(0);\r\n                sketchup.aplicar_angulo(valorAtual);\r\n                valorAplicado = valorAtual;\r\n                button.innerText = txt_fechar;\r\n                button.className = \"btn-primary\";\r\n              } else {\r\n                sketchup.fechar_janela();\r\n              }\r\n            }\r\n\r\n            function atualizarTooltip() {\r\n              const percent = (slider.value - slider.min) / (slider.max - slider.min);\r\n              const rangeWidth = slider.offsetWidth;\r\n              const pos = percent * (rangeWidth - 16) + 8;\r\n              tooltip.style.left = pos + \"px\";\r\n            }\r\n\r\n            function atualizar_progresso(valor) {\r\n              const texto = document.getElementById(\"progresso_texto\");\r\n              texto.innerText = valor >= 100 ? txt_concluido : valor + \"%\";\r\n            }\r\n\r\n            window.onload = () => {\r\n              atualizarTooltip();\r\n              setTimeout(() => {\r\n                sketchup.aplicar_angulo(slider.value);\r\n              }, 150);\r\n            };\r\n\r\n            slider.addEventListener(\"input\", atualizarTooltip);\r\n          </script>\r\n        </body>\r\n        </html>\r\n      HTML\r\n\r\n      @dialog.set_html(html)\r\n\r\n      @dialog.add_action_callback(\"aplicar_angulo\") do |_, angulo|\r\n        aplicar_suavizacao(angulo.to_f)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"fechar_janela\") do |_|\r\n        @dialog.close\r\n      end\r\n\r\n      @dialog.show\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::SuavizarArestasInterativo.iniciar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "substituir-textura-962k3",
    "title": {
      "pt": "Substituir Textura",
      "en": "Replace Texture",
      "es": "Reemplazar textura"
    },
    "author": "Henrique Barsa",
    "version": "1.0",
    "description": {
      "pt": "Substitua uma textura de todo o projeto, por outra.",
      "en": "Replace one texture throughout the project with another.",
      "es": "Reemplace una textura por otra en todo el proyecto."
    },
    "keywords": {
      "pt": [
        "textura",
        "material",
        "substituir"
      ],
      "en": [
        "texture",
        "material",
        "to replace"
      ],
      "es": [
        "textura",
        "material",
        "reemplazar"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module SubstituirMateriais\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :status_inicial    => \"Selecione o material a ser substituído.\",\r\n        :status_proximo    => \"Selecione outro material para substituir %{material}.\",\r\n        :status_aguarde    => \"Substituindo materiais. Aguarde, por favor...\",\r\n        :op_nome           => \"Substituir Materiais\",\r\n        :default_mat       => \"Padrão\",\r\n        :msg_substituir    => \"Substituir %{material} ...\",\r\n        :msg_por           => \"Substituir %{antigo}\\npor %{novo}\"\r\n      },\r\n      'en-US' => {\r\n        :status_inicial    => \"Select the material to be replaced.\",\r\n        :status_proximo    => \"Select another material to replace %{material}.\",\r\n        :status_aguarde    => \"Replacing materials. Please wait...\",\r\n        :op_nome           => \"Replace Materials\",\r\n        :default_mat       => \"Default\",\r\n        :msg_substituir    => \"Replace %{material} ...\",\r\n        :msg_por           => \"Replace %{antigo}\\nwith %{novo}\"\r\n      },\r\n      'es' => {\r\n        :status_inicial    => \"Seleccione el material que desea reemplazar.\",\r\n        :status_proximo    => \"Seleccione otro material para reemplazar %{material}.\",\r\n        :status_aguarde    => \"Reemplazando materiales. Por favor espere...\",\r\n        :op_nome           => \"Reemplazar Materiales\",\r\n        :default_mat       => \"Predeterminado\",\r\n        :msg_substituir    => \"Reemplazar %{material} ...\",\r\n        :msg_por           => \"Reemplazar %{antigo}\\npor %{novo}\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave, variaveis = {})\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      texto  = IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n      \r\n      variaveis.each { |k, v| texto = texto.gsub(\"%{#{k}}\", v.to_s) }\r\n      texto\r\n    end\r\n\r\n    class MatReplacer\r\n      def initialize\r\n        @picked = nil\r\n        @m_org = nil\r\n        @state = 0\r\n      end\r\n\r\n      def activate\r\n        @picked = nil\r\n        @m_org = nil\r\n        @state = 0\r\n        @pos = [0, 0, 0]\r\n        @drawn = false\r\n        update_ui\r\n        @debug = nil\r\n      end\r\n\r\n      def update_ui\r\n        Sketchup.set_status_text(SubstituirMateriais.obter_texto(:status_inicial))\r\n      end\r\n\r\n      def resume(view)\r\n        update_ui\r\n      end\r\n\r\n      def deactivate(view)\r\n        view.invalidate if @drawn\r\n      end\r\n\r\n      def onMouseMove(flags, x, y, view)\r\n        ph = view.pick_helper\r\n        ph.do_pick(x, y)\r\n\r\n        picked = if ph.picked_face\r\n                   ph.picked_face\r\n                 elsif ph.picked_edge\r\n                   ph.picked_edge\r\n                 else\r\n                   ph.best_picked\r\n                 end\r\n\r\n        index = 0\r\n        for i in 1..ph.count\r\n          if ph.element_at(i) == picked\r\n            index = i\r\n            break\r\n          end\r\n        end\r\n\r\n        path = ph.path_at(index)\r\n        t = ph.transformation_at(index)\r\n\r\n        if path.nil?\r\n          @picked = nil\r\n        else\r\n          @picked = nil\r\n          n = (picked.is_a?(Sketchup::Face)) ? picked.normal.transform(t).normalize : nil\r\n          path.each do |e|\r\n            next unless e.respond_to?(:material)\r\n            if e.is_a?(Sketchup::Face)\r\n              c = Sketchup.active_model.active_view.camera.direction\r\n              m = (c % n > 0) ? e.back_material : e.material\r\n              next if m.nil?\r\n              @picked = m\r\n            else\r\n              next if e.material.nil?\r\n              @picked = e.material\r\n            end\r\n          end\r\n        end\r\n\r\n        @pos = [x, y, 0]\r\n        view.invalidate\r\n      end\r\n\r\n      def onLButtonUp(flags, x, y, view)\r\n        if @state == 0\r\n          @m_org = @picked\r\n          @state = 1\r\n          o_name = (@m_org.nil?) ? SubstituirMateriais.obter_texto(:default_mat) : @m_org.display_name\r\n          Sketchup.set_status_text(SubstituirMateriais.obter_texto(:status_proximo, { material: o_name }))\r\n        else\r\n          return if @picked == @m_org\r\n\r\n          model = Sketchup.active_model\r\n          model.start_operation(SubstituirMateriais.obter_texto(:op_nome), true)\r\n          Sketchup.set_status_text(SubstituirMateriais.obter_texto(:status_aguarde))\r\n\r\n          model.entities.each do |e|\r\n            if e.respond_to?(:material)\r\n              e.material = @picked if e.material == @m_org\r\n            end\r\n            if e.respond_to?(:back_material)\r\n              e.back_material = @picked if e.back_material == @m_org\r\n            end\r\n          end\r\n\r\n          model.definitions.each do |d|\r\n            next if d.image?\r\n            d.entities.each do |e|\r\n              if e.respond_to?(:material)\r\n                e.material = @picked if e.material == @m_org\r\n              end\r\n              if e.respond_to?(:back_material)\r\n                e.back_material = @picked if e.back_material == @m_org\r\n              end\r\n            end\r\n          end\r\n\r\n          model.commit_operation\r\n          activate\r\n        end\r\n      end\r\n\r\n      def draw(view)\r\n        pos = @pos.dup\r\n        pos[0] += 30\r\n        pos[1] -= 30\r\n\r\n        if @state == 0\r\n          p_name = (@picked.nil?) ? SubstituirMateriais.obter_texto(:default_mat) : @picked.display_name\r\n          str = SubstituirMateriais.obter_texto(:msg_substituir, { material: p_name })\r\n        else\r\n          o_name = (@m_org.nil?) ? SubstituirMateriais.obter_texto(:default_mat) : @m_org.display_name\r\n          p_name = (@picked.nil?) ? SubstituirMateriais.obter_texto(:default_mat) : @picked.display_name\r\n          str = SubstituirMateriais.obter_texto(:msg_por, { antigo: o_name, novo: p_name })\r\n        end\r\n\r\n        text_options = {\r\n          font: \"Arial\",\r\n          size: 14,\r\n          bold: true,\r\n          color: \"black\"\r\n        }\r\n\r\n        view.draw_text(pos, str, text_options)\r\n        @drawn = true\r\n      end\r\n\r\n      def onSetCursor\r\n        if @state == 0\r\n          UI.set_cursor(648)\r\n        else\r\n          UI.set_cursor(651)\r\n        end\r\n        true\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      tool = MatReplacer.new\r\n      Sketchup.active_model.tools.push_tool(tool)\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::SubstituirMateriais.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "teletransportador-de-geometria-964iw",
    "title": {
      "pt": "Teletransportador de Geometria",
      "en": "Geometry Teleporter",
      "es": "Teletransportador de geometría"
    },
    "author": "Fábio Coutinho",
    "version": "1.2",
    "description": {
      "pt": "Ferramenta interativa que permite transportar grupos ou componentes do nível do modelo para dentro de outro grupo ou componente em qualquer profundidade. Possui dois modos de operação: transporte simples ou substituição do conteúdo de destino, com preservação de materiais e suporte visual dinâmico.",
      "en": "An interactive tool that allows you to transport groups or components from one model level into another group or component at any depth. It has two operating modes: simple transport or replacement of the target content, with material preservation and dynamic visual support.",
      "es": "Una herramienta interactiva que permite transportar grupos o componentes de un nivel de modelo a otro grupo o componente a cualquier profundidad. Ofrece dos modos de funcionamiento: transporte simple o reemplazo del contenido de destino, con preservación de material y soporte visual dinámico."
    },
    "keywords": {
      "pt": [
        "teletransporte",
        "substituir grupo",
        "mover componente"
      ],
      "en": [
        "teleportation",
        "replace group",
        "move component"
      ],
      "es": [
        "teletransportación",
        "reemplazar grupo",
        "mover componente"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module TeletransportadorDeGeometria\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :modo_transp    => \"Transportar\",\r\n        :modo_subst     => \"Substituir\",\r\n        :local_interno  => \"Interno\",\r\n        :local_externo  => \"Externo\",\r\n        :status_origem  => \"Modo (Ctrl): %{acao} | Localização (Shift): %{local} | Clique no item que será transportado.\",\r\n        :status_destino => \"Modo (Ctrl): %{acao} | Localização (Shift): %{local} | Clique no local de destino.\",\r\n        :op_nome        => \"Teletransporte\",\r\n        :erro_colar     => \"Erro ao colar instância no destino!\"\r\n      },\r\n      'en-US' => {\r\n        :modo_transp    => \"Transport\",\r\n        :modo_subst     => \"Replace\",\r\n        :local_interno  => \"Internal\",\r\n        :local_externo  => \"External\",\r\n        :status_origem  => \"Mode (Ctrl): %{acao} | Location (Shift): %{local} | Click on the item to be transported.\",\r\n        :status_destino => \"Mode (Ctrl): %{acao} | Location (Shift): %{local} | Click on the destination location.\",\r\n        :op_nome        => \"Teleport\",\r\n        :erro_colar     => \"Error pasting instance at destination!\"\r\n      },\r\n      'es' => {\r\n        :modo_transp    => \"Transportar\",\r\n        :modo_subst     => \"Sustituir\",\r\n        :local_interno  => \"Interno\",\r\n        :local_externo  => \"Externo\",\r\n        :status_origem  => \"Modo (Ctrl): %{acao} | Ubicación (Shift): %{local} | Haga clic en el elemento a transportar.\",\r\n        :status_destino => \"Modo (Ctrl): %{acao} | Ubicación (Shift): %{local} | Haga clic en la ubicación de destino.\",\r\n        :op_nome        => \"Teletransporte\",\r\n        :erro_colar     => \"¡Error al pegar la instancia en el destino!\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave, variaveis = {})\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      texto  = IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n      \r\n      variaveis.each { |k, v| texto = texto.gsub(\"%{#{k}}\", v.to_s) }\r\n      texto\r\n    end\r\n\r\n    class Tool\r\n      VK_CONTROL ||= 17\r\n      VK_SHIFT ||= 16\r\n\r\n      def initialize\r\n        @step = :select_source\r\n        @mode = :transportar\r\n        @localizacao = :externo\r\n        @source = nil\r\n      end\r\n\r\n      def activate\r\n        Sketchup.status_text = status_message\r\n        Sketchup.active_model.selection.clear\r\n      end\r\n\r\n      def status_message\r\n        acao = @mode == :transportar ? \r\n          TeletransportadorDeGeometria.obter_texto(:modo_transp) : \r\n          TeletransportadorDeGeometria.obter_texto(:modo_subst)\r\n        \r\n        local = @localizacao == :interno ? \r\n          TeletransportadorDeGeometria.obter_texto(:local_interno) : \r\n          TeletransportadorDeGeometria.obter_texto(:local_externo)\r\n        \r\n        case @step\r\n        when :select_source\r\n          TeletransportadorDeGeometria.obter_texto(:status_origem, { acao: acao, local: local })\r\n        when :select_target\r\n          TeletransportadorDeGeometria.obter_texto(:status_destino, { acao: acao, local: local })\r\n        end\r\n      end\r\n\r\n      def onKeyDown(key, repeat, flags, view)\r\n        case key\r\n        when VK_CONTROL\r\n          @mode = (@mode == :transportar ? :substituir : :transportar)\r\n        when VK_SHIFT\r\n          @localizacao = (@localizacao == :interno ? :externo : :interno)\r\n        end\r\n        Sketchup.status_text = status_message\r\n      end\r\n\r\n      def onMouseMove(flags, x, y, view)\r\n        model = Sketchup.active_model\r\n        ph = view.pick_helper\r\n        ph.do_pick(x, y)\r\n        path = ph.path_at(0)\r\n        return model.selection.clear unless path\r\n      \r\n        entity = path.to_a.first\r\n      \r\n        if @step == :select_source\r\n          if entity.is_a?(Sketchup::Group) || entity.is_a?(Sketchup::ComponentInstance)\r\n            model.selection.clear\r\n            model.selection.add(entity)\r\n          else\r\n            model.selection.clear\r\n          end\r\n        else\r\n          entity = path.to_a.reverse.find { |e| e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance) }\r\n          if entity\r\n            model.selection.clear\r\n            model.selection.add(entity)\r\n          else\r\n            model.selection.clear\r\n          end\r\n        end\r\n\r\n        Sketchup.status_text = status_message\r\n      end\r\n\r\n      def onLButtonDown(flags, x, y, view)\r\n        model = Sketchup.active_model\r\n        ph = view.pick_helper\r\n        ph.do_pick(x, y)\r\n        path = ph.path_at(0)\r\n        return unless path\r\n\r\n        path_array = path.to_a\r\n\r\n        if @step == :select_source\r\n          entity = path_array.first\r\n          return unless entity.is_a?(Sketchup::Group) || entity.is_a?(Sketchup::ComponentInstance)\r\n        else\r\n          entity = path_array.reverse.find { |e| e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance) }\r\n          return unless entity\r\n        end\r\n\r\n        entity.make_unique if entity.respond_to?(:make_unique)\r\n\r\n        instance_path = Sketchup::InstancePath.new(path_array[0..path_array.index(entity)])\r\n        global_tr = instance_path.transformation\r\n\r\n        if @step == :select_source\r\n          @source = {\r\n            entity: entity,\r\n            definition: entity.definition,\r\n            global_tr: global_tr\r\n          }\r\n          @step = :select_target\r\n          Sketchup.status_text = status_message\r\n        else\r\n          perform_transfer(@source, entity, global_tr, instance_path)\r\n          reset\r\n        end\r\n      end\r\n\r\n      def perform_transfer(source_data, destination, destination_tr, destination_path)\r\n        model = Sketchup.active_model\r\n        model.start_operation(TeletransportadorDeGeometria.obter_texto(:op_nome), true)\r\n      \r\n        source_entity = source_data[:entity]\r\n        source_definition = source_data[:definition]\r\n        source_tr = source_data[:global_tr]\r\n      \r\n        if @localizacao == :interno\r\n          dest_entities = destination.definition.entities\r\n          inverse_dest_tr = destination_tr.inverse\r\n          relative_tr = inverse_dest_tr * source_tr\r\n        else\r\n          dest_entities = destination.parent.entities\r\n      \r\n          if destination_path\r\n            parent_path = Sketchup::InstancePath.new(destination_path.to_a[0...-1])\r\n            inverse_parent_path_tr = parent_path.transformation.inverse\r\n            relative_tr = inverse_parent_path_tr * source_tr\r\n          else\r\n            relative_tr = source_tr\r\n          end\r\n        end\r\n      \r\n        new_instance = dest_entities.add_instance(source_definition, relative_tr)\r\n        new_instance.material = source_entity.material if source_entity.material\r\n      \r\n        unless new_instance && new_instance.valid?\r\n          UI.messagebox(TeletransportadorDeGeometria.obter_texto(:erro_colar))\r\n          model.abort_operation\r\n          return\r\n        end\r\n      \r\n        if @mode == :substituir\r\n          if @localizacao == :interno\r\n            keep_id = new_instance.entityID\r\n            to_erase = dest_entities.select { |e| e.entityID != keep_id }\r\n            dest_entities.erase_entities(to_erase)\r\n          else\r\n            destination.erase!\r\n          end\r\n        end\r\n      \r\n        source_entity.erase!\r\n      \r\n        model.commit_operation\r\n      end      \r\n\r\n      def reset\r\n        @step = :select_source\r\n        @source = nil\r\n        Sketchup.status_text = status_message\r\n        Sketchup.active_model.selection.clear\r\n      end\r\n\r\n      def deactivate(view)\r\n        Sketchup.status_text = \"\"\r\n        Sketchup.active_model.selection.clear\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      Sketchup.active_model.select_tool(Tool.new)\r\n    end\r\n  end\r\nend\r\n\r\nScriptUpComunidade::TeletransportadorDeGeometria.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "tornar-componentes-unicos-recursivamente-966oi",
    "title": {
      "pt": "Tornar Componentes Únicos - Recursivamente",
      "en": "Make Components Unique - Recursively",
      "es": "Hacer que los componentes sean únicos - Recursivamente"
    },
    "author": "Úrsula Müller",
    "version": "1.0",
    "description": {
      "pt": "Torna um componente único, bem como todos os componentes aninhados dentro dele.",
      "en": "It makes a component unique, as well as all the components nested within it.",
      "es": "Hace que un componente sea único, así como todos los componentes anidados en él."
    },
    "keywords": {
      "pt": [
        "tornar único"
      ],
      "en": [
        "to make unique"
      ],
      "es": [
        "para hacer único"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module TornarUnicoRecursivo\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao => \"Selecione um componente.\",\r\n        :op_nome      => \"Tornar Componentes Únicos Recursivamente\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao => \"Please select a component.\",\r\n        :op_nome      => \"Make Components Unique Recursively\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao => \"Seleccione un componente.\",\r\n        :op_nome      => \"Hacer componentes únicos recursivamente\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.tornar_unico_recursivamente(entidade)\r\n      return unless entidade.is_a?(Sketchup::ComponentInstance)\r\n\r\n      # Torna o componente atual único, se necessário\r\n      entidade.make_unique unless entidade.definition.instances.size <= 1\r\n\r\n      # Acessa a definição atualizada após make_unique\r\n      definicao = entidade.definition\r\n\r\n      # Itera sobre as entidades dentro da definição\r\n      definicao.entities.each do |ent|\r\n        # Se for um componente, chama a função recursivamente\r\n        tornar_unico_recursivamente(ent) if ent.is_a?(Sketchup::ComponentInstance)\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      if selection.empty?\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n      else\r\n        model.start_operation(obter_texto(:op_nome), true)\r\n\r\n        selection.each do |entidade|\r\n          tornar_unico_recursivamente(entidade)\r\n        end\r\n\r\n        model.commit_operation\r\n      end\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::TornarUnicoRecursivo.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "unir-faces-coplanares-9690s",
    "title": {
      "pt": "Unir Faces Coplanares",
      "en": "Joining Coplanar Faces",
      "es": "Unir caras coplanares"
    },
    "author": "Fábio Coutinho",
    "version": "1.4",
    "description": {
      "pt": "Promove a união de faces coplanares dos elementos selecionados, fazendo a limpeza de faces internas e soltas.",
      "en": "It promotes the joining of coplanar faces of the selected elements, cleaning up internal and loose faces.",
      "es": "Favorece la unión de caras coplanares de los elementos seleccionados, limpiando caras internas y sueltas."
    },
    "keywords": {
      "pt": [
        "limpeza de faces coplanares"
      ],
      "en": [
        "cleaning of coplanar surfaces"
      ],
      "es": [
        "limpieza de superficies coplanares"
      ]
    },
    "code": {
      "pt": "if defined?(MySolidFix)\r\n  MySolidFix.constants.each do |const|\r\n    MySolidFix.send(:remove_const, const) rescue nil\r\n  end\r\n  Object.send(:remove_const, :MySolidFix) rescue nil\r\nend\r\n\r\nmodule ScriptUpComunidade\r\n  module UnirFacesCoplanares\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :selecao_vazia     => \"Selecione um grupo, componente ou geometria.\",\r\n        :nome_operacao     => \"Limpar Faces Internas + Unir Coplanares\",\r\n        :status_faces      => \"Inspecionando faces...\",\r\n        :status_arestas    => \"Inspecionando arestas...\",\r\n        :status_manifold   => \"Resolvendo manifold...\",\r\n        :status_analisando => \"Analisando arestas...\",\r\n        :status_bordas     => \"Ordenando bordas de superficie...\",\r\n        :status_buracos    => \"Ordenando buracos de face...\",\r\n        :faces_removidas   => \"%d faces internas removidas com precisao.\",\r\n        :arestas_removidas => \"%d arestas removidas entre faces coplanares.\"\r\n      },\r\n      'en-US' => {\r\n        :selecao_vazia     => \"Please select a group, component, or geometry.\",\r\n        :nome_operacao     => \"Clean Internal Faces + Merge Coplanar\",\r\n        :status_faces      => \"Inspecting faces...\",\r\n        :status_arestas    => \"Inspecting edges...\",\r\n        :status_manifold   => \"Resolving manifold...\",\r\n        :status_analisando => \"Analyzing edges...\",\r\n        :status_bordas     => \"Sorting surface borders...\",\r\n        :status_buracos    => \"Sorting face holes...\",\r\n        :faces_removidas   => \"%d internal faces removed with precision.\",\r\n        :arestas_removidas => \"%d edges removed between coplanar faces.\"\r\n      },\r\n      'es' => {\r\n        :selecao_vazia     => \"Por favor seleccione un grupo, componente o geometria.\",\r\n        :nome_operacao     => \"Limpiar Caras Internas + Unir Coplanares\",\r\n        :status_faces      => \"Inspeccionando caras...\",\r\n        :status_arestas    => \"Inspeccionando aristas...\",\r\n        :status_manifold   => \"Resolviendo manifold...\",\r\n        :status_analisando => \"Analizando aristas...\",\r\n        :status_bordas     => \"Ordenando bordes de superficie...\",\r\n        :status_buracos    => \"Ordenando agujeros de cara...\",\r\n        :faces_removidas   => \"%d caras internas eliminadas con precision.\",\r\n        :arestas_removidas => \"%d aristas eliminadas entre caras coplanares.\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.executar\r\n      model     = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      if selection.empty?\r\n        UI.messagebox(obter_texto(:selecao_vazia))\r\n        return\r\n      end\r\n\r\n      tolerance       = 1e-6\r\n      angle_tolerance = 1e-3\r\n\r\n      model.start_operation(obter_texto(:nome_operacao), true)\r\n\r\n      total_removed = 0\r\n      total_edges   = 0\r\n\r\n      selection.each do |ent|\r\n        ents = case ent\r\n               when Sketchup::Group             then ent.entities\r\n               when Sketchup::ComponentInstance then ent.definition.entities\r\n               when Sketchup::Face, Sketchup::Edge then ent.parent.entities\r\n               else next\r\n               end\r\n\r\n        errors = MySolidFix::ErrorFinder.find_errors(ents)\r\n\r\n        internal_faces = errors.select { |e| e.is_a?(MySolidFix::SolidErrors::InternalFace) }\r\n        internal_faces.each do |err|\r\n          face = err.entities[0]\r\n          if face.valid?\r\n            face.erase!\r\n            total_removed += 1\r\n          end\r\n        end\r\n\r\n        ents.grep(Sketchup::Edge).each do |edge|\r\n          next unless edge.valid? && edge.faces.size == 2\r\n          f1, f2 = edge.faces\r\n          begin\r\n            angle    = f1.normal.angle_between(f2.normal)\r\n            coplanar = angle < angle_tolerance &&\r\n               f2.vertices.all? { |v|\r\n                 p = v.position\r\n                 a, b, c, d = f1.plane\r\n                 (a * p.x + b * p.y + c * p.z + d).abs < tolerance\r\n               }\r\n            if coplanar\r\n              edge.erase!\r\n              total_edges += 1\r\n            end\r\n          rescue\r\n            next\r\n          end\r\n        end\r\n      end\r\n\r\n      model.commit_operation\r\n      # puts obter_texto(:faces_removidas)   % total_removed\r\n      # puts obter_texto(:arestas_removidas) % total_edges\r\n    end\r\n\r\n  end\r\nend\r\n\r\nmodule MySolidFix\r\n  module Geometry\r\n\r\n    def self.arc(center, xaxis, normal, radius, start_angle, end_angle, num_segments = 12)\r\n      tr = Geom::Transformation.rotation(center, normal, start_angle)\r\n      points = []\r\n      points << center.offset(xaxis, radius).transform(tr)\r\n      angle = (end_angle - start_angle) / num_segments\r\n      tr = Geom::Transformation.rotation(center, normal, angle)\r\n      1.upto(num_segments) { |i|\r\n        points << points.last.transform(tr)\r\n      }\r\n      return points\r\n    end\r\n\r\n    def self.arc2d(center, xaxis, radius, start_angle, end_angle, num_segments = 24)\r\n      full_angle    = end_angle - start_angle\r\n      segment_angle = full_angle / num_segments\r\n      t   = Geom::Transformation.axes(center, xaxis, xaxis * Z_AXIS, Z_AXIS)\r\n      arc = []\r\n      (0..num_segments).each { |i|\r\n        angle = start_angle + (segment_angle * i)\r\n        x = radius * Math.cos(angle)\r\n        y = radius * Math.sin(angle)\r\n        arc << Geom::Point3d.new(x, y, 0).transform!(t)\r\n      }\r\n      arc\r\n    end\r\n\r\n    def self.circle(center, normal, radius, num_segments)\r\n      pi2   = Math::PI * 2\r\n      xaxis = normal.axes.x\r\n      points = self.arc(center, xaxis, normal, radius, 0.0, pi2, num_segments)\r\n      points.pop\r\n      return points\r\n    end\r\n\r\n    def self.circle2d(center, xaxis, radius, num_segments = 24)\r\n      num_segments = num_segments.to_i\r\n      angle = 360.degrees - (360.degrees / num_segments)\r\n      self.arc2d(center, xaxis, radius, 0, angle, num_segments - 1)\r\n    end\r\n\r\n    def self.arc_segments(angle, full_circle_segments, force_even = false)\r\n      segments = (full_circle_segments * (angle.abs / (Math::PI * 2))).to_i\r\n      segments += 1 if force_even && segments % 2 > 0\r\n      segments = 1 if segments < 1\r\n      return segments\r\n    end\r\n\r\n    def self.mid_point(edge)\r\n      pt1, pt2 = edge.vertices.map { |vertex| vertex.position }\r\n      Geom.linear_combination(0.5, pt1, 0.5, pt2)\r\n    end\r\n\r\n  end\r\nend\r\n\r\nmodule MySolidFix\r\n\r\n  class HeisenBug < RuntimeError; end\r\n\r\n  class Shell\r\n\r\n    PI2 = Math::PI * 2\r\n\r\n    attr_reader :internal_faces, :external_faces, :reversed_faces\r\n\r\n    def initialize(entities)\r\n      @entities      = entities\r\n      @shell_faces   = nil\r\n      @internal_faces  = nil\r\n      @external_faces  = nil\r\n      @reversed_faces  = nil\r\n    end\r\n\r\n    def resolve\r\n      @shell_faces    = Set.new\r\n      @internal_faces = Set.new\r\n      @external_faces = Set.new\r\n      @reversed_faces = Set.new\r\n\r\n      shell_front = Set.new\r\n      find_geometry_groups(@entities) { |geometry_group|\r\n        start_face = find_start_face(geometry_group, true)\r\n        next if start_face.nil?\r\n        shell_front.merge(find_shell(start_face))\r\n      }\r\n      faces           = @entities.grep(Sketchup::Face)\r\n      @internal_faces = Set.new(faces).subtract(shell_front)\r\n\r\n      temp_reversed_faces = @reversed_faces.dup\r\n\r\n      shell_back = Set.new\r\n      find_geometry_groups(@entities) { |geometry_group|\r\n        start_face = find_start_face(geometry_group, false)\r\n        next if start_face.nil?\r\n        shell_back.merge(find_shell(start_face))\r\n      }\r\n\r\n      @shell_faces    = shell_front.intersection(shell_back)\r\n      @external_faces = Set.new(faces).subtract(@internal_faces)\r\n                                      .subtract(@shell_faces)\r\n      @reversed_faces = @shell_faces.intersection(temp_reversed_faces)\r\n      nil\r\n    end\r\n\r\n    def valid?\r\n      if @shell_faces.nil?\r\n        raise RuntimeError, \"`resolve` must be called before calling `valid?`\"\r\n      end\r\n      @shell_faces.size > 0 && @shell_faces.all? { |face|\r\n        face.edges.all? { |edge|\r\n          faces = edge.faces.select { |f| @shell_faces.include?(f) }\r\n          faces.size > 1\r\n        }\r\n      }\r\n    end\r\n\r\n    private\r\n\r\n    def find_geometry_groups(entities)\r\n      num_groups = 0\r\n      stack = entities.to_a\r\n      until stack.empty?\r\n        entity = stack.pop\r\n        next unless entity.respond_to?(:all_connected)\r\n        num_groups += 1\r\n        geometry_group = entity.all_connected\r\n        yield(geometry_group)\r\n        stack = stack - geometry_group\r\n      end\r\n      num_groups\r\n    end\r\n\r\n    def get_faces(entity)\r\n      entity.faces.reject { |face| @internal_faces.include?(face) }\r\n    end\r\n\r\n    def face_normal(face)\r\n      normal = face.normal\r\n      if @reversed_faces.include?(face)\r\n        normal.reverse!\r\n      end\r\n      normal\r\n    end\r\n\r\n    def edge_reversed_in?(edge, face)\r\n      reversed = edge.reversed_in?(face)\r\n      if @reversed_faces.include?(face)\r\n        reversed = !reversed\r\n      end\r\n      reversed\r\n    end\r\n\r\n    def reverse_face(face)\r\n      if @reversed_faces.include?(face)\r\n        @reversed_faces.delete(face)\r\n      else\r\n        @reversed_faces << face\r\n      end\r\n      face\r\n    end\r\n\r\n    def find_start_face(entities, outside)\r\n      vertices = Set.new\r\n      entities.grep(Sketchup::Edge) { |edge|\r\n        vertices.merge(edge.vertices)\r\n      }\r\n      vertices.delete_if { |vertex| get_faces(vertex).empty? }\r\n      return nil if vertices.empty?\r\n\r\n      max_z_vertex = vertices.max { |a, b|\r\n        a.position.z <=> b.position.z\r\n      }\r\n\r\n      edges = max_z_vertex.edges.delete_if { |edge| get_faces(edge).empty? }\r\n      edge  = edges.min { |a, b|\r\n        val_a = edge_normal_z_component(a)\r\n        val_b = edge_normal_z_component(b)\r\n        result = val_a <=> val_b\r\n        if result.nil?\r\n          klass_a = val_a.class.name\r\n          klass_b = val_b.class.name\r\n          raise HeisenBug, \"A: #{a.line.inspect} (#{val_a.inspect}) #{klass_a} - B: #{b.line.inspect} (#{val_b.inspect}) #{klass_b}\"\r\n        end\r\n        result\r\n      }\r\n\r\n      face = get_faces(edge).max { |a, b|\r\n        face_normal(a).z.abs <=> face_normal(b).z.abs\r\n      }\r\n\r\n      if outside\r\n        reverse_face(face) if face_normal(face).z < 0\r\n      else\r\n        reverse_face(face) if face_normal(face).z > 0\r\n      end\r\n\r\n      face\r\n    end\r\n\r\n    def edge_normal_z_component(edge)\r\n      edge.line[1].z.abs\r\n    end\r\n\r\n    def edge_vector(edge, face)\r\n      if edge_reversed_in?(edge, face)\r\n        edge.end.position.vector_to(edge.start)\r\n      else\r\n        edge.start.position.vector_to(edge.end)\r\n      end\r\n    end\r\n\r\n    def get_other_face(edge, face)\r\n      other_face = get_faces(edge).find { |edge_face| edge_face != face }\r\n      return nil if other_face.nil?\r\n      if edge_reversed_in?(edge, face) == edge_reversed_in?(edge, other_face)\r\n        reverse_face(other_face)\r\n      end\r\n      other_face\r\n    end\r\n\r\n    def find_other_shell_face(edge, face)\r\n      return nil if get_faces(edge).size == 1\r\n      return get_other_face(edge, face) if get_faces(edge).size == 2\r\n      return nil if get_faces(edge).count(face) > 1\r\n\r\n      edge_direction = edge_vector(edge, face)\r\n      face_direction = face_normal(face)\r\n      product        = face_direction.cross(edge_direction)\r\n      reversed       = edge_reversed_in?(edge, face)\r\n\r\n      minimum_angle = PI2\r\n      shell_face    = nil\r\n\r\n      get_faces(edge).each { |other_face|\r\n        next if other_face == face\r\n\r\n        other_face_direction = face_normal(other_face)\r\n        if edge_reversed_in?(edge, other_face) == reversed\r\n          other_face_direction.reverse!\r\n        end\r\n\r\n        other_product = edge_direction.cross(other_face_direction)\r\n        angle = product.angle_between(other_product)\r\n        if other_product.dot(face_direction) < 0\r\n          angle = PI2 - angle\r\n        end\r\n\r\n        if angle < minimum_angle\r\n          minimum_angle = angle\r\n          shell_face    = other_face\r\n        end\r\n      }\r\n\r\n      return nil if shell_face.nil?\r\n\r\n      if edge_reversed_in?(edge, shell_face) == reversed\r\n        reverse_face(shell_face)\r\n      end\r\n\r\n      shell_face\r\n    end\r\n\r\n    def find_shell(start_face)\r\n      stack     = []\r\n      processed = Set.new\r\n      shell     = Set.new\r\n\r\n      stack << start_face\r\n      processed << start_face\r\n\r\n      until stack.empty? do\r\n        face = stack.pop\r\n        shell << face\r\n\r\n        face.loops.each { |loop|\r\n          loop.edges.each { |edge|\r\n            next if processed.include?(edge) || get_faces(edge).size < 2\r\n\r\n            processed << edge\r\n            other_shell_face = find_other_shell_face(edge, face)\r\n\r\n            next if other_shell_face.nil?\r\n            next if processed.include?(other_shell_face)\r\n\r\n            stack << other_shell_face\r\n            processed << other_shell_face\r\n          }\r\n        }\r\n      end\r\n\r\n      shell.to_a\r\n    end\r\n\r\n  end\r\nend\r\n\r\nmodule MySolidFix\r\n\r\n  module SolidErrors\r\n\r\n    class SolidError\r\n\r\n      ERROR_COLOR_EDGE = Sketchup::Color.new(255, 0, 0, 255).freeze\r\n      ERROR_COLOR_FACE = Sketchup::Color.new(255, 0, 0, 128).freeze\r\n\r\n      def self.type_name\r\n        self.name.split(\"::\").last\r\n      end\r\n\r\n      def self.display_name\r\n        self.name\r\n      end\r\n\r\n      def self.description\r\n        \"\"\r\n      end\r\n\r\n      attr_accessor :entities\r\n\r\n      def initialize(entities)\r\n        raise TypeError if entities.nil?\r\n        if entities.is_a?(Enumerable)\r\n          @entities = entities.clone\r\n        else\r\n          @entities = [entities]\r\n        end\r\n        @fixed = false\r\n      end\r\n\r\n      def fix\r\n        raise NotImplementedError\r\n      end\r\n\r\n      def fixed?\r\n        @fixed ? true : false\r\n      end\r\n\r\n      def fixable?\r\n        is_a?(Fixable)\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        raise NotImplementedError\r\n      end\r\n\r\n      def to_json(*args)\r\n        data = {\r\n          :id         => object_id,\r\n          :is_fixable => fixable?\r\n        }\r\n        data.to_json(*args)\r\n      end\r\n\r\n    end\r\n\r\n    module Fixable\r\n    end\r\n\r\n    module EraseToFix\r\n\r\n      include Fixable\r\n\r\n      def fix\r\n        entity = @entities.find { |entity| entity.valid? }\r\n        return false if entity.nil?\r\n        entities = entity.parent.entities\r\n        entities.erase_entities(@entities)\r\n        @fixed = true\r\n        true\r\n      end\r\n\r\n    end\r\n\r\n    class HiddenFace < SolidError\r\n\r\n      include Fixable\r\n\r\n      def self.display_name\r\n        \"Hidden Faces\"\r\n      end\r\n\r\n      def self.description\r\n        \"Hidden faces will not be exported to STL file, and may cause holes \"\\\r\n        \"in a mesh.\"\r\n      end\r\n\r\n      def fix\r\n        face = @entities[0]\r\n        return false if face.deleted?\r\n        face.visible = true\r\n        @fixed = true\r\n        true\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_FACE\r\n        draw_face(view, @entities[0], transformation, texture_id: texture_id)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        @entities[0].edges.each { |edge|\r\n          draw_edge(view, edge, transformation)\r\n        }\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class BorderEdge < SolidError\r\n\r\n      def self.display_name\r\n        \"Border Edges\"\r\n      end\r\n\r\n      def self.description\r\n        \"Border edges are connected to only one face and therefore doesn't \"\\\r\n        \"form a manifold. These cannot be fixed automatically and must be \"\\\r\n        \"fixed by hand.\"\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        draw_edge(view, @entities[0], transformation)\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class InternalFaceEdge < SolidError\r\n\r\n      def self.display_name\r\n        \"Internal Face Edges\"\r\n      end\r\n\r\n      def self.description\r\n        \"Internal face edges are edges connected to internal faces. However, \"\\\r\n        \"if there are holes in the mesh it is not possible to reliably \"\\\r\n        \"determine which faces are internal. Fix the holes in the mesh and \"\\\r\n        \"then run the tool again.\"\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        draw_edge(view, @entities[0], transformation)\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class InternalFace < SolidError\r\n\r\n      include EraseToFix\r\n\r\n      def self.display_name\r\n        \"Internal Faces\"\r\n      end\r\n\r\n      def self.description\r\n        \"Internal faces are faces located on the inside of a mesh that should \"\\\r\n        \"be a solid. These are automatically fixed by erasing the internal \"\\\r\n        \"faces.\"\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_FACE\r\n        draw_face(view, @entities[0], transformation, texture_id: texture_id)\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class ExternalFace < SolidError\r\n\r\n      include EraseToFix\r\n\r\n      def self.display_name\r\n        \"External Faces\"\r\n      end\r\n\r\n      def self.description\r\n        \"External faces are faces located on the outside of a mesh that should \"\\\r\n        \"be a solid. These are automatically fixed by erasing the internal \"\\\r\n        \"faces.\"\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_FACE\r\n        draw_face(view, @entities[0], transformation, texture_id: texture_id)\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class ReversedFace < SolidError\r\n\r\n      include Fixable\r\n\r\n      def self.display_name\r\n        \"Reversed Faces\"\r\n      end\r\n\r\n      def self.description\r\n        \"Many applications will not be able to treat a mesh as a solid if the \"\\\r\n        \"face normal (direction) isn't all uniform. The front side of a face \"\\\r\n        \"must be facing outwards. These can be fixed automatically by \"\\\r\n        \"reversing the faces.\"\r\n      end\r\n\r\n      def fix\r\n        face = @entities[0]\r\n        return false if face.deleted?\r\n\r\n        front_material = face.material\r\n        back_material  = face.back_material\r\n\r\n        front_mapping = uv_mapping(face, true)\r\n        back_mapping  = uv_mapping(face, false)\r\n\r\n        front_projection = get_projection(face, true)\r\n        back_projection  = get_projection(face, false)\r\n\r\n        face.reverse!\r\n\r\n        apply_material(face, back_material,  back_mapping,  true)\r\n        apply_material(face, front_material, front_mapping, false)\r\n\r\n        apply_projection(face, back_projection,  true)\r\n        apply_projection(face, front_projection, false)\r\n\r\n        @fixed = true\r\n        true\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_FACE\r\n        draw_face(view, @entities[0], transformation, texture_id: texture_id)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        @entities[0].edges.each { |edge|\r\n          draw_edge(view, edge, transformation)\r\n        }\r\n        nil\r\n      end\r\n\r\n      private\r\n\r\n      def uv_mapping(face, front)\r\n        material = (front) ? face.material : face.back_material\r\n        if material && material.texture\r\n          start_point = face.vertices.first.position\r\n\r\n          points = [start_point]\r\n          points << points[0].offset(face.normal.axes.x, 10)\r\n          points << points[0].offset(face.normal.axes.y, 10)\r\n          points << points[1].offset(face.normal.axes.y, 10)\r\n\r\n          tw  = Sketchup.create_texture_writer\r\n          uvh = face.get_UVHelper(true, true, tw)\r\n\r\n          mapping = []\r\n          points.each_with_index { |point, index|\r\n            uvq = (front) ? uvh.get_front_UVQ(point) : uvh.get_back_UVQ(point)\r\n            mapping << point\r\n            mapping << uvq_to_uv(uvq)\r\n          }\r\n\r\n          mapping\r\n        else\r\n          nil\r\n        end\r\n      end\r\n\r\n      def apply_material(face, material, uv_mapping, front)\r\n        if material && uv_mapping\r\n          face.position_material(material, uv_mapping, front)\r\n        else\r\n          if front\r\n            face.material = material\r\n          else\r\n            face.back_material = material\r\n          end\r\n        end\r\n        nil\r\n      end\r\n\r\n      def uvq_to_uv(uvq)\r\n        Geom::Point3d.new(uvq.x / uvq.z, uvq.y / uvq.z, 1.0)\r\n      end\r\n\r\n      def apply_projection(face, projection, front)\r\n        if projection && face.respond_to?(:set_texture_projection)\r\n          face.set_texture_projection(projection, front)\r\n        end\r\n        nil\r\n      end\r\n\r\n      def get_projection(face, front)\r\n        if face.respond_to?(:get_texture_projection)\r\n          face.get_texture_projection(front)\r\n        else\r\n          nil\r\n        end\r\n      end\r\n\r\n    end\r\n\r\n    class StrayEdge < SolidError\r\n\r\n      include EraseToFix\r\n\r\n      def self.display_name\r\n        \"Stray Edges\"\r\n      end\r\n\r\n      def self.description\r\n        \"Stray edges are not connected to any faces and doesn't form any part \"\\\r\n        \"of solids. These are automatically fixed by erasing the stray edges.\"\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        draw_edge(view, @entities[0], transformation)\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class SurfaceBorder < SolidError\r\n\r\n      def self.display_name\r\n        \"Surface Borders\"\r\n      end\r\n\r\n      def self.description\r\n        \"Edges that form the border of a surface or a hole in the mesh. \"\\\r\n        \"These cannot be fixed automatically. Manually close the mesh and \"\\\r\n        \"run the tool again.\"\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        @entities.each { |edge|\r\n          draw_edge(view, edge, transformation)\r\n        }\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class FaceHole < SolidError\r\n\r\n      include EraseToFix\r\n\r\n      def self.display_name\r\n        \"Face Holes\"\r\n      end\r\n\r\n      def self.description\r\n        \"Edges that form the a hole in a face. These are fixed automatically \"\\\r\n        \"by erasing the hole.\"\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        @entities.each { |edge|\r\n          draw_edge(view, edge, transformation)\r\n        }\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class NestedInstance < SolidError\r\n\r\n      def self.display_name\r\n        \"Nested Instances\"\r\n      end\r\n\r\n      def self.description\r\n        \"Nested instances will be exported correctly to STL file format by \"\\\r\n        \"the Trimble SketchUp STL exporter, but SketchUp's Solid Tools and \"\\\r\n        \"#{PLUGIN_NAME} doesn't treat nested instances as a solid.\"\r\n      end\r\n\r\n      def fix\r\n        raise NotImplementedError\r\n\r\n        return false if @entities[0].deleted?\r\n        @entities[0].explode\r\n        @fixed = true\r\n        true\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        draw_instance(view, @entities[0], transformation)\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class ImageEntity < SolidError\r\n\r\n      def self.display_name\r\n        \"Image Entity\"\r\n      end\r\n\r\n      def self.description\r\n        \"Image entities isn't exported by the Trimble SketchUp STL exporter, \"\\\r\n        \"but it prevent SketchUp's Solid Tools from performing it's \"\\\r\n        \"operations on the object.\"\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        draw_instance(view, @entities[0], transformation)\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class ShortEdge < SolidError\r\n\r\n      def self.display_name\r\n        \"Short Edges\"\r\n      end\r\n\r\n      def self.description\r\n        \"Small geometry might cause unpredictable results due to precision \"\\\r\n        \"errors. It's beneficial to try to avoid such small geometry. This \"\\\r\n        \"cannot be automatically fixed. You might want to scale the model up \"\\\r\n        \"by factors of 10 to work around such problems.\"\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        draw_edge(view, @entities[0], transformation)\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n  end\r\n\r\nend\r\n\r\nmodule MySolidFix\r\n\r\n  class ErrorFinder\r\n\r\n    def self.find_errors(entities)\r\n      raise TypeError unless entities.is_a?(Sketchup::Entities)\r\n\r\n      errors = []\r\n\r\n      self.time(\"Total analysis\") {\r\n\r\n        mesh_border_edges          = []\r\n        hole_edges                 = []\r\n        edges_with_internal_faces  = []\r\n\r\n        Sketchup.status_text = ScriptUpComunidade::UnirFacesCoplanares.obter_texto(:status_faces)\r\n\r\n        all_faces = entities.grep(Sketchup::Face)\r\n        all_faces.each { |face|\r\n          if !face.visible?\r\n            errors << SolidErrors::HiddenFace.new(face)\r\n          end\r\n        }\r\n\r\n        Sketchup.status_text = ScriptUpComunidade::UnirFacesCoplanares.obter_texto(:status_arestas)\r\n\r\n        entities.grep(Sketchup::Edge) { |edge|\r\n          num_faces = edge.faces.size\r\n          if num_faces == 0\r\n            errors << SolidErrors::StrayEdge.new(edge)\r\n          elsif num_faces == 1\r\n            face = edge.faces.first\r\n            if face.outer_loop.edges.include?(edge)\r\n              mesh_border_edges << edge\r\n            else\r\n              hole_edges << edge\r\n            end\r\n          elsif num_faces > 2\r\n            edges_with_internal_faces << edge\r\n          end\r\n        }\r\n\r\n        Sketchup.status_text = ScriptUpComunidade::UnirFacesCoplanares.obter_texto(:status_manifold)\r\n\r\n        shell = Shell.new(entities)\r\n\r\n        self.time(\"Resolving manifold\") {\r\n          shell.resolve\r\n        }\r\n\r\n        if shell.valid?\r\n          shell.internal_faces.each { |face|\r\n            errors << SolidErrors::InternalFace.new(face)\r\n          }\r\n          shell.external_faces.each { |face|\r\n            errors << SolidErrors::ExternalFace.new(face)\r\n          }\r\n          shell.reversed_faces.each { |face|\r\n            errors << SolidErrors::ReversedFace.new(face)\r\n          }\r\n        else\r\n          Sketchup.status_text = ScriptUpComunidade::UnirFacesCoplanares.obter_texto(:status_analisando)\r\n\r\n          Sketchup.status_text = ScriptUpComunidade::UnirFacesCoplanares.obter_texto(:status_bordas)\r\n          self.group_connected_edges(mesh_border_edges).each { |edges|\r\n            errors << SolidErrors::SurfaceBorder.new(edges)\r\n          }\r\n\r\n          Sketchup.status_text = ScriptUpComunidade::UnirFacesCoplanares.obter_texto(:status_buracos)\r\n          self.group_connected_edges(hole_edges).each { |edges|\r\n            errors << SolidErrors::FaceHole.new(edges)\r\n          }\r\n\r\n          edges_with_internal_faces.each { |edge|\r\n            errors << SolidErrors::InternalFaceEdge.new(edge)\r\n          }\r\n        end\r\n\r\n        self.time(\"Instance detection\") {\r\n          groups     = entities.grep(Sketchup::Group)\r\n          components = entities.grep(Sketchup::ComponentInstance)\r\n          instances  = groups + components\r\n          instances.each { |instance|\r\n            errors << SolidErrors::NestedInstance.new(instance)\r\n          }\r\n        }\r\n\r\n        self.time(\"Image detection\") {\r\n          entities.grep(Sketchup::Image) { |image|\r\n            errors << SolidErrors::ImageEntity.new(image)\r\n          }\r\n        }\r\n\r\n        if false\r\n          self.time(\"Short edge detection\") {\r\n            self.find_short_edges(entities) { |edge|\r\n              errors << SolidErrors::ShortEdge.new(edge)\r\n            }\r\n          }\r\n        end\r\n\r\n      }\r\n\r\n      Sketchup.status_text = \"\"\r\n\r\n      errors\r\n    end\r\n\r\n    def self.find_short_edges(entities, &block)\r\n      threshold = Settings.short_edge_threshold\r\n      entities.grep(Sketchup::Edge) { |edge|\r\n        if edge.length < threshold\r\n          block.call(edge)\r\n        end\r\n      }\r\n      nil\r\n    end\r\n\r\n    def self.fix_errors(errors, entities)\r\n      all_errors_fixed       = true\r\n      entities_to_be_erased  = Set.new\r\n      remaining_errors       = []\r\n      errors.each { |error|\r\n        if error.is_a?(SolidErrors::EraseToFix)\r\n          entities_to_be_erased.merge(error.entities)\r\n        else\r\n          remaining_errors << error\r\n        end\r\n      }\r\n\r\n      stray_edges = Set.new\r\n      entities_to_be_erased.grep(Sketchup::Face) { |face|\r\n        face.edges.each { |edge|\r\n          if edge.faces.all? { |f| entities_to_be_erased.include?(f) }\r\n            stray_edges << edge\r\n          end\r\n        }\r\n      }\r\n      entities_to_be_erased.merge(stray_edges)\r\n      entities_to_be_erased.reject! { |entity| entity.deleted? }\r\n\r\n      model = entities.model\r\n      begin\r\n        model.start_operation(\"Repair Solid\", true)\r\n        entities.erase_entities(entities_to_be_erased.to_a)\r\n        remaining_errors.each { |error|\r\n          begin\r\n            error.fix\r\n          rescue NotImplementedError => e\r\n            all_errors_fixed = false\r\n          end\r\n        }\r\n        model.commit_operation\r\n      rescue\r\n        model.commit_operation\r\n        raise\r\n      end\r\n      all_errors_fixed\r\n    end\r\n\r\n    def self.group_connected_edges(edges)\r\n      groups = []\r\n      stack  = edges.to_a.clone\r\n      until stack.empty?\r\n        cluster = []\r\n        cluster << stack.shift\r\n\r\n        edge     = cluster.first\r\n        haystack = self.neighbour_edges(edge) & stack\r\n        until haystack.empty?\r\n          next_edge = haystack.shift\r\n\r\n          if stack.include?(next_edge)\r\n            cluster << next_edge\r\n            stack.delete(next_edge)\r\n            haystack += self.neighbour_edges(next_edge) & stack\r\n          end\r\n        end\r\n\r\n        groups << cluster\r\n      end\r\n      groups\r\n    end\r\n\r\n    def self.neighbour_edges(edge)\r\n      (edge.start.edges + edge.end.edges) - [edge]\r\n    end\r\n\r\n    def self.time(message, &block)\r\n      start_time = Time.new\r\n      block.call\r\n      elapsed_time = Time.now - start_time\r\n      if false\r\n        puts \"> #{message} took: #{elapsed_time}s\"\r\n      end\r\n      nil\r\n    end\r\n\r\n  end\r\n\r\nend\r\n\r\nScriptUpComunidade::UnirFacesCoplanares.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "subdivide-face-96axz",
    "title": {
      "pt": "Subdivide Face",
      "en": "Subdivide Face",
      "es": "Subdividir cara"
    },
    "author": "Fábio Coutinho",
    "version": "0.4",
    "description": {
      "pt": "Subdivide face selecionada em distâncias iguais com resultado de malha suavizada. Ideal para usar com a ferramenta Modelar do Snadbox ou outras ferramentas de modificação de malha.",
      "en": "Subdivides selected face into equal distances resulting in a smoothed mesh. Ideal for use with the Snapbox Model tool or other mesh modification tools.",
      "es": "Subdivide la cara seleccionada en distancias iguales, lo que resulta en una malla suavizada. Ideal para usar con la herramienta Modelo Snapbox u otras herramientas de modificación de malla."
    },
    "keywords": {
      "pt": [
        "terreno",
        "malha",
        "sandbox"
      ],
      "en": [
        "land",
        "mesh",
        "sandbox"
      ],
      "es": [
        "tierra",
        "malla",
        "salvadera"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module SubdivideFaceDistancia\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao   => \"Selecione UMA face.\",\r\n        :operacao_nome  => \"Malha Interativa\",\r\n        :titulo_janela  => \"Ajuste de Malha\",\r\n        :label_h3       => \"Espaçamento da Malha\",\r\n        :unidade        => \"mm\",\r\n        :btn_cancelar   => \"Cancelar\",\r\n        :btn_aplicar    => \"Aplicar\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao   => \"Select ONE face.\",\r\n        :operacao_nome  => \"Interactive Mesh\",\r\n        :titulo_janela  => \"Mesh Adjustment\",\r\n        :label_h3       => \"Mesh Spacing\",\r\n        :unidade        => \"mm\",\r\n        :btn_cancelar   => \"Cancel\",\r\n        :btn_aplicar    => \"Apply\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao   => \"Seleccione UNA cara.\",\r\n        :operacao_nome  => \"Malla Interactiva\",\r\n        :titulo_janela  => \"Ajuste de Malla\",\r\n        :label_h3       => \"Espaciado de la Malla\",\r\n        :unidade        => \"mm\",\r\n        :btn_cancelar   => \"Cancelar\",\r\n        :btn_aplicar    => \"Aplicar\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    class MalhaPreviewTool\r\n      def initialize(model, face, loops2d, umin, umax, vmin, vmax, plane, t_l2w, modulo)\r\n        @model = model\r\n        @face = face\r\n        @loops2d = loops2d\r\n        @umin, @umax = umin, umax\r\n        @vmin, @vmax = vmin, vmax\r\n        @plane = plane\r\n        @t_l2w = t_l2w\r\n        @modulo = modulo\r\n        @eps = 1.0e-6\r\n        @draw_points = []\r\n        @dialog = nil\r\n        @is_applied = false\r\n      end\r\n\r\n      def activate\r\n        @model.start_operation(@modulo.obter_texto(:operacao_nome), true)\r\n        criar_dialogo\r\n        calcular_linhas(50)\r\n      end\r\n\r\n      def deactivate(view)\r\n        @dialog.close if @dialog && @dialog.visible?\r\n        @model.abort_operation unless @is_applied\r\n        view.invalidate\r\n      end\r\n\r\n      def draw(view)\r\n        return if @draw_points.empty?\r\n        view.drawing_color = \"red\"\r\n        view.line_width = 2\r\n        view.draw(GL_LINES, @draw_points)\r\n      end\r\n      \r\n      def calcular_linhas(step_val)\r\n        step = step_val.to_f.mm\r\n        return if step <= 0.0\r\n\r\n        @draw_points.clear\r\n        \r\n        uc = 0.5 * (@umin + @umax)\r\n        vc = 0.5 * (@vmin + @vmax)\r\n        nx = ((@umax - @umin) * 0.5 / step).floor\r\n        ny = ((@vmax - @vmin) * 0.5 / step).floor\r\n\r\n        vx = [uc]\r\n        (1..nx).each { |k| vx << (uc + k*step) << (uc - k*step) }\r\n        vx.select! { |x| x > @umin + @eps && x < @umax - @eps }\r\n        vx = unique_sorted(vx, @eps)\r\n\r\n        vy = [vc]\r\n        (1..ny).each { |k| vy << (vc + k*step) << (vc - k*step) }\r\n        vy.select! { |y| y > @vmin + @eps && y < @vmax - @eps }\r\n        vy = unique_sorted(vy, @eps)\r\n\r\n        vx.each do |ux|\r\n          ys = crossings_for_x(ux, @loops2d, @eps)\r\n          next if ys.length.odd?\r\n          (0...(ys.length/2)).each do |i|\r\n            y0, y1 = ys[2*i], ys[2*i + 1]\r\n            brk = [y0] + vy.select { |yy| yy > y0 + @eps && yy < y1 - @eps } + [y1]\r\n            brk = unique_sorted(brk, @eps)\r\n            (0...brk.length-1).each do |j|\r\n              adicionar_ponto(ux, brk[j], ux, brk[j+1])\r\n            end\r\n          end\r\n        end\r\n\r\n        vy.each do |vyv|\r\n          xs = crossings_for_y(vyv, @loops2d, @eps)\r\n          next if xs.length.odd?\r\n          (0...(xs.length/2)).each do |i|\r\n            x0, x1 = xs[2*i], xs[2*i + 1]\r\n            brk = [x0] + vx.select { |xx| xx > x0 + @eps && xx < x1 - @eps } + [x1]\r\n            brk = unique_sorted(brk, @eps)\r\n            (0...brk.length-1).each do |j|\r\n              adicionar_ponto(brk[j], vyv, brk[j+1], vyv)\r\n            end\r\n          end\r\n        end\r\n\r\n        @model.active_view.invalidate\r\n      end\r\n\r\n      def adicionar_ponto(x1, y1, x2, y2)\r\n        p1w = (@t_l2w * Geom::Point3d.new(x1, y1, 0)).project_to_plane(@plane)\r\n        p2w = (@t_l2w * Geom::Point3d.new(x2, y2, 0)).project_to_plane(@plane)\r\n        @draw_points << p1w << p2w\r\n      end\r\n\r\n      def criar_dialogo\r\n        html = <<-HTML\r\n        <!DOCTYPE html>\r\n        <html>\r\n        <head>\r\n          <style>\r\n            :root { --primary: #0f62fe; --bg: #f4f4f4; --text: #161616; --border: #c6c6c6; }\r\n            * { box-sizing: border-box; }\r\n            body { \r\n              font-family: \"Segoe UI\", Roboto, Helvetica, sans-serif;\r\n              padding: 20px; \r\n              background: var(--bg); \r\n              color: var(--text); \r\n              margin: 0; \r\n              display: flex; \r\n              flex-direction: column; \r\n              height: 100vh;\r\n            }\r\n            h3 { margin: 0 0 15px 0; font-size: 14px; font-weight: 600;\r\n            color: #525252; text-transform: uppercase; letter-spacing: 0.5px; }\r\n            .control-group { \r\n              background: #fff;\r\n              padding: 15px; \r\n              border-radius: 8px; \r\n              box-shadow: 0 1px 3px rgba(0,0,0,0.08);\r\n              border: 1px solid #e0e0e0;\r\n            }\r\n            .row { display: flex; align-items: center; gap: 12px; }\r\n            input[type=range] { flex-grow: 1; cursor: pointer; accent-color: var(--primary); }\r\n            input[type=number] { \r\n              width: 70px;\r\n              padding: 6px; \r\n              text-align: right; \r\n              border: 1px solid var(--border); \r\n              border-radius: 4px; \r\n              font-size: 14px;\r\n            }\r\n            input[type=number]:focus { outline: 1px solid var(--primary); border-color: var(--primary); }\r\n            .unit { font-size: 13px; color: #666; font-weight: 500; }\r\n            .actions { margin-top: auto; display: flex; gap: 10px; justify-content: flex-end;\r\n            padding-top: 15px;}\r\n            button { \r\n              padding: 8px 16px;\r\n              cursor: pointer; \r\n              border: 1px solid var(--border); \r\n              background: #fff; \r\n              border-radius: 4px; \r\n              font-size: 13px;\r\n              transition: all 0.2s ease;\r\n            }\r\n            button:hover { background: #e5e5e5; }\r\n            #btnApply { background: var(--primary); color: white; border: none; font-weight: 500; }\r\n            #btnApply:hover { background: #0353e9; }\r\n          </style>\r\n        </head>\r\n        <body>\r\n          <h3>#{@modulo.obter_texto(:label_h3)}</h3>\r\n          <div class=\"control-group\">\r\n            <div class=\"row\">\r\n              <input type=\"range\" id=\"slider\" min=\"5\" max=\"2000\" value=\"50\" step=\"1\">\r\n              <input type=\"number\" id=\"inputBox\" min=\"1\" value=\"50\">\r\n              <span class=\"unit\">#{@modulo.obter_texto(:unidade)}</span>\r\n            </div>\r\n          </div>\r\n          <div class=\"actions\">\r\n            <button id=\"btnCancel\">#{@modulo.obter_texto(:btn_cancelar)}</button>\r\n            <button id=\"btnApply\">#{@modulo.obter_texto(:btn_aplicar)}</button>\r\n          </div>\r\n          \r\n          <script>\r\n            const slider = document.getElementById('slider');\r\n            const inputBox = document.getElementById('inputBox');\r\n            let timeout = null;\r\n            \r\n            function update(val) {\r\n              clearTimeout(timeout);\r\n              timeout = setTimeout(() => sketchup.update_preview(Number(val)), 10);\r\n            }\r\n\r\n            slider.addEventListener('input', (e) => { inputBox.value = e.target.value; update(e.target.value); });\r\n            inputBox.addEventListener('change', (e) => { slider.value = e.target.value; update(e.target.value); });\r\n\r\n            document.getElementById('btnApply').addEventListener('click', () => sketchup.apply_mesh());\r\n            document.getElementById('btnCancel').addEventListener('click', () => sketchup.cancel_mesh());\r\n          </script>\r\n        </body>\r\n        </html>\r\n        HTML\r\n\r\n        @dialog = UI::HtmlDialog.new({\r\n          dialog_title: @modulo.obter_texto(:titulo_janela), \r\n          width: 360, \r\n          height: 220,\r\n          style: UI::HtmlDialog::STYLE_DIALOG, \r\n          resizable: false\r\n        })\r\n        @dialog.set_html(html)\r\n\r\n        @dialog.add_action_callback(\"update_preview\") { |_, val| calcular_linhas(val) }\r\n        @dialog.add_action_callback(\"apply_mesh\") { |_| aplicar_malha }\r\n        @dialog.add_action_callback(\"cancel_mesh\") { |_| @model.select_tool(nil) }\r\n        \r\n        @dialog.show\r\n      end\r\n\r\n      def aplicar_malha\r\n        @is_applied = true\r\n        ents = @face.parent.entities\r\n        created = []\r\n        \r\n        @draw_points.each_slice(2) do |p1, p2|\r\n          e = ents.add_line(p1, p2)\r\n          created << e if e\r\n        end\r\n        \r\n        created.compact.each { |e| e.find_faces if e.valid? && e.faces.empty? }\r\n        created.compact.each do |e|\r\n          if e.valid? && e.faces.length == 2\r\n            e.soft = true\r\n            e.smooth = true\r\n          end\r\n        end\r\n        \r\n        @model.commit_operation\r\n        @dialog.close\r\n        @model.select_tool(nil)\r\n      end\r\n\r\n      def unique_sorted(vals, eps)\r\n        vals.sort!\r\n        out = []; last = nil\r\n        vals.each do |v|\r\n          if last.nil? || (v - last).abs > eps\r\n            out << v; last = v\r\n          end\r\n        end\r\n        out\r\n      end\r\n\r\n      def crossings_for_x(ux, loops2d, eps)\r\n        ys = []\r\n        loops2d.each do |poly|\r\n          (0...poly.length).each do |i|\r\n            p1 = poly[i]; p2 = poly[(i + 1) % poly.length]\r\n            x1,y1 = p1.x, p1.y; x2,y2 = p2.x, p2.y\r\n            minx, maxx = [x1,x2].min, [x1,x2].max\r\n            next if ux < minx - eps || ux > maxx + eps\r\n            dx = x2 - x1; next if dx.abs < eps\r\n            t = (ux - x1) / dx; next if t <= 0.0 || t > 1.0 + 1e-12\r\n            ys << (y1 + t*(y2 - y1))\r\n          end\r\n        end\r\n        unique_sorted(ys, eps)\r\n      end\r\n\r\n      def crossings_for_y(vy, loops2d, eps)\r\n        xs = []\r\n        loops2d.each do |poly|\r\n          (0...poly.length).each do |i|\r\n            p1 = poly[i]; p2 = poly[(i + 1) % poly.length]\r\n            x1,y1 = p1.x, p1.y; x2,y2 = p2.x, p2.y\r\n            miny, maxy = [y1,y2].min, [y1,y2].max\r\n            next if vy < miny - eps || vy > maxy + eps\r\n            dy = y2 - y1; next if dy.abs < eps\r\n            t = (vy - y1) / dy; next if t <= 0.0 || t > 1.0 + 1e-12\r\n            xs << (x1 + t*(x2 - x1))\r\n          end\r\n        end\r\n        unique_sorted(xs, eps)\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      sel   = model.selection\r\n      unless sel[0].is_a?(Sketchup::Face)\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n      face = sel[0]\r\n      n = face.normal\r\n\r\n      longest = face.edges.max_by { |e| e.length.to_f }\r\n      u = nil\r\n      if longest\r\n        vraw = (longest.end.position - longest.start.position)\r\n        dot  = vraw.dot(n)\r\n        nsc  = Geom::Vector3d.new(n.x * dot, n.y * dot, n.z * dot)\r\n        vproj = vraw - nsc\r\n        u = vproj.length > 1e-6 ? vproj.normalize : nil\r\n      end\r\n      if u.nil? || u.length < 1e-6\r\n        u = n.cross(X_AXIS);\r\n        u = n.cross(Y_AXIS) if u.length < 1e-6\r\n        u.normalize!\r\n      end\r\n      v = n.cross(u).normalize\r\n\r\n      plane = [face.vertices.first.position, n]\r\n      bb_center = face.bounds.center\r\n      c = bb_center.project_to_plane(plane)\r\n      t_l2w = Geom::Transformation.axes(c, u, v, n)\r\n      t_w2l = t_l2w.inverse\r\n\r\n      loops2d = face.loops.map do |lp|\r\n        pts = lp.vertices.map { |vr| t_w2l * vr.position }\r\n        pts.map! { |p| Geom::Point3d.new(p.x, p.y, 0) }\r\n        pts\r\n      end\r\n\r\n      all_pts = loops2d.flatten\r\n      allx = all_pts.map(&:x)\r\n      ally = all_pts.map(&:y)\r\n      umin, umax = allx.min, allx.max\r\n      vmin, vmax = ally.min, ally.max\r\n\r\n      model.select_tool(MalhaPreviewTool.new(model, face, loops2d, umin, umax, vmin, vmax, plane, t_l2w, self))\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::SubdivideFaceDistancia.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "selecao-de-malha-por-raio-96dfv",
    "title": {
      "pt": "Seleção de Malha por Raio",
      "en": "Mesh Selection by Radius",
      "es": "Selección de malla por radio"
    },
    "author": "Fábio Coutinho",
    "version": "0.3",
    "description": {
      "pt": "Permite selecionar faces de uma malha com uma ferramenta circular. Você pode definir o raio e alterar entre selecionar ou remover seleção.",
      "en": "Allows you to select mesh faces with a circular tool. You can set the radius and switch between selecting or removing the selection.",
      "es": "Permite seleccionar caras de malla con una herramienta circular. Se puede ajustar el radio y alternar entre seleccionar o eliminar la selección."
    },
    "keywords": {
      "pt": [
        "seleção de malha"
      ],
      "en": [
        "mesh selection"
      ],
      "es": [
        "selección de malla"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module PolyBrushSelecao\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :status_text    => \"Pinte com botão esquerdo (commit no soltar). CTRL alterna modo. SHIFT+R reindexa. VCB: diâmetro + ENTER.\",\r\n        :modo_remover   => \"MODO: Desfazer (CTRL alterna)\",\r\n        :modo_selecionar => \"MODO: Selecionar (CTRL alterna)\",\r\n        :hud_diametro   => \"Diâmetro: %{diam} mm  |  Medidas: digite valor + ENTER\",\r\n        :op_nome        => \"PolyBrush Seleção\"\r\n      },\r\n      'en-US' => {\r\n        :status_text    => \"Paint with left button (commit on release). CTRL toggles mode. SHIFT+R reindexes. VCB: diameter + ENTER.\",\r\n        :modo_remover   => \"MODE: Remove (CTRL toggles)\",\r\n        :modo_selecionar => \"MODE: Select (CTRL toggles)\",\r\n        :hud_diametro   => \"Diameter: %{diam} mm  |  Measurements: type value + ENTER\",\r\n        :op_nome        => \"PolyBrush Selection\"\r\n      },\r\n      'es' => {\r\n        :status_text    => \"Pinte con el botón izquierdo (confirmar al soltar). CTRL alterna modo. SHIFT+R reindexa. VCB: diámetro + ENTER.\",\r\n        :modo_remover   => \"MODO: Deshacer (CTRL alterna)\",\r\n        :modo_selecionar => \"MODO: Seleccionar (CTRL alterna)\",\r\n        :hud_diametro   => \"Diámetro: %{diam} mm  |  Medidas: escriba valor + ENTER\",\r\n        :op_nome        => \"Selección PolyBrush\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave, variaveis = {})\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      texto  = IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n      variaveis.each { |k, v| texto = texto.gsub(\"%{#{k}}\", v.to_s) }\r\n      texto\r\n    end\r\n\r\n    class Tool\r\n      include Math\r\n\r\n      def initialize\r\n        require 'set'\r\n\r\n        @diameter_mm = 10000.0\r\n        @radius      = @diameter_mm.mm / 2.0\r\n        @mode_remove = false\r\n        @dragging    = false\r\n        @cursor_pt   = nil\r\n        @ctrl_prev   = false\r\n\r\n        model    = Sketchup.active_model\r\n        @edit_tr = model.edit_transform\r\n\r\n        # Eixos do contexto\r\n        @px = Geom::Vector3d.new(1,0,0).transform(@edit_tr)\r\n        @px.length == 0 ? @px.set!(1,0,0) : @px.normalize!\r\n        @py = Geom::Vector3d.new(0,1,0).transform(@edit_tr); @py.length == 0 ? @py.set!(0,1,0) : @py.normalize!\r\n        @pz = Geom::Vector3d.new(0,0,1).transform(@edit_tr)\r\n        @pz.length == 0 ? @pz.set!(0,0,1) : @pz.normalize!\r\n        @porigin = Geom::Point3d.new(0,0,0).transform(@edit_tr)\r\n\r\n        # Índice espacial inicial\r\n        build_uv_cache(@radius)\r\n\r\n        # Buffers da passada atual (arrasto)\r\n        @stroke_face_pids = nil   \r\n        @stroke_painted   = Set.new \r\n        @applied_ids      = Set.new \r\n        @sel_initial_face_pids = Set.new\r\n        @sel_initial_others    = [] \r\n      end\r\n\r\n      # ---------- Utils ----------\r\n      def scale_vec(v, s) Geom::Vector3d.new(v.x*s, v.y*s, v.z*s) end\r\n\r\n      def project_uv(p3)\r\n        v = p3 - @porigin\r\n        [v.dot(@px), v.dot(@py)]\r\n      end\r\n\r\n      def pick_on_surface(x, y, view)\r\n        ray = view.pickray(x, y)\r\n        hit = Sketchup.active_model.raytest(ray, true)\r\n        pt = hit && hit[0]\r\n        pt ||= Geom.intersect_line_plane(ray, [@porigin, @pz])\r\n        pt ? pt.offset(@pz, 0.5.mm) : nil\r\n      end\r\n\r\n      def circle_points(center3d, radius_len, segments = 64)\r\n        r = radius_len.to_f\r\n        pts = []\r\n        segments.times do |i|\r\n          t  = 2.0 * PI * (i.to_f / segments)\r\n          vx = scale_vec(@px, r * Math.cos(t))\r\n          vy = scale_vec(@py, r * Math.sin(t))\r\n          pts << center3d.offset(vx + vy)\r\n        end\r\n        pts\r\n      end\r\n\r\n      # ---------- Índice Espacial / Cache ----------\r\n      def build_uv_cache(cell_size = @radius)\r\n        ents  = Sketchup.active_model.active_entities\r\n        @faces = ents.grep(Sketchup::Face).select(&:valid?)\r\n        @pid_to_face = {}\r\n        @uv_by_pid   = {}\r\n        @grid        = {}\r\n        @cell = [cell_size.to_f, 1.mm.to_f].max\r\n\r\n        @faces.each do |f|\r\n          pid = f.persistent_id\r\n          @pid_to_face[pid] = f\r\n          uvs = f.vertices.map { |v| project_uv(v.position) }\r\n          @uv_by_pid[pid] = uvs\r\n          umin, umax = uvs.map(&:first).minmax\r\n          vmin, vmax = uvs.map(&:last ).minmax\r\n          ix0 = (umin/@cell).floor\r\n          ix1 = (umax/@cell).floor\r\n          iy0 = (vmin/@cell).floor\r\n          iy1 = (vmax/@cell).floor\r\n          (ix0..ix1).each do |ix|\r\n            (iy0..iy1).each do |iy|\r\n              key = \"#{ix},#{iy}\"\r\n              (@grid[key] ||= Set.new) << pid\r\n            end\r\n          end\r\n        end\r\n      end\r\n\r\n      def candidate_pids(center3d, radius)\r\n        uc, vc = project_uv(center3d)\r\n        r  = radius.to_f\r\n        cr = (r/@cell).ceil\r\n        cix = (uc/@cell).floor\r\n        ciy = (vc/@cell).floor\r\n        out = Set.new\r\n        (-cr..cr).each do |dx|\r\n          (-cr..cr).each do |dy|\r\n            key = \"#{cix+dx},#{ciy+dy}\"\r\n            s = @grid[key]\r\n            out.merge(s) if s\r\n          end\r\n        end\r\n        out\r\n      end\r\n\r\n      # ---------- Passada (arrasto) em memória ----------\r\n      def begin_stroke\r\n        sel = Sketchup.active_model.selection\r\n        faces = sel.grep(Sketchup::Face)\r\n        others = sel.to_a - faces\r\n        @sel_initial_face_pids = Set.new(faces.map(&:persistent_id))\r\n        @sel_initial_others    = others\r\n        @stroke_face_pids = @sel_initial_face_pids.dup\r\n        @stroke_painted.clear\r\n        @applied_ids.clear\r\n      end\r\n\r\n      def apply_brush_at(center3d)\r\n        return unless center3d\r\n        return unless @stroke_face_pids\r\n\r\n        r   = @radius.to_f\r\n        r2  = r*r\r\n        uc, vc = project_uv(center3d)\r\n\r\n        candidate_pids(center3d, r).each do |pid|\r\n          next if @applied_ids.include?(pid)\r\n          uvs = @uv_by_pid[pid]\r\n          next unless uvs && !uvs.empty?\r\n          inside = uvs.any? { |(u,v)| ((u-uc)**2 + (v-vc)**2) <= r2 }\r\n          next unless inside\r\n\r\n          if @mode_remove\r\n            @stroke_face_pids.delete(pid)\r\n          else\r\n            @stroke_face_pids.add(pid)\r\n          end\r\n\r\n          @stroke_painted.add(pid)\r\n          @applied_ids.add(pid)\r\n        end\r\n      end\r\n\r\n      def commit_stroke\r\n        return unless @stroke_face_pids\r\n\r\n        faces_final = @stroke_face_pids.map { |pid|\r\n          f = @pid_to_face[pid]\r\n          (f && f.valid?) ? f : nil\r\n        }.compact\r\n        final_selection = @sel_initial_others + faces_final\r\n\r\n        model = Sketchup.active_model\r\n        sel   = model.selection\r\n        model.start_operation(PolyBrushSelecao.obter_texto(:op_nome), true)\r\n        sel.clear\r\n        sel.add(final_selection)\r\n        model.commit_operation\r\n\r\n        @stroke_face_pids = nil\r\n        @stroke_painted.clear\r\n        @applied_ids.clear\r\n      end\r\n\r\n      def cancel_stroke\r\n        @stroke_face_pids = nil\r\n        @stroke_painted.clear\r\n        @applied_ids.clear\r\n      end\r\n\r\n      # ---------- HUD ----------\r\n      def hud_lines\r\n        mode = @mode_remove ? PolyBrushSelecao.obter_texto(:modo_remover) : PolyBrushSelecao.obter_texto(:modo_selecionar)\r\n        dim  = PolyBrushSelecao.obter_texto(:hud_diametro, {:diam => @diameter_mm.to_i})\r\n        [mode, dim]\r\n      end\r\n\r\n      def is_ctrl_key?(key) key == 17 end \r\n      def ctrl_down?(flags) (flags & COPY_MODIFIER_KEY) == COPY_MODIFIER_KEY end\r\n\r\n      # ---------- Tool API ----------\r\n      def activate\r\n        Sketchup.status_text = PolyBrushSelecao.obter_texto(:status_text)\r\n      end\r\n\r\n      def deactivate(view); view.invalidate; end\r\n\r\n      def onMouseMove(flags, x, y, view)\r\n        @cursor_pt = pick_on_surface(x, y, view)\r\n        if @dragging\r\n          apply_brush_at(@cursor_pt)\r\n        end\r\n        view.invalidate\r\n      end\r\n\r\n      def onLButtonDown(flags, x, y, view)\r\n        @dragging = true\r\n        begin_stroke\r\n        @cursor_pt = pick_on_surface(x, y, view)\r\n        apply_brush_at(@cursor_pt)\r\n        view.invalidate\r\n      end\r\n\r\n      def onLButtonUp(flags, x, y, view)\r\n        @dragging = false\r\n        commit_stroke\r\n        view.invalidate\r\n      end\r\n\r\n      def onKeyDown(key, repeat, flags, view)\r\n        if key == 82 && (flags & SHIFT_MODIFIER_KEY) == SHIFT_MODIFIER_KEY # 'R'\r\n          build_uv_cache(@radius)\r\n          UI.beep\r\n          view.invalidate\r\n          return\r\n        end\r\n\r\n        if (is_ctrl_key?(key) || ctrl_down?(flags)) && !@ctrl_prev\r\n          @mode_remove = !@mode_remove\r\n          @ctrl_prev = true\r\n          view.invalidate\r\n        end\r\n      end\r\n\r\n      def onKeyUp(key, repeat, flags, view)\r\n        @ctrl_prev = false unless ctrl_down?(flags)\r\n      end\r\n\r\n      def onCancel(reason, view)\r\n        @dragging = false\r\n        cancel_stroke\r\n        view.invalidate\r\n      end\r\n\r\n      def onUserText(text, view)\r\n        str = text.to_s.strip\r\n        return if str.empty?\r\n        len = if str =~ /[a-zA-Z]/\r\n                begin\r\n                  str.to_l\r\n                rescue\r\n                  nil\r\n                end\r\n              else\r\n                (str.to_f).mm\r\n              end\r\n\r\n        return unless len && len > 0.0\r\n        @diameter_mm = len.to_mm\r\n        @radius      = len / 2.0\r\n        build_uv_cache(@radius)\r\n        view.invalidate\r\n      end\r\n\r\n      def draw(view)\r\n        if @cursor_pt\r\n          r = @radius.to_f\r\n          pts = circle_points(@cursor_pt, r, 72)\r\n          view.line_stipple  = \"\"\r\n          view.line_width    = 2\r\n          view.drawing_color = @mode_remove ? Sketchup::Color.new(220, 60, 60) : Sketchup::Color.new(60, 180, 60)\r\n          view.draw(GL_LINE_LOOP, pts)\r\n\r\n          cpts = circle_points(@cursor_pt, [r * 0.025, 2.mm.to_f].max, 24)\r\n          view.line_width = 1\r\n          view.drawing_color = Sketchup::Color.new(40, 40, 40)\r\n          view.draw(GL_LINE_LOOP, cpts)\r\n\r\n          scr = view.screen_coords(@cursor_pt)\r\n          y = scr.y + 18\r\n          hud_lines.each do |txt|\r\n            view.draw_text(Geom::Point3d.new(scr.x + 12, y, 0), txt)\r\n            y += 16\r\n          end\r\n        end\r\n\r\n        return unless @dragging && !@stroke_painted.empty?\r\n        view.line_width = 1\r\n        view.drawing_color = Sketchup::Color.new(30, 150, 240)\r\n        @stroke_painted.each do |pid|\r\n          f = @pid_to_face[pid]\r\n          next unless f && f.valid?\r\n          edges = f.outer_loop.edges\r\n          pts = []\r\n          edges.each do |e|\r\n            pts << e.start.position\r\n            pts << e.end.position\r\n          end\r\n          view.draw(GL_LINES, pts) unless pts.empty?\r\n        end\r\n      end\r\n\r\n      def getExtents\r\n        bb = Geom::BoundingBox.new\r\n        if @cursor_pt\r\n          r = @radius.to_f\r\n          xoff = scale_vec(@px, r)\r\n          yoff = scale_vec(@py, r)\r\n          bb.add(@cursor_pt.offset(xoff + yoff))\r\n          bb.add(@cursor_pt.offset(xoff - yoff))\r\n          bb.add(@cursor_pt.offset(scale_vec(@px, -r) + yoff))\r\n          bb.add(@cursor_pt.offset(scale_vec(@px, -r) + scale_vec(@py, -r)))\r\n        end\r\n        bb\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      Sketchup.active_model.tools.push_tool(Tool.new)\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::PolyBrushSelecao.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "remover-materiais-aplicados-96f3p",
    "title": {
      "pt": "Remover Materiais Aplicados",
      "en": "Remove Applied Materials",
      "es": "Eliminar materiales aplicados"
    },
    "author": "Fábio Coutinho",
    "version": "0.2",
    "description": {
      "pt": "Remove todos os materiais aplicados em toda a hierarquia dos elementos selecionados.",
      "en": "Remove all materials applied across the entire hierarchy of the selected elements.",
      "es": "Eliminar todos los materiales aplicados en toda la jerarquía de los elementos seleccionados."
    },
    "keywords": {
      "pt": [
        "remover materiais",
        "material",
        "textura"
      ],
      "en": [
        "remove materials",
        "material",
        "texture"
      ],
      "es": [
        "retirar materiales",
        "material",
        "textura"
      ]
    },
    "code": {
      "pt": "# Remover TODOS os materiais do selecionado (grupo/componente) e de toda a hierarquia\r\n# Cole no Console Ruby com um grupo ou componente selecionado.\r\n\r\nmodel = Sketchup.active_model\r\nsel = model.selection\r\nalvos = sel.grep(Sketchup::Group) + sel.grep(Sketchup::ComponentInstance)\r\n\r\nif alvos.empty?\r\n  puts \"Selecione um grupo ou componente.\"\r\n  return\r\nend\r\n\r\nfaces_limpas = 0\r\ninst_processadas = 0\r\ndefinicoes_unicas = 0\r\ndefs_processadas = {} # NOVO: Dicionário para evitar reprocessamento\r\n\r\nclear_entities = nil\r\nclear_instance = nil\r\n\r\nclear_entities = lambda { |entities|\r\n  # Faces: limpa frente e verso de forma direta, sem checagens redundantes\r\n  entities.grep(Sketchup::Face).each do |f|\r\n    if f.material\r\n      f.material = nil\r\n      faces_limpas += 1\r\n    end\r\n    if f.back_material\r\n      f.back_material = nil\r\n      faces_limpas += 1\r\n    end\r\n  end\r\n\r\n  # Grupos e Componentes: concatenados para iterar apenas uma vez\r\n  (entities.grep(Sketchup::Group) + entities.grep(Sketchup::ComponentInstance)).each do |inst|\r\n    next if inst.deleted?\r\n    inst.material = nil if inst.material\r\n    inst_processadas += 1\r\n    clear_instance.call(inst)\r\n  end\r\n}\r\n\r\nclear_instance = lambda { |inst|\r\n  is_group = inst.is_a?(Sketchup::Group)\r\n  \r\n  # Removemos o make_unique. A limpeza agora age direto na raiz da Definição.\r\n  # Isso iguala a performance ao Material Tools.\r\n  defn = is_group ? inst.entities.parent : inst.definition\r\n  \r\n  # Checa o cache: varre as entidades internas apenas na primeira vez que encontrar esta definição\r\n  unless defs_processadas[defn]\r\n    defs_processadas[defn] = true\r\n    clear_entities.call(is_group ? inst.entities : defn.entities)\r\n  end\r\n}\r\n\r\nmodel.start_operation(\"Remover Materiais Recursivo\", true)\r\nbegin\r\n  alvos.each do |t|\r\n    t.material = nil if t.respond_to?(:material) && t.material\r\n    inst_processadas += 1\r\n    clear_instance.call(t)\r\n  end\r\n  model.commit_operation\r\nrescue => e\r\n  model.abort_operation\r\n  puts \"Erro: #{e}\"\r\nend\r\n\r\nputs \"Materiais removidos.\"\r\nputs \"Faces limpas: #{faces_limpas}\"\r\nputs \"Instâncias processadas: #{inst_processadas}\"\r\nputs \"Definições tornadas únicas: #{definicoes_unicas}\""
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "regua-dinamica-de-superficie-96h28",
    "title": {
      "pt": "Régua Dinâmica de Superfície",
      "en": "Dynamic Surface Ruler",
      "es": "Regla de superficie dinámica"
    },
    "author": "Fábio Coutinho",
    "version": "0.4",
    "description": {
      "pt": "Régua dinâmica que acompanha a posição do cursor e mostra a medida da superfície de aresta a aresta.",
      "en": "A dynamic ruler that follows the cursor's position and shows the surface area measurement from edge to edge.",
      "es": "Una regla dinámica que sigue la posición del cursor y muestra la medida del área de la superficie de borde a borde."
    },
    "keywords": {
      "pt": [
        "régua",
        "medidas"
      ],
      "en": [
        "ruler",
        "measures"
      ],
      "es": [
        "gobernante",
        "medidas"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module MedirParedes\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :status_texto => \"Unidade: %s (CTRL) | Setas ESQUERDA e DIREITA alteram a rotação.\",\r\n        :console_ativo => \"[RaycastTool] Ativo. Medição parede-a-parede ignorando ocultos.\",\r\n        :console_clique => \"[Raycast] Clique ignorado. Use Ctrl para unidades.\"\r\n      },\r\n      'en-US' => {\r\n        :status_texto => \"Unit: %s (CTRL) | LEFT and RIGHT arrows change rotation.\",\r\n        :console_ativo => \"[RaycastTool] Active. Wall-to-wall measurement ignoring hidden objects.\",\r\n        :console_clique => \"[Raycast] Click ignored. Use Ctrl for units.\"\r\n      },\r\n      'es' => {\r\n        :status_texto => \"Unidad: %s (CTRL) | Flechas IZQUIERDA y DERECHA cambian la rotación.\",\r\n        :console_ativo => \"[RaycastTool] Activo. Medición de pared a pared ignorando ocultos.\",\r\n        :console_clique => \"[Raycast] Clic ignorado. Use Ctrl para unidades.\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.executar\r\n      Sketchup.active_model.select_tool(Tool.new)\r\n    end\r\n\r\n    class Tool\r\n      # Constantes\r\n      EPS       = 1.mm unless defined?(EPS)\r\n      VEC_EPS   = 1e-5 unless defined?(VEC_EPS)\r\n      Z_AXIS    = Geom::Vector3d.new(0, 0, 1) unless defined?(Z_AXIS)\r\n      X_AXIS    = Geom::Vector3d.new(1, 0, 0) unless defined?(X_AXIS)\r\n\r\n      def activate\r\n        @ip = Sketchup::InputPoint.new\r\n        @preview_data = nil\r\n        @rot_index = 0 \r\n        @last_x = 0\r\n        @last_y = 0\r\n\r\n        setup_initial_unit\r\n        Sketchup.active_model.active_view.invalidate\r\n        update_status_text\r\n        puts MedirParedes.obter_texto(:console_ativo)\r\n      end\r\n\r\n      def deactivate(view)\r\n        view.invalidate\r\n      end\r\n\r\n      def resume(view)\r\n        update_status_text\r\n        view.invalidate\r\n      end\r\n\r\n      def onCancel(reason, view)\r\n        @preview_data = nil\r\n        view.invalidate\r\n      end\r\n\r\n      def onKeyUp(key, repeat, flags, view)\r\n        case key\r\n        when VK_RIGHT\r\n          @rot_index = (@rot_index + 1) % 4\r\n          trigger_update(view)\r\n        when VK_LEFT\r\n          @rot_index = (@rot_index - 1) % 4\r\n          trigger_update(view)\r\n        when VK_CONTROL\r\n          @unit_index = (@unit_index + 1) % 3\r\n          trigger_update(view)\r\n        end\r\n      end\r\n\r\n      def onKeyDown(key, repeat, flags, view)\r\n      end\r\n\r\n      def onMouseMove(flags, x, y, view)\r\n        @last_x, @last_y = x, y\r\n        @ip.pick(view, x, y)\r\n        @preview_data = calculate_raycast_hits(view, x, y)\r\n        view.invalidate\r\n      end\r\n\r\n      def draw(view)\r\n        @ip.draw(view) if @ip.valid?\r\n\r\n        if @preview_data\r\n          p_center, p_hit_pos, p_hit_neg = @preview_data\r\n          \r\n          pt_start = p_hit_neg ? p_hit_neg : p_center\r\n          pt_end   = p_hit_pos ? p_hit_pos : p_center\r\n\r\n          if pt_start != pt_end\r\n            view.line_width = 2\r\n            view.line_stipple = \"_\"\r\n            view.drawing_color = \"red\" \r\n            view.draw(GL_LINES, pt_start, pt_end)\r\n            view.draw_points([pt_start, pt_end], 10, 2, \"red\")\r\n\r\n            total_dist = pt_start.distance(pt_end)\r\n            text_str = format_distance(total_dist)\r\n\r\n            screen_p1 = view.screen_coords(pt_start)\r\n            screen_p2 = view.screen_coords(pt_end)\r\n            \r\n            text_pos = calculate_smart_text_pos(screen_p1, screen_p2)\r\n\r\n            draw_highlighted_text(view, text_pos, text_str)\r\n          end\r\n        end\r\n      end\r\n\r\n      def draw_highlighted_text(view, screen_pt, text)\r\n        options = { :color => \"red\", :size => 20, :bold => true, :font => \"Arial\" }\r\n        begin\r\n          view.draw_text(screen_pt, text, options)\r\n        rescue\r\n          view.draw_text(screen_pt, text)\r\n        end\r\n      end\r\n\r\n      def calculate_smart_text_pos(sp1, sp2)\r\n        mid_x = (sp1.x + sp2.x) / 2.0\r\n        mid_y = (sp1.y + sp2.y) / 2.0\r\n        \r\n        vx = sp2.x - sp1.x\r\n        vy = sp2.y - sp1.y\r\n        len = Math.sqrt(vx*vx + vy*vy)\r\n        offset_dist = 25.0\r\n\r\n        return Geom::Point3d.new(mid_x, mid_y - offset_dist, 0) if len < 1.0\r\n\r\n        ux = vx / len\r\n        uy = vy / len\r\n        perp_x = -uy\r\n        perp_y = ux\r\n\r\n        if perp_y > 0\r\n          perp_x = -perp_x\r\n          perp_y = -perp_y\r\n        end\r\n\r\n        final_x = mid_x + (perp_x * offset_dist) - 20\r\n        final_y = mid_y + (perp_y * offset_dist) - 10\r\n\r\n        Geom::Point3d.new(final_x, final_y, 0)\r\n      end\r\n\r\n      def onLButtonDown(flags, x, y, view)\r\n        puts MedirParedes.obter_texto(:console_clique)\r\n      end\r\n\r\n      private\r\n\r\n      def setup_initial_unit\r\n        model_unit = Sketchup.active_model.options['UnitsOptions']['LengthUnit']\r\n        case model_unit\r\n        when 2 then @unit_index = 0 # mm\r\n        when 3 then @unit_index = 1 # cm\r\n        when 4 then @unit_index = 2 # m\r\n        else        @unit_index = 1 \r\n        end\r\n      end\r\n\r\n      def format_distance(dist_inch)\r\n        val = 0.0\r\n        suffix = \"\"\r\n        case @unit_index\r\n        when 0 then val = dist_inch.to_mm; suffix = \"mm\"\r\n        when 1 then val = dist_inch.to_cm; suffix = \"cm\"\r\n        when 2 then val = dist_inch.to_m;  suffix = \"m\"\r\n        end\r\n        sprintf(\"%.2f %s\", val, suffix)\r\n      end\r\n\r\n      def update_status_text\r\n        units = [\"mm\", \"cm\", \"m\"]\r\n        cur_unit = units[@unit_index]\r\n        Sketchup.set_status_text(sprintf(MedirParedes.obter_texto(:status_texto), cur_unit))\r\n      end\r\n\r\n      def trigger_update(view)\r\n        update_status_text\r\n        onMouseMove(0, @last_x, @last_y, view)\r\n      end\r\n\r\n      def calculate_raycast_hits(view, x, y)\r\n        ph = view.pick_helper\r\n        ph.do_pick(x, y)\r\n        path = ph.path_at(0)\r\n        return nil unless path && !path.empty?\r\n\r\n        face = path.reverse.find { |e| e.is_a?(Sketchup::Face) }\r\n        return nil unless face\r\n        return nil unless @ip.valid?\r\n        \r\n        click_world = @ip.position\r\n\r\n        insts = path.take_while { |e| e.is_a?(Sketchup::ComponentInstance) || e.is_a?(Sketchup::Group) }\r\n        t_world_from_ctx = Geom::Transformation.new\r\n        insts.each { |i| t_world_from_ctx *= i.transformation }\r\n\r\n        normal_local = face.normal\r\n        side_local = normal_local.cross(Z_AXIS)\r\n        side_local = X_AXIS.clone if !side_local.valid? || side_local.length < VEC_EPS\r\n        side_local.normalize!\r\n\r\n        if @rot_index > 0\r\n          angle = @rot_index * 90.degrees\r\n          tr_rot = Geom::Transformation.rotation(Geom::Point3d.new(0,0,0), normal_local, angle)\r\n          side_local.transform!(tr_rot)\r\n        end\r\n\r\n        side_world = side_local.transform(t_world_from_ctx)\r\n        return nil if !side_world.valid? || side_world.length < VEC_EPS\r\n        side_world.normalize!\r\n\r\n        p2_pos = global_raycast_recursive(click_world, side_world)\r\n        p2_neg = global_raycast_recursive(click_world, side_world.reverse)\r\n\r\n        [click_world, p2_pos, p2_neg]\r\n      end\r\n\r\n      def global_raycast_recursive(start_pt_world, vec_world)\r\n        return nil if vec_world.nil? || !vec_world.valid?\r\n        \r\n        current_origin = start_pt_world\r\n        model = Sketchup.active_model\r\n\r\n        100.times do\r\n          origin_offset = current_origin.offset(vec_world, EPS)\r\n          ray = [origin_offset, vec_world]\r\n          \r\n          result = model.raytest(ray, true) \r\n          \r\n          return nil unless result \r\n          \r\n          hit_point, hit_path = result\r\n\r\n          if is_full_path_visible?(hit_path)\r\n            return hit_point \r\n          else\r\n            current_origin = hit_point\r\n          end\r\n        end\r\n        \r\n        return nil \r\n      end\r\n\r\n      def is_full_path_visible?(path)\r\n        path.each do |ent|\r\n          return false if ent.respond_to?(:visible?) && !ent.visible?\r\n\r\n          if ent.respond_to?(:layer)\r\n            layer = ent.layer\r\n            if layer.is_a?(String)\r\n              l_obj = Sketchup.active_model.layers[layer]\r\n              return false if l_obj && !l_obj.visible?\r\n            elsif layer.respond_to?(:visible?)\r\n              return false unless layer.visible?\r\n            end\r\n          end\r\n        end\r\n        true\r\n      end\r\n\r\n    end\r\n  end\r\nend\r\n\r\nScriptUpComunidade::MedirParedes.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "tour-virtual-96idc",
    "title": {
      "pt": "Tour Virtual",
      "en": "Virtual Tour",
      "es": "Visita virtual"
    },
    "author": "Fábio Coutinho",
    "version": "2.6",
    "description": {
      "pt": "Permite criar e gerenciar a criação de cenas em linha de tempo, várias linhas de tempo, apresentar a transição entre elas de forma suave e sem impacto de troca de cena e exportação de vídeo com FFMPEG de forma rápida por captura de tela enquanto apresenta.",
      "en": "It allows you to create and manage timeline scenes, multiple timelines, present the transition between them smoothly and without scene change impact, and quickly export video with FFMPEG by screen capture while presenting.",
      "es": "Le permite crear y administrar escenas de línea de tiempo, múltiples líneas de tiempo, presentar la transición entre ellas sin problemas y sin impacto en el cambio de escena, y exportar rápidamente video con FFMPEG mediante captura de pantalla mientras se presenta."
    },
    "keywords": {
      "pt": [
        "tour",
        "apresentação",
        "vídeo"
      ],
      "en": [
        "tour",
        "presentation",
        "video"
      ],
      "es": [
        "recorrido",
        "presentación",
        "video"
      ]
    },
    "code": {
      "pt": "require 'json'\r\nrequire 'sketchup.rb'\r\nrequire 'base64'\r\nrequire 'tmpdir'\r\nrequire 'fiddle/import'\r\nrequire 'fileutils'\r\nrequire 'open3'\r\nrequire 'etc'\r\nrequire 'open-uri'\r\nif Sketchup.platform == :platform_win\r\n  require 'win32ole'\r\nend\r\n\r\nmodule ScriptUpComunidade\r\nmodule TourVirtual\r\n\r\n# --- Definições de Diretórios ---\r\nplugins_root = Sketchup.find_support_file(\"Plugins\")\r\nPLUGIN_DIR = if plugins_root\r\n               File.expand_path(File.join(plugins_root, 'ScriptUp'))\r\n             else\r\n               File.expand_path(File.dirname(__FILE__))\r\n             end\r\n\r\nIDIOMAS = {\r\n  'pt-BR' => {\r\n    :status_clicar_arrastar  => \"CLIQUE E ARRASTE para definir a área de gravação do vídeo.\",\r\n    :area_pequena            => \"Área muito pequena. Tente novamente.\",\r\n    :selecionar_pasta        => \"Selecione a pasta para salvar\",\r\n    :ffmpeg_nao_encontrado   => \"FFmpeg não encontrado.\",\r\n    :erro_gravador           => \"Erro ao iniciar gravador: \",\r\n    :gravacao_finalizada     => \"Gravação finalizada!\\nSalvo em: \",\r\n    :ffmpeg_instalado        => \"FFmpeg instalado. Execute o Tour Virtual novamente.\",\r\n    :titulo_dialogo          => \"Tour Virtual\",\r\n    :ffmpeg_plugins_erro     => \"Não foi possível resolver a pasta Plugins automaticamente.\",\r\n    :ffmpeg_instalar_em      => \"Instalar FFmpeg em:\",\r\n    :ffmpeg_origem           => \"Origem:\",\r\n    :ffmpeg_continuar        => \"Continuar?\",\r\n    :ffmpeg_cancelada        => \"Instalação cancelada.\",\r\n    :ffmpeg_ja_existe        => \"Já existe:\",\r\n    :ffmpeg_sobrescrever     => \"Deseja sobrescrever?\",\r\n    :ffmpeg_falha_expand     => \"Falha no Expand-Archive (PowerShell).\",\r\n    :ffmpeg_falha_unzip      => \"Falha no unzip (macOS).\",\r\n    :ffmpeg_exe_nao_encontrado => \"Executável ffmpeg não encontrado no pacote baixado.\",\r\n    :ffmpeg_sucesso          => \"FFmpeg instalado com sucesso em:\",\r\n    :ffmpeg_falhou           => \"Falhou:\",\r\n    :ffmpeg_abrindo_nav      => \"Abrindo o link no navegador...\",\r\n    :titulo                  => \"Tour Virtual\",\r\n    :subtitulo               => \"Linha do Tempo\",\r\n    :total                   => \"Total:\",\r\n    :visao                   => \"Visão\",\r\n    :play                    => \"Play\",\r\n    :stop                    => \"Stop\",\r\n    :play_all                => \"Play All\",\r\n    :stop_all                => \"Stop All\",\r\n    :atalho                  => \"Atalho\",\r\n    :pressione               => \"Pressione...\",\r\n    :ok                      => \"Ok\",\r\n    :loop                    => \"Loop\",\r\n    :easing                  => \"Easing\",\r\n    :visoes_salvas           => \"Visões salvas\",\r\n    :gerenciar_timeline      => \"Gerenciar Time Line\",\r\n    :nova                    => \"Nova\",\r\n    :exportar_atual          => \"Exportar Atual\",\r\n    :exportar_projeto        => \"Exportar Projeto\",\r\n    :importar                => \"Importar\",\r\n    :exportar_video          => \"Exportar Vídeo\",\r\n    :selecione_formato       => \"Selecione o formato…\",\r\n    :largura                 => \"Largura\",\r\n    :altura                  => \"Altura\",\r\n    :gravar_projeto          => \"Gravar todo o projeto (todas as Time Lines)\",\r\n    :iniciar_quadro1         => \"Iniciar do quadro 1\",\r\n    :iniciar_gravacao        => \"Iniciar Gravação\",\r\n    :gravando                => \"Gravando...\",\r\n    :ffmpeg_necessario       => \"FFmpeg necessário para gravar vídeo.\",\r\n    :instalar_ffmpeg         => \"Instalar FFmpeg\",\r\n    :nome_arquivo            => \"Nome do arquivo\",\r\n    :extensao_mp4            => \"A extensão .mp4 será adicionada automaticamente.\",\r\n    :cancelar                => \"Cancelar\",\r\n    :salvar                  => \"Salvar\",\r\n    :viewport_atual          => \"Viewport atual:\",\r\n    :paisagem                => \"Paisagem\",\r\n    :retrato                 => \"Retrato\",\r\n    :quadrado                => \"Quadrado\",\r\n    :classico                => \"Clássico\",\r\n    :ultra_wide              => \"Ultra-wide\",\r\n    :viewport_inteira        => \"Viewport Inteira\",\r\n    :personalizado           => \"Personalizado\",\r\n    :nome_timeline           => \"Nome da Time Line:\",\r\n    :nenhuma_visao           => \"Nenhuma visão adicionada.\",\r\n    :dica_visao              => \"Posicione a câmera e clique em <b>+ Visão</b>.\",\r\n    :ancora                  => \"Âncora\",\r\n    :excluir                 => \"Excluir\",\r\n    :min_duas_visoes         => \"Adicione pelo menos duas visões.\",\r\n    :sem_tl_2mais            => \"Nenhuma Time Line com 2+ visões.\",\r\n    :sem_visoes_exportar     => \"Nenhuma visão para exportar.\",\r\n    :sem_tl_exportar         => \"Nenhuma Time Line para exportar.\",\r\n    :importada               => \"Importada\",\r\n    :formato_invalido        => \"Formato inválido.\",\r\n    :erro_importar           => \"Erro ao importar: \",\r\n    :visoes                  => \"visões\",\r\n    :nova_timeline           => \"Nome da nova Time Line:\",\r\n    :area_gravacao           => \"Área de gravação: \",\r\n    :sem_tl_min_duas         => \"Nenhuma Time Line com pelo menos duas visões.\",\r\n    :dims_invalidas          => \"Dimensões inválidas (mínimo 50 x 50 px).\",\r\n    :digite_nome             => \"Digite um nome para o arquivo.\",\r\n  },\r\n  'en-US' => {\r\n    :status_clicar_arrastar  => \"CLICK AND DRAG to define the video recording area.\",\r\n    :area_pequena            => \"Area too small. Try again.\",\r\n    :selecionar_pasta        => \"Select folder to save\",\r\n    :ffmpeg_nao_encontrado   => \"FFmpeg not found.\",\r\n    :erro_gravador           => \"Error starting recorder: \",\r\n    :gravacao_finalizada     => \"Recording finished!\\nSaved to: \",\r\n    :ffmpeg_instalado        => \"FFmpeg installed. Run Virtual Tour again.\",\r\n    :titulo_dialogo          => \"Virtual Tour\",\r\n    :ffmpeg_plugins_erro     => \"Could not resolve the Plugins folder automatically.\",\r\n    :ffmpeg_instalar_em      => \"Install FFmpeg to:\",\r\n    :ffmpeg_origem           => \"Source:\",\r\n    :ffmpeg_continuar        => \"Continue?\",\r\n    :ffmpeg_cancelada        => \"Installation cancelled.\",\r\n    :ffmpeg_ja_existe        => \"Already exists:\",\r\n    :ffmpeg_sobrescrever     => \"Overwrite?\",\r\n    :ffmpeg_falha_expand     => \"Expand-Archive failed (PowerShell).\",\r\n    :ffmpeg_falha_unzip      => \"unzip failed (macOS).\",\r\n    :ffmpeg_exe_nao_encontrado => \"FFmpeg executable not found in downloaded package.\",\r\n    :ffmpeg_sucesso          => \"FFmpeg successfully installed to:\",\r\n    :ffmpeg_falhou           => \"Failed:\",\r\n    :ffmpeg_abrindo_nav      => \"Opening the link in browser...\",\r\n    :titulo                  => \"Virtual Tour\",\r\n    :subtitulo               => \"Timeline\",\r\n    :total                   => \"Total:\",\r\n    :visao                   => \"Vision\",\r\n    :play                    => \"Play\",\r\n    :stop                    => \"Stop\",\r\n    :play_all                => \"Play All\",\r\n    :stop_all                => \"Stop All\",\r\n    :atalho                  => \"Hotkey\",\r\n    :pressione               => \"Press a key...\",\r\n    :ok                      => \"Ok\",\r\n    :loop                    => \"Loop\",\r\n    :easing                  => \"Easing\",\r\n    :visoes_salvas           => \"Saved visions\",\r\n    :gerenciar_timeline      => \"Manage Timeline\",\r\n    :nova                    => \"New\",\r\n    :exportar_atual          => \"Export Current\",\r\n    :exportar_projeto        => \"Export Project\",\r\n    :importar                => \"Import\",\r\n    :exportar_video          => \"Export Video\",\r\n    :selecione_formato       => \"Select format…\",\r\n    :largura                 => \"Width\",\r\n    :altura                  => \"Height\",\r\n    :gravar_projeto          => \"Record entire project (all Timelines)\",\r\n    :iniciar_quadro1         => \"Start from frame 1\",\r\n    :iniciar_gravacao        => \"Start Recording\",\r\n    :gravando                => \"Recording...\",\r\n    :ffmpeg_necessario       => \"FFmpeg is required to record video.\",\r\n    :instalar_ffmpeg         => \"Install FFmpeg\",\r\n    :nome_arquivo            => \"File name\",\r\n    :extensao_mp4            => \"The .mp4 extension will be added automatically.\",\r\n    :cancelar                => \"Cancel\",\r\n    :salvar                  => \"Save\",\r\n    :viewport_atual          => \"Current viewport:\",\r\n    :paisagem                => \"Landscape\",\r\n    :retrato                 => \"Portrait\",\r\n    :quadrado                => \"Square\",\r\n    :classico                => \"Classic\",\r\n    :ultra_wide              => \"Ultra-wide\",\r\n    :viewport_inteira        => \"Full Viewport\",\r\n    :personalizado           => \"Custom\",\r\n    :nome_timeline           => \"Timeline name:\",\r\n    :nenhuma_visao           => \"No visions added.\",\r\n    :dica_visao              => \"Position the camera and click <b>+ Vision</b>.\",\r\n    :ancora                  => \"Anchor\",\r\n    :excluir                 => \"Delete\",\r\n    :min_duas_visoes         => \"Add at least two visions.\",\r\n    :sem_tl_2mais            => \"No Timeline with 2+ visions.\",\r\n    :sem_visoes_exportar     => \"No visions to export.\",\r\n    :sem_tl_exportar         => \"No Timeline to export.\",\r\n    :importada               => \"Imported\",\r\n    :formato_invalido        => \"Invalid format.\",\r\n    :erro_importar           => \"Import error: \",\r\n    :visoes                  => \"visions\",\r\n    :nova_timeline           => \"New Timeline name:\",\r\n    :area_gravacao           => \"Recording area: \",\r\n    :sem_tl_min_duas         => \"No Timeline with at least two visions.\",\r\n    :dims_invalidas          => \"Invalid dimensions (minimum 50 x 50 px).\",\r\n    :digite_nome             => \"Enter a file name.\",\r\n  },\r\n  'es' => {\r\n    :status_clicar_arrastar  => \"HAZ CLIC Y ARRASTRA para definir el área de grabación del video.\",\r\n    :area_pequena            => \"Área demasiado pequeña. Inténtalo de nuevo.\",\r\n    :selecionar_pasta        => \"Selecciona la carpeta para guardar\",\r\n    :ffmpeg_nao_encontrado   => \"FFmpeg no encontrado.\",\r\n    :erro_gravador           => \"Error al iniciar grabador: \",\r\n    :gravacao_finalizada     => \"¡Grabación finalizada!\\nGuardado en: \",\r\n    :ffmpeg_instalado        => \"FFmpeg instalado. Ejecuta Tour Virtual de nuevo.\",\r\n    :titulo_dialogo          => \"Tour Virtual\",\r\n    :ffmpeg_plugins_erro     => \"No se pudo resolver la carpeta Plugins automáticamente.\",\r\n    :ffmpeg_instalar_em      => \"Instalar FFmpeg en:\",\r\n    :ffmpeg_origem           => \"Origen:\",\r\n    :ffmpeg_continuar        => \"¿Continuar?\",\r\n    :ffmpeg_cancelada        => \"Instalación cancelada.\",\r\n    :ffmpeg_ja_existe        => \"Ya existe:\",\r\n    :ffmpeg_sobrescrever     => \"¿Sobrescribir?\",\r\n    :ffmpeg_falha_expand     => \"Error en Expand-Archive (PowerShell).\",\r\n    :ffmpeg_falha_unzip      => \"Error en unzip (macOS).\",\r\n    :ffmpeg_exe_nao_encontrado => \"Ejecutable FFmpeg no encontrado en el paquete descargado.\",\r\n    :ffmpeg_sucesso          => \"FFmpeg instalado con éxito en:\",\r\n    :ffmpeg_falhou           => \"Falló:\",\r\n    :ffmpeg_abrindo_nav      => \"Abriendo el enlace en el navegador...\",\r\n    :titulo                  => \"Tour Virtual\",\r\n    :subtitulo               => \"Línea de Tiempo\",\r\n    :total                   => \"Total:\",\r\n    :visao                   => \"Visión\",\r\n    :play                    => \"Play\",\r\n    :stop                    => \"Stop\",\r\n    :play_all                => \"Play All\",\r\n    :stop_all                => \"Stop All\",\r\n    :atalho                  => \"Atajo\",\r\n    :pressione               => \"Presiona...\",\r\n    :ok                      => \"Ok\",\r\n    :loop                    => \"Loop\",\r\n    :easing                  => \"Easing\",\r\n    :visoes_salvas           => \"Visiones guardadas\",\r\n    :gerenciar_timeline      => \"Gestionar Línea de Tiempo\",\r\n    :nova                    => \"Nueva\",\r\n    :exportar_atual          => \"Exportar Actual\",\r\n    :exportar_projeto        => \"Exportar Proyecto\",\r\n    :importar                => \"Importar\",\r\n    :exportar_video          => \"Exportar Video\",\r\n    :selecione_formato       => \"Selecciona el formato…\",\r\n    :largura                 => \"Ancho\",\r\n    :altura                  => \"Alto\",\r\n    :gravar_projeto          => \"Grabar todo el proyecto (todas las Líneas de Tiempo)\",\r\n    :iniciar_quadro1         => \"Iniciar desde el cuadro 1\",\r\n    :iniciar_gravacao        => \"Iniciar Grabación\",\r\n    :gravando                => \"Grabando...\",\r\n    :ffmpeg_necessario       => \"FFmpeg necesario para grabar video.\",\r\n    :instalar_ffmpeg         => \"Instalar FFmpeg\",\r\n    :nome_arquivo            => \"Nombre del archivo\",\r\n    :extensao_mp4            => \"La extensión .mp4 se añadirá automáticamente.\",\r\n    :cancelar                => \"Cancelar\",\r\n    :salvar                  => \"Guardar\",\r\n    :viewport_atual          => \"Viewport actual:\",\r\n    :paisagem                => \"Paisaje\",\r\n    :retrato                 => \"Retrato\",\r\n    :quadrado                => \"Cuadrado\",\r\n    :classico                => \"Clásico\",\r\n    :ultra_wide              => \"Ultra-wide\",\r\n    :viewport_inteira        => \"Viewport Completa\",\r\n    :personalizado           => \"Personalizado\",\r\n    :nome_timeline           => \"Nombre de la Línea de Tiempo:\",\r\n    :nenhuma_visao           => \"Ninguna visión añadida.\",\r\n    :dica_visao              => \"Posiciona la cámara y haz clic en <b>+ Visión</b>.\",\r\n    :ancora                  => \"Ancla\",\r\n    :excluir                 => \"Eliminar\",\r\n    :min_duas_visoes         => \"Añade al menos dos visiones.\",\r\n    :sem_tl_2mais            => \"Ninguna Línea de Tiempo con 2+ visiones.\",\r\n    :sem_visoes_exportar     => \"Ninguna visión para exportar.\",\r\n    :sem_tl_exportar         => \"Ninguna Línea de Tiempo para exportar.\",\r\n    :importada               => \"Importada\",\r\n    :formato_invalido        => \"Formato inválido.\",\r\n    :erro_importar           => \"Error al importar: \",\r\n    :visoes                  => \"visiones\",\r\n    :nova_timeline           => \"Nombre de la nueva Línea de Tiempo:\",\r\n    :area_gravacao           => \"Área de grabación: \",\r\n    :sem_tl_min_duas         => \"Ninguna Línea de Tiempo con al menos dos visiones.\",\r\n    :dims_invalidas          => \"Dimensiones inválidas (mínimo 50 x 50 px).\",\r\n    :digite_nome             => \"Escribe un nombre para el archivo.\",\r\n  },\r\n}\r\n\r\ndef self.obter_texto(chave)\r\n  locale = Sketchup.get_locale\r\n  lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n  IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\nend\r\n\r\n# --- Script de Instalação do FFmpeg (Mantido) ---\r\nFFMPEG_INSTALL_SCRIPT ||= <<~'RUBY'\r\n  require 'sketchup'\r\n  require 'open-uri'\r\n  require 'fileutils'\r\n  require 'tmpdir'\r\n\r\n  URL_WIN ||= 'https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-master-latest-win64-gpl.zip'\r\n  URL_MAC ||= 'https://evermeet.cx/ffmpeg/getrelease/zip'\r\n\r\n  win = Sketchup.platform == :platform_win\r\n  major = Sketchup.version.to_s[/^\\d+/].to_i\r\n  sketchup_year = 2000 + major\r\n\r\n  plugins_dir = Sketchup.find_support_file('Plugins')\r\n  if !plugins_dir || plugins_dir.empty? || !Dir.exist?(plugins_dir)\r\n    if win\r\n      base = ENV['APPDATA'].to_s\r\n      plugins_dir = File.join(base, 'SketchUp', \"SketchUp #{sketchup_year}\", 'SketchUp', 'Plugins')\r\n    else\r\n      plugins_dir = File.expand_path(\"~/Library/Application Support/SketchUp #{sketchup_year}/SketchUp/Plugins\")\r\n    end\r\n  end\r\n\r\n  target_dir = File.join(plugins_dir, 'ScriptUp', 'ffmpeg')\r\n  target_exe = File.join(target_dir, win ? 'ffmpeg.exe' : 'ffmpeg')\r\n  url = win ? URL_WIN : URL_MAC\r\n  default_zip_name = win ? 'ffmpeg-win64-gpl-latest.zip' : 'ffmpeg-macos-release.zip'\r\n\r\n  proceed = true\r\n\r\n  unless plugins_dir && !plugins_dir.empty?\r\n    UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_plugins_erro))\r\n    proceed = false\r\n  end\r\n\r\n  if proceed\r\n    msg = \"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_instalar_em)}\\n#{target_dir}\\n\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_origem)}\\n#{url}\\n\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_continuar)}\"\r\n    if UI.messagebox(msg, MB_YESNO) != IDYES\r\n      UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_cancelada))\r\n      proceed = false\r\n    end\r\n  end\r\n\r\n  if proceed && File.exist?(target_exe)\r\n    overwrite = UI.messagebox(\"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_ja_existe)}\\n#{target_exe}\\n\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_sobrescrever)}\", MB_YESNO)\r\n    if overwrite != IDYES\r\n      UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_cancelada))\r\n      proceed = false\r\n    end\r\n  end\r\n\r\n  if proceed\r\n    Dir.mktmpdir('ffmpeg_dl_') do |tmp|\r\n      zip_path = File.join(tmp, default_zip_name)\r\n      extract_dir = File.join(tmp, 'unzipped')\r\n      begin\r\n        URI.open(url, 'rb') do |io|\r\n          File.open(zip_path, 'wb') { |f| IO.copy_stream(io, f) }\r\n        end\r\n        Dir.mkdir(extract_dir)\r\n        if win\r\n          ps = 'powershell -NoProfile -ExecutionPolicy Bypass -Command'\r\n          cmd = \"#{ps} \\\"Expand-Archive -LiteralPath '#{zip_path}' -DestinationPath '#{extract_dir}' -Force\\\"\"\r\n          ok = system(cmd)\r\n          raise ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_falha_expand) unless ok\r\n        else\r\n          ok = system(\"unzip -o -q '#{zip_path}' -d '#{extract_dir}'\")\r\n          raise ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_falha_unzip) unless ok\r\n        end\r\n\r\n        pattern = win ? '**/ffmpeg.exe' : '**/ffmpeg'\r\n        bin = Dir.glob(File.join(extract_dir, pattern)).find { |p| File.file?(p) }\r\n        raise ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_exe_nao_encontrado) unless bin\r\n\r\n        FileUtils.mkdir_p(target_dir) unless Dir.exist?(target_dir)\r\n        FileUtils.cp(bin, target_exe)\r\n        unless win\r\n          FileUtils.chmod(0o755, target_exe)\r\n          system(\"xattr -d com.apple.quarantine '#{target_exe}' 2>/dev/null\")\r\n        end\r\n\r\n        UI.messagebox(\"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_sucesso)}\\n#{target_exe}\")\r\n        puts \"OK: #{target_exe}\"\r\n      rescue => e\r\n        UI.messagebox(\"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_falhou)} #{e.message}\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_abrindo_nav)}\")\r\n        UI.openURL(url)\r\n      end\r\n    end\r\n  end\r\nRUBY\r\n\r\n# --- Módulo WindowUtils ---\r\nmodule WindowUtils\r\n  extend Fiddle::Importer\r\n  dlload 'user32.dll' if Sketchup.platform == :platform_win\r\n\r\n  if Sketchup.platform == :platform_win\r\n    typealias 'HWND', 'void*'\r\n    extern 'HWND GetActiveWindow()'\r\n    extern 'HWND GetForegroundWindow()'\r\n    extern 'HWND GetWindow(HWND, int)'\r\n    extern 'int GetWindowRect(HWND, void*)'\r\n    extern 'HWND GetParent(HWND)'\r\n    \r\n    GW_CHILD = 5\r\n    GW_HWNDNEXT = 2\r\n    Rect = struct ['long left', 'long top', 'long right', 'long bottom']\r\n  end\r\n\r\n  def self.get_viewport_rect_deep(view)\r\n    return nil unless Sketchup.platform == :platform_win\r\n    \r\n    hwnd = GetForegroundWindow()\r\n    return nil if hwnd.nil? || hwnd == 0\r\n\r\n    vw = view.vpwidth\r\n    vh = view.vpheight\r\n    \r\n    found = find_recursive(hwnd, vw, vh)\r\n    return found if found\r\n\r\n    parent = GetParent(hwnd)\r\n    if parent && parent != 0\r\n      found = find_recursive(parent, vw, vh)\r\n      return found if found\r\n    end\r\n\r\n    nil\r\n  end\r\n\r\n  def self.find_recursive(parent_hwnd, target_w, target_h)\r\n    child = GetWindow(parent_hwnd, GW_CHILD)\r\n    while child && child.to_i != 0\r\n      rect = Rect.malloc\r\n      if GetWindowRect(child, rect) != 0\r\n        w = rect.right - rect.left\r\n        h = rect.bottom - rect.top\r\n        match = check_match(w, h, target_w, target_h, rect)\r\n        return match if match\r\n      end\r\n      found_in_child = find_recursive(child, target_w, target_h)\r\n      return found_in_child if found_in_child\r\n      child = GetWindow(child, GW_HWNDNEXT)\r\n    end\r\n    nil\r\n  end\r\n\r\n  def self.check_match(w, h, target_w, target_h, rect)\r\n    tol = 30\r\n    [1.0, 1.25, 1.5, 2.0].each do |scale|\r\n      if (w - target_w * scale).abs <= tol && (h - target_h * scale).abs <= tol\r\n        return { :x => rect.left, :y => rect.top, :w => w, :h => h, :scale => scale }\r\n      end\r\n    end\r\n    nil\r\n  end\r\nend\r\n\r\n# --- Módulo ScreenCapture (GDI32) ---\r\n# Captures the SketchUp viewport via Win32 GDI and produces a BMP thumbnail\r\n# encoded as Base64, suitable for embedding in an HTML <img> tag.\r\n#\r\n# Uses Fiddle::Importer (Ruby stdlib) to call gdi32.dll and user32.dll functions.\r\n# Also declares PrintWindow from user32.dll as a fallback for occluded windows.\r\n#\r\n# Fiddle type mapping reference (from fiddle/types.rb Win32Types):\r\n#   HANDLE / HDC / HWND / HBITMAP  ->  void*   (pointer-sized, correct for 32/64-bit)\r\n#   DWORD                          ->  unsigned long\r\n#   BOOL                           ->  int\r\n#   UINT                           ->  unsigned int\r\n#\r\n# The extern signatures below use 'void*' directly for all handle types\r\n# (HDC, HBITMAP, HGDIOBJ) so we do not need to include Fiddle::Win32Types\r\n# or add custom typealiases beyond what WindowUtils already defines.\r\nmodule ScreenCapture\r\n  extend Fiddle::Importer\r\n\r\n  if Sketchup.platform == :platform_win\r\n    dlload 'gdi32.dll', 'user32.dll'\r\n\r\n    # --- user32.dll functions ---\r\n    # HDC GetDC(HWND hWnd)\r\n    #   hWnd=NULL(0) returns DC for entire screen\r\n    extern 'void* GetDC(void*)'\r\n\r\n    # int ReleaseDC(HWND hWnd, HDC hDC)\r\n    extern 'int ReleaseDC(void*, void*)'\r\n\r\n    # BOOL PrintWindow(HWND hwnd, HDC hdcBlt, UINT nFlags)\r\n    #   Asks the window to paint itself into the given DC.\r\n    #   Works even when the window is partially occluded (unlike BitBlt from screen DC).\r\n    extern 'int PrintWindow(void*, void*, unsigned int)'\r\n\r\n    # --- gdi32.dll functions ---\r\n    # HDC CreateCompatibleDC(HDC hdc)\r\n    extern 'void* CreateCompatibleDC(void*)'\r\n\r\n    # HBITMAP CreateCompatibleBitmap(HDC hdc, int cx, int cy)\r\n    extern 'void* CreateCompatibleBitmap(void*, int, int)'\r\n\r\n    # HGDIOBJ SelectObject(HDC hdc, HGDIOBJ h)\r\n    extern 'void* SelectObject(void*, void*)'\r\n\r\n    # BOOL BitBlt(HDC hdc, int x, int y, int cx, int cy,\r\n    #             HDC hdcSrc, int x1, int y1, DWORD rop)\r\n    extern 'int BitBlt(void*, int, int, int, int, void*, int, int, unsigned long)'\r\n\r\n    # BOOL StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest,\r\n    #                 HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop)\r\n    extern 'int StretchBlt(void*, int, int, int, int, void*, int, int, int, int, unsigned long)'\r\n\r\n    # int SetStretchBltMode(HDC hdc, int mode)\r\n    extern 'int SetStretchBltMode(void*, int)'\r\n\r\n    # int GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines,\r\n    #               LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage)\r\n    #   lpvBits and lpbmi are both void* (raw pointers to caller-allocated buffers)\r\n    extern 'int GetDIBits(void*, void*, unsigned int, unsigned int, void*, void*, unsigned int)'\r\n\r\n    # BOOL DeleteDC(HDC hdc)\r\n    extern 'int DeleteDC(void*)'\r\n\r\n    # BOOL DeleteObject(HGDIOBJ ho)\r\n    extern 'int DeleteObject(void*)'\r\n\r\n    # --- Raster-operation and mode constants ---\r\n    SRCCOPY        = 0x00CC0020\r\n    HALFTONE       = 4          # SetStretchBltMode mode for high-quality shrinking\r\n    DIB_RGB_COLORS = 0          # GetDIBits color table usage\r\n\r\n    # --- PrintWindow flags ---\r\n    PW_CLIENTONLY          = 0x00000001  # capture client area only (no title bar)\r\n    PW_RENDERFULLCONTENT   = 0x00000002  # Win 8.1+: captures DirectX/DWM content\r\n  end\r\n\r\n  # Build a 40-byte BITMAPINFOHEADER as a packed binary string.\r\n  #\r\n  # The BITMAPINFOHEADER struct layout (40 bytes total):\r\n  #   DWORD  biSize          (4 bytes, unsigned 32-bit LE)   = 40\r\n  #   LONG   biWidth         (4 bytes, signed   32-bit LE)\r\n  #   LONG   biHeight        (4 bytes, signed   32-bit LE)   negative = top-down DIB\r\n  #   WORD   biPlanes        (2 bytes, unsigned 16-bit LE)   = 1\r\n  #   WORD   biBitCount      (2 bytes, unsigned 16-bit LE)   = 24 for RGB\r\n  #   DWORD  biCompression   (4 bytes, unsigned 32-bit LE)   = 0 (BI_RGB)\r\n  #   DWORD  biSizeImage     (4 bytes, unsigned 32-bit LE)\r\n  #   LONG   biXPelsPerMeter (4 bytes, signed   32-bit LE)   = 0\r\n  #   LONG   biYPelsPerMeter (4 bytes, signed   32-bit LE)   = 0\r\n  #   DWORD  biClrUsed       (4 bytes, unsigned 32-bit LE)   = 0\r\n  #   DWORD  biClrImportant  (4 bytes, unsigned 32-bit LE)   = 0\r\n  #\r\n  # Pack template: 'L<' = uint32 LE, 'l<' = int32 LE, 'S<' = uint16 LE\r\n  # Combined: 'L< l< l< S< S< L< L< l< l< L< L<'  (spaces for clarity)\r\n  #\r\n  # Using negative biHeight produces a top-down DIB, which means:\r\n  #  - Row 0 in memory is the top row of the image\r\n  #  - No vertical flip is needed when writing the BMP file\r\n  #  - The BMP file header must also use the negative height to match\r\n  def self.pack_bitmapinfoheader(width, height, image_size)\r\n    [\r\n      40,           # biSize\r\n      width,        # biWidth\r\n      -height,      # biHeight (negative = top-down)\r\n      1,            # biPlanes\r\n      24,           # biBitCount (24-bit RGB)\r\n      0,            # biCompression (BI_RGB = uncompressed)\r\n      image_size,   # biSizeImage\r\n      0,            # biXPelsPerMeter\r\n      0,            # biYPelsPerMeter\r\n      0,            # biClrUsed\r\n      0             # biClrImportant\r\n    ].pack('L<l<l<S<S<L<L<l<l<L<L<')\r\n  end\r\n\r\n  # Build the 14-byte BMP file header (BITMAPFILEHEADER).\r\n  #\r\n  # Layout:\r\n  #   WORD   bfType      = 0x4D42 (\"BM\")\r\n  #   DWORD  bfSize      = total file size in bytes\r\n  #   WORD   bfReserved1 = 0\r\n  #   WORD   bfReserved2 = 0\r\n  #   DWORD  bfOffBits   = offset to pixel data = 14 + 40 = 54\r\n  #\r\n  # Pack template: 'S< L< S< S< L<'\r\n  def self.pack_bmp_file_header(pixel_data_size)\r\n    file_size = 14 + 40 + pixel_data_size\r\n    [\r\n      0x4D42,       # bfType (\"BM\")\r\n      file_size,    # bfSize\r\n      0,            # bfReserved1\r\n      0,            # bfReserved2\r\n      54            # bfOffBits (14-byte file header + 40-byte info header)\r\n    ].pack('S<L<S<S<L<')\r\n  end\r\n\r\n  # Capture the SketchUp viewport as a scaled-down BMP thumbnail and return\r\n  # a Base64-encoded string. Returns nil on failure (non-Windows, HWND not found, etc.).\r\n  #\r\n  # Strategy:\r\n  #   1. StretchBlt from screen DC (fast, works when viewport is visible)\r\n  #   2. If vp[:hwnd] is available, PrintWindow can be used as alternative\r\n  #\r\n  # Parameters:\r\n  #   view     - Sketchup::View instance\r\n  #   thumb_w  - desired thumbnail width  in pixels (default 96)\r\n  #   thumb_h  - desired thumbnail height in pixels (default 60)\r\n  #\r\n  # Returns: Base64-encoded BMP string, or nil on failure.\r\n  def self.capture_viewport(view, thumb_w = 96, thumb_h = 60)\r\n    return nil unless Sketchup.platform == :platform_win\r\n\r\n    vp = WindowUtils.get_viewport_rect_deep(view)\r\n    return nil unless vp\r\n\r\n    src_w = vp[:w]\r\n    src_h = vp[:h]\r\n\r\n    # Get screen DC -- needed for CreateCompatibleBitmap color depth\r\n    screen_dc = GetDC(0)\r\n    return nil if screen_dc.nil? || screen_dc.to_i == 0\r\n\r\n    begin\r\n      # Create a memory DC compatible with the screen\r\n      mem_dc = CreateCompatibleDC(screen_dc)\r\n      return nil if mem_dc.nil? || mem_dc.to_i == 0\r\n\r\n      begin\r\n        # Create a bitmap at the desired thumbnail size\r\n        bmp = CreateCompatibleBitmap(screen_dc, thumb_w, thumb_h)\r\n        return nil if bmp.nil? || bmp.to_i == 0\r\n\r\n        begin\r\n          old = SelectObject(mem_dc, bmp)\r\n          SetStretchBltMode(mem_dc, HALFTONE)\r\n\r\n          # StretchBlt from the screen DC directly into the thumbnail-sized bitmap.\r\n          # This both captures AND scales in a single operation.\r\n          ok = StretchBlt(\r\n            mem_dc, 0, 0, thumb_w, thumb_h,\r\n            screen_dc, vp[:x], vp[:y], src_w, src_h,\r\n            SRCCOPY\r\n          )\r\n          return nil if ok == 0\r\n\r\n          # IMPORTANT: Deselect the bitmap from the DC before calling GetDIBits.\r\n          # Per MSDN: \"The bitmap identified by hbmp must not be selected into\r\n          # a device context when the application calls this function.\"\r\n          SelectObject(mem_dc, old)\r\n          old = nil\r\n\r\n          # Calculate row stride (BMP rows must be padded to 4-byte boundaries)\r\n          stride     = ((thumb_w * 3 + 3) & ~3)\r\n          pixel_size = stride * thumb_h\r\n\r\n          # Pack the BITMAPINFOHEADER into a Fiddle::Pointer buffer.\r\n          # GetDIBits may modify the header (e.g., filling in biSizeImage),\r\n          # so we use a mutable native buffer rather than a Ruby String.\r\n          bmi_bytes = pack_bitmapinfoheader(thumb_w, thumb_h, pixel_size)\r\n          bmi_ptr   = Fiddle::Pointer.malloc(bmi_bytes.bytesize)\r\n          bmi_ptr[0, bmi_bytes.bytesize] = bmi_bytes\r\n\r\n          # Allocate the pixel data buffer\r\n          buf = Fiddle::Pointer.malloc(pixel_size)\r\n\r\n          begin\r\n            # GetDIBits(hdc, hbm, start, cLines, lpvBits, lpbmi, usage)\r\n            # hdc: a DC compatible with the bitmap (mem_dc works)\r\n            # hbm: the bitmap handle (NOT selected into any DC)\r\n            rows = GetDIBits(mem_dc, bmp, 0, thumb_h, buf, bmi_ptr, DIB_RGB_COLORS)\r\n            return nil if rows == 0\r\n\r\n            # Read the raw pixel bytes from the Fiddle::Pointer buffer.\r\n            # ptr[offset, length] returns a Ruby String (binary safe, works since Ruby 2.0).\r\n            pixel_data = buf[0, pixel_size]\r\n\r\n            # Assemble the complete BMP file: file header + info header + pixel data\r\n            file_hdr = pack_bmp_file_header(pixel_size)\r\n            info_hdr = pack_bitmapinfoheader(thumb_w, thumb_h, pixel_size)\r\n\r\n            Base64.strict_encode64(file_hdr + info_hdr + pixel_data)\r\n          ensure\r\n            Fiddle.free(bmi_ptr) if bmi_ptr\r\n            Fiddle.free(buf)     if buf\r\n          end\r\n        ensure\r\n          SelectObject(mem_dc, old) if old\r\n          DeleteObject(bmp)\r\n        end\r\n      ensure\r\n        DeleteDC(mem_dc)\r\n      end\r\n    ensure\r\n      ReleaseDC(0, screen_dc)\r\n    end\r\n  rescue => e\r\n    puts \"ScreenCapture error: #{e.message}\"\r\n    puts e.backtrace.first(5).join(\"\\n\")\r\n    nil\r\n  end\r\nend\r\n\r\nmodule TourPlugin\r\n  class AreaSelectorTool\r\n    def initialize(callback)\r\n      @callback = callback\r\n      @start_x = nil; @start_y = nil; @current_x = nil; @current_y = nil\r\n      @drawing = false\r\n    end\r\n\r\n    def activate\r\n      Sketchup.active_model.active_view.invalidate\r\n      Sketchup.status_text = ScriptUpComunidade::TourVirtual.obter_texto(:status_clicar_arrastar)\r\n    end\r\n\r\n    def onLButtonDown(flags, x, y, view)\r\n      @start_x = x; @start_y = y; @current_x = x; @current_y = y\r\n      @drawing = true\r\n    end\r\n\r\n    def onMouseMove(flags, x, y, view)\r\n      if @drawing\r\n        @current_x = x; @current_y = y\r\n        view.invalidate\r\n      end\r\n    end\r\n\r\n    def onLButtonUp(flags, x, y, view)\r\n      return unless @drawing\r\n      @drawing = false\r\n      x1 = [@start_x, @current_x].min\r\n      y1 = [@start_y, @current_y].min\r\n      x2 = [@start_x, @current_x].max\r\n      y2 = [@start_y, @current_y].max\r\n      width = x2 - x1\r\n      height = y2 - y1\r\n\r\n      if width < 50 || height < 50\r\n        UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:area_pequena))\r\n        Sketchup.active_model.select_tool(nil)\r\n        return\r\n      end\r\n\r\n      @callback.call({ :x => x1, :y => y1, :w => width, :h => height })\r\n      Sketchup.active_model.select_tool(nil) \r\n    end\r\n\r\n    def draw(view)\r\n      return unless @drawing && @start_x && @current_x\r\n      points = [\r\n        Geom::Point3d.new(@start_x, @start_y, 0),\r\n        Geom::Point3d.new(@current_x, @start_y, 0),\r\n        Geom::Point3d.new(@current_x, @current_y, 0),\r\n        Geom::Point3d.new(@start_x, @current_y, 0)\r\n      ]\r\n      view.line_width = 3\r\n      view.drawing_color = 'red'\r\n      view.draw2d(GL_LINE_LOOP, points)\r\n    end\r\n  end\r\n\r\n  class ExportPreviewTool\r\n    def initialize(target_w, target_h)\r\n      @target_w = target_w\r\n      @target_h = target_h\r\n    end\r\n\r\n    def activate\r\n      Sketchup.active_model.active_view.invalidate\r\n    end\r\n\r\n    def deactivate(view)\r\n      view.invalidate\r\n    end\r\n\r\n    def draw(view)\r\n      vw = view.vpwidth\r\n      vh = view.vpheight\r\n      ew = [@target_w, vw].min\r\n      eh = [@target_h, vh].min\r\n      ox = (vw - ew) / 2\r\n      oy = (vh - eh) / 2\r\n\r\n      # Escurecer áreas fora da gravação (letterbox/pillarbox)\r\n      view.drawing_color = Sketchup::Color.new(0, 0, 0, 120)\r\n      if oy > 0\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(0, 0, 0), Geom::Point3d.new(vw, 0, 0),\r\n          Geom::Point3d.new(vw, oy, 0), Geom::Point3d.new(0, oy, 0)\r\n        ])\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(0, oy + eh, 0), Geom::Point3d.new(vw, oy + eh, 0),\r\n          Geom::Point3d.new(vw, vh, 0), Geom::Point3d.new(0, vh, 0)\r\n        ])\r\n      end\r\n      if ox > 0\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(0, oy, 0), Geom::Point3d.new(ox, oy, 0),\r\n          Geom::Point3d.new(ox, oy + eh, 0), Geom::Point3d.new(0, oy + eh, 0)\r\n        ])\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(ox + ew, oy, 0), Geom::Point3d.new(vw, oy, 0),\r\n          Geom::Point3d.new(vw, oy + eh, 0), Geom::Point3d.new(ox + ew, oy + eh, 0)\r\n        ])\r\n      end\r\n\r\n      # Borda branca ao redor da área de gravação\r\n      view.line_width = 2\r\n      view.drawing_color = Sketchup::Color.new(255, 255, 255, 200)\r\n      view.draw2d(GL_LINE_LOOP, [\r\n        Geom::Point3d.new(ox, oy, 0), Geom::Point3d.new(ox + ew, oy, 0),\r\n        Geom::Point3d.new(ox + ew, oy + eh, 0), Geom::Point3d.new(ox, oy + eh, 0)\r\n      ])\r\n    end\r\n  end\r\n\r\n  module CameraTimeline\r\n    def self.obter_texto(chave)\r\n      ScriptUpComunidade::TourVirtual.obter_texto(chave)\r\n    end\r\n\r\n    module GlobalKey\r\n      extend Fiddle::Importer\r\n      if Sketchup.platform == :platform_win\r\n        dlload 'user32.dll'\r\n        extern 'short GetAsyncKeyState(int)'\r\n      else\r\n        dlload '/System/Library/Frameworks/ApplicationServices.framework/ApplicationServices'\r\n        extern 'bool CGEventSourceKeyState(int, int)'\r\n      end\r\n\r\n      DEFAULT_HOTKEY = Sketchup.platform == :platform_win ? 0x6B : 69\r\n      @key_code = Sketchup.read_default(\"TourVirtual\", \"Hotkey\", DEFAULT_HOTKEY).to_i\r\n      @ctrl = Sketchup.read_default(\"TourVirtual\", \"HotkeyCtrl\", false)\r\n      @alt = Sketchup.read_default(\"TourVirtual\", \"HotkeyAlt\", false)\r\n      @shift = Sketchup.read_default(\"TourVirtual\", \"HotkeyShift\", false)\r\n\r\n      # Windows virtual key codes for modifiers\r\n      VK_CONTROL = 0x11\r\n      VK_MENU    = 0x12\r\n      VK_SHIFT   = 0x10\r\n      # macOS key codes for modifiers\r\n      MAC_CTRL  = 59\r\n      MAC_SHIFT = 56\r\n      MAC_ALT   = 58\r\n\r\n      def self.set_hotkey(code, ctrl, alt, shift)\r\n        @key_code = code.to_i\r\n        @ctrl = ctrl\r\n        @alt = alt\r\n        @shift = shift\r\n      end\r\n\r\n      def self.key_code; @key_code; end\r\n      def self.ctrl; @ctrl; end\r\n      def self.alt; @alt; end\r\n      def self.shift; @shift; end\r\n\r\n      def self.key_pressed?(code)\r\n        if Sketchup.platform == :platform_win\r\n          GetAsyncKeyState(code) & 0x8000 != 0\r\n        else\r\n          CGEventSourceKeyState(0, code)\r\n        end\r\n      end\r\n\r\n      def self.space_pressed?\r\n        return false unless key_pressed?(@key_code)\r\n        if Sketchup.platform == :platform_win\r\n          return false if @ctrl && !key_pressed?(VK_CONTROL)\r\n          return false if @alt && !key_pressed?(VK_MENU)\r\n          return false if @shift && !key_pressed?(VK_SHIFT)\r\n        else\r\n          return false if @ctrl && !key_pressed?(MAC_CTRL)\r\n          return false if @alt && !key_pressed?(MAC_ALT)\r\n          return false if @shift && !key_pressed?(MAC_SHIFT)\r\n        end\r\n        true\r\n      end\r\n    end\r\n\r\n    def self.start_space_timer\r\n      return if defined?(@space_timer) && @space_timer\r\n      @space_down = false\r\n      @space_timer = UI.start_timer(0.1, true) do\r\n        if GlobalKey.space_pressed?\r\n          unless @space_down\r\n            @space_down = true\r\n            @dialog.execute_script('triggerSpaceFromRuby()')\r\n          end\r\n        else\r\n          @space_down = false\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.stop_space_timer\r\n      if defined?(@space_timer) && @space_timer\r\n        UI.stop_timer(@space_timer)\r\n        @space_timer = nil\r\n      end\r\n    end\r\n\r\n    def self.capture_thumbnail\r\n      view = Sketchup.active_model.active_view\r\n      # Tentar screen capture instantâneo via GDI32 (Windows)\r\n      result = ScreenCapture.capture_viewport(view, 96, 60) rescue nil\r\n      return result if result && result.length > 0\r\n      # Fallback: write_image (lento, mas funciona em qualquer plataforma)\r\n      path = File.join(Dir.tmpdir, \"thumb_#{Time.now.to_i}.jpg\")\r\n      view.write_image(path, 96, 60, false, 0.5)\r\n      encoded = Base64.strict_encode64(File.binread(path))\r\n      File.delete(path) if File.exist?(path)\r\n      encoded\r\n    end\r\n\r\n    # --- Lógica de Exportação ---\r\n    def self.calcular_rect_gravacao(export_width, export_height)\r\n      view = Sketchup.active_model.active_view\r\n      viewport_global = WindowUtils.get_viewport_rect_deep(view)\r\n\r\n      unless viewport_global\r\n        viewport_global = { :x => 0, :y => 0, :w => view.vpwidth, :h => view.vpheight, :scale => 1.0 }\r\n      end\r\n\r\n      vp_w = viewport_global[:w]\r\n      vp_h = viewport_global[:h]\r\n\r\n      final_w = [export_width.to_i, vp_w].min\r\n      final_h = [export_height.to_i, vp_h].min\r\n\r\n      offset_x = viewport_global[:x] + ((vp_w - final_w) / 2).to_i\r\n      offset_y = viewport_global[:y] + ((vp_h - final_h) / 2).to_i\r\n\r\n      final_w -= 1 if final_w.odd?\r\n      final_h -= 1 if final_h.odd?\r\n\r\n      { :x => offset_x, :y => offset_y, :w => final_w, :h => final_h }\r\n    end\r\n\r\n    def self.iniciar_processo_exportacao(json_data, use_easing, start_index_from_js, export_width, export_height, filename)\r\n      effective_index = start_index_from_js.to_i\r\n\r\n      if effective_index == 0\r\n        @dialog.execute_script(\"currentIndex = 0; updateTime(0); sketchup.goto_camera(JSON.stringify(visoes[0]));\")\r\n        sleep(0.5)\r\n      end\r\n\r\n      rect = calcular_rect_gravacao(export_width, export_height)\r\n      executar_gravacao_ffmpeg(json_data, use_easing, rect, effective_index, filename)\r\n    end\r\n\r\n    def self.iniciar_processo_exportacao_projeto(all_timelines_json, use_easing, active_tl_index, start_vision_index, export_width, export_height, filename)\r\n      timelines = JSON.parse(all_timelines_json, symbolize_names: true)\r\n      rect = calcular_rect_gravacao(export_width, export_height)\r\n\r\n      start_tl = active_tl_index.to_i\r\n      start_vision = start_vision_index.to_i\r\n\r\n      # Calcular duração total a partir do ponto de início\r\n      total_time = 0.0\r\n      timelines.each_with_index do |tl, i|\r\n        next if i < start_tl\r\n        next unless tl[:visoes] && tl[:visoes].length >= 2\r\n        sorted = tl[:visoes].sort_by { |v| v[:time] }\r\n        first_v = (i == start_tl && start_vision > 0 && start_vision < sorted.length) ? start_vision : 0\r\n        if first_v < sorted.length - 1\r\n          total_time += sorted.last[:time] - sorted[first_v][:time]\r\n          total_time += 0.5\r\n        end\r\n      end\r\n\r\n      play_cmd = \"startRecordingPlayAll(#{start_tl}, #{start_vision})\"\r\n      executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, play_cmd)\r\n    end\r\n\r\n    def self.executar_gravacao_ffmpeg(json_data, use_easing, rect, start_index, filename)\r\n      camera_keys = JSON.parse(json_data, symbolize_names: true)\r\n      camera_keys.sort_by! { |v| v[:time] }\r\n\r\n      total_time = 0\r\n      if start_index < camera_keys.length - 1\r\n        relevant_keys = camera_keys[start_index..-1]\r\n        relevant_keys.each_cons(2) { |c, n| total_time += (n[:time] - c[:time]).abs }\r\n      end\r\n\r\n      executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, \"triggerSpaceFromRuby()\")\r\n    end\r\n\r\n    def self.executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, play_command)\r\n      folder = UI.select_directory(title: obter_texto(:selecionar_pasta))\r\n      return unless folder\r\n\r\n      output_path = File.join(folder, \"#{filename}.mp4\")\r\n\r\n      is_win = Sketchup.platform == :platform_win\r\n      ffmpeg_path = File.join(PLUGIN_DIR, 'ffmpeg', is_win ? 'ffmpeg.exe' : 'ffmpeg')\r\n\r\n      unless File.exist?(ffmpeg_path)\r\n        UI.messagebox(obter_texto(:ffmpeg_nao_encontrado))\r\n        return\r\n      end\r\n\r\n      duration_padding = 4.0\r\n      recording_duration = total_time + duration_padding\r\n\r\n      input_format = is_win ? 'gdigrab' : 'avfoundation'\r\n      input_source = is_win ? 'desktop' : '1:none'\r\n\r\n      cmd_array = [\r\n        \"\\\"#{ffmpeg_path}\\\"\",\r\n        '-y',\r\n        '-f', input_format,\r\n        '-framerate', '30',\r\n        '-t', recording_duration.to_s\r\n      ]\r\n\r\n      if is_win\r\n        cmd_array.concat([\r\n          '-draw_mouse', '0',\r\n          '-offset_x', rect[:x].to_s,\r\n          '-offset_y', rect[:y].to_s,\r\n          '-video_size', \"#{rect[:w]}x#{rect[:h]}\",\r\n          '-i', input_source\r\n        ])\r\n      else\r\n        cmd_array.concat([\r\n          '-i', input_source,\r\n          '-vf', \"crop=#{rect[:w]}:#{rect[:h]}:#{rect[:x]}:#{rect[:y]}\"\r\n        ])\r\n      end\r\n\r\n      cmd_array.concat([\r\n        '-c:v', 'libx264',\r\n        '-preset', 'ultrafast',\r\n        '-pix_fmt', 'yuv420p',\r\n        \"\\\"#{output_path}\\\"\"\r\n      ])\r\n\r\n      cmd = cmd_array.join(' ')\r\n\r\n      begin\r\n        if is_win\r\n           WIN32OLE.new('WScript.Shell').Run(cmd, 0, false)\r\n        else\r\n           pid = spawn(cmd)\r\n           Process.detach(pid)\r\n        end\r\n      rescue => e\r\n        UI.messagebox(\"#{obter_texto(:erro_gravador)}#{e.message}\")\r\n        return\r\n      end\r\n\r\n      sleep(1.5)\r\n\r\n      @dialog.execute_script(\"showRecordingIndicator()\")\r\n      @dialog.execute_script(play_command)\r\n\r\n      UI.start_timer(recording_duration + 1.0, false) do\r\n        @dialog.execute_script(\"hideRecordingIndicator()\")\r\n        UI.messagebox(\"#{obter_texto(:gravacao_finalizada)}#{output_path}\")\r\n        @dialog.execute_script(\"resetPlayButton(); resetPlayAll();\")\r\n      end\r\n    end\r\n\r\n    def self.start_ui\r\n      current_hotkey = GlobalKey.key_code\r\n      hotkey_ctrl = GlobalKey.ctrl ? 'true' : 'false'\r\n      hotkey_alt = GlobalKey.alt ? 'true' : 'false'\r\n      hotkey_shift = GlobalKey.shift ? 'true' : 'false'\r\n      ffmpeg_path = File.join(PLUGIN_DIR, 'ffmpeg', Sketchup.platform == :platform_win ? 'ffmpeg.exe' : 'ffmpeg')\r\n      \r\n      has_ffmpeg = File.exist?(ffmpeg_path)\r\n\r\n      view = Sketchup.active_model.active_view\r\n      vp_width = view.vpwidth\r\n      vp_height = view.vpheight\r\n\r\n      js_i18n_hash = {}\r\n      IDIOMAS[IDIOMAS.key?(Sketchup.get_locale) ? Sketchup.get_locale : 'en-US'].each { |k, v| js_i18n_hash[k] = v }\r\n      js_i18n_json = js_i18n_hash.to_json\r\n\r\n      html = <<-HTML\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n  <meta charset=\"utf-8\">\r\n  <title>#{obter_texto(:titulo)}</title>\r\n  <style>\r\n    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }\r\n    body {\r\n      font-family: system-ui, -apple-system, 'Segoe UI', sans-serif;\r\n      background: #f5f5f5; color: #333; font-size: 13px;\r\n      padding: 16px; line-height: 1.4;\r\n    }\r\n\r\n    /* Header */\r\n    .header {\r\n      display: flex; align-items: center; gap: 10px;\r\n      padding-bottom: 14px; border-bottom: 2px solid #0066cc;\r\n      margin-bottom: 16px;\r\n    }\r\n    .header svg { flex-shrink: 0; }\r\n    .header h1 { font-size: 17px; font-weight: 700; color: #1a1a1a; }\r\n    .header .subtitle { font-size: 11px; color: #888; font-weight: 400; }\r\n\r\n    /* Cards */\r\n    .card {\r\n      background: #fff; border: 1px solid #e0e0e0; border-radius: 8px;\r\n      box-shadow: 0 1px 3px rgba(0,0,0,0.06); margin-bottom: 12px;\r\n      overflow: hidden;\r\n    }\r\n    .card-header {\r\n      display: flex; align-items: center; justify-content: space-between;\r\n      padding: 10px 14px; background: #fafafa; border-bottom: 1px solid #eee;\r\n      cursor: pointer; user-select: none;\r\n    }\r\n    .card-header h2 { font-size: 13px; font-weight: 600; color: #444; }\r\n    .card-header .toggle-icon { font-size: 11px; color: #999; transition: transform 0.2s; }\r\n    .card-header.collapsed .toggle-icon { transform: rotate(-90deg); }\r\n    .card-body { padding: 14px; }\r\n    .card-body.collapsed { display: none; }\r\n\r\n    /* Timeline */\r\n    .timeline-wrapper { position: relative; padding: 8px 0 20px; }\r\n    .timeline-track {\r\n      position: absolute; top: 20px; left: 6px; right: 6px; height: 4px;\r\n      background: #ddd; border-radius: 2px; z-index: 0;\r\n    }\r\n    #timeline_range {\r\n      -webkit-appearance: none; appearance: none; width: 100%;\r\n      height: 6px; background: transparent; outline: none;\r\n      position: relative; z-index: 2; cursor: pointer;\r\n    }\r\n    #timeline_range::-webkit-slider-runnable-track {\r\n      height: 6px; background: linear-gradient(90deg, #0066cc 0%, #4da6ff 100%);\r\n      border-radius: 3px;\r\n    }\r\n    #timeline_range::-webkit-slider-thumb {\r\n      -webkit-appearance: none; width: 16px; height: 16px;\r\n      background: #0066cc; border: 2px solid #fff; border-radius: 50%;\r\n      margin-top: -5px; cursor: grab; box-shadow: 0 1px 4px rgba(0,0,0,0.2);\r\n    }\r\n    #timeline_range::-webkit-slider-thumb:active { cursor: grabbing; transform: scale(1.15); }\r\n    #markers_layer {\r\n      position: absolute; top: 0; left: 0; width: 100%; height: 40px;\r\n      pointer-events: none; z-index: 3;\r\n    }\r\n    .marker {\r\n      position: absolute; top: 26px; width: 14px; height: 14px;\r\n      background: #0066cc; border-radius: 50%; border: 2px solid #fff;\r\n      transform: translateX(-50%); pointer-events: auto; cursor: pointer;\r\n      box-shadow: 0 1px 3px rgba(0,0,0,0.15); transition: transform 0.15s, background 0.15s;\r\n    }\r\n    .marker:hover { transform: translateX(-50%) scale(1.25); }\r\n    .marker.anchor { background: #dc3545; }\r\n    .marker .marker-tooltip {\r\n      position: absolute; bottom: 18px; left: 50%; transform: translateX(-50%);\r\n      background: #333; color: #fff; font-size: 10px; padding: 2px 6px;\r\n      border-radius: 3px; white-space: nowrap; opacity: 0;\r\n      pointer-events: none; transition: opacity 0.15s;\r\n    }\r\n    .marker:hover .marker-tooltip { opacity: 1; }\r\n    .time-row {\r\n      display: flex; align-items: center; justify-content: space-between;\r\n      margin-top: 8px; gap: 12px;\r\n    }\r\n    .time-display { font-size: 20px; font-weight: 700; color: #0066cc; font-variant-numeric: tabular-nums; }\r\n    .time-display small { font-size: 12px; color: #888; font-weight: 400; }\r\n    .time-input-group { display: flex; align-items: center; gap: 6px; }\r\n    .time-input-group label { font-size: 11px; color: #666; }\r\n\r\n    /* Buttons */\r\n    .btn {\r\n      display: inline-flex; align-items: center; justify-content: center; gap: 6px;\r\n      padding: 7px 14px; border: 1px solid transparent; border-radius: 6px;\r\n      font-size: 12px; font-weight: 500; cursor: pointer;\r\n      transition: all 0.15s; outline: none; font-family: inherit;\r\n    }\r\n    .btn:active { transform: scale(0.97); }\r\n    .btn-primary { background: #0066cc; color: #fff; }\r\n    .btn-primary:hover { background: #0052a3; }\r\n    .btn-success { background: #28a745; color: #fff; }\r\n    .btn-success:hover { background: #218838; }\r\n    .btn-danger { background: #dc3545; color: #fff; }\r\n    .btn-danger:hover { background: #c82333; }\r\n    .btn-outline { background: transparent; border: 1px solid #ccc; color: #555; }\r\n    .btn-outline:hover { background: #f0f0f0; border-color: #aaa; }\r\n    .btn-sm { padding: 4px 10px; font-size: 11px; }\r\n    .btn-record { background: #dc3545; color: #fff; padding: 10px 20px; font-size: 13px; font-weight: 600; }\r\n    .btn-record:hover { background: #c82333; }\r\n    .btn-record:disabled { background: #ccc; color: #888; cursor: not-allowed; }\r\n\r\n    .btn-group { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }\r\n\r\n    /* Checkboxes */\r\n    .check-group { display: flex; align-items: center; gap: 16px; margin-top: 10px; }\r\n    .check-item { display: flex; align-items: center; gap: 5px; }\r\n    .check-item input[type=\"checkbox\"] {\r\n      width: 15px; height: 15px; accent-color: #0066cc; cursor: pointer;\r\n    }\r\n    .check-item label { font-size: 12px; color: #555; cursor: pointer; }\r\n\r\n    /* Hotkey */\r\n    .hotkey-editor {\r\n      display: none; align-items: center; gap: 6px;\r\n      background: #f9f9f9; padding: 6px 10px; border-radius: 6px; border: 1px solid #ddd;\r\n    }\r\n    .hotkey-editor.visible { display: inline-flex; }\r\n    .hotkey-editor input {\r\n      width: 100px; padding: 4px 8px; border: 1px solid #ccc;\r\n      border-radius: 4px; font-size: 12px; font-family: monospace;\r\n      outline: none;\r\n    }\r\n    .hotkey-editor input:focus { border-color: #0066cc; }\r\n\r\n    /* Vision List */\r\n    .vision-list { max-height: 350px; overflow-y: auto; }\r\n    .vision-list::-webkit-scrollbar { width: 6px; }\r\n    .vision-list::-webkit-scrollbar-track { background: #f0f0f0; border-radius: 3px; }\r\n    .vision-list::-webkit-scrollbar-thumb { background: #ccc; border-radius: 3px; }\r\n    .vision-list::-webkit-scrollbar-thumb:hover { background: #aaa; }\r\n    .vision-item {\r\n      display: flex; align-items: center; gap: 10px; padding: 8px 10px;\r\n      border-bottom: 1px solid #f0f0f0; cursor: pointer;\r\n      transition: background 0.12s;\r\n    }\r\n    .vision-item:hover { background: #f7faff; }\r\n    .vision-item:last-child { border-bottom: none; }\r\n    .vision-item .vision-num {\r\n      font-size: 11px; font-weight: 700; color: #999; width: 20px;\r\n      text-align: center; flex-shrink: 0;\r\n    }\r\n    .vision-item img {\r\n      width: 72px; height: 45px; object-fit: cover; border-radius: 4px;\r\n      border: 1px solid #ddd; flex-shrink: 0;\r\n    }\r\n    .vision-item img.thumb-placeholder {\r\n      background: linear-gradient(135deg, #e0e0e0 0%, #c0c0c0 100%);\r\n      animation: pulse-placeholder 1s ease-in-out infinite alternate;\r\n    }\r\n    @keyframes pulse-placeholder {\r\n      from { opacity: 0.6; }\r\n      to { opacity: 1.0; }\r\n    }\r\n    .vision-item .vision-info { flex: 1; min-width: 0; }\r\n    .vision-item .vision-time-input {\r\n      width: 58px; padding: 3px 6px; border: 1px solid #ddd; border-radius: 4px;\r\n      font-size: 12px; text-align: center; outline: none; font-family: inherit;\r\n    }\r\n    .vision-item .vision-time-input:focus { border-color: #0066cc; }\r\n    .vision-item .vision-time-input:disabled { background: #f5f5f5; color: #999; }\r\n    .vision-actions { display: flex; align-items: center; gap: 6px; flex-shrink: 0; }\r\n    .anchor-toggle {\r\n      width: 26px; height: 26px; border-radius: 50%; border: 2px solid #ddd;\r\n      background: transparent; cursor: pointer; display: flex;\r\n      align-items: center; justify-content: center; transition: all 0.15s;\r\n      font-size: 12px; color: #ccc;\r\n    }\r\n    .anchor-toggle:hover { border-color: #dc3545; color: #dc3545; }\r\n    .anchor-toggle.active { background: #dc3545; border-color: #dc3545; color: #fff; }\r\n    .delete-btn {\r\n      width: 26px; height: 26px; border-radius: 50%; border: 1px solid #eee;\r\n      background: transparent; cursor: pointer; display: flex;\r\n      align-items: center; justify-content: center; transition: all 0.15s;\r\n      font-size: 14px; color: #ccc;\r\n    }\r\n    .delete-btn:hover { background: #fee; border-color: #dc3545; color: #dc3545; }\r\n    .empty-state {\r\n      text-align: center; padding: 30px 16px; color: #aaa;\r\n    }\r\n    .empty-state svg { margin-bottom: 8px; opacity: 0.4; }\r\n    .empty-state p { font-size: 12px; }\r\n\r\n    /* Export Section */\r\n    .preset-select {\r\n      width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px;\r\n      font-size: 12px; font-family: inherit; outline: none; background: #fff;\r\n      cursor: pointer; color: #333;\r\n    }\r\n    .preset-select:focus { border-color: #0066cc; }\r\n    .preset-preview {\r\n      display: flex; align-items: center; justify-content: center;\r\n      padding: 8px; margin-top: 8px; background: #f7faff;\r\n      border: 1px dashed #b3d4fc; border-radius: 6px;\r\n      font-size: 12px; color: #0066cc; font-weight: 600;\r\n    }\r\n    .custom-dims {\r\n      display: none; gap: 8px; align-items: center; margin-top: 8px;\r\n    }\r\n    .custom-dims.visible { display: flex; }\r\n    .custom-dims input {\r\n      width: 80px; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px;\r\n      font-size: 12px; text-align: center; outline: none; font-family: inherit;\r\n    }\r\n    .custom-dims input:focus { border-color: #0066cc; }\r\n    .custom-dims span { color: #999; font-weight: 600; }\r\n\r\n    /* Recording indicator */\r\n    .recording-bar {\r\n      display: none; align-items: center; gap: 8px; padding: 10px 14px;\r\n      background: #fff5f5; border: 1px solid #f5c6cb; border-radius: 6px;\r\n      margin-top: 10px;\r\n    }\r\n    .recording-bar.active { display: flex; }\r\n    .recording-dot {\r\n      width: 10px; height: 10px; background: #dc3545; border-radius: 50%;\r\n      animation: pulse 1s infinite;\r\n    }\r\n    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }\r\n    .recording-bar span { font-size: 12px; color: #dc3545; font-weight: 600; }\r\n\r\n    /* Playing overlay */\r\n    body.playing .card { opacity: 0.6; pointer-events: none; }\r\n    body.playing .card.playback-card { opacity: 1; pointer-events: auto; }\r\n    body.playing .card.playback-card .btn:not(#play_button):not(#play_all_button) { pointer-events: none; opacity: 0.4; }\r\n    body.playing #play_button, body.playing #play_all_button { pointer-events: auto !important; opacity: 1 !important; }\r\n\r\n    /* Input base */\r\n    input[type=\"number\"] {\r\n      -moz-appearance: textfield;\r\n    }\r\n    input[type=\"number\"]::-webkit-inner-spin-button {\r\n      -webkit-appearance: none;\r\n    }\r\n\r\n    /* Draggable markers */\r\n    .marker { cursor: grab; }\r\n    .marker.dragging {\r\n      transform: translateX(-50%) scale(1.3);\r\n      z-index: 20;\r\n      cursor: grabbing;\r\n    }\r\n    .marker.no-drag { cursor: default; }\r\n\r\n    /* Saved timelines list */\r\n    .saved-timelines-list { margin-top: 10px; }\r\n    .saved-timelines-list:empty { display: none; }\r\n    .tl-item {\r\n      display: flex; align-items: center; gap: 8px;\r\n      padding: 6px 10px; border-bottom: 1px solid #f0f0f0;\r\n      cursor: pointer; transition: background 0.12s; font-size: 12px;\r\n    }\r\n    .tl-item:hover { background: #f7faff; }\r\n    .tl-item:last-child { border-bottom: none; }\r\n    .tl-item .tl-indicator {\r\n      width: 8px; height: 8px; border-radius: 50%;\r\n      background: #ccc; flex-shrink: 0;\r\n    }\r\n    .tl-item.active .tl-indicator { background: #0066cc; }\r\n    .tl-item .tl-name { flex: 1; font-weight: 500; color: #333; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }\r\n    .tl-item .tl-count { color: #999; font-size: 11px; flex-shrink: 0; }\r\n    .tl-item .tl-delete {\r\n      width: 20px; height: 20px; border-radius: 50%; border: 1px solid #eee;\r\n      background: transparent; cursor: pointer; display: flex;\r\n      align-items: center; justify-content: center; font-size: 12px; color: #ccc;\r\n      flex-shrink: 0; transition: all 0.15s;\r\n    }\r\n    .tl-item .tl-delete:hover { background: #fee; border-color: #dc3545; color: #dc3545; }\r\n\r\n    /* Drag-and-drop for timeline reordering */\r\n    .tl-drag-handle {\r\n      cursor: grab; flex-shrink: 0; color: #ccc; font-size: 14px;\r\n      padding: 0 4px; user-select: none;\r\n    }\r\n    .tl-drag-handle:active { cursor: grabbing; }\r\n    .tl-item.dragging { opacity: 0.4; }\r\n    .tl-item.drag-over-top { border-top: 2px solid #0066cc; }\r\n    .tl-item.drag-over-bottom { border-bottom: 2px solid #0066cc; }\r\n\r\n    /* Viewport info */\r\n    .viewport-info {\r\n      font-size: 11px; color: #666; margin-bottom: 10px;\r\n      padding: 6px 10px; background: #f9f9f9; border-radius: 4px; border: 1px solid #eee;\r\n    }\r\n\r\n    /* Misc */\r\n    .hidden { display: none !important; }\r\n    .mt-8 { margin-top: 8px; }\r\n  </style>\r\n</head>\r\n<body>\r\n\r\n<!-- Header -->\r\n<div class=\"header\">\r\n  <svg width=\"28\" height=\"28\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"#0066cc\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <path d=\"M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z\"/>\r\n    <circle cx=\"12\" cy=\"13\" r=\"4\"/>\r\n  </svg>\r\n  <div>\r\n    <h1>#{obter_texto(:titulo)}</h1>\r\n    <span class=\"subtitle\">#{obter_texto(:subtitulo)}</span>\r\n  </div>\r\n</div>\r\n\r\n<!-- Timeline Card -->\r\n<div class=\"card\">\r\n  <div class=\"card-body\">\r\n    <div class=\"timeline-wrapper\">\r\n      <div class=\"timeline-track\"></div>\r\n      <input type=\"range\" min=\"0\" max=\"60\" step=\"0.1\" value=\"0\" id=\"timeline_range\" oninput=\"updateTime(this.value)\">\r\n      <div id=\"markers_layer\"></div>\r\n    </div>\r\n    <div class=\"time-row\">\r\n      <div class=\"time-display\"><span id=\"current_time\">0.0</span><small>s</small></div>\r\n      <div class=\"time-input-group\">\r\n        <label>#{obter_texto(:total)}</label>\r\n        <input id=\"max_time\" type=\"number\" step=\"1\" value=\"60\" min=\"1\" onchange=\"atualizarTempoTotal()\"\r\n          style=\"width:65px; padding:4px 8px; border:1px solid #ddd; border-radius:4px; font-size:12px; text-align:center; outline:none; font-family:inherit;\">\r\n        <small style=\"color:#888;\">s</small>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Playback Controls Card -->\r\n<div class=\"card playback-card\">\r\n  <div class=\"card-body\">\r\n    <div class=\"btn-group\">\r\n      <button class=\"btn btn-primary\" onclick=\"addVision()\">\r\n        <svg width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2.5\"><line x1=\"12\" y1=\"5\" x2=\"12\" y2=\"19\"/><line x1=\"5\" y1=\"12\" x2=\"19\" y2=\"12\"/></svg>\r\n        #{obter_texto(:visao)}\r\n      </button>\r\n      <button id=\"play_button\" class=\"btn btn-success\" onclick=\"togglePlay()\">&#9654; #{obter_texto(:play)}</button>\r\n      <button id=\"play_all_button\" class=\"btn btn-outline btn-sm hidden\" onclick=\"togglePlayAll()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><polygon points=\"5 3 19 12 5 21 5 3\"/><line x1=\"19\" y1=\"3\" x2=\"19\" y2=\"21\"/></svg>\r\n        #{obter_texto(:play_all)}\r\n      </button>\r\n      <button class=\"btn btn-outline btn-sm\" onclick=\"mostrarCampoAtalho()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><rect x=\"2\" y=\"4\" width=\"20\" height=\"16\" rx=\"2\"/><line x1=\"6\" y1=\"8\" x2=\"6\" y2=\"8\"/><line x1=\"10\" y1=\"8\" x2=\"10\" y2=\"8\"/><line x1=\"14\" y1=\"8\" x2=\"14\" y2=\"8\"/><line x1=\"18\" y1=\"8\" x2=\"18\" y2=\"8\"/><line x1=\"8\" y1=\"16\" x2=\"16\" y2=\"16\"/></svg>\r\n        #{obter_texto(:atalho)}\r\n      </button>\r\n      <span id=\"hotkey_edit\" class=\"hotkey-editor\">\r\n        <input id=\"hotkey_input\" type=\"text\" placeholder=\"#{obter_texto(:pressione)}\" onkeydown=\"capturarAtalhoInput(event)\">\r\n        <button class=\"btn btn-primary btn-sm\" onclick=\"confirmarAtalho()\">#{obter_texto(:ok)}</button>\r\n      </span>\r\n    </div>\r\n    <div class=\"check-group\">\r\n      <div class=\"check-item\">\r\n        <input type=\"checkbox\" id=\"loop_checkbox\">\r\n        <label for=\"loop_checkbox\">#{obter_texto(:loop)}</label>\r\n      </div>\r\n      <div class=\"check-item\">\r\n        <input type=\"checkbox\" id=\"easing_checkbox\">\r\n        <label for=\"easing_checkbox\">#{obter_texto(:easing)}</label>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Visions Card -->\r\n<div class=\"card\">\r\n  <div class=\"card-header\" onclick=\"toggleSection('visions')\">\r\n    <h2>#{obter_texto(:visoes_salvas)} <span id=\"vision_count\" style=\"color:#999; font-weight:400;\"></span></h2>\r\n    <span class=\"toggle-icon\" id=\"visions_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body\" id=\"visions_body\">\r\n    <div class=\"vision-list\" id=\"lista_visoes\"></div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Gerenciar Time Line Card -->\r\n<div class=\"card\">\r\n  <div class=\"card-header\" onclick=\"toggleSection('timeline_mgr')\">\r\n    <h2>#{obter_texto(:gerenciar_timeline)}</h2>\r\n    <span class=\"toggle-icon\" id=\"timeline_mgr_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body\" id=\"timeline_mgr_body\">\r\n    <div class=\"btn-group\">\r\n      <button class=\"btn btn-outline\" onclick=\"novaTimeline()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z\"/><polyline points=\"14 2 14 8 20 8\"/><line x1=\"12\" y1=\"18\" x2=\"12\" y2=\"12\"/><line x1=\"9\" y1=\"15\" x2=\"15\" y2=\"15\"/></svg>\r\n        #{obter_texto(:nova)}\r\n      </button>\r\n      <button class=\"btn btn-outline\" onclick=\"exportarTimeline()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\"/><polyline points=\"7 10 12 15 17 10\"/><line x1=\"12\" y1=\"15\" x2=\"12\" y2=\"3\"/></svg>\r\n        #{obter_texto(:exportar_atual)}\r\n      </button>\r\n      <button class=\"btn btn-outline\" onclick=\"exportarProjeto()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z\"/><polyline points=\"9 14 12 17 15 14\"/><line x1=\"12\" y1=\"17\" x2=\"12\" y2=\"10\"/></svg>\r\n        #{obter_texto(:exportar_projeto)}\r\n      </button>\r\n      <input type=\"file\" id=\"import_file\" class=\"hidden\" accept=\".json\" onchange=\"importarTimeline(this)\">\r\n      <button class=\"btn btn-outline\" onclick=\"document.getElementById('import_file').click()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\"/><polyline points=\"17 8 12 3 7 8\"/><line x1=\"12\" y1=\"3\" x2=\"12\" y2=\"15\"/></svg>\r\n        #{obter_texto(:importar)}\r\n      </button>\r\n    </div>\r\n    <div id=\"saved_timelines_list\" class=\"saved-timelines-list\"></div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Exportar Vídeo Card (colapsado por padrão) -->\r\n<div class=\"card\">\r\n  <div class=\"card-header collapsed\" onclick=\"toggleSection('export')\">\r\n    <h2>#{obter_texto(:exportar_video)}</h2>\r\n    <span class=\"toggle-icon\" id=\"export_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body collapsed\" id=\"export_body\">\r\n    <div id=\"ffmpeg_section\" class=\"#{has_ffmpeg ? '' : 'hidden'}\">\r\n      <div class=\"viewport-info\">\r\n        #{obter_texto(:viewport_atual)} <strong>#{vp_width} x #{vp_height} px</strong>\r\n      </div>\r\n\r\n      <select id=\"preset_select\" class=\"preset-select\" onchange=\"onPresetChange()\">\r\n        <option value=\"\" disabled selected>#{obter_texto(:selecione_formato)}</option>\r\n      </select>\r\n\r\n      <div class=\"custom-dims\" id=\"custom_dims\">\r\n        <input type=\"number\" id=\"custom_w\" min=\"50\" placeholder=\"#{obter_texto(:largura)}\" value=\"1280\">\r\n        <span>x</span>\r\n        <input type=\"number\" id=\"custom_h\" min=\"50\" placeholder=\"#{obter_texto(:altura)}\" value=\"720\">\r\n        <small style=\"color:#888;\">px</small>\r\n      </div>\r\n\r\n      <div class=\"preset-preview\" id=\"preset_preview\" style=\"display:none;\"></div>\r\n\r\n      <div class=\"check-group\" style=\"margin-top:12px; flex-direction:column; align-items:flex-start; gap:8px;\">\r\n        <div class=\"check-item\">\r\n          <input type=\"checkbox\" id=\"rec_projeto\">\r\n          <label for=\"rec_projeto\">#{obter_texto(:gravar_projeto)}</label>\r\n        </div>\r\n        <div class=\"check-item\">\r\n          <input type=\"checkbox\" id=\"rec_inicio\" checked>\r\n          <label for=\"rec_inicio\">#{obter_texto(:iniciar_quadro1)}</label>\r\n        </div>\r\n      </div>\r\n\r\n      <button class=\"btn btn-record mt-8\" id=\"btn_record\" onclick=\"iniciarGravacao()\" disabled style=\"width:100%; margin-top:12px;\">\r\n        <svg width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><circle cx=\"12\" cy=\"12\" r=\"4\" fill=\"currentColor\"/></svg>\r\n        #{obter_texto(:iniciar_gravacao)}\r\n      </button>\r\n\r\n      <div class=\"recording-bar\" id=\"recording_bar\">\r\n        <div class=\"recording-dot\"></div>\r\n        <span>#{obter_texto(:gravando)}</span>\r\n      </div>\r\n    </div>\r\n\r\n    <div id=\"ffmpeg_install\" class=\"#{has_ffmpeg ? 'hidden' : ''}\" style=\"text-align:center; padding:12px 0;\">\r\n      <p style=\"color:#888; font-size:12px; margin-bottom:10px;\">#{obter_texto(:ffmpeg_necessario)}</p>\r\n      <button class=\"btn btn-primary\" onclick=\"instalarExportacao()\">#{obter_texto(:instalar_ffmpeg)}</button>\r\n    </div>\r\n\r\n    <!-- Modal de nome do arquivo -->\r\n    <div id=\"filename_modal\" style=\"display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.4);z-index:100;align-items:center;justify-content:center;\">\r\n      <div style=\"background:#fff;border-radius:10px;padding:24px;width:320px;box-shadow:0 8px 30px rgba(0,0,0,0.2);\">\r\n        <h3 style=\"font-size:14px;font-weight:600;color:#333;margin-bottom:12px;\">#{obter_texto(:nome_arquivo)}</h3>\r\n        <input id=\"filename_input\" type=\"text\" value=\"tour_final\" style=\"width:100%;padding:8px 12px;border:1px solid #ddd;border-radius:6px;font-size:13px;font-family:inherit;outline:none;margin-bottom:6px;\">\r\n        <small style=\"color:#888;\">#{obter_texto(:extensao_mp4)}</small>\r\n        <div style=\"display:flex;gap:8px;margin-top:16px;justify-content:flex-end;\">\r\n          <button class=\"btn btn-outline btn-sm\" onclick=\"fecharModalFilename()\">#{obter_texto(:cancelar)}</button>\r\n          <button class=\"btn btn-primary btn-sm\" onclick=\"confirmarFilename()\">#{obter_texto(:salvar)}</button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<script>\r\n    const I18N = #{js_i18n_json};\r\n    let visoes = [], playing = false, currentIndex = 0;\r\n    let hotkey = { keyCode: #{current_hotkey}, ctrl: #{hotkey_ctrl}, alt: #{hotkey_alt}, shift: #{hotkey_shift} };\r\n    let capturingHotkey = false, pendingHotkey = null;\r\n    let savedTimelines = [];\r\n    let activeTimelineIndex = -1;\r\n    let playingAll = false, playAllQueue = [], playAllCurrentIdx = 0;\r\n    var viewportW = #{vp_width}, viewportH = #{vp_height};\r\n\r\n    if (window.sketchup) { window.sketchup.set_hotkey(hotkey.keyCode, hotkey.ctrl, hotkey.alt, hotkey.shift); }\r\n\r\n    /* --- Export Formats (aspect ratios) --- */\r\n    const EXPORT_FORMATS = [\r\n      { label: '16:9 ' + I18N.paisagem, ratio: [16, 9] },\r\n      { label: '9:16 ' + I18N.retrato, ratio: [9, 16] },\r\n      { label: '1:1 ' + I18N.quadrado, ratio: [1, 1] },\r\n      { label: '4:3 ' + I18N.classico, ratio: [4, 3] },\r\n      { label: '21:9 ' + I18N.ultra_wide, ratio: [21, 9] },\r\n      { label: I18N.viewport_inteira, ratio: null },\r\n      { label: I18N.personalizado, ratio: null, custom: true }\r\n    ];\r\n\r\n    function calcEffectiveDims(ratioW, ratioH, vpW, vpH) {\r\n      const scaleW = vpW / ratioW;\r\n      const scaleH = vpH / ratioH;\r\n      const scale = Math.min(scaleW, scaleH);\r\n      let w = Math.floor(ratioW * scale);\r\n      let h = Math.floor(ratioH * scale);\r\n      w = w % 2 === 0 ? w : w - 1;\r\n      h = h % 2 === 0 ? h : h - 1;\r\n      return { w: w, h: h };\r\n    }\r\n\r\n    function populatePresets() {\r\n      const sel = document.getElementById(\"preset_select\");\r\n      sel.innerHTML = '<option value=\"\" disabled selected>' + I18N.selecione_formato + '</option>';\r\n      EXPORT_FORMATS.forEach((fmt, i) => {\r\n        const opt = document.createElement(\"option\");\r\n        opt.value = i.toString();\r\n        if (fmt.custom) {\r\n          opt.textContent = fmt.label;\r\n        } else if (fmt.ratio) {\r\n          const dims = calcEffectiveDims(fmt.ratio[0], fmt.ratio[1], viewportW, viewportH);\r\n          opt.textContent = fmt.label + \" (\" + dims.w + \" x \" + dims.h + \" px)\";\r\n        } else {\r\n          let w = viewportW % 2 === 0 ? viewportW : viewportW - 1;\r\n          let h = viewportH % 2 === 0 ? viewportH : viewportH - 1;\r\n          opt.textContent = fmt.label + \" (\" + w + \" x \" + h + \" px)\";\r\n        }\r\n        sel.appendChild(opt);\r\n      });\r\n    }\r\n\r\n    /* --- Section Toggle --- */\r\n    function toggleSection(name) {\r\n      const body = document.getElementById(name + '_body');\r\n      const icon = document.getElementById(name + '_toggle');\r\n      const header = icon.parentElement;\r\n      const wasCollapsed = body.classList.contains('collapsed');\r\n      if (wasCollapsed) {\r\n        body.classList.remove('collapsed');\r\n        header.classList.remove('collapsed');\r\n      } else {\r\n        body.classList.add('collapsed');\r\n        header.classList.add('collapsed');\r\n      }\r\n      /* Hide viewport preview when closing export card */\r\n      if (name === 'export' && !wasCollapsed) {\r\n        if (window.sketchup) window.sketchup.hide_export_preview();\r\n      }\r\n    }\r\n\r\n    /* --- Timeline --- */\r\n    function updateTime(val) {\r\n      document.getElementById(\"current_time\").innerText = parseFloat(val).toFixed(1);\r\n    }\r\n\r\n    function atualizarTempoTotal() {\r\n      const novoMax = parseFloat(document.getElementById(\"max_time\").value);\r\n      if (isNaN(novoMax) || novoMax <= 0) return;\r\n      document.getElementById(\"timeline_range\").max = novoMax;\r\n      visoes.forEach(v => { if (v.time > novoMax) v.time = novoMax - 0.1; });\r\n      renderMarkers();\r\n    }\r\n\r\n    /* --- Visions --- */\r\n    function addVision() {\r\n      if (savedTimelines.length === 0 && visoes.length === 0) {\r\n        var name = prompt(I18N.nome_timeline, \"Time Line 1\");\r\n        if (!name) return;\r\n        savedTimelines.push({ name: name, visoes: [], maxTime: 60 });\r\n        activeTimelineIndex = 0;\r\n        renderSavedTimelines();\r\n      }\r\n      const time = parseFloat(document.getElementById(\"timeline_range\").value);\r\n      sketchup.capture_camera(time);\r\n    }\r\n\r\n    function captureVisionFromRuby(camJson) {\r\n      const obj = JSON.parse(camJson);\r\n      obj.walk = false; obj.anchor = false;\r\n      visoes = visoes.filter(v => v.time !== obj.time);\r\n      visoes.push(obj);\r\n      visoes.sort((a, b) => a.time - b.time);\r\n      visoes[0].time = 0.0;\r\n      syncActiveTimeline();\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    /* --- Draggable markers --- */\r\n    function setupMarkerDrag(marker, visionIndex, slider, maxTime) {\r\n      if (visionIndex === 0) {\r\n        marker.classList.add(\"no-drag\");\r\n        return;\r\n      }\r\n      marker.addEventListener(\"mousedown\", function(e) {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        marker.classList.add(\"dragging\");\r\n        const sliderPadding = 8;\r\n\r\n        function onMove(ev) {\r\n          const sliderRect = slider.getBoundingClientRect();\r\n          const usableWidth = sliderRect.width - sliderPadding * 2;\r\n          const relativeX = Math.max(0, Math.min(ev.clientX - sliderRect.left - sliderPadding, usableWidth));\r\n          const newTime = parseFloat(((relativeX / usableWidth) * maxTime).toFixed(1));\r\n          marker.style.left = (relativeX + sliderPadding) + \"px\";\r\n          const tooltip = marker.querySelector(\".marker-tooltip\");\r\n          if (tooltip) tooltip.textContent = newTime.toFixed(1) + \"s\";\r\n        }\r\n\r\n        function onUp(ev) {\r\n          marker.classList.remove(\"dragging\");\r\n          document.removeEventListener(\"mousemove\", onMove);\r\n          document.removeEventListener(\"mouseup\", onUp);\r\n          const sliderRect = slider.getBoundingClientRect();\r\n          const usableWidth = sliderRect.width - sliderPadding * 2;\r\n          const relativeX = Math.max(0, Math.min(ev.clientX - sliderRect.left - sliderPadding, usableWidth));\r\n          const newTime = parseFloat(((relativeX / usableWidth) * maxTime).toFixed(1));\r\n          visoes[visionIndex].time = Math.max(0.1, newTime);\r\n          visoes.sort((a, b) => a.time - b.time);\r\n          if (visoes.length > 0) visoes[0].time = 0.0;\r\n          renderMarkers();\r\n        }\r\n\r\n        document.addEventListener(\"mousemove\", onMove);\r\n        document.addEventListener(\"mouseup\", onUp);\r\n      });\r\n    }\r\n\r\n    function syncActiveTimeline() {\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n    }\r\n\r\n    function renderMarkers() {\r\n      const layer = document.getElementById(\"markers_layer\");\r\n      const lista = document.getElementById(\"lista_visoes\");\r\n      const slider = document.getElementById(\"timeline_range\");\r\n      const max = parseFloat(slider.max);\r\n      const width = slider.offsetWidth;\r\n      const countEl = document.getElementById(\"vision_count\");\r\n\r\n      layer.innerHTML = \"\"; lista.innerHTML = \"\";\r\n      countEl.textContent = visoes.length > 0 ? \"(\" + visoes.length + \")\" : \"\";\r\n\r\n      if (visoes.length === 0) {\r\n        lista.innerHTML = '<div class=\"empty-state\">' +\r\n          '<svg width=\"36\" height=\"36\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"#ccc\" stroke-width=\"1.5\"><path d=\"M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z\"/><circle cx=\"12\" cy=\"13\" r=\"4\"/></svg>' +\r\n          '<p>' + I18N.nenhuma_visao + '<br>' + I18N.dica_visao + '</p></div>';\r\n        return;\r\n      }\r\n\r\n      visoes.forEach((v, i) => {\r\n        /* Marker on timeline */\r\n        const percent = max > 0 ? v.time / max : 0;\r\n        const marker = document.createElement(\"div\");\r\n        marker.className = \"marker\" + (v.anchor ? \" anchor\" : \"\");\r\n        const sliderPadding = 8;\r\n        const usableWidth = width - sliderPadding * 2;\r\n        marker.style.left = (percent * usableWidth + sliderPadding) + \"px\";\r\n        const tooltip = document.createElement(\"span\");\r\n        tooltip.className = \"marker-tooltip\";\r\n        tooltip.textContent = v.time.toFixed(1) + \"s\";\r\n        marker.appendChild(tooltip);\r\n        marker.onclick = () => {\r\n          slider.value = v.time; updateTime(v.time); currentIndex = i;\r\n          resetPlayButton(); sketchup.goto_camera(JSON.stringify(v));\r\n        };\r\n        /* Draggable */\r\n        setupMarkerDrag(marker, i, slider, max);\r\n        layer.appendChild(marker);\r\n\r\n        /* Vision list item */\r\n        const item = document.createElement(\"div\");\r\n        item.className = \"vision-item\";\r\n        item.onclick = () => {\r\n          slider.value = v.time; updateTime(v.time); currentIndex = i;\r\n          resetPlayButton(); sketchup.goto_camera(JSON.stringify(v));\r\n        };\r\n\r\n        const num = document.createElement(\"span\");\r\n        num.className = \"vision-num\";\r\n        num.textContent = (i + 1);\r\n\r\n        const img = document.createElement(\"img\");\r\n        if (v.thumb && v.thumb.length > 0) {\r\n          const mime = v.thumb.startsWith(\"/9j/\") ? \"image/jpeg\" : \"image/bmp\";\r\n          img.src = \"data:\" + mime + \";base64,\" + v.thumb;\r\n        } else {\r\n          img.src = \"\";\r\n          img.className = \"thumb-placeholder\";\r\n        }\r\n\r\n        const info = document.createElement(\"div\");\r\n        info.className = \"vision-info\";\r\n        const timeInput = document.createElement(\"input\");\r\n        timeInput.type = \"number\"; timeInput.step = \"0.1\";\r\n        timeInput.value = v.time.toFixed(1);\r\n        timeInput.className = \"vision-time-input\";\r\n        timeInput.disabled = (i === 0);\r\n        timeInput.onclick = (e) => e.stopPropagation();\r\n        timeInput.onchange = () => {\r\n          v.time = parseFloat(timeInput.value);\r\n          visoes.sort((a, b) => a.time - b.time);\r\n          renderMarkers();\r\n        };\r\n        info.appendChild(timeInput);\r\n\r\n        const actions = document.createElement(\"div\");\r\n        actions.className = \"vision-actions\";\r\n\r\n        const anchorBtn = document.createElement(\"button\");\r\n        anchorBtn.className = \"anchor-toggle\" + (v.anchor ? \" active\" : \"\");\r\n        anchorBtn.innerHTML = \"&#9875;\";\r\n        anchorBtn.title = I18N.ancora;\r\n        anchorBtn.onclick = (e) => {\r\n          e.stopPropagation();\r\n          v.anchor = !v.anchor;\r\n          renderMarkers();\r\n        };\r\n        actions.appendChild(anchorBtn);\r\n\r\n        const delBtn = document.createElement(\"button\");\r\n        delBtn.className = \"delete-btn\";\r\n        delBtn.innerHTML = \"&times;\";\r\n        delBtn.title = I18N.excluir;\r\n        delBtn.onclick = (e) => {\r\n          e.stopPropagation();\r\n          visoes.splice(i, 1);\r\n          if (visoes.length > 0) visoes[0].time = 0.0;\r\n          syncActiveTimeline();\r\n          renderMarkers();\r\n          renderSavedTimelines();\r\n        };\r\n        actions.appendChild(delBtn);\r\n\r\n        item.appendChild(num);\r\n        item.appendChild(img);\r\n        item.appendChild(info);\r\n        item.appendChild(actions);\r\n        lista.appendChild(item);\r\n      });\r\n    }\r\n\r\n    /* --- Playback --- */\r\n    function togglePlay() {\r\n      if (!playing) {\r\n        if (visoes.length < 2) return alert(I18N.min_duas_visoes);\r\n        if (currentIndex >= visoes.length - 1) currentIndex = 0;\r\n        playing = true;\r\n        document.body.classList.add(\"playing\");\r\n        document.getElementById(\"play_button\").innerHTML = \"&#9724; \" + I18N.stop;\r\n        document.getElementById(\"play_button\").className = \"btn btn-danger\";\r\n        sketchup.play_tour(JSON.stringify(visoes), document.getElementById(\"loop_checkbox\").checked, false, document.getElementById(\"easing_checkbox\").checked, currentIndex);\r\n      } else {\r\n        resetPlayButton();\r\n        sketchup.stop_tour();\r\n      }\r\n    }\r\n\r\n    function resetPlayButton() {\r\n      playing = false;\r\n      document.body.classList.remove(\"playing\");\r\n      document.getElementById(\"play_button\").innerHTML = \"&#9654; \" + I18N.play;\r\n      document.getElementById(\"play_button\").className = \"btn btn-success\";\r\n    }\r\n\r\n    function togglePlayAll() {\r\n      if (playingAll) {\r\n        resetPlayAll();\r\n        sketchup.stop_tour();\r\n        return;\r\n      }\r\n      if (savedTimelines.length < 2) return;\r\n      /* Save current timeline state */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n      /* Build queue of timelines with 2+ visions */\r\n      playAllQueue = savedTimelines.map(function(tl, i) { return i; }).filter(function(i) { return savedTimelines[i].visoes.length >= 2; });\r\n      if (playAllQueue.length < 1) { alert(I18N.sem_tl_2mais); return; }\r\n      playingAll = true;\r\n      playAllCurrentIdx = 0;\r\n      document.body.classList.add(\"playing\");\r\n      document.getElementById(\"play_all_button\").innerHTML = \"&#9724; \" + I18N.stop_all;\r\n      document.getElementById(\"play_all_button\").className = \"btn btn-danger btn-sm\";\r\n      playTimelineAtQueueIndex(0);\r\n    }\r\n\r\n    function playTimelineAtQueueIndex(qIdx) {\r\n      var tlIdx = playAllQueue[qIdx];\r\n      var tl = savedTimelines[tlIdx];\r\n      visoes = JSON.parse(JSON.stringify(tl.visoes));\r\n      document.getElementById(\"max_time\").value = tl.maxTime;\r\n      document.getElementById(\"timeline_range\").max = tl.maxTime;\r\n      activeTimelineIndex = tlIdx;\r\n      currentIndex = 0;\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n      sketchup.play_tour(\r\n        JSON.stringify(visoes),\r\n        false,\r\n        false,\r\n        document.getElementById(\"easing_checkbox\").checked,\r\n        0\r\n      );\r\n    }\r\n\r\n    function resetPlayAll() {\r\n      playingAll = false;\r\n      playAllQueue = [];\r\n      playAllCurrentIdx = 0;\r\n      document.body.classList.remove(\"playing\");\r\n      var btn = document.getElementById(\"play_all_button\");\r\n      btn.innerHTML = '<svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><polygon points=\"5 3 19 12 5 21 5 3\"/><line x1=\"19\" y1=\"3\" x2=\"19\" y2=\"21\"/></svg> ' + I18N.play_all;\r\n      btn.className = \"btn btn-outline btn-sm\";\r\n      playing = false;\r\n      document.getElementById(\"play_button\").innerHTML = \"&#9654; \" + I18N.play;\r\n      document.getElementById(\"play_button\").className = \"btn btn-success\";\r\n    }\r\n\r\n    function startRecordingPlayAll(startTlIdx, startVisionIdx) {\r\n      syncActiveTimeline();\r\n      /* Montar fila de timelines com 2+ visões, a partir de startTlIdx */\r\n      playAllQueue = [];\r\n      for (var i = startTlIdx; i < savedTimelines.length; i++) {\r\n        if (savedTimelines[i].visoes.length >= 2) playAllQueue.push(i);\r\n      }\r\n      if (playAllQueue.length === 0) return;\r\n\r\n      playingAll = true;\r\n      playAllCurrentIdx = 0;\r\n      playing = true;\r\n      document.body.classList.add(\"playing\");\r\n      document.getElementById(\"play_button\").innerHTML = \"&#9724; \" + I18N.stop;\r\n      document.getElementById(\"play_button\").className = \"btn btn-danger\";\r\n\r\n      /* Carregar a primeira timeline da fila */\r\n      var firstTlIdx = playAllQueue[0];\r\n      var tl = savedTimelines[firstTlIdx];\r\n      visoes = JSON.parse(JSON.stringify(tl.visoes));\r\n      document.getElementById(\"max_time\").value = tl.maxTime;\r\n      document.getElementById(\"timeline_range\").max = tl.maxTime;\r\n      activeTimelineIndex = firstTlIdx;\r\n      currentIndex = startVisionIdx;\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n\r\n      sketchup.play_tour(\r\n        JSON.stringify(visoes),\r\n        false,\r\n        false,\r\n        document.getElementById(\"easing_checkbox\").checked,\r\n        startVisionIdx\r\n      );\r\n    }\r\n\r\n    function updatePlayAllButton() {\r\n      var btn = document.getElementById(\"play_all_button\");\r\n      if (savedTimelines.length > 1) {\r\n        btn.classList.remove(\"hidden\");\r\n      } else {\r\n        btn.classList.add(\"hidden\");\r\n      }\r\n    }\r\n\r\n    function pauseAtIndex(idx) {\r\n      currentIndex = idx;\r\n      if (playingAll) {\r\n        playAllCurrentIdx++;\r\n        if (playAllCurrentIdx < playAllQueue.length) {\r\n          playTimelineAtQueueIndex(playAllCurrentIdx);\r\n          return;\r\n        } else {\r\n          resetPlayAll();\r\n          return;\r\n        }\r\n      }\r\n      resetPlayButton();\r\n    }\r\n    function triggerSpaceFromRuby() { togglePlay(); }\r\n    function updatePlayhead(time) {\r\n      var slider = document.getElementById(\"timeline_range\");\r\n      slider.value = time;\r\n      document.getElementById(\"current_time\").innerText = parseFloat(time).toFixed(1);\r\n    }\r\n\r\n    /* --- Timeline Management --- */\r\n    function exportarTimeline() {\r\n      if (visoes.length === 0) { alert(I18N.sem_visoes_exportar); return; }\r\n      var tlName = (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length)\r\n        ? savedTimelines[activeTimelineIndex].name : \"Time Line\";\r\n      /* Download JSON */\r\n      var dataStr = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(visoes, null, 2));\r\n      var a = document.createElement(\"a\");\r\n      a.setAttribute(\"href\", dataStr);\r\n      a.setAttribute(\"download\", tlName.replace(/[^a-zA-Z0-9_-]/g, \"_\") + \".json\");\r\n      document.body.appendChild(a); a.click(); a.remove();\r\n      /* Salvar na lista */\r\n      saveCurrentToTimelines(tlName);\r\n    }\r\n\r\n    function exportarProjeto() {\r\n      syncActiveTimeline();\r\n      if (savedTimelines.length === 0) { alert(I18N.sem_tl_exportar); return; }\r\n      var projeto = { type: \"tour_virtual_project\", timelines: savedTimelines };\r\n      var dataStr = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(projeto, null, 2));\r\n      var a = document.createElement(\"a\");\r\n      a.setAttribute(\"href\", dataStr);\r\n      a.setAttribute(\"download\", \"projeto_tour_virtual.json\");\r\n      document.body.appendChild(a); a.click(); a.remove();\r\n    }\r\n\r\n    function saveCurrentToTimelines(name) {\r\n      var maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      var entry = { name: name, visoes: JSON.parse(JSON.stringify(visoes)), maxTime: maxTime };\r\n      /* Atualizar existente se ativo, senão adicionar novo */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex] = entry;\r\n      } else {\r\n        savedTimelines.push(entry);\r\n        activeTimelineIndex = savedTimelines.length - 1;\r\n      }\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    function importarTimeline(input) {\r\n      var file = input.files[0];\r\n      if (!file) return;\r\n      var reader = new FileReader();\r\n      reader.onload = function(e) {\r\n        try {\r\n          var imported = JSON.parse(e.target.result);\r\n          /* Detectar se é um projeto completo */\r\n          if (imported && imported.type === \"tour_virtual_project\" && Array.isArray(imported.timelines)) {\r\n            syncActiveTimeline();\r\n            imported.timelines.forEach(function(tl) {\r\n              if (tl.visoes) {\r\n                tl.visoes.sort(function(a, b) { return a.time - b.time; });\r\n                if (tl.visoes.length > 0) tl.visoes[0].time = 0.0;\r\n              }\r\n              savedTimelines.push({ name: tl.name || I18N.importada, visoes: tl.visoes || [], maxTime: tl.maxTime || 60 });\r\n            });\r\n            if (savedTimelines.length > 0 && activeTimelineIndex < 0) {\r\n              activeTimelineIndex = 0;\r\n              var first = savedTimelines[0];\r\n              visoes = JSON.parse(JSON.stringify(first.visoes));\r\n              document.getElementById(\"max_time\").value = first.maxTime;\r\n              document.getElementById(\"timeline_range\").max = first.maxTime;\r\n              renderMarkers();\r\n            }\r\n            renderSavedTimelines();\r\n            return;\r\n          }\r\n          /* Time Line única */\r\n          if (!Array.isArray(imported)) throw I18N.formato_invalido;\r\n          imported.sort(function(a, b) { return a.time - b.time; });\r\n          if (imported.length > 0) imported[0].time = 0.0;\r\n          var maxTime = imported.length > 0 ? Math.ceil(imported[imported.length - 1].time + 1) : 60;\r\n          var name = file.name.replace(/\\\\.json$/i, \"\");\r\n          savedTimelines.push({ name: name, visoes: imported, maxTime: maxTime });\r\n          renderSavedTimelines();\r\n        } catch (err) { alert(I18N.erro_importar + err); }\r\n      };\r\n      reader.readAsText(file);\r\n      input.value = \"\";\r\n    }\r\n\r\n    function switchTimeline(index) {\r\n      if (index === activeTimelineIndex) return;\r\n      /* Save current state if there's an active timeline */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n      /* Load selected timeline */\r\n      const tl = savedTimelines[index];\r\n      visoes = JSON.parse(JSON.stringify(tl.visoes));\r\n      document.getElementById(\"max_time\").value = tl.maxTime;\r\n      document.getElementById(\"timeline_range\").max = tl.maxTime;\r\n      activeTimelineIndex = index;\r\n      currentIndex = 0;\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    function deleteTimeline(index) {\r\n      if (index === activeTimelineIndex) return;\r\n      savedTimelines.splice(index, 1);\r\n      if (activeTimelineIndex > index) activeTimelineIndex--;\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    function renderSavedTimelines() {\r\n      var container = document.getElementById(\"saved_timelines_list\");\r\n      container.innerHTML = \"\";\r\n      if (savedTimelines.length === 0) { updatePlayAllButton(); return; }\r\n      var dragSrcIndex = null;\r\n\r\n      savedTimelines.forEach(function(tl, i) {\r\n        var item = document.createElement(\"div\");\r\n        item.className = \"tl-item\" + (i === activeTimelineIndex ? \" active\" : \"\");\r\n        item.draggable = true;\r\n        item.dataset.index = i;\r\n\r\n        /* Drag handle */\r\n        var handle = document.createElement(\"span\");\r\n        handle.className = \"tl-drag-handle\";\r\n        handle.innerHTML = \"&#9776;\";\r\n        item.appendChild(handle);\r\n\r\n        /* Drag events */\r\n        item.addEventListener(\"dragstart\", function(e) {\r\n          dragSrcIndex = i;\r\n          item.classList.add(\"dragging\");\r\n          e.dataTransfer.effectAllowed = \"move\";\r\n        });\r\n        item.addEventListener(\"dragover\", function(e) {\r\n          e.preventDefault();\r\n          e.dataTransfer.dropEffect = \"move\";\r\n          var rect = item.getBoundingClientRect();\r\n          var midY = rect.top + rect.height / 2;\r\n          item.classList.remove(\"drag-over-top\", \"drag-over-bottom\");\r\n          item.classList.add(e.clientY < midY ? \"drag-over-top\" : \"drag-over-bottom\");\r\n        });\r\n        item.addEventListener(\"dragleave\", function() {\r\n          item.classList.remove(\"drag-over-top\", \"drag-over-bottom\");\r\n        });\r\n        item.addEventListener(\"drop\", function(e) {\r\n          e.preventDefault();\r\n          item.classList.remove(\"drag-over-top\", \"drag-over-bottom\");\r\n          if (dragSrcIndex === null || dragSrcIndex === i) return;\r\n          var rect = item.getBoundingClientRect();\r\n          var midY = rect.top + rect.height / 2;\r\n          var targetIndex = e.clientY < midY ? i : i + 1;\r\n          if (dragSrcIndex < targetIndex) targetIndex--;\r\n          var moved = savedTimelines.splice(dragSrcIndex, 1)[0];\r\n          savedTimelines.splice(targetIndex, 0, moved);\r\n          if (activeTimelineIndex === dragSrcIndex) {\r\n            activeTimelineIndex = targetIndex;\r\n          } else if (dragSrcIndex < activeTimelineIndex && targetIndex >= activeTimelineIndex) {\r\n            activeTimelineIndex--;\r\n          } else if (dragSrcIndex > activeTimelineIndex && targetIndex <= activeTimelineIndex) {\r\n            activeTimelineIndex++;\r\n          }\r\n          renderSavedTimelines();\r\n        });\r\n        item.addEventListener(\"dragend\", function() {\r\n          item.classList.remove(\"dragging\");\r\n          dragSrcIndex = null;\r\n        });\r\n\r\n        item.onclick = function() { switchTimeline(i); };\r\n\r\n        var indicator = document.createElement(\"span\");\r\n        indicator.className = \"tl-indicator\";\r\n        item.appendChild(indicator);\r\n\r\n        var nameEl = document.createElement(\"span\");\r\n        nameEl.className = \"tl-name\";\r\n        nameEl.textContent = tl.name;\r\n        item.appendChild(nameEl);\r\n\r\n        var count = document.createElement(\"span\");\r\n        count.className = \"tl-count\";\r\n        count.textContent = tl.visoes.length + \" \" + I18N.visoes;\r\n        item.appendChild(count);\r\n\r\n        if (i !== activeTimelineIndex) {\r\n          var del = document.createElement(\"button\");\r\n          del.className = \"tl-delete\";\r\n          del.innerHTML = \"&times;\";\r\n          del.title = I18N.excluir;\r\n          del.onclick = function(e) { e.stopPropagation(); deleteTimeline(i); };\r\n          item.appendChild(del);\r\n        }\r\n\r\n        container.appendChild(item);\r\n      });\r\n\r\n      updatePlayAllButton();\r\n    }\r\n\r\n    function novaTimeline() {\r\n      var name = prompt(I18N.nova_timeline, \"Time Line \" + (savedTimelines.length + 1));\r\n      if (!name) return;\r\n      /* Salvar timeline atual na lista se pertencer a uma timeline salva */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n      /* Criar nova timeline vazia e adicioná-la à lista */\r\n      savedTimelines.push({ name: name, visoes: [], maxTime: 60 });\r\n      activeTimelineIndex = savedTimelines.length - 1;\r\n      /* Limpar estado */\r\n      visoes = [];\r\n      currentIndex = 0;\r\n      document.getElementById(\"max_time\").value = 60;\r\n      document.getElementById(\"timeline_range\").max = 60;\r\n      document.getElementById(\"timeline_range\").value = 0;\r\n      updateTime(0);\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    /* --- Video Export with Proportional Presets --- */\r\n    function onPresetChange() {\r\n      const sel = document.getElementById(\"preset_select\");\r\n      const preview = document.getElementById(\"preset_preview\");\r\n      const customDims = document.getElementById(\"custom_dims\");\r\n      const btnRecord = document.getElementById(\"btn_record\");\r\n      const idx = parseInt(sel.value);\r\n\r\n      if (isNaN(idx)) {\r\n        customDims.classList.remove(\"visible\");\r\n        preview.style.display = \"none\";\r\n        btnRecord.disabled = true;\r\n        if (window.sketchup) window.sketchup.hide_export_preview();\r\n        return;\r\n      }\r\n\r\n      const fmt = EXPORT_FORMATS[idx];\r\n      btnRecord.disabled = false;\r\n\r\n      if (fmt.custom) {\r\n        customDims.classList.add(\"visible\");\r\n        preview.style.display = \"none\";\r\n        if (window.sketchup) window.sketchup.hide_export_preview();\r\n      } else {\r\n        customDims.classList.remove(\"visible\");\r\n        let dims;\r\n        if (fmt.ratio) {\r\n          dims = calcEffectiveDims(fmt.ratio[0], fmt.ratio[1], viewportW, viewportH);\r\n        } else {\r\n          dims = { w: viewportW % 2 === 0 ? viewportW : viewportW - 1, h: viewportH % 2 === 0 ? viewportH : viewportH - 1 };\r\n        }\r\n        preview.textContent = I18N.area_gravacao + dims.w + \" x \" + dims.h + \" px\";\r\n        preview.style.display = \"flex\";\r\n        /* Show preview overlay in viewport */\r\n        if (window.sketchup) window.sketchup.show_export_preview(dims.w, dims.h);\r\n      }\r\n    }\r\n\r\n    function getExportDimensions() {\r\n      const sel = document.getElementById(\"preset_select\");\r\n      const idx = parseInt(sel.value);\r\n      if (isNaN(idx)) return null;\r\n      const fmt = EXPORT_FORMATS[idx];\r\n      if (fmt.custom) {\r\n        return {\r\n          w: parseInt(document.getElementById(\"custom_w\").value) || 1280,\r\n          h: parseInt(document.getElementById(\"custom_h\").value) || 720\r\n        };\r\n      }\r\n      if (fmt.ratio) {\r\n        return calcEffectiveDims(fmt.ratio[0], fmt.ratio[1], viewportW, viewportH);\r\n      }\r\n      return { w: viewportW % 2 === 0 ? viewportW : viewportW - 1, h: viewportH % 2 === 0 ? viewportH : viewportH - 1 };\r\n    }\r\n\r\n    function iniciarGravacao() {\r\n      var gravarProjeto = document.getElementById(\"rec_projeto\").checked;\r\n      var desdeInicio = document.getElementById(\"rec_inicio\").checked;\r\n\r\n      if (gravarProjeto) {\r\n        syncActiveTimeline();\r\n        var temVisoes = savedTimelines.some(function(tl) { return tl.visoes.length >= 2; });\r\n        if (!temVisoes) { alert(I18N.sem_tl_min_duas); return; }\r\n      } else {\r\n        if (visoes.length < 2) { alert(I18N.min_duas_visoes); return; }\r\n      }\r\n      var dims = getExportDimensions();\r\n      if (!dims || dims.w < 50 || dims.h < 50) { alert(I18N.dims_invalidas); return; }\r\n\r\n      /* Mostrar modal de nome */\r\n      document.getElementById(\"filename_input\").value = gravarProjeto ? \"projeto_tour\" : \"tour_final\";\r\n      document.getElementById(\"filename_modal\").style.display = \"flex\";\r\n      document.getElementById(\"filename_input\").focus();\r\n      document.getElementById(\"filename_input\").select();\r\n    }\r\n\r\n    function fecharModalFilename() {\r\n      document.getElementById(\"filename_modal\").style.display = \"none\";\r\n    }\r\n\r\n    function confirmarFilename() {\r\n      var nome = document.getElementById(\"filename_input\").value.trim();\r\n      if (!nome) { alert(I18N.digite_nome); return; }\r\n      document.getElementById(\"filename_modal\").style.display = \"none\";\r\n\r\n      var gravarProjeto = document.getElementById(\"rec_projeto\").checked;\r\n      var desdeInicio = document.getElementById(\"rec_inicio\").checked;\r\n      var dims = getExportDimensions();\r\n      var startIdx = desdeInicio ? 0 : currentIndex;\r\n\r\n      if (window.sketchup) window.sketchup.hide_export_preview();\r\n\r\n      if (gravarProjeto) {\r\n        syncActiveTimeline();\r\n        var allTimelines = JSON.stringify(savedTimelines);\r\n        var startTl = desdeInicio ? 0 : activeTimelineIndex;\r\n        var startVision = desdeInicio ? 0 : currentIndex;\r\n        if (window.sketchup) {\r\n          window.sketchup.start_export_project(\r\n            allTimelines,\r\n            document.getElementById(\"easing_checkbox\").checked,\r\n            startTl,\r\n            startVision,\r\n            dims.w,\r\n            dims.h,\r\n            nome\r\n          );\r\n        }\r\n      } else {\r\n        if (window.sketchup) {\r\n          window.sketchup.start_export_process(\r\n            JSON.stringify(visoes),\r\n            document.getElementById(\"easing_checkbox\").checked,\r\n            startIdx,\r\n            dims.w,\r\n            dims.h,\r\n            nome\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    function showRecordingIndicator() {\r\n      document.getElementById(\"recording_bar\").classList.add(\"active\");\r\n    }\r\n    function hideRecordingIndicator() {\r\n      document.getElementById(\"recording_bar\").classList.remove(\"active\");\r\n    }\r\n\r\n    function instalarExportacao() {\r\n      if (window.sketchup) { window.sketchup.install_ffmpeg(); }\r\n    }\r\n\r\n    /* --- Hotkey --- */\r\n    function mostrarCampoAtalho() {\r\n      capturingHotkey = true; pendingHotkey = null;\r\n      document.getElementById(\"hotkey_input\").value = \"\";\r\n      document.getElementById(\"hotkey_edit\").classList.add(\"visible\");\r\n      document.getElementById(\"hotkey_input\").focus();\r\n    }\r\n    function capturarAtalhoInput(e) {\r\n      e.preventDefault();\r\n      /* Ignorar teclas modificadoras sozinhas */\r\n      if ([16, 17, 18, 91, 93].includes(e.keyCode)) return;\r\n      pendingHotkey = {\r\n        keyCode: e.keyCode,\r\n        ctrl: e.ctrlKey,\r\n        alt: e.altKey,\r\n        shift: e.shiftKey\r\n      };\r\n      /* Montar label legivel */\r\n      var parts = [];\r\n      if (e.ctrlKey) parts.push(\"Ctrl\");\r\n      if (e.altKey) parts.push(\"Alt\");\r\n      if (e.shiftKey) parts.push(\"Shift\");\r\n      parts.push(e.code.replace(\"Key\", \"\").replace(\"Digit\", \"\"));\r\n      document.getElementById(\"hotkey_input\").value = parts.join(\" + \");\r\n    }\r\n    function confirmarAtalho() {\r\n      if (pendingHotkey !== null) {\r\n        hotkey = pendingHotkey;\r\n        if (window.sketchup) {\r\n          window.sketchup.set_hotkey(hotkey.keyCode, hotkey.ctrl, hotkey.alt, hotkey.shift);\r\n        }\r\n      }\r\n      capturingHotkey = false;\r\n      document.getElementById(\"hotkey_edit\").classList.remove(\"visible\");\r\n    }\r\n\r\n    /* --- Global bindings --- */\r\n    window.captureVisionFromRuby = captureVisionFromRuby;\r\n    window.resetPlayButton = resetPlayButton;\r\n    window.pauseAtIndex = pauseAtIndex;\r\n    window.triggerSpaceFromRuby = triggerSpaceFromRuby;\r\n    window.showRecordingIndicator = showRecordingIndicator;\r\n    window.hideRecordingIndicator = hideRecordingIndicator;\r\n    window.updatePlayhead = updatePlayhead;\r\n    window.resetPlayAll = resetPlayAll;\r\n    window.startRecordingPlayAll = startRecordingPlayAll;\r\n    window.addEventListener(\"resize\", () => { renderMarkers(); });\r\n\r\n    document.addEventListener(\"keydown\", (e) => {\r\n      if (!capturingHotkey &&\r\n          e.keyCode === hotkey.keyCode &&\r\n          e.ctrlKey === hotkey.ctrl &&\r\n          e.altKey === hotkey.alt &&\r\n          e.shiftKey === hotkey.shift &&\r\n          ![\"INPUT\", \"TEXTAREA\"].includes(e.target.tagName)) {\r\n        e.preventDefault(); togglePlay();\r\n      }\r\n    });\r\n\r\n    /* Init */\r\n    populatePresets();\r\n    renderMarkers();\r\n</script>\r\n</body>\r\n</html>\r\nHTML\r\n\r\n      @dialog ||= UI::HtmlDialog.new({\r\n        :dialog_title => obter_texto(:titulo_dialogo),\r\n        :preferences_key => \"com.example.tour\",\r\n        :scrollable => true,\r\n        :resizable => true,\r\n        :width => 430,\r\n        :height => 790,\r\n        :style => UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n\r\n      @dialog.set_html(html)\r\n      start_space_timer\r\n\r\n      @dialog.add_action_callback(\"set_hotkey\") do |_, key_code, ctrl, alt, shift|\r\n        GlobalKey.set_hotkey(key_code.to_i, ctrl, alt, shift)\r\n        Sketchup.write_default(\"TourVirtual\", \"Hotkey\", key_code.to_i)\r\n        Sketchup.write_default(\"TourVirtual\", \"HotkeyCtrl\", ctrl ? true : false)\r\n        Sketchup.write_default(\"TourVirtual\", \"HotkeyAlt\", alt ? true : false)\r\n        Sketchup.write_default(\"TourVirtual\", \"HotkeyShift\", shift ? true : false)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"capture_camera\") do |_, time_code|\r\n        cam = Sketchup.active_model.active_view.camera\r\n        thumb = capture_thumbnail\r\n        camera_data = {\r\n          time: time_code.to_f,\r\n          eye: cam.eye.to_a,\r\n          target: cam.target.to_a,\r\n          up: cam.up.to_a,\r\n          fov: cam.fov,\r\n          perspective: cam.perspective?,\r\n          thumb: thumb,\r\n          anchor: false\r\n        }\r\n        json_str = camera_data.to_json.gsub('\"', '\\\"')\r\n        @dialog.execute_script(\"captureVisionFromRuby(\\\"#{json_str}\\\")\")\r\n      end\r\n\r\n      @dialog.add_action_callback(\"goto_camera\") do |_, cam_json|\r\n        cam_data = JSON.parse(cam_json, symbolize_names: true)\r\n        cam = Sketchup::Camera.new(cam_data[:eye], cam_data[:target], cam_data[:up], cam_data[:perspective])\r\n        cam.fov = cam_data[:fov]\r\n        Sketchup.active_model.active_view.camera = cam\r\n      end\r\n\r\n      @dialog.add_action_callback(\"play_tour\") do |_, json_data, loop_enabled, inverse_mode, use_easing, start_index|\r\n        @camera_keys = JSON.parse(json_data, symbolize_names: true)\r\n        view = Sketchup.active_model.active_view\r\n        return if @camera_keys.length < 2\r\n        @camera_keys.sort_by! { |v| v[:time] }\r\n        @index = start_index.to_i\r\n        @direction = 1\r\n        @ping_pong = loop_enabled && inverse_mode\r\n\r\n        define_singleton_method(:ease_in_out_quad) do |t|\r\n          t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t\r\n        end\r\n\r\n        define_singleton_method(:catmull_rom) do |p0, p1, p2, p3, t|\r\n          t2 = t * t\r\n          t3 = t2 * t\r\n          [\r\n            0.5 * ((2 * p1[0]) + (-p0[0] + p2[0]) * t + (2*p0[0] - 5*p1[0] + 4*p2[0] - p3[0]) * t2 + (-p0[0] + 3*p1[0] - 3*p2[0] + p3[0]) * t3),\r\n            0.5 * ((2 * p1[1]) + (-p0[1] + p2[1]) * t + (2*p0[1] - 5*p1[1] + 4*p2[1] - p3[1]) * t2 + (-p0[1] + 3*p1[1] - 3*p2[1] + p3[1]) * t3),\r\n            0.5 * ((2 * p1[2]) + (-p0[2] + p2[2]) * t + (2*p0[2] - 5*p1[2] + 4*p2[2] - p3[2]) * t2 + (-p0[2] + 3*p1[2] - 3*p2[2] + p3[2]) * t3)\r\n          ]\r\n        end\r\n\r\n        define_singleton_method(:catmull_rom_1d) do |p0, p1, p2, p3, t|\r\n          t2 = t * t\r\n          t3 = t2 * t\r\n          0.5 * ((2 * p1) + (-p0 + p2) * t + (2*p0 - 5*p1 + 4*p2 - p3) * t2 + (-p0 + 3*p1 - 3*p2 + p3) * t3)\r\n        end\r\n\r\n        define_singleton_method(:play_transition) do\r\n          current = @camera_keys[@index]\r\n          next_index = @index + @direction\r\n\r\n          if next_index >= @camera_keys.size || next_index < 0\r\n            if loop_enabled\r\n               @index = 0\r\n               UI.start_timer(0.01) { play_transition }\r\n               return\r\n            else\r\n              @dialog.execute_script(\"pauseAtIndex(0)\")\r\n              return\r\n            end\r\n          end\r\n\r\n          next_cam = @camera_keys[next_index]\r\n          duration = (next_cam[:time] - current[:time]).abs\r\n          t_start = Time.now\r\n\r\n          p0 = @camera_keys[[@index - 1, 0].max]\r\n          p1 = current\r\n          p2 = next_cam\r\n          p3 = @camera_keys[[@index + 2, @camera_keys.size - 1].min]\r\n\r\n          @walk_shake = {\r\n            z_phase: rand * Math::PI * 2, x_phase: rand * Math::PI * 2,\r\n            z_amp: 0.8 + rand * 0.4, x_amp: 0.3 + rand * 0.4\r\n          }\r\n          playhead_counter = 0\r\n\r\n          @timer_id = UI.start_timer(0.03, true) do\r\n            t_elapsed = Time.now - t_start\r\n            t = duration.zero? ? 1.0 : [t_elapsed / duration, 1.0].min\r\n            t = use_easing ? ease_in_out_quad(t) : t\r\n\r\n            # Atualizar playhead na timeline (~a cada 0.09s)\r\n            playhead_counter += 1\r\n            if playhead_counter % 3 == 0\r\n              interpolated_time = current[:time] + t * (next_cam[:time] - current[:time])\r\n              @dialog.execute_script(\"updatePlayhead(#{interpolated_time.round(1)})\")\r\n            end\r\n\r\n            eye    = catmull_rom(p0[:eye],    p1[:eye],    p2[:eye],    p3[:eye],    t)\r\n            target = catmull_rom(p0[:target], p1[:target], p2[:target], p3[:target], t)\r\n            up     = catmull_rom(p0[:up],     p1[:up],     p2[:up],     p3[:up],     t)\r\n\r\n            # Interpolação Catmull-Rom para o FOV: suavidade total acompanhando a curva da câmera\r\n            fov = catmull_rom_1d(p0[:fov], p1[:fov], p2[:fov], p3[:fov], t)\r\n\r\n            if current[:walk]\r\n              eye[2] += Math.sin(t * Math::PI * 6 + @walk_shake[:z_phase]) * @walk_shake[:z_amp]\r\n              eye[0] += Math.sin(t * Math::PI * 3 + @walk_shake[:x_phase]) * @walk_shake[:x_amp]\r\n            end\r\n\r\n            cam = Sketchup::Camera.new(eye, target, up, current[:perspective])\r\n            cam.fov = fov\r\n            view.camera = cam\r\n            view.refresh\r\n\r\n            if t >= 1.0\r\n              UI.stop_timer(@timer_id)\r\n              @index = next_index\r\n              if @camera_keys[@index][:anchor] && @index > 0\r\n                @dialog.execute_script(\"pauseAtIndex(#{@index})\")\r\n              else\r\n                play_transition\r\n              end\r\n            end\r\n          end\r\n        end\r\n\r\n        play_transition\r\n      end\r\n\r\n      # Callback de exportação com presets de resolução\r\n      @dialog.add_action_callback(\"start_export_process\") do |_, json_data, use_easing, start_index, width, height, filename|\r\n        iniciar_processo_exportacao(json_data, use_easing, start_index, width.to_i, height.to_i, filename.to_s)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"start_export_project\") do |_, all_timelines_json, use_easing, active_tl_index, start_vision_index, width, height, filename|\r\n        iniciar_processo_exportacao_projeto(all_timelines_json, use_easing, active_tl_index.to_i, start_vision_index.to_i, width.to_i, height.to_i, filename.to_s)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"install_ffmpeg\") do |_|\r\n        eval(FFMPEG_INSTALL_SCRIPT, TOPLEVEL_BINDING)\r\n        UI.messagebox(obter_texto(:ffmpeg_instalado))\r\n      end\r\n\r\n      @dialog.add_action_callback(\"stop_tour\") do |_|\r\n        UI.stop_timer(@timer_id) if @timer_id\r\n        @dialog.execute_script(\"resetPlayButton()\")\r\n      end\r\n\r\n      @dialog.add_action_callback(\"show_export_preview\") do |_, width, height|\r\n        @preview_tool = ExportPreviewTool.new(width.to_i, height.to_i)\r\n        Sketchup.active_model.select_tool(@preview_tool)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"hide_export_preview\") do |_|\r\n        Sketchup.active_model.select_tool(nil)\r\n        @preview_tool = nil\r\n      end\r\n\r\n      @dialog.set_on_closed {\r\n        UI.stop_timer(@timer_id) if defined?(@timer_id) && @timer_id\r\n        stop_space_timer\r\n        if @preview_tool\r\n          Sketchup.active_model.select_tool(nil)\r\n          @preview_tool = nil\r\n        end\r\n      }\r\n\r\n      @dialog.show\r\n    end\r\n  end\r\nend\r\n\r\ndef self.executar\r\n  TourPlugin::CameraTimeline.start_ui\r\nend\r\n\r\nend # module TourVirtual\r\nend # module ScriptUpComunidade\r\n\r\nScriptUpComunidade::TourVirtual.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "exportar-imagem-da-viewport-96k7o",
    "title": {
      "pt": "Exportar Imagem da Viewport",
      "en": "Export Viewport Image",
      "es": "Exportar imagen de la ventana gráfica"
    },
    "author": "Fábio Coutinho",
    "version": "1.0",
    "description": {
      "pt": "Permite exportar imagens da viewport usando resoluções predefinidas ou personalizada e com controle de campo de visão (FOV).",
      "en": "Allows you to export images from the viewport using predefined or custom resolutions and with field of view (FOV) control.",
      "es": "Le permite exportar imágenes desde la ventana gráfica utilizando resoluciones predefinidas o personalizadas y con control del campo de visión (FOV)."
    },
    "keywords": {
      "pt": [
        "print",
        "viewport"
      ],
      "en": [
        "print",
        "viewport"
      ],
      "es": [
        "imprimir",
        "ventana gráfica"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module ExportViewport\r\n    # ─────────────────────────────────────────────────────────────\r\n    #  Export Viewport – Screenshot with aspect ratio preview\r\n    #  Multi-language support: PT-BR, EN-US, ES\r\n    # ─────────────────────────────────────────────────────────────\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        # ── Dialog / Header ──\r\n        :titulo_dialogo              => \"Exportar Viewport\",\r\n        :titulo_header               => \"📷 Exportar Viewport\",\r\n        :subtitulo_header            => \"Configure as dimensões e opções da imagem\",\r\n\r\n        # ── Dimensions ──\r\n        :largura                     => \"Largura (px)\",\r\n        :altura                      => \"Altura (px)\",\r\n        :manter_proporcao            => \"Manter proporção\",\r\n\r\n        # ── Presets ──\r\n        :predefinicoes               => \"Predefinições\",\r\n        :cat_telas                   => \"Telas\",\r\n        :cat_impressao               => \"Impressão\",\r\n        :preset_quadrado             => \"Quadrado\",\r\n        :preset_retrato              => \"Retrato\",\r\n        :preset_paisagem             => \"Paisagem\",\r\n        :preset_story_reels          => \"Story / Reels\",\r\n        :preset_publicacao           => \"Publicação\",\r\n        :preset_capa                 => \"Capa\",\r\n        :preset_story                => \"Story\",\r\n        :preset_video                => \"Vídeo\",\r\n        :preset_pin                  => \"Pin\",\r\n\r\n        # ── FOV ──\r\n        :campo_visao                 => \"Campo de visão (FOV)\",\r\n        :ajuste_fov                  => \"Ajuste o ângulo da câmera perspectiva\",\r\n        :restaurar_fov               => \"Restaurar FOV original\",\r\n        :fov_disponivel_perspectiva  => \"Disponível apenas em projeção perspectiva\",\r\n        :mudar_perspectiva           => \"Mude para projeção perspectiva para ajustar o FOV.\",\r\n\r\n        # ── Options ──\r\n        :anti_aliasing               => \"Anti-aliasing\",\r\n        :suavizacao                  => \"Suavização de bordas (mais lento)\",\r\n        :preview_viewport            => \"Preview na viewport\",\r\n        :mostrar_tarjas              => \"Mostrar tarjas de proporção\",\r\n\r\n        # ── Info bar ──\r\n        :proporcao                   => \"Proporção:\",\r\n        :megapixels                  => \"Megapixels:\",\r\n\r\n        # ── Buttons ──\r\n        :fechar                      => \"Fechar\",\r\n        :exportar_png                => \"Exportar PNG\",\r\n\r\n        # ── Export ──\r\n        :salvar_imagem               => \"Salvar imagem da viewport\",\r\n        :exportar_sucesso            => \"Imagem exportada com sucesso!\",\r\n        :erro_exportar               => \"Erro ao exportar:\"\r\n      },\r\n\r\n      'en-US' => {\r\n        # ── Dialog / Header ──\r\n        :titulo_dialogo              => \"Export Viewport\",\r\n        :titulo_header               => \"📷 Export Viewport\",\r\n        :subtitulo_header            => \"Configure image dimensions and options\",\r\n\r\n        # ── Dimensions ──\r\n        :largura                     => \"Width (px)\",\r\n        :altura                      => \"Height (px)\",\r\n        :manter_proporcao            => \"Keep aspect ratio\",\r\n\r\n        # ── Presets ──\r\n        :predefinicoes               => \"Presets\",\r\n        :cat_telas                   => \"Screens\",\r\n        :cat_impressao               => \"Print\",\r\n        :preset_quadrado             => \"Square\",\r\n        :preset_retrato              => \"Portrait\",\r\n        :preset_paisagem             => \"Landscape\",\r\n        :preset_story_reels          => \"Story / Reels\",\r\n        :preset_publicacao           => \"Post\",\r\n        :preset_capa                 => \"Cover\",\r\n        :preset_story                => \"Story\",\r\n        :preset_video                => \"Video\",\r\n        :preset_pin                  => \"Pin\",\r\n\r\n        # ── FOV ──\r\n        :campo_visao                 => \"Field of view (FOV)\",\r\n        :ajuste_fov                  => \"Adjust the perspective camera angle\",\r\n        :restaurar_fov               => \"Reset original FOV\",\r\n        :fov_disponivel_perspectiva  => \"Available only in perspective projection\",\r\n        :mudar_perspectiva           => \"Switch to perspective projection to adjust FOV.\",\r\n\r\n        # ── Options ──\r\n        :anti_aliasing               => \"Anti-aliasing\",\r\n        :suavizacao                  => \"Edge smoothing (slower)\",\r\n        :preview_viewport            => \"Viewport preview\",\r\n        :mostrar_tarjas              => \"Show aspect ratio bars\",\r\n\r\n        # ── Info bar ──\r\n        :proporcao                   => \"Aspect ratio:\",\r\n        :megapixels                  => \"Megapixels:\",\r\n\r\n        # ── Buttons ──\r\n        :fechar                      => \"Close\",\r\n        :exportar_png                => \"Export PNG\",\r\n\r\n        # ── Export ──\r\n        :salvar_imagem               => \"Save viewport image\",\r\n        :exportar_sucesso            => \"Image exported successfully!\",\r\n        :erro_exportar               => \"Export error:\"\r\n      },\r\n\r\n      'es' => {\r\n        # ── Dialog / Header ──\r\n        :titulo_dialogo              => \"Exportar Viewport\",\r\n        :titulo_header               => \"📷 Exportar Viewport\",\r\n        :subtitulo_header            => \"Configure las dimensiones y opciones de la imagen\",\r\n\r\n        # ── Dimensions ──\r\n        :largura                     => \"Ancho (px)\",\r\n        :altura                      => \"Alto (px)\",\r\n        :manter_proporcao            => \"Mantener proporción\",\r\n\r\n        # ── Presets ──\r\n        :predefinicoes               => \"Predefiniciones\",\r\n        :cat_telas                   => \"Pantallas\",\r\n        :cat_impressao               => \"Impresión\",\r\n        :preset_quadrado             => \"Cuadrado\",\r\n        :preset_retrato              => \"Retrato\",\r\n        :preset_paisagem             => \"Paisaje\",\r\n        :preset_story_reels          => \"Story / Reels\",\r\n        :preset_publicacao           => \"Publicación\",\r\n        :preset_capa                 => \"Portada\",\r\n        :preset_story                => \"Story\",\r\n        :preset_video                => \"Vídeo\",\r\n        :preset_pin                  => \"Pin\",\r\n\r\n        # ── FOV ──\r\n        :campo_visao                 => \"Campo de visión (FOV)\",\r\n        :ajuste_fov                  => \"Ajuste el ángulo de la cámara perspectiva\",\r\n        :restaurar_fov               => \"Restaurar FOV original\",\r\n        :fov_disponivel_perspectiva  => \"Disponible solo en proyección perspectiva\",\r\n        :mudar_perspectiva           => \"Cambie a proyección perspectiva para ajustar el FOV.\",\r\n\r\n        # ── Options ──\r\n        :anti_aliasing               => \"Anti-aliasing\",\r\n        :suavizacao                  => \"Suavizado de bordes (más lento)\",\r\n        :preview_viewport            => \"Vista previa en viewport\",\r\n        :mostrar_tarjas              => \"Mostrar barras de proporción\",\r\n\r\n        # ── Info bar ──\r\n        :proporcao                   => \"Proporción:\",\r\n        :megapixels                  => \"Megapíxeles:\",\r\n\r\n        # ── Buttons ──\r\n        :fechar                      => \"Cerrar\",\r\n        :exportar_png                => \"Exportar PNG\",\r\n\r\n        # ── Export ──\r\n        :salvar_imagem               => \"Guardar imagen del viewport\",\r\n        :exportar_sucesso            => \"¡Imagen exportada con éxito!\",\r\n        :erro_exportar               => \"Error al exportar:\"\r\n      }\r\n    }.freeze\r\n\r\n    # ─── Tradução ──────────────────────────────────────────────\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    # ─────────────────────────────────────────────────────────────\r\n\r\n    OVERLAY_ID = \"export_viewport_overlay\".freeze\r\n\r\n    def self.cleanup_overlay\r\n      model = Sketchup.active_model\r\n      return unless model\r\n\r\n      if @ro_observer\r\n        begin\r\n          model.rendering_options.remove_observer(@ro_observer)\r\n        rescue\r\n        end\r\n        @ro_observer = nil\r\n      end\r\n\r\n      view = model.active_view\r\n      if defined?(Sketchup::Overlay) && view.respond_to?(:overlays)\r\n        view.overlays.each do |ol|\r\n          if ol.id == OVERLAY_ID\r\n            ol.enabled = false\r\n            break\r\n          end\r\n        end\r\n      end\r\n\r\n      @current_ratio = nil\r\n      view.invalidate\r\n    end\r\n\r\n    # ─── Letterbox Tool ────────────────────────────────────────\r\n\r\n    class LetterboxTool\r\n      def initialize(ratio)\r\n        @ratio = ratio\r\n        @active = true\r\n        @visible = true\r\n      end\r\n\r\n      def visible=(v)\r\n        @visible = v\r\n        Sketchup.active_model.active_view.invalidate\r\n      end\r\n\r\n      def ratio=(r)\r\n        @ratio = r\r\n        Sketchup.active_model.active_view.invalidate\r\n      end\r\n\r\n      def deactivate(view)\r\n        @active = false\r\n        view.invalidate\r\n      end\r\n\r\n      def active?\r\n        @active\r\n      end\r\n\r\n      def suspend(view)\r\n        view.invalidate\r\n      end\r\n\r\n      def resume(view)\r\n        view.invalidate\r\n      end\r\n\r\n      def onCancel(reason, view)\r\n        ScriptUpComunidade::ExportViewport.remove_letterbox\r\n        view.invalidate\r\n      end\r\n\r\n      def draw(view)\r\n        return unless @active && @visible && @ratio && @ratio > 0\r\n\r\n        vw = view.vpwidth.to_f\r\n        vh = view.vpheight.to_f\r\n        return if vw <= 0 || vh <= 0\r\n\r\n        viewport_ratio = vw / vh\r\n        target_ratio = @ratio\r\n\r\n        overlay_color = Sketchup::Color.new(0, 0, 0, 140)\r\n\r\n        if target_ratio > viewport_ratio\r\n          visible_h = vw / target_ratio\r\n          bar_h = (vh - visible_h) / 2.0\r\n\r\n          if bar_h > 1\r\n            pts_top = [\r\n              Geom::Point3d.new(0, 0, 0),\r\n              Geom::Point3d.new(vw, 0, 0),\r\n              Geom::Point3d.new(vw, bar_h, 0),\r\n              Geom::Point3d.new(0, bar_h, 0)\r\n            ]\r\n            view.drawing_color = overlay_color\r\n            view.draw2d(GL_QUADS, pts_top)\r\n\r\n            pts_bot = [\r\n              Geom::Point3d.new(0, vh - bar_h, 0),\r\n              Geom::Point3d.new(vw, vh - bar_h, 0),\r\n              Geom::Point3d.new(vw, vh, 0),\r\n              Geom::Point3d.new(0, vh, 0)\r\n            ]\r\n            view.drawing_color = overlay_color\r\n            view.draw2d(GL_QUADS, pts_bot)\r\n\r\n            border_color = Sketchup::Color.new(255, 255, 255, 80)\r\n            view.line_stipple = \"\"\r\n            view.line_width = 1\r\n            view.drawing_color = border_color\r\n            view.draw2d(GL_LINES, [\r\n              Geom::Point3d.new(0, bar_h, 0),\r\n              Geom::Point3d.new(vw, bar_h, 0),\r\n              Geom::Point3d.new(0, vh - bar_h, 0),\r\n              Geom::Point3d.new(vw, vh - bar_h, 0)\r\n            ])\r\n          end\r\n        else\r\n          visible_w = vh * target_ratio\r\n          bar_w = (vw - visible_w) / 2.0\r\n\r\n          if bar_w > 1\r\n            pts_left = [\r\n              Geom::Point3d.new(0, 0, 0),\r\n              Geom::Point3d.new(bar_w, 0, 0),\r\n              Geom::Point3d.new(bar_w, vh, 0),\r\n              Geom::Point3d.new(0, vh, 0)\r\n            ]\r\n            view.drawing_color = overlay_color\r\n            view.draw2d(GL_QUADS, pts_left)\r\n\r\n            pts_right = [\r\n              Geom::Point3d.new(vw - bar_w, 0, 0),\r\n              Geom::Point3d.new(vw, 0, 0),\r\n              Geom::Point3d.new(vw, vh, 0),\r\n              Geom::Point3d.new(vw - bar_w, vh, 0)\r\n            ]\r\n            view.drawing_color = overlay_color\r\n            view.draw2d(GL_QUADS, pts_right)\r\n\r\n            border_color = Sketchup::Color.new(255, 255, 255, 80)\r\n            view.line_stipple = \"\"\r\n            view.line_width = 1\r\n            view.drawing_color = border_color\r\n            view.draw2d(GL_LINES, [\r\n              Geom::Point3d.new(bar_w, 0, 0),\r\n              Geom::Point3d.new(bar_w, vh, 0),\r\n              Geom::Point3d.new(vw - bar_w, 0, 0),\r\n              Geom::Point3d.new(vw - bar_w, vh, 0)\r\n            ])\r\n          end\r\n        end\r\n      end\r\n    end\r\n\r\n    @letterbox_tool = nil\r\n    @original_fov = nil\r\n\r\n    def self.set_letterbox(width, height)\r\n      return if width <= 0 || height <= 0\r\n\r\n      ratio = width.to_f / height.to_f\r\n      model = Sketchup.active_model\r\n\r\n      if @letterbox_tool && @letterbox_tool.active?\r\n        @letterbox_tool.ratio = ratio\r\n        @letterbox_tool.visible = true\r\n      else\r\n        @letterbox_tool = LetterboxTool.new(ratio)\r\n        model.select_tool(@letterbox_tool)\r\n      end\r\n    end\r\n\r\n    def self.hide_letterbox\r\n      if @letterbox_tool && @letterbox_tool.active?\r\n        @letterbox_tool.visible = false\r\n      end\r\n    end\r\n\r\n    def self.remove_letterbox\r\n      if @letterbox_tool\r\n        @letterbox_tool = nil\r\n        Sketchup.active_model.select_tool(nil)\r\n      end\r\n    end\r\n\r\n    # ─── FOV Control ───────────────────────────────────────────\r\n    def self.save_original_fov\r\n      camera = Sketchup.active_model.active_view.camera\r\n      @original_fov = camera.perspective? ? camera.fov : nil\r\n    end\r\n\r\n    def self.restore_original_fov\r\n      return unless @original_fov\r\n      camera = Sketchup.active_model.active_view.camera\r\n      camera.fov = @original_fov if camera.perspective?\r\n      @original_fov = nil\r\n    end\r\n\r\n    def self.set_camera_fov(degrees)\r\n      camera = Sketchup.active_model.active_view.camera\r\n      return unless camera.perspective?\r\n      degrees = [[degrees.to_f, 1.0].max, 120.0].min\r\n      camera.fov = degrees\r\n    end\r\n\r\n    def self.current_fov\r\n      camera = Sketchup.active_model.active_view.camera\r\n      camera.perspective? ? camera.fov : nil\r\n    end\r\n\r\n    # ─── Export image ──────────────────────────────────────────\r\n    def self.export_image(width, height, antialias)\r\n      model = Sketchup.active_model\r\n      view = model.active_view\r\n\r\n      path = UI.savepanel(\r\n        obter_texto(:salvar_imagem),\r\n        \"\",\r\n        \"viewport_export.png\"\r\n      )\r\n      return unless path\r\n\r\n      path += \".png\" unless path.downcase.end_with?(\".png\", \".jpg\", \".jpeg\", \".tif\", \".tiff\", \".bmp\")\r\n\r\n      had_letterbox = @letterbox_tool && @letterbox_tool.active?\r\n      @letterbox_tool.visible = false if had_letterbox\r\n\r\n      keys = {\r\n        :filename    => path,\r\n        :width       => width.to_i,\r\n        :height      => height.to_i,\r\n        :antialias   => antialias,\r\n        :compression => 0.9,\r\n        :transparent => false\r\n      }\r\n\r\n      begin\r\n        view.write_image(keys)\r\n        UI.messagebox(\"#{obter_texto(:exportar_sucesso)}\\n\\n#{path}\")\r\n      rescue => e\r\n        UI.messagebox(\"#{obter_texto(:erro_exportar)} #{e.message}\")\r\n      ensure\r\n        if had_letterbox && @letterbox_tool\r\n          @letterbox_tool.visible = true\r\n        end\r\n      end\r\n    end\r\n\r\n    # ─── Dialog HTML ───────────────────────────────────────────\r\n    def self.html_content\r\n      <<~HTML\r\n        <!DOCTYPE html>\r\n        <html>\r\n        <head>\r\n          <meta charset=\"UTF-8\">\r\n          <style>\r\n            @import url('https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600&display=swap');\r\n\r\n            * {\r\n              margin: 0;\r\n              padding: 0;\r\n              box-sizing: border-box;\r\n            }\r\n\r\n            body {\r\n              font-family: 'DM Sans', 'Segoe UI', sans-serif;\r\n              background: #1a1a2e;\r\n              color: #e0e0e0;\r\n              padding: 0;\r\n              overflow: hidden;\r\n              height: 100vh;\r\n              display: flex;\r\n              flex-direction: column;\r\n            }\r\n\r\n            /* ── Header ── */\r\n            .header {\r\n              background: linear-gradient(135deg, #16213e 0%, #1a1a2e 100%);\r\n              padding: 18px 24px 14px;\r\n              border-bottom: 1px solid rgba(255,255,255,0.06);\r\n            }\r\n\r\n            .header h1 {\r\n              font-size: 15px;\r\n              font-weight: 600;\r\n              color: #f0f0f0;\r\n              letter-spacing: 0.3px;\r\n            }\r\n\r\n            .header p {\r\n              font-size: 11px;\r\n              color: #888;\r\n              margin-top: 3px;\r\n            }\r\n\r\n            /* ── Content ── */\r\n            .content {\r\n              flex: 1;\r\n              padding: 20px 24px;\r\n              display: flex;\r\n              flex-direction: column;\r\n              gap: 18px;\r\n              overflow-y: auto;\r\n              min-height: 0;\r\n            }\r\n\r\n            .content::-webkit-scrollbar {\r\n              width: 6px;\r\n            }\r\n\r\n            .content::-webkit-scrollbar-track {\r\n              background: transparent;\r\n            }\r\n\r\n            .content::-webkit-scrollbar-thumb {\r\n              background: rgba(255,255,255,0.1);\r\n              border-radius: 3px;\r\n            }\r\n\r\n            /* ── Dimension Inputs ── */\r\n            .dimensions-row {\r\n              display: flex;\r\n              gap: 12px;\r\n              align-items: flex-end;\r\n            }\r\n\r\n            .input-group {\r\n              flex: 1;\r\n              display: flex;\r\n              flex-direction: column;\r\n              gap: 5px;\r\n            }\r\n\r\n            .input-group label {\r\n              font-size: 11px;\r\n              font-weight: 500;\r\n              color: #aaa;\r\n              text-transform: uppercase;\r\n              letter-spacing: 0.8px;\r\n            }\r\n\r\n            .input-group input {\r\n              width: 100%;\r\n              padding: 10px 12px;\r\n              background: rgba(255,255,255,0.05);\r\n              border: 1px solid rgba(255,255,255,0.1);\r\n              border-radius: 8px;\r\n              color: #fff;\r\n              font-size: 14px;\r\n              font-family: 'DM Sans', sans-serif;\r\n              font-weight: 500;\r\n              text-align: center;\r\n              transition: all 0.2s ease;\r\n              outline: none;\r\n            }\r\n\r\n            .input-group input:focus {\r\n              border-color: #4a9eff;\r\n              background: rgba(74, 158, 255, 0.06);\r\n              box-shadow: 0 0 0 3px rgba(74, 158, 255, 0.1);\r\n            }\r\n\r\n            .link-btn {\r\n              width: 36px;\r\n              height: 42px;\r\n              display: flex;\r\n              align-items: center;\r\n              justify-content: center;\r\n              background: rgba(255,255,255,0.05);\r\n              border: 1px solid rgba(255,255,255,0.1);\r\n              border-radius: 8px;\r\n              cursor: pointer;\r\n              transition: all 0.2s ease;\r\n              flex-shrink: 0;\r\n              color: #666;\r\n            }\r\n\r\n            .link-btn:hover {\r\n              background: rgba(255,255,255,0.08);\r\n            }\r\n\r\n            .link-btn.active {\r\n              background: rgba(74, 158, 255, 0.15);\r\n              border-color: rgba(74, 158, 255, 0.3);\r\n              color: #4a9eff;\r\n            }\r\n\r\n            .link-btn svg {\r\n              width: 16px;\r\n              height: 16px;\r\n            }\r\n\r\n            .unit-hint {\r\n              font-size: 10px;\r\n              color: #666;\r\n              text-align: center;\r\n              margin-top: -2px;\r\n            }\r\n\r\n            /* ── Presets ── */\r\n            .presets-section {\r\n              display: flex;\r\n              flex-direction: column;\r\n              gap: 6px;\r\n            }\r\n\r\n            .presets-label {\r\n              font-size: 11px;\r\n              font-weight: 500;\r\n              color: #aaa;\r\n              text-transform: uppercase;\r\n              letter-spacing: 0.8px;\r\n            }\r\n\r\n            .presets-list {\r\n              max-height: 240px;\r\n              overflow-y: auto;\r\n              border: 1px solid rgba(255,255,255,0.06);\r\n              border-radius: 8px;\r\n              background: rgba(0,0,0,0.15);\r\n            }\r\n\r\n            .presets-list::-webkit-scrollbar {\r\n              width: 6px;\r\n            }\r\n\r\n            .presets-list::-webkit-scrollbar-track {\r\n              background: transparent;\r\n            }\r\n\r\n            .presets-list::-webkit-scrollbar-thumb {\r\n              background: rgba(255,255,255,0.15);\r\n              border-radius: 3px;\r\n            }\r\n\r\n            .preset-category {\r\n              padding: 6px 12px 4px;\r\n              font-size: 10px;\r\n              font-weight: 600;\r\n              color: #666;\r\n              text-transform: uppercase;\r\n              letter-spacing: 0.8px;\r\n              position: sticky;\r\n              top: 0;\r\n              background: rgba(18, 18, 34, 0.97);\r\n              z-index: 1;\r\n            }\r\n\r\n            .preset-item {\r\n              display: flex;\r\n              justify-content: space-between;\r\n              align-items: center;\r\n              padding: 7px 12px;\r\n              cursor: pointer;\r\n              transition: all 0.15s ease;\r\n              font-size: 12px;\r\n              border-left: 2px solid transparent;\r\n            }\r\n\r\n            .preset-item:hover {\r\n              background: rgba(74, 158, 255, 0.08);\r\n            }\r\n\r\n            .preset-item.active {\r\n              background: rgba(74, 158, 255, 0.12);\r\n              border-left-color: #4a9eff;\r\n            }\r\n\r\n            .preset-name {\r\n              color: #ccc;\r\n            }\r\n\r\n            .preset-item.active .preset-name {\r\n              color: #4a9eff;\r\n            }\r\n\r\n            .preset-dims {\r\n              color: #666;\r\n              font-size: 11px;\r\n              font-variant-numeric: tabular-nums;\r\n            }\r\n\r\n            .preset-item.active .preset-dims {\r\n              color: rgba(74, 158, 255, 0.7);\r\n            }\r\n\r\n            /* ── Options ── */\r\n            .options-section {\r\n              display: flex;\r\n              flex-direction: column;\r\n              gap: 10px;\r\n            }\r\n\r\n            .option-row {\r\n              display: flex;\r\n              align-items: center;\r\n              justify-content: space-between;\r\n              padding: 8px 0;\r\n            }\r\n\r\n            .option-label {\r\n              font-size: 13px;\r\n              color: #ccc;\r\n            }\r\n\r\n            .option-label small {\r\n              display: block;\r\n              font-size: 10px;\r\n              color: #777;\r\n              margin-top: 1px;\r\n            }\r\n\r\n            /* Toggle switch */\r\n            .toggle {\r\n              position: relative;\r\n              width: 40px;\r\n              height: 22px;\r\n              cursor: pointer;\r\n            }\r\n\r\n            .toggle input {\r\n              opacity: 0;\r\n              width: 0;\r\n              height: 0;\r\n            }\r\n\r\n            .toggle-track {\r\n              position: absolute;\r\n              top: 0; left: 0; right: 0; bottom: 0;\r\n              background: rgba(255,255,255,0.1);\r\n              border-radius: 11px;\r\n              transition: background 0.2s;\r\n            }\r\n\r\n            .toggle input:checked + .toggle-track {\r\n              background: #4a9eff;\r\n            }\r\n\r\n            .toggle-thumb {\r\n              position: absolute;\r\n              top: 2px;\r\n              left: 2px;\r\n              width: 18px;\r\n              height: 18px;\r\n              background: #fff;\r\n              border-radius: 50%;\r\n              transition: transform 0.2s;\r\n              pointer-events: none;\r\n            }\r\n\r\n            .toggle input:checked ~ .toggle-thumb {\r\n              transform: translateX(18px);\r\n            }\r\n\r\n            /* ── Info bar ── */\r\n            .info-bar {\r\n              background: rgba(255,255,255,0.03);\r\n              border-radius: 8px;\r\n              padding: 10px 14px;\r\n              display: flex;\r\n              justify-content: space-between;\r\n              font-size: 11px;\r\n              color: #777;\r\n            }\r\n\r\n            .info-bar span strong {\r\n              color: #bbb;\r\n              font-weight: 500;\r\n            }\r\n\r\n            /* ── Footer ── */\r\n            .footer {\r\n              padding: 16px 24px;\r\n              border-top: 1px solid rgba(255,255,255,0.06);\r\n              display: flex;\r\n              gap: 10px;\r\n              justify-content: flex-end;\r\n              background: rgba(0,0,0,0.15);\r\n            }\r\n\r\n            .btn {\r\n              padding: 10px 22px;\r\n              border-radius: 8px;\r\n              font-size: 13px;\r\n              font-family: 'DM Sans', sans-serif;\r\n              font-weight: 500;\r\n              cursor: pointer;\r\n              border: none;\r\n              transition: all 0.2s ease;\r\n              letter-spacing: 0.2px;\r\n            }\r\n\r\n            .btn-close {\r\n              background: rgba(255,255,255,0.06);\r\n              color: #aaa;\r\n            }\r\n\r\n            .btn-close:hover {\r\n              background: rgba(255,255,255,0.1);\r\n              color: #ccc;\r\n            }\r\n\r\n            .btn-export {\r\n              background: linear-gradient(135deg, #4a9eff, #3b7dd8);\r\n              color: #fff;\r\n              box-shadow: 0 2px 12px rgba(74, 158, 255, 0.25);\r\n            }\r\n\r\n            .btn-export:hover {\r\n              background: linear-gradient(135deg, #5aa8ff, #4a8ee8);\r\n              box-shadow: 0 4px 16px rgba(74, 158, 255, 0.35);\r\n              transform: translateY(-1px);\r\n            }\r\n\r\n            .btn-export:active {\r\n              transform: translateY(0);\r\n            }\r\n\r\n            /* ── Divider ── */\r\n            .divider {\r\n              height: 1px;\r\n              background: rgba(255,255,255,0.06);\r\n            }\r\n\r\n            /* ── FOV Slider ── */\r\n            .fov-section {\r\n              display: flex;\r\n              flex-direction: column;\r\n              gap: 8px;\r\n            }\r\n\r\n            .fov-header {\r\n              display: flex;\r\n              align-items: center;\r\n              justify-content: space-between;\r\n            }\r\n\r\n            .fov-label {\r\n              font-size: 13px;\r\n              color: #ccc;\r\n            }\r\n\r\n            .fov-label small {\r\n              display: block;\r\n              font-size: 10px;\r\n              color: #777;\r\n              margin-top: 1px;\r\n            }\r\n\r\n            .fov-controls {\r\n              display: flex;\r\n              align-items: center;\r\n              gap: 8px;\r\n            }\r\n\r\n            .fov-value {\r\n              font-size: 13px;\r\n              font-weight: 500;\r\n              color: #4a9eff;\r\n              min-width: 38px;\r\n              text-align: right;\r\n              font-variant-numeric: tabular-nums;\r\n            }\r\n\r\n            .fov-reset-btn {\r\n              width: 28px;\r\n              height: 28px;\r\n              display: flex;\r\n              align-items: center;\r\n              justify-content: center;\r\n              background: rgba(255,255,255,0.05);\r\n              border: 1px solid rgba(255,255,255,0.1);\r\n              border-radius: 6px;\r\n              cursor: pointer;\r\n              transition: all 0.2s ease;\r\n              color: #666;\r\n              flex-shrink: 0;\r\n            }\r\n\r\n            .fov-reset-btn:hover {\r\n              background: rgba(255,255,255,0.08);\r\n              color: #aaa;\r\n            }\r\n\r\n            .fov-slider-row {\r\n              display: flex;\r\n              align-items: center;\r\n              gap: 10px;\r\n            }\r\n\r\n            .fov-slider-row input[type=\"range\"] {\r\n              flex: 1;\r\n              -webkit-appearance: none;\r\n              appearance: none;\r\n              height: 4px;\r\n              background: rgba(255,255,255,0.1);\r\n              border-radius: 2px;\r\n              outline: none;\r\n              cursor: pointer;\r\n            }\r\n\r\n            .fov-slider-row input[type=\"range\"]::-webkit-slider-thumb {\r\n              -webkit-appearance: none;\r\n              appearance: none;\r\n              width: 16px;\r\n              height: 16px;\r\n              background: #4a9eff;\r\n              border-radius: 50%;\r\n              cursor: pointer;\r\n              box-shadow: 0 1px 4px rgba(74, 158, 255, 0.3);\r\n              transition: box-shadow 0.2s ease;\r\n            }\r\n\r\n            .fov-slider-row input[type=\"range\"]::-webkit-slider-thumb:hover {\r\n              box-shadow: 0 2px 8px rgba(74, 158, 255, 0.5);\r\n            }\r\n\r\n            .fov-slider-labels {\r\n              display: flex;\r\n              justify-content: space-between;\r\n              font-size: 9px;\r\n              color: #555;\r\n              margin-top: -4px;\r\n            }\r\n\r\n            .fov-disabled-msg {\r\n              font-size: 11px;\r\n              color: #666;\r\n              font-style: italic;\r\n              padding: 8px 0;\r\n            }\r\n          </style>\r\n        </head>\r\n        <body>\r\n\r\n          <div class=\"header\">\r\n            <h1>#{obter_texto(:titulo_header)}</h1>\r\n            <p>#{obter_texto(:subtitulo_header)}</p>\r\n          </div>\r\n\r\n          <div class=\"content\">\r\n\r\n            <!-- Dimensions -->\r\n            <div class=\"dimensions-row\">\r\n              <div class=\"input-group\">\r\n                <label>#{obter_texto(:largura)}</label>\r\n                <input type=\"number\" id=\"inputW\" value=\"1920\" min=\"100\" max=\"10000\" step=\"1\">\r\n              </div>\r\n\r\n              <div class=\"link-btn active\" id=\"linkBtn\" title=\"#{obter_texto(:manter_proporcao)}\">\r\n                <svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\">\r\n                  <path d=\"M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71\"/>\r\n                  <path d=\"M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71\"/>\r\n                </svg>\r\n              </div>\r\n\r\n              <div class=\"input-group\">\r\n                <label>#{obter_texto(:altura)}</label>\r\n                <input type=\"number\" id=\"inputH\" value=\"1080\" min=\"100\" max=\"10000\" step=\"1\">\r\n              </div>\r\n            </div>\r\n\r\n            <!-- Presets -->\r\n            <div class=\"presets-section\">\r\n              <div class=\"presets-label\">#{obter_texto(:predefinicoes)}</div>\r\n              <div class=\"presets-list\">\r\n                <div class=\"preset-category\">#{obter_texto(:cat_telas)}</div>\r\n                <div class=\"preset-item active\" data-w=\"1920\" data-h=\"1080\">\r\n                  <span class=\"preset-name\">Full HD</span>\r\n                  <span class=\"preset-dims\">1920 × 1080</span>\r\n                </div>\r\n                <div class=\"preset-item\" data-w=\"2560\" data-h=\"1440\">\r\n                  <span class=\"preset-name\">2K QHD</span>\r\n                  <span class=\"preset-dims\">2560 × 1440</span>\r\n                </div>\r\n                <div class=\"preset-item\" data-w=\"3840\" data-h=\"2160\">\r\n                  <span class=\"preset-name\">4K UHD</span>\r\n                  <span class=\"preset-dims\">3840 × 2160</span>\r\n                </div>\r\n\r\n                <div class=\"preset-category\">Instagram</div>\r\n                <div class=\"preset-item\" data-w=\"1080\" data-h=\"1080\">\r\n                  <span class=\"preset-name\">#{obter_texto(:preset_quadrado)}</span>\r\n                  <span class=\"preset-dims\">1080 × 1080</span>\r\n                </div>\r\n                <div class=\"preset-item\" data-w=\"1080\" data-h=\"1350\">\r\n                  <span class=\"preset-name\">#{obter_texto(:preset_retrato)}</span>\r\n                  <span class=\"preset-dims\">1080 × 1350</span>\r\n                </div>\r\n                <div class=\"preset-item\" data-w=\"1080\" data-h=\"566\">\r\n                  <span class=\"preset-name\">#{obter_texto(:preset_paisagem)}</span>\r\n                  <span class=\"preset-dims\">1080 × 566</span>\r\n                </div>\r\n                <div class=\"preset-item\" data-w=\"1080\" data-h=\"1920\">\r\n                  <span class=\"preset-name\">#{obter_texto(:preset_story_reels)}</span>\r\n                  <span class=\"preset-dims\">1080 × 1920</span>\r\n                </div>\r\n\r\n                <div class=\"preset-category\">Facebook</div>\r\n                <div class=\"preset-item\" data-w=\"1200\" data-h=\"630\">\r\n                  <span class=\"preset-name\">#{obter_texto(:preset_publicacao)}</span>\r\n                  <span class=\"preset-dims\">1200 × 630</span>\r\n                </div>\r\n                <div class=\"preset-item\" data-w=\"1640\" data-h=\"924\">\r\n                  <span class=\"preset-name\">#{obter_texto(:preset_capa)}</span>\r\n                  <span class=\"preset-dims\">1640 × 924</span>\r\n                </div>\r\n                <div class=\"preset-item\" data-w=\"1080\" data-h=\"1920\">\r\n                  <span class=\"preset-name\">#{obter_texto(:preset_story)}</span>\r\n                  <span class=\"preset-dims\">1080 × 1920</span>\r\n                </div>\r\n\r\n                <div class=\"preset-category\">YouTube</div>\r\n                <div class=\"preset-item\" data-w=\"1280\" data-h=\"720\">\r\n                  <span class=\"preset-name\">Thumbnail</span>\r\n                  <span class=\"preset-dims\">1280 × 720</span>\r\n                </div>\r\n                <div class=\"preset-item\" data-w=\"2560\" data-h=\"1440\">\r\n                  <span class=\"preset-name\">Banner</span>\r\n                  <span class=\"preset-dims\">2560 × 1440</span>\r\n                </div>\r\n\r\n                <div class=\"preset-category\">X (Twitter)</div>\r\n                <div class=\"preset-item\" data-w=\"1600\" data-h=\"900\">\r\n                  <span class=\"preset-name\">#{obter_texto(:preset_publicacao)}</span>\r\n                  <span class=\"preset-dims\">1600 × 900</span>\r\n                </div>\r\n                <div class=\"preset-item\" data-w=\"1500\" data-h=\"500\">\r\n                  <span class=\"preset-name\">Header</span>\r\n                  <span class=\"preset-dims\">1500 × 500</span>\r\n                </div>\r\n\r\n                <div class=\"preset-category\">LinkedIn</div>\r\n                <div class=\"preset-item\" data-w=\"1200\" data-h=\"627\">\r\n                  <span class=\"preset-name\">#{obter_texto(:preset_publicacao)}</span>\r\n                  <span class=\"preset-dims\">1200 × 627</span>\r\n                </div>\r\n                <div class=\"preset-item\" data-w=\"1584\" data-h=\"396\">\r\n                  <span class=\"preset-name\">#{obter_texto(:preset_capa)}</span>\r\n                  <span class=\"preset-dims\">1584 × 396</span>\r\n                </div>\r\n\r\n                <div class=\"preset-category\">Pinterest</div>\r\n                <div class=\"preset-item\" data-w=\"1000\" data-h=\"1500\">\r\n                  <span class=\"preset-name\">#{obter_texto(:preset_pin)}</span>\r\n                  <span class=\"preset-dims\">1000 × 1500</span>\r\n                </div>\r\n\r\n                <div class=\"preset-category\">TikTok</div>\r\n                <div class=\"preset-item\" data-w=\"1080\" data-h=\"1920\">\r\n                  <span class=\"preset-name\">#{obter_texto(:preset_video)}</span>\r\n                  <span class=\"preset-dims\">1080 × 1920</span>\r\n                </div>\r\n\r\n                <div class=\"preset-category\">#{obter_texto(:cat_impressao)}</div>\r\n                <div class=\"preset-item\" data-w=\"3508\" data-h=\"2480\">\r\n                  <span class=\"preset-name\">A4 300dpi</span>\r\n                  <span class=\"preset-dims\">3508 × 2480</span>\r\n                </div>\r\n                <div class=\"preset-item\" data-w=\"4961\" data-h=\"3508\">\r\n                  <span class=\"preset-name\">A3 300dpi</span>\r\n                  <span class=\"preset-dims\">4961 × 3508</span>\r\n                </div>\r\n              </div>\r\n            </div>\r\n\r\n            <div class=\"divider\"></div>\r\n\r\n            <!-- FOV Control -->\r\n            <div class=\"fov-section\" id=\"fovSection\">\r\n              <div class=\"fov-header\">\r\n                <div class=\"fov-label\">\r\n                  #{obter_texto(:campo_visao)}\r\n                  <small>#{obter_texto(:ajuste_fov)}</small>\r\n                </div>\r\n                <div class=\"fov-controls\">\r\n                  <span class=\"fov-value\" id=\"fovValue\">35.0°</span>\r\n                  <div class=\"fov-reset-btn\" id=\"fovResetBtn\" title=\"#{obter_texto(:restaurar_fov)}\">\r\n                    <svg viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" width=\"14\" height=\"14\">\r\n                      <path d=\"M3 12a9 9 0 1 1 3 6.36\"/>\r\n                      <polyline points=\"3 16 3 12 7 12\"/>\r\n                    </svg>\r\n                  </div>\r\n                </div>\r\n              </div>\r\n              <div class=\"fov-slider-row\">\r\n                <input type=\"range\" id=\"fovSlider\" min=\"1\" max=\"120\" step=\"0.1\" value=\"35\">\r\n              </div>\r\n              <div class=\"fov-slider-labels\">\r\n                <span>1°</span>\r\n                <span>60°</span>\r\n                <span>120°</span>\r\n              </div>\r\n            </div>\r\n\r\n            <div class=\"divider\"></div>\r\n\r\n            <!-- Options -->\r\n            <div class=\"options-section\">\r\n              <div class=\"option-row\">\r\n                <div class=\"option-label\">\r\n                  #{obter_texto(:anti_aliasing)}\r\n                  <small>#{obter_texto(:suavizacao)}</small>\r\n                </div>\r\n                <label class=\"toggle\">\r\n                  <input type=\"checkbox\" id=\"antialiasToggle\" checked>\r\n                  <div class=\"toggle-track\"></div>\r\n                  <div class=\"toggle-thumb\"></div>\r\n                </label>\r\n              </div>\r\n\r\n              <div class=\"option-row\">\r\n                <div class=\"option-label\">\r\n                  #{obter_texto(:preview_viewport)}\r\n                  <small>#{obter_texto(:mostrar_tarjas)}</small>\r\n                </div>\r\n                <label class=\"toggle\">\r\n                  <input type=\"checkbox\" id=\"previewToggle\" checked>\r\n                  <div class=\"toggle-track\"></div>\r\n                  <div class=\"toggle-thumb\"></div>\r\n                </label>\r\n              </div>\r\n            </div>\r\n\r\n            <!-- Info -->\r\n            <div class=\"info-bar\">\r\n              <span>#{obter_texto(:proporcao)} <strong id=\"ratioText\">16:9</strong></span>\r\n              <span>#{obter_texto(:megapixels)} <strong id=\"mpText\">2.07 MP</strong></span>\r\n            </div>\r\n\r\n          </div>\r\n\r\n          <div class=\"footer\">\r\n            <button class=\"btn btn-close\" id=\"btnClose\">#{obter_texto(:fechar)}</button>\r\n            <button class=\"btn btn-export\" id=\"btnExport\">#{obter_texto(:exportar_png)}</button>\r\n          </div>\r\n\r\n          <script>\r\n            // ── i18n strings (injected from Ruby) ──\r\n            var LANG = {\r\n              campo_visao: \"#{obter_texto(:campo_visao)}\",\r\n              fov_disponivel_perspectiva: \"#{obter_texto(:fov_disponivel_perspectiva)}\",\r\n              mudar_perspectiva: \"#{obter_texto(:mudar_perspectiva)}\"\r\n            };\r\n\r\n            // ── Elements ──\r\n            var inputW = document.getElementById('inputW');\r\n            var inputH = document.getElementById('inputH');\r\n            var linkBtn = document.getElementById('linkBtn');\r\n            var previewToggle = document.getElementById('previewToggle');\r\n            var antialiasToggle = document.getElementById('antialiasToggle');\r\n            var ratioText = document.getElementById('ratioText');\r\n            var mpText = document.getElementById('mpText');\r\n            var chips = document.querySelectorAll('.preset-item');\r\n            var btnClose = document.getElementById('btnClose');\r\n            var btnExport = document.getElementById('btnExport');\r\n\r\n            var fovSection = document.getElementById('fovSection');\r\n            var fovSlider = document.getElementById('fovSlider');\r\n            var fovValue = document.getElementById('fovValue');\r\n            var fovResetBtn = document.getElementById('fovResetBtn');\r\n\r\n            var linked = true;\r\n            var baseRatio = 1920 / 1080;\r\n            var fovIsPerspective = true;\r\n            var fovOriginal = 35.0;\r\n\r\n            // ── Helper functions ──\r\n            function gcd(a, b) { return b === 0 ? a : gcd(b, a % b); }\r\n\r\n            function initializeFov(fovDegrees, isPerspective) {\r\n              fovIsPerspective = isPerspective;\r\n              if (isPerspective && fovDegrees > 0) {\r\n                fovOriginal = fovDegrees;\r\n                fovSlider.value = fovDegrees;\r\n                fovValue.textContent = fovDegrees.toFixed(1) + '\\\\u00B0';\r\n              } else {\r\n                fovSection.innerHTML =\r\n                  '<div class=\"fov-label\">' + LANG.campo_visao +\r\n                  '<small>' + LANG.fov_disponivel_perspectiva + '</small></div>' +\r\n                  '<div class=\"fov-disabled-msg\">' + LANG.mudar_perspectiva + '</div>';\r\n              }\r\n            }\r\n\r\n            function updateFovSlider(val) {\r\n              fovSlider.value = val;\r\n              fovValue.textContent = val.toFixed(1) + '\\\\u00B0';\r\n            }\r\n\r\n            function updateInfo() {\r\n              var w = parseInt(inputW.value) || 1920;\r\n              var h = parseInt(inputH.value) || 1080;\r\n\r\n              var d = gcd(w, h);\r\n              var rw = w / d;\r\n              var rh = h / d;\r\n              if (rw > 50 || rh > 50) {\r\n                var r = w / h;\r\n                if (Math.abs(r - 16/9) < 0.01) { rw = 16; rh = 9; }\r\n                else if (Math.abs(r - 4/3) < 0.01) { rw = 4; rh = 3; }\r\n                else if (Math.abs(r - 21/9) < 0.01) { rw = 21; rh = 9; }\r\n                else if (Math.abs(r - 1) < 0.01) { rw = 1; rh = 1; }\r\n                else { rw = r.toFixed(2); rh = 1; }\r\n              }\r\n              ratioText.textContent = rw + ':' + rh;\r\n\r\n              var mp = (w * h) / 1000000;\r\n              mpText.textContent = mp.toFixed(2) + ' MP';\r\n\r\n              chips.forEach(function(chip) {\r\n                var cw = parseInt(chip.dataset.w);\r\n                var ch = parseInt(chip.dataset.h);\r\n                chip.classList.toggle('active', cw === w && ch === h);\r\n              });\r\n\r\n              if (previewToggle.checked) {\r\n                sketchup.set_letterbox(w + ',' + h);\r\n              }\r\n            }\r\n\r\n            // ── Link ratio ──\r\n            linkBtn.addEventListener('click', function() {\r\n              linked = !linked;\r\n              linkBtn.classList.toggle('active', linked);\r\n              if (linked) {\r\n                baseRatio = (parseInt(inputW.value) || 1920) / (parseInt(inputH.value) || 1080);\r\n              }\r\n            });\r\n\r\n            // ── Inputs ──\r\n            var debounceTimer = null;\r\n\r\n            function debounceUpdate() {\r\n              clearTimeout(debounceTimer);\r\n              debounceTimer = setTimeout(function() {\r\n                updateInfo();\r\n              }, 200);\r\n            }\r\n\r\n            inputW.addEventListener('input', function() {\r\n              if (linked) {\r\n                var w = parseInt(inputW.value) || 1920;\r\n                inputH.value = Math.round(w / baseRatio);\r\n              }\r\n              debounceUpdate();\r\n            });\r\n\r\n            inputH.addEventListener('input', function() {\r\n              if (linked) {\r\n                var h = parseInt(inputH.value) || 1080;\r\n                inputW.value = Math.round(h * baseRatio);\r\n              }\r\n              debounceUpdate();\r\n            });\r\n\r\n            // ── Presets ──\r\n            chips.forEach(function(chip) {\r\n              chip.addEventListener('click', function() {\r\n                var w = parseInt(chip.dataset.w);\r\n                var h = parseInt(chip.dataset.h);\r\n                inputW.value = w;\r\n                inputH.value = h;\r\n                baseRatio = w / h;\r\n                updateInfo();\r\n              });\r\n            });\r\n\r\n            // ── FOV slider ──\r\n            fovSlider.addEventListener('input', function() {\r\n              var val = parseFloat(fovSlider.value);\r\n              fovValue.textContent = val.toFixed(1) + '\\\\u00B0';\r\n              sketchup.set_fov(val.toString());\r\n            });\r\n\r\n            fovResetBtn.addEventListener('click', function() {\r\n              sketchup.reset_fov();\r\n            });\r\n\r\n            // ── Preview toggle ──\r\n            previewToggle.addEventListener('change', function() {\r\n              if (previewToggle.checked) {\r\n                updateInfo();\r\n              } else {\r\n                sketchup.hide_letterbox();\r\n              }\r\n            });\r\n\r\n            // ── Buttons ──\r\n            btnClose.addEventListener('click', function() {\r\n              sketchup.close_dialog();\r\n            });\r\n\r\n            btnExport.addEventListener('click', function() {\r\n              var w = parseInt(inputW.value) || 1920;\r\n              var h = parseInt(inputH.value) || 1080;\r\n              var aa = antialiasToggle.checked ? 1 : 0;\r\n              sketchup.export_image(w + ',' + h + ',' + aa);\r\n            });\r\n\r\n            // Initialize\r\n            updateInfo();\r\n\r\n            // Request initial FOV from SketchUp\r\n            setTimeout(function() {\r\n              sketchup.get_initial_fov();\r\n            }, 100);\r\n          </script>\r\n\r\n        </body>\r\n        </html>\r\n      HTML\r\n    end\r\n\r\n    # ─── Show dialog ───────────────────────────────────────────\r\n    def self.show_dialog\r\n      cleanup_overlay\r\n      save_original_fov\r\n\r\n      dlg = UI::HtmlDialog.new(\r\n        {\r\n          :dialog_title    => obter_texto(:titulo_dialogo),\r\n          :preferences_key => \"ExportViewportDialog\",\r\n          :width           => 380,\r\n          :height          => 820,\r\n          :resizable       => false,\r\n          :style           => UI::HtmlDialog::STYLE_DIALOG\r\n        }\r\n      )\r\n\r\n      # ── Callbacks ──\r\n      dlg.add_action_callback(\"set_letterbox\") do |_ctx, params|\r\n        parts = params.split(\",\")\r\n        w = parts[0].to_f\r\n        h = parts[1].to_f\r\n        set_letterbox(w, h) if w > 0 && h > 0\r\n      end\r\n\r\n      dlg.add_action_callback(\"remove_letterbox\") do |_ctx, _params|\r\n        remove_letterbox\r\n      end\r\n\r\n      dlg.add_action_callback(\"hide_letterbox\") do |_ctx, _params|\r\n        hide_letterbox\r\n      end\r\n\r\n      dlg.add_action_callback(\"set_fov\") do |_ctx, params|\r\n        degrees = params.to_f\r\n        set_camera_fov(degrees)\r\n      end\r\n\r\n      dlg.add_action_callback(\"reset_fov\") do |_ctx, _params|\r\n        if @original_fov\r\n          camera = Sketchup.active_model.active_view.camera\r\n          camera.fov = @original_fov if camera.perspective?\r\n          dlg.execute_script(\"updateFovSlider(#{@original_fov.round(1)})\")\r\n        end\r\n      end\r\n\r\n      dlg.add_action_callback(\"get_initial_fov\") do |_ctx, _params|\r\n        camera = Sketchup.active_model.active_view.camera\r\n        if camera.perspective?\r\n          fov_val = camera.fov.round(1)\r\n          dlg.execute_script(\"initializeFov(#{fov_val}, true)\")\r\n        else\r\n          dlg.execute_script(\"initializeFov(0, false)\")\r\n        end\r\n      end\r\n\r\n      dlg.add_action_callback(\"export_image\") do |_ctx, params|\r\n        parts = params.split(\",\")\r\n        w = parts[0].to_i\r\n        h = parts[1].to_i\r\n        aa = parts[2].to_i == 1\r\n        export_image(w, h, aa)\r\n      end\r\n\r\n      dlg.add_action_callback(\"close_dialog\") do |_ctx, _params|\r\n        remove_letterbox\r\n        restore_original_fov\r\n        dlg.close\r\n      end\r\n\r\n      dlg.set_on_closed {\r\n        remove_letterbox\r\n        restore_original_fov\r\n      }\r\n\r\n      dlg.set_html(html_content)\r\n      dlg.show\r\n      @dialog = dlg\r\n    end\r\n\r\n    # ─── Entry point ───────────────────────────────────────────\r\n    def self.executar\r\n      show_dialog\r\n    end\r\n  end\r\nend\r\n\r\nScriptUpComunidade::ExportViewport.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "cronometro-96lpc",
    "title": {
      "pt": "Cronômetro",
      "en": "Stopwatch",
      "es": "Cronógrafo"
    },
    "author": "João Felipe Silva",
    "version": "5",
    "description": {
      "pt": "Contador de tempo de projeto. Ele para quando não está usando e, logo depois que começar a usar, volta a contar.",
      "en": "Project time counter. It stops when not in use and resumes counting as soon as it starts being used.",
      "es": "Contador de tiempo del proyecto. Se detiene cuando no se usa y reanuda el conteo en cuanto empieza a usarse."
    },
    "keywords": {
      "pt": [
        "tempo",
        "cronômetro"
      ],
      "en": [
        "time",
        "stopwatch"
      ],
      "es": [
        "tiempo",
        "cronógrafo"
      ]
    },
    "code": {
      "pt": "# ============================================================\r\n# Cronômetro flutuante ultra compacto – SketchUp\r\n# ============================================================\r\n\r\nSketchup.active_model.start_operation(\"Cronômetro\", true)\r\n\r\nif defined?(@cronometro_dialog)\r\n  @cronometro_dialog.close\r\nend\r\n\r\nbegin\r\n  def cronometro_auto_file\r\n    model_path = Sketchup.active_model.path\r\n    if model_path.empty?\r\n      File.join(ENV['TEMP'], \"cronometro_temp.txt\")\r\n    else\r\n      File.join(File.dirname(model_path), \"#{File.basename(model_path, '.*')}_tempo.txt\")\r\n    end\r\n  end\r\n\r\n  @cronometro_start = Time.now\r\n  @cronometro_paused = 0\r\n  @cronometro_is_paused = false\r\n  @last_activity_time = Time.now\r\n  @last_camera_state = nil\r\n  @cronometro_check_timer = nil\r\n  @cronometro_save_timer = nil\r\n  @cronometro_initial_load = false\r\n\r\n  def update_elapsed_time\r\n    if @cronometro_start && !@cronometro_is_paused\r\n      elapsed = Time.now - @cronometro_start\r\n      @cronometro_paused += elapsed\r\n      @cronometro_start = Time.now\r\n      return elapsed\r\n    end\r\n    0\r\n  end\r\n\r\n  def cronometro_format_time(seconds)\r\n    t = seconds.to_i\r\n    h = t/3600; m=(t%3600)/60; s=t%60\r\n    format(\"%02d:%02d:%02d\", h, m, s)\r\n  end\r\n\r\n  def cronometro_current_time\r\n    if @cronometro_start && !@cronometro_is_paused\r\n      Time.now - @cronometro_start + @cronometro_paused\r\n    else\r\n      @cronometro_paused\r\n    end\r\n  end\r\n\r\n  def cronometro_auto_save\r\n    was_running = update_elapsed_time>0\r\n    current_time=@cronometro_paused\r\n    return if current_time<=0\r\n    File.write(cronometro_auto_file, cronometro_format_time(current_time))\r\n    if was_running\r\n      @cronometro_start=Time.now\r\n      @cronometro_is_paused=false\r\n    end\r\n  end\r\n\r\n  def setup_auto_save\r\n    @cronometro_save_timer = UI.start_timer(30,true){ cronometro_auto_save }\r\n  end\r\n\r\n  def cronometro_load_time\r\n    return if @cronometro_initial_load\r\n    @cronometro_initial_load=true\r\n    file_path=cronometro_auto_file\r\n    if File.exist?(file_path)\r\n      content = File.read(file_path).strip.gsub(\"\\r\",\"\").gsub(\"\\n\",\"\")\r\n      if content =~ /\\A\\d{2}:\\d{2}:\\d{2}\\z/\r\n        h,m,s=content.split(':').map(&:to_i)\r\n        @cronometro_paused=h*3600+m*60+s\r\n      end\r\n    end\r\n  end\r\n\r\n  def detect_camera_activity\r\n    view=Sketchup.active_model.active_view\r\n    cam=view.camera\r\n    state=[cam.eye.to_a,cam.target.to_a,cam.up.to_a].flatten\r\n    if @last_camera_state != state\r\n      @last_camera_state = state\r\n      @last_activity_time = Time.now\r\n      if @cronometro_is_paused\r\n        @cronometro_start = Time.now - @cronometro_paused\r\n        @cronometro_is_paused=false\r\n        @cronometro_paused=0\r\n      end\r\n    end\r\n    if !@cronometro_is_paused && (Time.now - @last_activity_time)>=15\r\n      update_elapsed_time\r\n      @cronometro_is_paused=true\r\n    end\r\n  end\r\n\r\n  html=<<-HTML\r\n  <!DOCTYPE html>\r\n  <html>\r\n  <head>\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <style>\r\n      html, body{margin:0;padding:0;background:transparent;}\r\n      #bar{\r\n        display:flex; align-items:center; background: rgba(30,30,30,0.9);\r\n        border-radius:6px; padding:2px; cursor:move; box-shadow:0 2px 5px rgba(0,0,0,0.4);\r\n      }\r\n      #display{color:white; font-weight:bold; font-size:12px; margin:0 3px; width:70px; text-align:center;}\r\n      button{\r\n        border:none; margin:0 2px; width:24px; height:24px; border-radius:4px;\r\n        cursor:pointer; display:flex; align-items:center; justify-content:center; padding:0;\r\n      }\r\n      #start{background:#4CAF50;}\r\n      #pause{background:#2196F3;}\r\n      #reset{background:#f44336;}\r\n      #save{background:#FFC107;}\r\n      #import{background:#9C27B0;}\r\n      button svg{width:12px; height:12px; fill:white;}\r\n    </style>\r\n    <script>\r\n      let bar, offsetX, offsetY, dragging=false;\r\n      function initDrag(){\r\n        bar=document.getElementById('bar');\r\n        bar.onmousedown=function(e){dragging=true; offsetX=e.clientX-bar.offsetLeft; offsetY=e.clientY-bar.offsetTop;};\r\n        window.onmouseup=function(){dragging=false;};\r\n        window.onmousemove=function(e){if(dragging){bar.style.left=(e.clientX-offsetX)+'px';bar.style.top=(e.clientY-offsetY)+'px';}};\r\n      }\r\n      function updateDisplay(){window.location='skp:getTime@';setTimeout(updateDisplay,500);}\r\n      function setDisplay(v){document.getElementById('display').innerText=v;}\r\n      window.onload=function(){initDrag();updateDisplay();};\r\n    </script>\r\n  </head>\r\n  <body>\r\n    <div id=\"bar\">\r\n      <div id=\"display\">00:00:00</div>\r\n      <button id=\"start\" onclick=\"window.location='skp:startTimer@'\">&#9658;</button>\r\n      <button id=\"pause\" onclick=\"window.location='skp:pauseTimer@'\">&#10074;&#10074;</button>\r\n      <button id=\"reset\" onclick=\"window.location='skp:resetTimer@'\">&#8634;</button>\r\n      <button id=\"save\" onclick=\"window.location='skp:saveTime@'\">\r\n        <svg viewBox=\"0 0 24 24\"><path d=\"M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2zM12 17a3 3 0 1 0 0-6 3 3 0 0 0 0 6z\"/></svg>\r\n      </button>\r\n      <button id=\"import\" onclick=\"window.location='skp:importTime@'\">\r\n        <svg viewBox=\"0 0 24 24\"><path d=\"M5 20h14v-2H5v2zm7-18L5.33 9h3.34v4h4V9h3.34L12 2z\"/></svg>\r\n      </button>\r\n    </div>\r\n  </body>\r\n  </html>\r\n  HTML\r\n\r\n  # Título mínimo da janela: só \"Cronômetro\"\r\n  @cronometro_dialog = UI::WebDialog.new(\"Cronômetro\", false, \"CronometroCompacto\", 230, 32, 150, 150)\r\n  @cronometro_dialog.set_html(html)\r\n\r\n  # Callbacks\r\n  @cronometro_dialog.add_action_callback(\"getTime\"){|d,_| d.execute_script(\"setDisplay('#{cronometro_format_time(cronometro_current_time)}');\")}\r\n  @cronometro_dialog.add_action_callback(\"startTimer\"){|_,_| if @cronometro_is_paused; @cronometro_start=Time.now-@cronometro_paused; @cronometro_is_paused=false; @cronometro_paused=0; end}\r\n  @cronometro_dialog.add_action_callback(\"pauseTimer\"){|_,_| update_elapsed_time; @cronometro_is_paused=true}\r\n  @cronometro_dialog.add_action_callback(\"resetTimer\"){|_,_| @cronometro_start=nil; @cronometro_paused=0; @cronometro_is_paused=true}\r\n  @cronometro_dialog.add_action_callback(\"saveTime\"){|_,_| cronometro_auto_save; UI.messagebox(\"Tempo salvo!\")}\r\n  @cronometro_dialog.add_action_callback(\"importTime\") do |_,_|\r\n    path=UI.openpanel(\"Importar Tempo\",\"\",\"*.txt\")\r\n    if path && File.exist?(path)\r\n      content=File.read(path).strip.gsub(\"\\r\",\"\").gsub(\"\\n\",\"\")\r\n      if content=~/\\A\\d{2}:\\d{2}:\\d{2}\\z/\r\n        h,m,s=content.split(':').map(&:to_i)\r\n        @cronometro_paused=h*3600+m*60+s\r\n        UI.messagebox(\"Tempo carregado: #{content}\")\r\n      else\r\n        UI.messagebox(\"Formato inválido! Use 00:00:00\")\r\n      end\r\n    end\r\n  end\r\n\r\n  @cronometro_check_timer=UI.start_timer(1.0,true){ detect_camera_activity }\r\n  setup_auto_save\r\n  cronometro_load_time\r\n  @cronometro_dialog.show\r\n\r\nrescue => e\r\n  puts \"Erro: #{e.message}\"\r\nend\r\n\r\nSketchup.active_model.commit_operation"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "clonar-componentes-96nzw",
    "title": {
      "pt": "Clonar componentes",
      "en": "Clone components",
      "es": "Componentes de clonación"
    },
    "author": "Igor Terra Tozzi",
    "version": "12",
    "description": {
      "pt": "O Clonar Componentes é uma ferramenta de produtividade essencial para quem precisa padronizar modelos de forma ultra rápida no SketchUp. Sabe quando você espalha vários blocos genéricos ou grupos pelo projeto e depois decide que todos eles deveriam ser um componente específico (como uma cadeira, uma luminária ou uma árvore)? Este script faz essa troca em segundos.",
      "en": "The Component Cloning tool is an essential productivity tool for anyone who needs to standardize models ultra-fast in SketchUp. You know when you scatter several generic blocks or groups throughout your project and then decide that they should all be a specific component (like a chair, a lamp, or a tree)? This script makes that switch in seconds.",
      "es": "La herramienta Clonación de Componentes es una herramienta de productividad esencial para cualquiera que necesite estandarizar modelos ultrarrápido en SketchUp. ¿Sabes cuando distribuyes varios bloques o grupos genéricos por todo el proyecto y luego decides que todos deben ser un componente específico (como una silla, una lámpara o un árbol)? Este script realiza ese cambio en segundos."
    },
    "keywords": {
      "pt": [
        "o clonar componentes é uma ferramenta de produtividade essencial para quem precisa padronizar modelos de forma ultra rápida no sketchup. sabe quando você espalha vários blocos genéricos ou grupos pelo projeto e depois decide que todos eles deveriam ser um componente específico (como uma cadeira",
        "uma luminária ou uma árvore)? este script faz essa troca em segundos."
      ],
      "en": [
        "cloning components is an essential productivity tool for anyone who needs to standardize models ultra-fast in sketchup. you know when you scatter several generic blocks or groups throughout the project and then decide that they should all be a specific component (like a chair)?",
        "a lamp or a tree? this script makes that switch in seconds."
      ],
      "es": [
        "clonar componentes es una herramienta de productividad esencial para cualquiera que necesite estandarizar modelos ultrarrápido en sketchup. ¿sabes cuando distribuyes varios bloques o grupos genéricos por el proyecto y luego decides que todos deben ser un componente específico (como una silla)?",
        "¿una lámpara o un árbol? este script te permite cambiar de lugar en segundos."
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module ClonarComponentes\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :selecao_vazia   => \"Selecione pelo menos uma entidade (incluindo a cadeira referência).\",\r\n        :erro_componente => \"Nenhum componente encontrado na seleção.\\nSelecione um componente de referência e os grupos a substituir.\",\r\n        :operacao        => \"Clonar componente de referência\",\r\n        :sucesso_prefixo => \"✅ Clonagem concluída. Todas as entidades selecionadas agora são instâncias de \"\r\n      },\r\n      'en-US' => {\r\n        :selecao_vazia   => \"Please select at least one entity (including the reference component).\",\r\n        :erro_componente => \"No component found in selection.\\nSelect a reference component and the groups to replace.\",\r\n        :operacao        => \"Clone reference component\",\r\n        :sucesso_prefixo => \"✅ Cloning completed. All selected entities are now instances of \"\r\n      },\r\n      'es' => {\r\n        :selecao_vazia   => \"Seleccione al menos una entidad (incluyendo el componente de referencia).\",\r\n        :erro_componente => \"No se encontró ningún componente en la selección.\\nSeleccione un componente de referencia y los grupos a sustituir.\",\r\n        :operacao        => \"Clonar componente de referencia\",\r\n        :sucesso_prefixo => \"✅ Clonación completada. Todas las entidades seleccionadas son ahora instancias de \"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      sel = model.selection\r\n\r\n      if sel.empty?\r\n        UI.messagebox(obter_texto(:selecao_vazia))\r\n        return\r\n      end\r\n\r\n      # Pega o primeiro componente selecionado como referência\r\n      reference_inst = sel.find { |e| e.is_a?(Sketchup::ComponentInstance) }\r\n\r\n      unless reference_inst\r\n        UI.messagebox(obter_texto(:erro_componente))\r\n        return\r\n      end\r\n\r\n      reference_def = reference_inst.definition\r\n\r\n      model.start_operation(obter_texto(:operacao), true)\r\n\r\n      sel.to_a.each do |ent|\r\n        next if ent == reference_inst\r\n        if ent.is_a?(Sketchup::Group) || ent.is_a?(Sketchup::ComponentInstance)\r\n          tr = ent.transformation\r\n          ent.erase!\r\n          model.entities.add_instance(reference_def, tr)\r\n        end\r\n      end\r\n\r\n      model.commit_operation\r\n      puts \"#{obter_texto(:sucesso_prefixo)}\\\"#{reference_def.name}\\\".\"\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::ClonarComponentes.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "gerenciador-de-cenas-inteligente-96q7g",
    "title": {
      "pt": "Gerenciador de Cenas Inteligente",
      "en": "Intelligent Scene Manager",
      "es": "Administrador de escenas inteligente"
    },
    "author": "Comunidade ScriptUp",
    "version": "1.1",
    "description": {
      "pt": "Automatiza a criação de estruturas padronizadas para arquitetura e interiores através de templates customizáveis. Ele permite organizar cenas em grupos (como Plantas ou Cortes), sincronizar câmeras e estilos em massa e gerenciar nomes de forma visual. Ideal para eliminar tarefas repetitivas e padronizar entregas técnicas no SketchUp.",
      "en": "Automates the creation of standardized structures for architecture and interiors through customizable templates. It allows you to organize scenes into groups (such as Plans or Sections), synchronize cameras and styles in bulk, and manage names visually. Ideal for eliminating repetitive tasks and standardizing technical deliverables in SketchUp.",
      "es": "Automatiza la creación de estructuras estandarizadas para arquitectura e interiores mediante plantillas personalizables. Permite organizar escenas en grupos (como planos o secciones), sincronizar cámaras y estilos en bloque y gestionar nombres visualmente. Ideal para eliminar tareas repetitivas y estandarizar los resultados técnicos en SketchUp."
    },
    "keywords": {
      "pt": [
        "organização de cenas",
        "automação sketchup",
        "templates de projeto",
        "arquitetura",
        "design de interiores",
        "sincronização de estilos",
        "gestão de grupos",
        "produtividade"
      ],
      "en": [
        "scene organization",
        "sketchup automation",
        "project templates",
        "architecture",
        "interior design",
        "style synchronization",
        "group management",
        "productivity"
      ],
      "es": [
        "organización de la escena",
        "automatización de sketchup",
        "plantillas de proyecto",
        "arquitectura",
        "diseño de interiores",
        "sincronización de estilos",
        "gestión de grupos",
        "productividad"
      ]
    },
    "code": {
      "pt": "require 'sketchup.rb'\r\nrequire 'json'\r\n\r\nmodule ScriptUpComunidade\r\n  module GerenciadorCenas\r\n    extend self\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :menu_plugins => 'Plugins',\r\n        :menu_gerenciador => 'Gerenciador de Cenas',\r\n        :menu_abrir => 'Abrir Painel',\r\n        :dialog_title => 'Gerenciador de Cenas - ScriptUp',\r\n        :arq_padrao => 'Arquitetura Padrão',\r\n        :plantas => 'Plantas',\r\n        :planta_baixa => 'Planta Baixa - Térreo',\r\n        :planta_cob => 'Planta de Cobertura',\r\n        :cortes => 'Cortes',\r\n        :corte_aa => 'Corte AA (Longitudinal)',\r\n        :corte_bb => 'Corte BB (Transversal)',\r\n        :fachadas => 'Fachadas',\r\n        :fachada_prin => 'Fachada Principal',\r\n        :perspectivas => 'Perspectivas',\r\n        :isometrica => 'Vista Isométrica',\r\n        :int_padrao => 'Interiores Padrão',\r\n        :planta_layout => 'Planta de Layout',\r\n        :planta_forro => 'Planta de Forro e Iluminação',\r\n        :planta_pisos => 'Planta de Pisos',\r\n        :detalhamento => 'Detalhamento',\r\n        :marcenaria_01 => 'Marcenaria 01',\r\n        :marcenaria_02 => 'Marcenaria 02',\r\n        :vistas => 'Vistas',\r\n        :vista_int_01 => 'Vista Interna 01',\r\n        :vista_int_02 => 'Vista Interna 02',\r\n        :limite_templates => \"Limite máximo de 10 templates atingido.\\nExclua algum em 'Gerenciar' antes de criar um novo.\",\r\n        :sem_grupo => 'Sem Grupo',\r\n        :toast_template_salvo => \"mostrarToast('Template \\\\'%s\\\\' salvo com sucesso!')\",\r\n        :toast_template_atualizado => \"mostrarToast('Template atualizado com sucesso!')\",\r\n        :op_gerar_template => \"Gerar Template: %s\",\r\n        :msg_template_gerado => \"Template '%s' gerado!\\n%d novas cenas estruturadas no modelo.\",\r\n        :toast_template_excluido => \"mostrarToast('Template %s excluído.')\",\r\n        :op_mover_cenas => \"Mover Cenas de Grupo\",\r\n        :msg_cena_existe => \"Aviso: Já existe uma cena chamada '%s'.\",\r\n        :op_colar_prop => \"Colar Propriedades\",\r\n        :op_criar_cena => \"Criar Cena\",\r\n        :msg_ative_cena_base => \"Ative uma cena base no SketchUp primeiro.\",\r\n        :op_sync_grupo => \"Sincronizar %s Grupo\",\r\n        :msg_cenas_atualizadas => \"%d cena(s) do grupo '%s' atualizada(s)!\",\r\n        :title_alt_tema => 'Alternar Modo Escuro',\r\n        :html_titulo_painel => '📐 ScriptUp Cenas',\r\n        :title_gerar_template => 'Gerar as cenas do Template Selecionado',\r\n        :btn_salvar_modelo => '💾 Salvar Modelo como Template',\r\n        :title_gerenciar_templates => 'Gerenciar Templates',\r\n        :html_criar_nova_cena => 'Criar Nova Cena',\r\n        :placeholder_grupo => 'Grupo (ex: Cortes)',\r\n        :placeholder_nome => 'Nome (ex: AA)',\r\n        :btn_add_cena => '+ Adicionar Cena',\r\n        :html_suas_cenas => 'Suas Cenas',\r\n        :title_atualizar => 'Atualiza se criou cenas fora do painel',\r\n        :btn_atualizar => '⟳ Atualizar',\r\n        :html_carregando => 'A carregar cenas...',\r\n        :menu_criar_grupo_sel => '📁 Criar Grupo com Seleção...',\r\n        :menu_mover_grupo => '↔️ Mover de Grupo...',\r\n        :menu_renomear => '✏️ Renomear Cena',\r\n        :menu_copiar_prop => '📄 Copiar Propriedades',\r\n        :menu_copiar_cam => '🎥 Copiar Câmera',\r\n        :menu_copiar_estilo => '🎨 Copiar Estilo/Tags',\r\n        :menu_colar_prop => '📋 Colar Propriedades',\r\n        :menu_excluir_cena => '🗑️ Excluir Cena',\r\n        :modal_titulo_default => 'Título',\r\n        :placeholder_novo_grupo => 'Digite o nome do novo grupo...',\r\n        :btn_cancelar => 'Cancelar',\r\n        :btn_ok => 'OK',\r\n        :html_gerenciar_templates => '⚙️ Gerenciar Templates',\r\n        :btn_fechar => 'Fechar',\r\n        :html_editor_template => '✏️ Editor de Template',\r\n        :html_edite_nomes => 'Edite nomes, grupos e cenas livremente.',\r\n        :html_nome_template => 'Nome do Template:',\r\n        :btn_criar_novo_grupo => '+ Criar Novo Grupo',\r\n        :btn_salvar_alt => '💾 Salvar Alterações',\r\n        :html_notificacao => 'Notificação',\r\n        :js_nenhum_template => 'Nenhum Template',\r\n        :js_estrutura_atual => 'A estrutura atual formará um novo template. Nome:',\r\n        :js_salvar_template => 'Salvar Template',\r\n        :js_vazio => 'Vazio.',\r\n        :js_editar => '✏️ Editar',\r\n        :js_excluir_template_title => 'Excluir Template',\r\n        :js_aviso_exclusao => 'Aviso de Exclusão',\r\n        :js_msg_excluir_template => 'Deseja excluir permanentemente o template \"${t}\" do seu computador?',\r\n        :js_excluir => 'Excluir',\r\n        :js_nome_grupo => 'Nome do Grupo',\r\n        :js_apagar_grupo => 'Apagar grupo inteiro',\r\n        :js_nova_cena_grupo => '+ Nova Cena neste grupo',\r\n        :js_nome_cena => 'Nome da cena',\r\n        :js_template_sem_nome => 'O template precisa de um nome!',\r\n        :js_nenhuma_cena => 'Nenhuma cena encontrada.',\r\n        :js_cenas_soltas => 'Cenas Soltas',\r\n        :js_nova => '+ Nova',\r\n        :js_add_nova_cena_em => 'Adicionar nova cena em ${grupo}',\r\n        :js_sync_cam => '🎥 Sync Câmera',\r\n        :js_sync_estilos => '🎨 Sync Estilos',\r\n        :js_criar_grupo_qtd => '📁 Criar Grupo com ${qtd} Cenas...',\r\n        :js_mover_qtd => '↔️ Mover ${qtd} Cenas...',\r\n        :js_excluir_qtd => '🗑️ Excluir ${qtd} Cenas',\r\n        :js_camera => 'Câmera',\r\n        :js_estilo => 'Estilo',\r\n        :js_colar_de => '📋 Colar ${txt} de [${cenaCopiada.substring(0, 8)}...]',\r\n        :js_copiada_de => '${txt} copiada de \"${cenaCopiada}\"',\r\n        :js_estilos_tags => 'Estilo e Tags',\r\n        :js_colando_em => 'A colar na cena \"${cenasAlvoContextMenu[0]}\"...',\r\n        :js_exclusao_massa => 'Exclusão em Massa',\r\n        :js_msg_excluir_massa => 'Tem a certeza que deseja excluir ${cenasAlvoContextMenu.length} cenas permanentemente?',\r\n        :js_msg_excluir_unica => 'Tem a certeza que deseja excluir a cena \"${cenasAlvoContextMenu[0]}\" permanentemente?',\r\n        :js_renomear_cena => 'Renomear Cena',\r\n        :js_guardar => 'Guardar',\r\n        :js_mover_cenas_qtd => 'Mover ${cenasAlvoContextMenu.length} Cenas',\r\n        :js_mover_para_grupo => 'Mover para Grupo',\r\n        :js_selecione_destino => 'Selecione o grupo de destino:',\r\n        :js_criar_novo_grupo_opt => '+ Criar Novo Grupo...',\r\n        :js_mover => 'Mover',\r\n        :js_agrupar_qtd => 'Agrupar ${cenasAlvoContextMenu.length} Cenas',\r\n        :js_nome_novo_grupo => 'Nome do novo grupo:',\r\n        :js_criar_mover => 'Criar e Mover'\r\n      },\r\n      'en-US' => {\r\n        :menu_plugins => 'Plugins',\r\n        :menu_gerenciador => 'Scene Manager',\r\n        :menu_abrir => 'Open Panel',\r\n        :dialog_title => 'Scene Manager - ScriptUp',\r\n        :arq_padrao => 'Standard Architecture',\r\n        :plantas => 'Plans',\r\n        :planta_baixa => 'Floor Plan - Ground',\r\n        :planta_cob => 'Roof Plan',\r\n        :cortes => 'Sections',\r\n        :corte_aa => 'Section AA (Longitudinal)',\r\n        :corte_bb => 'Section BB (Transverse)',\r\n        :fachadas => 'Elevations',\r\n        :fachada_prin => 'Front Elevation',\r\n        :perspectivas => 'Perspectives',\r\n        :isometrica => 'Isometric View',\r\n        :int_padrao => 'Standard Interiors',\r\n        :planta_layout => 'Layout Plan',\r\n        :planta_forro => 'Ceiling and Lighting Plan',\r\n        :planta_pisos => 'Floor Finishes Plan',\r\n        :detalhamento => 'Detailing',\r\n        :marcenaria_01 => 'Millwork 01',\r\n        :marcenaria_02 => 'Millwork 02',\r\n        :vistas => 'Views',\r\n        :vista_int_01 => 'Internal View 01',\r\n        :vista_int_02 => 'Internal View 02',\r\n        :limite_templates => \"Maximum limit of 10 templates reached.\\nDelete one in 'Manage' before creating a new one.\",\r\n        :sem_grupo => 'Ungrouped',\r\n        :toast_template_salvo => \"mostrarToast('Template \\\\'%s\\\\' saved successfully!')\",\r\n        :toast_template_atualizado => \"mostrarToast('Template updated successfully!')\",\r\n        :op_gerar_template => \"Generate Template: %s\",\r\n        :msg_template_gerado => \"Template '%s' generated!\\n%d new scenes structured in the model.\",\r\n        :toast_template_excluido => \"mostrarToast('Template %s deleted.')\",\r\n        :op_mover_cenas => \"Move Scenes from Group\",\r\n        :msg_cena_existe => \"Warning: A scene named '%s' already exists.\",\r\n        :op_colar_prop => \"Paste Properties\",\r\n        :op_criar_cena => \"Create Scene\",\r\n        :msg_ative_cena_base => \"Activate a base scene in SketchUp first.\",\r\n        :op_sync_grupo => \"Synchronize %s Group\",\r\n        :msg_cenas_atualizadas => \"%d scene(s) from group '%s' updated!\",\r\n        :title_alt_tema => 'Toggle Dark Mode',\r\n        :html_titulo_painel => '📐 ScriptUp Scenes',\r\n        :title_gerar_template => 'Generate scenes from Selected Template',\r\n        :btn_salvar_modelo => '💾 Save Model as Template',\r\n        :title_gerenciar_templates => 'Manage Templates',\r\n        :html_criar_nova_cena => 'Create New Scene',\r\n        :placeholder_grupo => 'Group (e.g. Sections)',\r\n        :placeholder_nome => 'Name (e.g. AA)',\r\n        :btn_add_cena => '+ Add Scene',\r\n        :html_suas_cenas => 'Your Scenes',\r\n        :title_atualizar => 'Update if you created scenes outside the panel',\r\n        :btn_atualizar => '⟳ Update',\r\n        :html_carregando => 'Loading scenes...',\r\n        :menu_criar_grupo_sel => '📁 Create Group with Selection...',\r\n        :menu_mover_grupo => '↔️ Move Group...',\r\n        :menu_renomear => '✏️ Rename Scene',\r\n        :menu_copiar_prop => '📄 Copy Properties',\r\n        :menu_copiar_cam => '🎥 Copy Camera',\r\n        :menu_copiar_estilo => '🎨 Copy Style/Tags',\r\n        :menu_colar_prop => '📋 Paste Properties',\r\n        :menu_excluir_cena => '🗑️ Delete Scene',\r\n        :modal_titulo_default => 'Title',\r\n        :placeholder_novo_grupo => 'Type the new group name...',\r\n        :btn_cancelar => 'Cancel',\r\n        :btn_ok => 'OK',\r\n        :html_gerenciar_templates => '⚙️ Manage Templates',\r\n        :btn_fechar => 'Close',\r\n        :html_editor_template => '✏️ Template Editor',\r\n        :html_edite_nomes => 'Edit names, groups, and scenes freely.',\r\n        :html_nome_template => 'Template Name:',\r\n        :btn_criar_novo_grupo => '+ Create New Group',\r\n        :btn_salvar_alt => '💾 Save Changes',\r\n        :html_notificacao => 'Notification',\r\n        :js_nenhum_template => 'No Template',\r\n        :js_estrutura_atual => 'The current structure will form a new template. Name:',\r\n        :js_salvar_template => 'Save Template',\r\n        :js_vazio => 'Empty.',\r\n        :js_editar => '✏️ Edit',\r\n        :js_excluir_template_title => 'Delete Template',\r\n        :js_aviso_exclusao => 'Deletion Warning',\r\n        :js_msg_excluir_template => 'Do you want to permanently delete the template \"${t}\" from your computer?',\r\n        :js_excluir => 'Delete',\r\n        :js_nome_grupo => 'Group Name',\r\n        :js_apagar_grupo => 'Delete entire group',\r\n        :js_nova_cena_grupo => '+ New Scene in this group',\r\n        :js_nome_cena => 'Scene name',\r\n        :js_template_sem_nome => 'The template needs a name!',\r\n        :js_nenhuma_cena => 'No scenes found.',\r\n        :js_cenas_soltas => 'Ungrouped Scenes',\r\n        :js_nova => '+ New',\r\n        :js_add_nova_cena_em => 'Add new scene in ${grupo}',\r\n        :js_sync_cam => '🎥 Sync Camera',\r\n        :js_sync_estilos => '🎨 Sync Styles',\r\n        :js_criar_grupo_qtd => '📁 Create Group with ${qtd} Scenes...',\r\n        :js_mover_qtd => '↔️ Move ${qtd} Scenes...',\r\n        :js_excluir_qtd => '🗑️ Delete ${qtd} Scenes',\r\n        :js_camera => 'Camera',\r\n        :js_estilo => 'Style',\r\n        :js_colar_de => '📋 Paste ${txt} from [${cenaCopiada.substring(0, 8)}...]',\r\n        :js_copiada_de => '${txt} copied from \"${cenaCopiada}\"',\r\n        :js_estilos_tags => 'Style and Tags',\r\n        :js_colando_em => 'Pasting into scene \"${cenasAlvoContextMenu[0]}\"...',\r\n        :js_exclusao_massa => 'Mass Deletion',\r\n        :js_msg_excluir_massa => 'Are you sure you want to permanently delete ${cenasAlvoContextMenu.length} scenes?',\r\n        :js_msg_excluir_unica => 'Are you sure you want to permanently delete the scene \"${cenasAlvoContextMenu[0]}\"?',\r\n        :js_renomear_cena => 'Rename Scene',\r\n        :js_guardar => 'Save',\r\n        :js_mover_cenas_qtd => 'Move ${cenasAlvoContextMenu.length} Scenes',\r\n        :js_mover_para_grupo => 'Move to Group',\r\n        :js_selecione_destino => 'Select destination group:',\r\n        :js_criar_novo_grupo_opt => '+ Create New Group...',\r\n        :js_mover => 'Move',\r\n        :js_agrupar_qtd => 'Group ${cenasAlvoContextMenu.length} Scenes',\r\n        :js_nome_novo_grupo => 'New group name:',\r\n        :js_criar_mover => 'Create and Move'\r\n      },\r\n      'es' => {\r\n        :menu_plugins => 'Plugins',\r\n        :menu_gerenciador => 'Gestor de Escenas',\r\n        :menu_abrir => 'Abrir Panel',\r\n        :dialog_title => 'Gestor de Escenas - ScriptUp',\r\n        :arq_padrao => 'Arquitectura Estándar',\r\n        :plantas => 'Plantas',\r\n        :planta_baixa => 'Planta Baja',\r\n        :planta_cob => 'Planta de Cubierta',\r\n        :cortes => 'Cortes',\r\n        :corte_aa => 'Corte AA (Longitudinal)',\r\n        :corte_bb => 'Corte BB (Transversal)',\r\n        :fachadas => 'Fachadas',\r\n        :fachada_prin => 'Fachada Principal',\r\n        :perspectivas => 'Perspectivas',\r\n        :isometrica => 'Vista Isométrica',\r\n        :int_padrao => 'Interiores Estándar',\r\n        :planta_layout => 'Planta de Layout',\r\n        :planta_forro => 'Planta de Techo e Iluminación',\r\n        :planta_pisos => 'Planta de Pisos',\r\n        :detalhamento => 'Detallado',\r\n        :marcenaria_01 => 'Carpintería 01',\r\n        :marcenaria_02 => 'Carpintería 02',\r\n        :vistas => 'Vistas',\r\n        :vista_int_01 => 'Vista Interna 01',\r\n        :vista_int_02 => 'Vista Interna 02',\r\n        :limite_templates => \"Límite máximo de 10 plantillas alcanzado.\\nElimine alguna en 'Gestionar' antes de crear una nueva.\",\r\n        :sem_grupo => 'Sin Grupo',\r\n        :toast_template_salvo => \"mostrarToast('¡Plantilla \\\\'%s\\\\' guardada con éxito!')\",\r\n        :toast_template_atualizado => \"mostrarToast('¡Plantilla actualizada con éxito!')\",\r\n        :op_gerar_template => \"Generar Plantilla: %s\",\r\n        :msg_template_gerado => \"¡Plantilla '%s' generada!\\n%d nuevas escenas estructuradas en el modelo.\",\r\n        :toast_template_excluido => \"mostrarToast('Plantilla %s eliminada.')\",\r\n        :op_mover_cenas => \"Mover Escenas de Grupo\",\r\n        :msg_cena_existe => \"Aviso: Ya existe una escena llamada '%s'.\",\r\n        :op_colar_prop => \"Pegar Propiedades\",\r\n        :op_criar_cena => \"Crear Escena\",\r\n        :msg_ative_cena_base => \"Active una escena base en SketchUp primero.\",\r\n        :op_sync_grupo => \"Sincronizar Grupo %s\",\r\n        :msg_cenas_atualizadas => \"¡%d escena(s) del grupo '%s' actualizada(s)!\",\r\n        :title_alt_tema => 'Alternar Modo Oscuro',\r\n        :html_titulo_painel => '📐 Escenas ScriptUp',\r\n        :title_gerar_template => 'Generar las escenas de la Plantilla Seleccionada',\r\n        :btn_salvar_modelo => '💾 Guardar Modelo como Plantilla',\r\n        :title_gerenciar_templates => 'Gestionar Plantillas',\r\n        :html_criar_nova_cena => 'Crear Nueva Escena',\r\n        :placeholder_grupo => 'Grupo (ej: Cortes)',\r\n        :placeholder_nome => 'Nombre (ej: AA)',\r\n        :btn_add_cena => '+ Añadir Escena',\r\n        :html_suas_cenas => 'Tus Escenas',\r\n        :title_atualizar => 'Actualiza si creaste escenas fuera del panel',\r\n        :btn_atualizar => '⟳ Actualizar',\r\n        :html_carregando => 'Cargando escenas...',\r\n        :menu_criar_grupo_sel => '📁 Crear Grupo con Selección...',\r\n        :menu_mover_grupo => '↔️ Mover de Grupo...',\r\n        :menu_renomear => '✏️ Renombrar Escena',\r\n        :menu_copiar_prop => '📄 Copiar Propiedades',\r\n        :menu_copiar_cam => '🎥 Copiar Cámara',\r\n        :menu_copiar_estilo => '🎨 Copiar Estilo/Etiquetas',\r\n        :menu_colar_prop => '📋 Pegar Propiedades',\r\n        :menu_excluir_cena => '🗑️ Eliminar Escena',\r\n        :modal_titulo_default => 'Título',\r\n        :placeholder_novo_grupo => 'Escriba el nombre del nuevo grupo...',\r\n        :btn_cancelar => 'Cancelar',\r\n        :btn_ok => 'OK',\r\n        :html_gerenciar_templates => '⚙️ Gestionar Plantillas',\r\n        :btn_fechar => 'Cerrar',\r\n        :html_editor_template => '✏️ Editor de Plantillas',\r\n        :html_edite_nomes => 'Edite nombres, grupos y escenas libremente.',\r\n        :html_nome_template => 'Nombre de la Plantilla:',\r\n        :btn_criar_novo_grupo => '+ Crear Nuevo Grupo',\r\n        :btn_salvar_alt => '💾 Guardar Cambios',\r\n        :html_notificacao => 'Notificación',\r\n        :js_nenhum_template => 'Ninguna Plantilla',\r\n        :js_estrutura_atual => 'La estructura actual formará una nueva plantilla. Nombre:',\r\n        :js_salvar_template => 'Guardar Plantilla',\r\n        :js_vazio => 'Vacío.',\r\n        :js_editar => '✏️ Editar',\r\n        :js_excluir_template_title => 'Eliminar Plantilla',\r\n        :js_aviso_exclusao => 'Aviso de Eliminación',\r\n        :js_msg_excluir_template => '¿Desea eliminar permanentemente la plantilla \"${t}\" de su computadora?',\r\n        :js_excluir => 'Eliminar',\r\n        :js_nome_grupo => 'Nombre del Grupo',\r\n        :js_apagar_grupo => 'Borrar grupo entero',\r\n        :js_nova_cena_grupo => '+ Nueva Escena en este grupo',\r\n        :js_nome_cena => 'Nombre de la escena',\r\n        :js_template_sem_nome => '¡La plantilla necesita un nombre!',\r\n        :js_nenhuma_cena => 'No se encontraron escenas.',\r\n        :js_cenas_soltas => 'Escenas Sueltas',\r\n        :js_nova => '+ Nueva',\r\n        :js_add_nova_cena_em => 'Añadir nueva escena en ${grupo}',\r\n        :js_sync_cam => '🎥 Sync Cámara',\r\n        :js_sync_estilos => '🎨 Sync Estilos',\r\n        :js_criar_grupo_qtd => '📁 Crear Grupo con ${qtd} Escenas...',\r\n        :js_mover_qtd => '↔️ Mover ${qtd} Escenas...',\r\n        :js_excluir_qtd => '🗑️ Eliminar ${qtd} Escenas',\r\n        :js_camera => 'Cámara',\r\n        :js_estilo => 'Estilo',\r\n        :js_colar_de => '📋 Pegar ${txt} de [${cenaCopiada.substring(0, 8)}...]',\r\n        :js_copiada_de => '${txt} copiada de \"${cenaCopiada}\"',\r\n        :js_estilos_tags => 'Estilo y Etiquetas',\r\n        :js_colando_em => 'Pegando en la escena \"${cenasAlvoContextMenu[0]}\"...',\r\n        :js_exclusao_massa => 'Eliminación en Masa',\r\n        :js_msg_excluir_massa => '¿Está seguro de que desea eliminar permanentemente ${cenasAlvoContextMenu.length} escenas?',\r\n        :js_msg_excluir_unica => '¿Está seguro de que desea eliminar permanentemente la escena \"${cenasAlvoContextMenu[0]}\"?',\r\n        :js_renomear_cena => 'Renombrar Escena',\r\n        :js_guardar => 'Guardar',\r\n        :js_mover_cenas_qtd => 'Mover ${cenasAlvoContextMenu.length} Escenas',\r\n        :js_mover_para_grupo => 'Mover al Grupo',\r\n        :js_selecione_destino => 'Seleccione el grupo de destino:',\r\n        :js_criar_novo_grupo_opt => '+ Crear Nuevo Grupo...',\r\n        :js_mover => 'Mover',\r\n        :js_agrupar_qtd => 'Agrupar ${cenasAlvoContextMenu.length} Escenas',\r\n        :js_nome_novo_grupo => 'Nombre del nuevo grupo:',\r\n        :js_criar_mover => 'Crear y Mover'\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    @dialog = nil\r\n\r\n    def self.executar\r\n      mostrar_painel\r\n    end\r\n\r\n    def self.mostrar_painel\r\n      if @dialog && @dialog.visible?\r\n        @dialog.bring_to_front\r\n        return\r\n      end\r\n\r\n      @dialog = UI::HtmlDialog.new(\r\n        {\r\n          :dialog_title => obter_texto(:dialog_title),\r\n          :preferences_key => \"com.hd.scenemanager.ui\",\r\n          :scrollable => true,\r\n          :resizable => true,\r\n          :width => 380,\r\n          :height => 720,\r\n          :style => UI::HtmlDialog::STYLE_DIALOG\r\n        }\r\n      )\r\n\r\n      @dialog.set_html(html_interface)\r\n      configurar_callbacks(@dialog)\r\n      @dialog.show\r\n    end\r\n\r\n    # =================================================================\r\n    # SISTEMA DE ARQUIVOS DE TEMPLATES\r\n    # =================================================================\r\n    def self.caminho_arquivo_templates\r\n      File.join(Dir.home, 'HillDantas_TemplatesCenas.json')\r\n    end\r\n\r\n    def self.obter_templates\r\n      default_templates = {\r\n        obter_texto(:arq_padrao) => {\r\n          obter_texto(:plantas) => [obter_texto(:planta_baixa), obter_texto(:planta_cob)],\r\n          obter_texto(:cortes) => [obter_texto(:corte_aa), obter_texto(:corte_bb)],\r\n          obter_texto(:fachadas) => [obter_texto(:fachada_prin)],\r\n          obter_texto(:perspectivas) => [obter_texto(:isometrica)]\r\n        },\r\n        obter_texto(:int_padrao) => {\r\n          obter_texto(:plantas) => [obter_texto(:planta_layout), obter_texto(:planta_forro), obter_texto(:planta_pisos)],\r\n          obter_texto(:detalhamento) => [obter_texto(:marcenaria_01), obter_texto(:marcenaria_02)],\r\n          obter_texto(:vistas) => [obter_texto(:vista_int_01), obter_texto(:vista_int_02)]\r\n        }\r\n      }\r\n      \r\n      if File.exist?(caminho_arquivo_templates)\r\n        begin\r\n          return JSON.parse(File.read(caminho_arquivo_templates))\r\n        rescue\r\n          return default_templates\r\n        end\r\n      end\r\n      \r\n      default_templates\r\n    end\r\n\r\n    def self.salvar_templates_arquivo(hash_templates)\r\n      File.write(caminho_arquivo_templates, hash_templates.to_json)\r\n    end\r\n    # =================================================================\r\n\r\n    def self.configurar_callbacks(dialog)\r\n      dialog.add_action_callback(\"carregar_dados_iniciais\") do |_|\r\n        enviar_dados_cenas()\r\n        enviar_lista_templates()\r\n      end\r\n\r\n      dialog.add_action_callback(\"carregar_cenas\") do |_|\r\n        enviar_dados_cenas \r\n      end\r\n\r\n      dialog.add_action_callback(\"salvar_template_atual\") do |_, nome_template|\r\n        templates = obter_templates()\r\n        nome_limpo = nome_template.strip\r\n        \r\n        if templates.keys.size >= 10 && !templates.key?(nome_limpo)\r\n          UI.messagebox(obter_texto(:limite_templates))\r\n          next\r\n        end\r\n\r\n        model = Sketchup.active_model\r\n        estrutura_atual = {}\r\n        \r\n        model.pages.each do |pagina|\r\n          grupo = pagina.get_attribute('GerenciadorCenas', 'grupo')\r\n          if grupo.nil? || grupo.to_s.strip.empty?\r\n            match = pagina.name.match(/^\\[(.*?)\\]\\s(.*)$/)\r\n            grupo = match ? match[1] : obter_texto(:sem_grupo)\r\n          end\r\n          \r\n          estrutura_atual[grupo] ||= []\r\n          nome_cena = pagina.name.sub(/^\\[.*?\\]\\s/, '')\r\n          estrutura_atual[grupo] << nome_cena\r\n        end\r\n\r\n        templates[nome_limpo] = estrutura_atual\r\n        salvar_templates_arquivo(templates)\r\n        enviar_lista_templates()\r\n        @dialog.execute_script(obter_texto(:toast_template_salvo) % nome_limpo)\r\n      end\r\n\r\n      dialog.add_action_callback(\"salvar_edicao_template\") do |_, nome_antigo, nome_novo, json_dados|\r\n        templates = obter_templates()\r\n        nome_novo_limpo = nome_novo.strip\r\n        dados_novos = JSON.parse(json_dados)\r\n\r\n        templates.delete(nome_antigo) if nome_antigo != nome_novo_limpo\r\n        templates[nome_novo_limpo] = dados_novos\r\n        \r\n        salvar_templates_arquivo(templates)\r\n        enviar_lista_templates()\r\n        @dialog.execute_script(obter_texto(:toast_template_atualizado))\r\n      end\r\n\r\n      dialog.add_action_callback(\"gerar_template_selecionado\") do |_, nome_template|\r\n        UI.start_timer(0.0, false) do\r\n          templates = obter_templates()\r\n          estrutura = templates[nome_template]\r\n          \r\n          if estrutura\r\n            model = Sketchup.active_model\r\n            model.start_operation(obter_texto(:op_gerar_template) % nome_template, true)\r\n            \r\n            cenas_criadas = 0\r\n            estrutura.each do |grupo, nomes|\r\n              nomes.each do |nome_cena|\r\n                unless model.pages.to_a.find { |p| p.name == nome_cena }\r\n                  nova_pagina = model.pages.add(nome_cena)\r\n                  nova_pagina.transition_time = 0.0\r\n                  nova_pagina.set_attribute('GerenciadorCenas', 'grupo', grupo)\r\n                  cenas_criadas += 1\r\n                end\r\n              end\r\n            end\r\n            model.commit_operation\r\n            \r\n            UI.start_timer(0.2, false) do\r\n              enviar_dados_cenas()\r\n              UI.messagebox(obter_texto(:msg_template_gerado) % [nome_template, cenas_criadas])\r\n            end\r\n          end\r\n        end\r\n      end\r\n\r\n      dialog.add_action_callback(\"excluir_template\") do |_, nome_template|\r\n        UI.start_timer(0.0, false) do\r\n          templates = obter_templates()\r\n          templates.delete(nome_template)\r\n          salvar_templates_arquivo(templates)\r\n          enviar_lista_templates()\r\n          @dialog.execute_script(obter_texto(:toast_template_excluido) % nome_template)\r\n        end\r\n      end\r\n\r\n      dialog.add_action_callback(\"criar_cena\") do |_, grupo, nome|\r\n        UI.start_timer(0.0, false) do\r\n          criar_cena_agrupada(grupo, nome)\r\n          enviar_dados_cenas \r\n        end\r\n      end\r\n      \r\n      dialog.add_action_callback(\"sincronizar_grupo\") do |_, grupo, tipo|\r\n        UI.start_timer(0.0, false) do\r\n          sincronizar_propriedade_grupo(grupo, tipo) \r\n        end\r\n      end\r\n\r\n      dialog.add_action_callback(\"ativar_cena\") do |_, nome_cena|\r\n        model = Sketchup.active_model\r\n        pagina = model.pages.to_a.find { |p| p.name == nome_cena }\r\n        model.pages.selected_page = pagina if pagina\r\n      end\r\n\r\n      dialog.add_action_callback(\"excluir_cena_confirmada\") do |_, nome_cena|\r\n        UI.start_timer(0.0, false) do\r\n          model = Sketchup.active_model\r\n          pagina = model.pages.to_a.find { |p| p.name == nome_cena }\r\n          if pagina\r\n            if model.pages.selected_page == pagina\r\n              pagina_segura = model.pages.to_a.find { |p| p != pagina }\r\n              model.pages.selected_page = pagina_segura if pagina_segura\r\n            end\r\n            model.pages.erase(pagina)\r\n            UI.start_timer(0.5, false) { enviar_dados_cenas }\r\n          end\r\n        end\r\n      end\r\n\r\n      dialog.add_action_callback(\"excluir_cenas_confirmadas\") do |_, nomes_cenas|\r\n        UI.start_timer(0.0, false) do\r\n          model = Sketchup.active_model\r\n          paginas_para_apagar = nomes_cenas.map { |n| model.pages.to_a.find { |p| p.name == n } }.compact\r\n          if paginas_para_apagar.include?(model.pages.selected_page)\r\n            pagina_segura = model.pages.to_a.find { |p| !paginas_para_apagar.include?(p) }\r\n            model.pages.selected_page = pagina_segura if pagina_segura\r\n          end\r\n          paginas_para_apagar.reverse.each { |pagina| model.pages.erase(pagina) }\r\n          UI.start_timer(0.5, false) { enviar_dados_cenas }\r\n        end\r\n      end\r\n\r\n      dialog.add_action_callback(\"mover_cenas_confirmadas\") do |_, nomes_cenas, novo_grupo|\r\n        UI.start_timer(0.0, false) do\r\n          model = Sketchup.active_model\r\n          model.start_operation(obter_texto(:op_mover_cenas), true)\r\n          nomes_cenas.each do |nome_cena|\r\n            pagina = model.pages.to_a.find { |p| p.name == nome_cena }\r\n            if pagina && !novo_grupo.strip.empty?\r\n              pagina.set_attribute('GerenciadorCenas', 'grupo', novo_grupo.strip)\r\n            end\r\n          end\r\n          model.commit_operation\r\n          UI.start_timer(0.1, false) { enviar_dados_cenas }\r\n        end\r\n      end\r\n\r\n      dialog.add_action_callback(\"renomear_cena_confirmada\") do |_, nome_antigo, nome_novo|\r\n        UI.start_timer(0.0, false) do\r\n          model = Sketchup.active_model\r\n          pagina = model.pages.to_a.find { |p| p.name == nome_antigo }\r\n          if pagina && !nome_novo.strip.empty?\r\n            begin\r\n              pagina.name = nome_novo.strip\r\n            rescue\r\n              UI.messagebox(obter_texto(:msg_cena_existe) % nome_novo.strip)\r\n            end\r\n            UI.start_timer(0.2, false) { enviar_dados_cenas }\r\n          end\r\n        end\r\n      end\r\n\r\n      dialog.add_action_callback(\"copiar_propriedades\") do |_, source_name, target_name, tipo|\r\n        UI.start_timer(0.0, false) do\r\n          model = Sketchup.active_model\r\n          source_page = model.pages.to_a.find { |p| p.name == source_name }\r\n          target_page = model.pages.to_a.find { |p| p.name == target_name }\r\n          if source_page && target_page\r\n            source_page.transition_time = 0.0\r\n            model.pages.selected_page = source_page\r\n            UI.start_timer(0.15, false) do\r\n              model.start_operation(obter_texto(:op_colar_prop), true)\r\n              flags = (tipo == 'camera') ? 1 : (2 | 16 | 32 | 64)\r\n              target_page.update(flags)\r\n              model.commit_operation\r\n              target_page.transition_time = 0.0\r\n              model.pages.selected_page = target_page\r\n            end\r\n          end\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.enviar_lista_templates\r\n      templates = obter_templates()\r\n      @dialog.execute_script(\"atualizarSelectTemplates(#{templates.to_json})\")\r\n    end\r\n\r\n    def self.enviar_dados_cenas\r\n      model = Sketchup.active_model\r\n      dados = {}\r\n      \r\n      model.pages.each do |pagina|\r\n        grupo = pagina.get_attribute('GerenciadorCenas', 'grupo')\r\n        if grupo.nil? || grupo.to_s.strip.empty?\r\n          match = pagina.name.match(/^\\[(.*?)\\]\\s(.*)$/)\r\n          if match\r\n            grupo = match[1]\r\n            nome_limpo = match[2]\r\n            pagina.set_attribute('GerenciadorCenas', 'grupo', grupo)\r\n            pagina.name = nome_limpo rescue nil \r\n          else\r\n            grupo = obter_texto(:sem_grupo)\r\n          end\r\n        end\r\n     \r\n        dados[grupo] ||= []\r\n        dados[grupo] << pagina.name\r\n      end\r\n      \r\n      @dialog.execute_script(\"atualizarUI(#{dados.to_json})\")\r\n    end\r\n\r\n    def self.criar_cena_agrupada(grupo, nome_cena)\r\n      return if grupo.empty? || nome_cena.empty?\r\n      model = Sketchup.active_model\r\n      model.start_operation(obter_texto(:op_criar_cena), true)\r\n      nova_pagina = model.pages.add(nome_cena)\r\n      nova_pagina.transition_time = 0.0\r\n      nova_pagina.set_attribute('GerenciadorCenas', 'grupo', grupo)\r\n      model.commit_operation\r\n    end\r\n\r\n    def self.sincronizar_propriedade_grupo(grupo_alvo, tipo)\r\n      model = Sketchup.active_model\r\n      cena_atual = model.pages.selected_page\r\n      return UI.messagebox(obter_texto(:msg_ative_cena_base)) unless cena_atual\r\n\r\n      model.start_operation(obter_texto(:op_sync_grupo) % tipo, true)\r\n      flags = tipo == \"camera\" ? 1 : (2 | 16 | 32 | 64) \r\n      contador = 0\r\n      model.pages.each do |pagina|\r\n        grupo_da_pagina = pagina.get_attribute('GerenciadorCenas', 'grupo', obter_texto(:sem_grupo))\r\n        if grupo_da_pagina == grupo_alvo && pagina != cena_atual\r\n          pagina.update(flags)\r\n          contador += 1\r\n        end\r\n      end\r\n      model.commit_operation\r\n      UI.messagebox(obter_texto(:msg_cenas_atualizadas) % [contador, grupo_alvo])\r\n    end\r\n\r\n    # --- INTERFACE HTML/CSS/JS ---\r\n    def self.html_interface\r\n      <<~HTML\r\n        <!DOCTYPE html>\r\n        <html>\r\n        <head>\r\n          <meta charset=\"UTF-8\">\r\n          <meta name=\"color-scheme\" content=\"light dark\">\r\n          <style>\r\n            :root {\r\n              --bg-body: #f4f6f8;\r\n              --bg-panel: #ffffff;\r\n              --bg-editor-grp: #f8f9fa;\r\n              --text-main: #333333;\r\n              --text-muted: #666666;\r\n              --border: #e0e0e0;\r\n              --primary: #0078d7;\r\n              --primary-hover: #005a9e;\r\n              --success: #28a745;\r\n              --danger: #dc3545;\r\n              --item-hover: #eef5fa;\r\n              --shadow: rgba(0, 0, 0, 0.08);\r\n              --modal-bg: rgba(0, 0, 0, 0.4);\r\n            }\r\n\r\n            body.dark-mode {\r\n              --bg-body: #1e1e1e;\r\n              --bg-panel: #252526;\r\n              --bg-editor-grp: #2d2d30;\r\n              --text-main: #d4d4d4;\r\n              --text-muted: #aaaaaa;\r\n              --border: #3c3c3c;\r\n              --primary: #3a96dd;\r\n              --primary-hover: #5ab0f7;\r\n              --success: #32c455;\r\n              --danger: #f04757;\r\n              --item-hover: #37373d;\r\n              --shadow: rgba(0, 0, 0, 0.3);\r\n              --modal-bg: rgba(0, 0, 0, 0.6);\r\n            }\r\n\r\n            body { font-family: 'Segoe UI', Tahoma, sans-serif; padding: 15px;\r\n                   background-color: var(--bg-body); color: var(--text-main); margin: 0; transition: background-color 0.3s, color 0.3s;\r\n            }\r\n            \r\n            .top-bar { display: flex;\r\n                       justify-content: space-between; align-items: center; margin-bottom: 10px; }\r\n            h2 { font-size: 16px;\r\n                 margin: 0; display: flex; align-items: center; gap: 8px; font-weight: 600; color: var(--text-main);\r\n            }\r\n            .theme-btn { background: var(--bg-panel); border: 1px solid var(--border); color: var(--text-main);\r\n                         border-radius: 50%; width: 32px; height: 32px; cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 5px var(--shadow);\r\n                         transition: all 0.2s; }\r\n            .theme-btn:hover { background: var(--item-hover);\r\n            }\r\n\r\n            .section-title { font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-muted);\r\n                             border-bottom: 1px solid var(--border); padding-bottom: 5px; margin: 15px 0 10px 0; display: flex; justify-content: space-between;\r\n                             align-items: center;}\r\n\r\n            .btn { background-color: var(--primary); color: white; border: none;\r\n                   padding: 8px 12px; cursor: pointer; border-radius: 6px; font-weight: bold; transition: background 0.2s; box-shadow: 0 2px 4px var(--shadow);\r\n            }\r\n            .btn:hover { background-color: var(--primary-hover);\r\n            }\r\n            .btn-success { background-color: var(--success); width: 100%;\r\n            }\r\n            .btn-success:hover { filter: brightness(0.9);\r\n            }\r\n            .btn-secondary { background-color: var(--bg-panel); color: var(--text-main); border: 1px solid var(--border);\r\n                             box-shadow: none; font-size: 12px; font-weight: 600; display: flex; align-items: center; justify-content: center;\r\n                             gap: 5px;}\r\n            .btn-secondary:hover { background-color: var(--item-hover);\r\n            }\r\n\r\n            .template-block { background: var(--bg-panel); padding: 12px; border-radius: 8px;\r\n                              border: 1px solid var(--border); margin-bottom: 5px; box-shadow: 0 2px 5px var(--shadow);\r\n            }\r\n            .template-row-1 { display: flex; gap: 8px; margin-bottom: 8px;\r\n            }\r\n            .template-row-2 { display: flex; gap: 8px;\r\n            }\r\n\r\n            .btn-inline-add { background: transparent; border: 1px solid var(--primary); color: var(--primary);\r\n                              border-radius: 4px; padding: 2px 8px; font-size: 11px; font-weight: bold; cursor: pointer; transition: 0.2s;\r\n                              margin-right: 5px;}\r\n            .btn-inline-add:hover { background: var(--primary); color: white;\r\n            }\r\n            \r\n            .btn-sync { background-color: var(--bg-body);\r\n                        color: var(--text-main); border: 1px solid var(--border); padding: 5px 10px; font-size: 11px; margin-right: 5px; border-radius: 4px; cursor: pointer; transition: all 0.2s;\r\n            }\r\n            .btn-sync:hover { background-color: var(--item-hover); border-color: var(--primary);\r\n            }\r\n            .btn-refresh { background-color: transparent; border: 1px solid var(--border); border-radius: 4px;\r\n                           padding: 3px 8px; font-size: 11px; cursor: pointer; color: var(--text-muted); transition: all 0.2s;\r\n            }\r\n            .btn-refresh:hover { background-color: var(--item-hover); color: var(--primary);\r\n            }\r\n            \r\n            .form-group { display: flex;\r\n                          gap: 8px; margin-bottom: 12px; }\r\n            input[type=\"text\"], select { flex: 1;\r\n                                         padding: 8px 10px; border: 1px solid var(--border); border-radius: 6px; background-color: var(--bg-panel); color: var(--text-main); font-family: inherit; outline: none; transition: border 0.2s;\r\n                                         font-size: 13px;}\r\n            input[type=\"text\"]:focus, select:focus { border-color: var(--primary);\r\n            }\r\n            \r\n            details { background: var(--bg-panel);\r\n                      padding: 10px; border-radius: 8px; margin-bottom: 12px; box-shadow: 0 2px 6px var(--shadow); border: 1px solid var(--border); transition: all 0.2s;\r\n            }\r\n            summary { font-weight: 600; cursor: pointer; outline: none; margin-bottom: 5px;\r\n                      color: var(--text-main); font-size: 14px; display: flex; align-items: center; justify-content: space-between; user-select: none;\r\n            }\r\n            summary::-webkit-details-marker { display:none;\r\n            }\r\n            .summary-content { display: flex; align-items: center; gap: 8px; flex: 1;\r\n            }\r\n            .summary-arrow { color: var(--text-muted); transition: transform 0.2s;\r\n                             margin-left: 5px;}\r\n            details[open] .summary-arrow { transform: rotate(180deg);\r\n            }\r\n            \r\n            ul { list-style-type: none;\r\n                 padding: 0; margin: 8px 0 0 0; }\r\n            li { display: flex;\r\n                 align-items: center; padding: 8px 10px; border-radius: 6px; font-size: 13px; color: var(--text-main); cursor: pointer; transition: background 0.1s; margin-bottom: 2px;\r\n            }\r\n            li:hover { background-color: var(--item-hover);\r\n            }\r\n            .scene-cb { margin-right: 10px; cursor: pointer; width: 15px; height: 15px;\r\n                        accent-color: var(--primary); }\r\n            .cena-nome { flex: 1; overflow: hidden; text-overflow: ellipsis;\r\n                         white-space: nowrap; }\r\n\r\n            .actions { margin-top: 12px; display: flex;\r\n                       border-top: 1px solid var(--border); padding-top: 10px; }\r\n\r\n            #contextMenu {\r\n              display: none;\r\n              position: absolute; background: var(--bg-panel); border: 1px solid var(--border); \r\n              box-shadow: 0 4px 12px var(--shadow); border-radius: 6px; padding: 6px 0; z-index: 1000;\r\n              min-width: 190px;\r\n            }\r\n            .cm-item { padding: 8px 16px; font-size: 13px;\r\n                       cursor: pointer; position: relative; color: var(--text-main); display: flex; align-items: center; gap: 8px;\r\n            }\r\n            .cm-item:hover { background-color: var(--primary); color: white;\r\n            }\r\n            .cm-item.danger:hover { background-color: var(--danger); color: white;\r\n            }\r\n            \r\n            .has-submenu::after { content: \"▸\";\r\n                                  margin-left: auto; font-size: 16px; }\r\n            .submenu { display: none; position: absolute;\r\n                       left: 100%; top: -1px; background: var(--bg-panel); border: 1px solid var(--border); box-shadow: 0 4px 12px var(--shadow); border-radius: 6px; padding: 6px 0;\r\n                       min-width: 150px; }\r\n            .has-submenu:hover .submenu { display: block;\r\n            }\r\n            .submenu-item { padding: 8px 16px; color: var(--text-main); font-size: 13px;\r\n                            display: flex; align-items: center; gap: 8px;}\r\n            .submenu-item:hover { background-color: var(--primary);\r\n                                  color: white; }\r\n\r\n            #menuColar { display: none; color: var(--primary); font-weight: bold;\r\n                         border-top: 1px solid var(--border); margin-top: 4px; padding-top: 8px; }\r\n            #menuColar:hover { background-color: var(--primary);\r\n                               color: white; }\r\n\r\n            /* Modais */\r\n            .modal-overlay { display: none;\r\n                             position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--modal-bg); z-index: 2000; align-items: center; justify-content: center; backdrop-filter: blur(2px);\r\n            }\r\n            .modal-box { background: var(--bg-panel); padding: 20px; border-radius: 10px; width: 85%;\r\n                         max-width: 320px; box-shadow: 0 10px 25px rgba(0,0,0,0.2); border: 1px solid var(--border);\r\n            }\r\n            .modal-box h3 { margin-top: 0; font-size: 16px; margin-bottom: 12px;\r\n                            color: var(--text-main); }\r\n            .modal-buttons { display: flex; justify-content: flex-end; gap: 10px;\r\n                             margin-top: 20px; }\r\n            .btn-cancel { background: transparent; color: var(--text-muted);\r\n                          border: 1px solid var(--border); padding: 8px 14px; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600;\r\n            }\r\n            .btn-cancel:hover { background: var(--bg-body); color: var(--text-main);\r\n            }\r\n            .btn-confirm-modal { background: var(--primary); color: white; padding: 8px 14px;\r\n                                 border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600;\r\n            }\r\n            .btn-danger-modal { background: var(--danger); color: white; padding: 8px 14px;\r\n                                border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600;\r\n            }\r\n            \r\n            .tpl-list-item { display: flex;\r\n                             justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid var(--border); font-size: 13px; color: var(--text-main);\r\n            }\r\n            .tpl-list-item:last-child { border-bottom: none;\r\n            }\r\n            .tpl-actions { display: flex; gap: 5px;\r\n            }\r\n            .tpl-btn-edit { color: var(--primary); cursor: pointer; font-weight: bold;\r\n                            padding: 4px 8px; border-radius: 4px; transition: 0.2s; border: 1px solid transparent;}\r\n            .tpl-btn-edit:hover { background: var(--primary);\r\n                                  color: white; }\r\n            .tpl-btn-delete { color: var(--danger); cursor: pointer; font-weight: bold;\r\n                              padding: 4px 8px; border-radius: 4px; transition: 0.2s;}\r\n            .tpl-btn-delete:hover { background: var(--danger);\r\n                                    color: white; }\r\n\r\n            /* EDITOR VISUAL DE TEMPLATE */\r\n            .edit-area { max-height: 400px;\r\n                         overflow-y: auto; padding-right: 5px; margin-top: 15px;}\r\n            .edit-grp-block { background: var(--bg-editor-grp);\r\n                              border: 1px solid var(--border); border-radius: 6px; padding: 10px; margin-bottom: 10px;\r\n            }\r\n            .edit-grp-header { display: flex; gap: 8px; align-items: center; margin-bottom: 8px;\r\n            }\r\n            .edit-grp-input { font-weight: bold; flex: 1; padding: 6px !important;\r\n            }\r\n            .edit-scn-list { margin-left: 15px; border-left: 2px solid var(--border); padding-left: 10px;\r\n                             margin-bottom: 8px; }\r\n            .edit-scn-item { display: flex; gap: 8px; align-items: center;\r\n                             margin-bottom: 5px; }\r\n            .edit-scn-input { flex: 1; padding: 5px !important;\r\n                              font-size: 12px !important; }\r\n            .btn-icon-del { background: transparent; border: none;\r\n                            color: var(--danger); cursor: pointer; font-size: 14px; padding: 4px; border-radius: 4px;\r\n            }\r\n            .btn-icon-del:hover { background: var(--danger); color: white;\r\n            }\r\n            .btn-add-mini { background: transparent; border: 1px dashed var(--primary); color: var(--primary);\r\n                            padding: 4px 8px; border-radius: 4px; font-size: 11px; cursor: pointer; font-weight: bold; width: 100%; text-align: left;\r\n                            transition: 0.2s;}\r\n            .btn-add-mini:hover { background: var(--primary); color: white; border-style: solid;\r\n            }\r\n\r\n            #toast { visibility: hidden; min-width: 200px; background-color: var(--text-main); color: var(--bg-panel);\r\n                     text-align: center; border-radius: 6px; padding: 12px; position: fixed; z-index: 3000; left: 50%; bottom: 20px; transform: translateX(-50%); font-size: 13px; font-weight: bold;\r\n                     opacity: 0; transition: opacity 0.3s, bottom 0.3s; box-shadow: 0 4px 10px var(--shadow);\r\n            }\r\n            #toast.show { visibility: visible; opacity: 1; bottom: 40px;\r\n            }\r\n          </style>\r\n        </head>\r\n        <body>\r\n\r\n          <div class=\"top-bar\">\r\n            <h2>#{obter_texto(:html_titulo_painel)}</h2>\r\n            <button class=\"theme-btn\" id=\"btnTheme\" onclick=\"toggleTheme()\" title=\"#{obter_texto(:title_alt_tema)}\">🌙</button>\r\n          </div>\r\n\r\n          <div class=\"template-block\">\r\n            <div class=\"template-row-1\">\r\n              <select id=\"selectTemplateAtual\"></select>\r\n              <button class=\"btn\" style=\"flex: 0 0 45px; padding: 0; font-size: 18px;\"\r\n                      onclick=\"acionarGerarTemplate()\" title=\"#{obter_texto(:title_gerar_template)}\">⚡</button>\r\n            </div>\r\n            <div class=\"template-row-2\">\r\n              <button class=\"btn btn-secondary\" style=\"flex: 1;\"\r\n                      onclick=\"abrirModalSalvarTemplate()\">#{obter_texto(:btn_salvar_modelo)}</button>\r\n              <button class=\"btn btn-secondary\" style=\"flex: 0 0 45px; padding: 0; font-size: 16px;\"\r\n                      onclick=\"abrirModalGerenciarTemplates()\" title=\"#{obter_texto(:title_gerenciar_templates)}\">⚙️</button>\r\n            </div>\r\n          </div>\r\n          \r\n          <div class=\"section-title\">#{obter_texto(:html_criar_nova_cena)}</div>\r\n          <div class=\"form-group\">\r\n            <input type=\"text\" id=\"grupoInput\" placeholder=\"#{obter_texto(:placeholder_grupo)}\">\r\n            <input type=\"text\" id=\"nomeInput\" placeholder=\"#{obter_texto(:placeholder_nome)}\" onkeypress=\"handleEnter(event)\">\r\n          </div>\r\n          <button class=\"btn btn-success\" onclick=\"criarCena()\">#{obter_texto(:btn_add_cena)}</button>\r\n\r\n          <div class=\"section-title\">\r\n            #{obter_texto(:html_suas_cenas)} \r\n            <button class=\"btn-refresh\" onclick=\"sketchup.carregar_cenas()\" title=\"#{obter_texto(:title_atualizar)}\">#{obter_texto(:btn_atualizar)}</button>\r\n          </div>\r\n          <div id=\"listaCenas\">#{obter_texto(:html_carregando)}</div>\r\n\r\n          <div id=\"contextMenu\">\r\n            <div class=\"cm-item\" id=\"cm-agrupar\" onclick=\"acionarMenu('agrupar_bulk')\" style=\"font-weight: bold; color: var(--primary); border-bottom: 1px solid var(--border); padding-bottom: 8px;\r\n                 margin-bottom: 3px;\">#{obter_texto(:menu_criar_grupo_sel)}</div>\r\n            <div class=\"cm-item\" id=\"cm-mover\" onclick=\"acionarMenu('mover')\">#{obter_texto(:menu_mover_grupo)}</div>\r\n            <div class=\"cm-item\" id=\"cm-renomear\" onclick=\"acionarMenu('renomear')\">#{obter_texto(:menu_renomear)}</div>\r\n            <div class=\"cm-item has-submenu\" id=\"cm-copiar\">#{obter_texto(:menu_copiar_prop)}\r\n              <div class=\"submenu\">\r\n                <div class=\"submenu-item\" onclick=\"acionarCopiar('camera')\">#{obter_texto(:menu_copiar_cam)}</div>\r\n                <div class=\"submenu-item\" onclick=\"acionarCopiar('estilo_tags')\">#{obter_texto(:menu_copiar_estilo)}</div>\r\n              </div>\r\n            </div>\r\n            <div class=\"cm-item\" id=\"menuColar\" onclick=\"acionarColar()\">#{obter_texto(:menu_colar_prop)}</div>\r\n            <div class=\"cm-item danger\" id=\"cm-excluir\" onclick=\"acionarMenu('excluir')\" style=\"border-top: 1px solid var(--border);\r\n                 margin-top: 3px; padding-top: 8px;\">#{obter_texto(:menu_excluir_cena)}</div>\r\n          </div>\r\n\r\n          <div id=\"modalOverlay\" class=\"modal-overlay\">\r\n            <div class=\"modal-box\">\r\n              <h3 id=\"modalTitle\">#{obter_texto(:modal_titulo_default)}</h3>\r\n              <input type=\"text\" id=\"modalInput\" style=\"display:none; width: 100%; box-sizing: border-box;\">\r\n              <p id=\"modalText\" style=\"font-size: 13px; color: var(--text-muted); margin-bottom: 5px; display:none;\"></p>\r\n              <div id=\"moverContainer\" style=\"display:none; margin-top: 10px;\">\r\n                <select id=\"selectGrupo\" style=\"width: 100%; margin-bottom: 10px;\"></select>\r\n                <input type=\"text\" id=\"inputNovoGrupo\" placeholder=\"#{obter_texto(:placeholder_novo_grupo)}\" style=\"display:none; width: 100%; box-sizing: border-box;\">\r\n              </div>\r\n              <div class=\"modal-buttons\">\r\n                <button class=\"btn-cancel\" onclick=\"fecharModal()\">#{obter_texto(:btn_cancelar)}</button>\r\n                <button id=\"modalBtnConfirm\" class=\"btn-confirm-modal\" onclick=\"confirmarModal()\">#{obter_texto(:btn_ok)}</button>\r\n              </div>\r\n            </div>\r\n          </div>\r\n\r\n          <div id=\"modalGerenciarTemplates\" class=\"modal-overlay\">\r\n            <div class=\"modal-box\" style=\"width: 90%; max-width: 350px;\">\r\n              <h3>#{obter_texto(:html_gerenciar_templates)}</h3>\r\n              <div id=\"listaGerenciarTemplates\" style=\"max-height: 300px; overflow-y: auto; background: var(--bg-body); border: 1px solid var(--border); border-radius: 6px;\"></div>\r\n              <div class=\"modal-buttons\">\r\n                <button class=\"btn-cancel\" onclick=\"fecharModalTemplates()\">#{obter_texto(:btn_fechar)}</button>\r\n              </div>\r\n            </div>\r\n          </div>\r\n\r\n          <div id=\"modalEditorVisual\" class=\"modal-overlay\">\r\n            <div class=\"modal-box\" style=\"width: 95%; max-width: 450px;\">\r\n              <h3>#{obter_texto(:html_editor_template)}</h3>\r\n              <p style=\"font-size: 11px; color: var(--text-muted); margin-top: -10px; margin-bottom: 10px;\">#{obter_texto(:html_edite_nomes)}</p>\r\n              \r\n              <label style=\"font-size: 12px; font-weight: bold; color: var(--text-muted);\">#{obter_texto(:html_nome_template)}</label>\r\n              <input type=\"text\" id=\"editTplName\" style=\"font-weight: bold; color: var(--primary); margin-bottom: 10px;\">\r\n              \r\n              <div class=\"edit-area\" id=\"editTplContent\"></div>\r\n              \r\n              <button class=\"btn-add-mini\" style=\"text-align: center; padding: 8px; margin-top: 10px;\" onclick=\"adicionarGrupoVazioNoEditor()\">#{obter_texto(:btn_criar_novo_grupo)}</button>\r\n\r\n              <div class=\"modal-buttons\">\r\n                <button class=\"btn-cancel\" onclick=\"fecharEditorVisual()\">#{obter_texto(:btn_cancelar)}</button>\r\n                <button class=\"btn-confirm-modal\" onclick=\"salvarEditorVisual()\">#{obter_texto(:btn_salvar_alt)}</button>\r\n              </div>\r\n            </div>\r\n          </div>\r\n\r\n          <div id=\"toast\">#{obter_texto(:html_notificacao)}</div>\r\n\r\n          <script>\r\n            let objetoTemplates = {}; \r\n            let nomeTemplateEmEdicao = \"\";\r\n\r\n            function toggleTheme() {\r\n              const body = document.body;\r\n              body.classList.toggle('dark-mode');\r\n              const isDark = body.classList.contains('dark-mode');\r\n              localStorage.setItem('hd_theme', isDark ? 'dark' : 'light');\r\n              document.getElementById('btnTheme').textContent = isDark ? '☀️' : '🌙';\r\n            }\r\n\r\n            function obterIcone(grupo) {\r\n              const nome = grupo.toLowerCase();\r\n              if (nome.includes('planta') || nome.includes('plan')) return '📐';\r\n              if (nome.includes('corte') || nome.includes('seção') || nome.includes('secção') || nome.includes('section')) return '✂️';\r\n              if (nome.includes('fachada') || nome.includes('elevação') || nome.includes('elevation')) return '🏠';\r\n              if (nome.includes('perspectiva') || nome.includes('3d') || nome.includes('vista') || nome.includes('view') || nome.includes('perspective')) return '👁️';\r\n              if (nome.includes('marcenaria') || nome.includes('detalhe') || nome.includes('millwork') || nome.includes('detail') || nome.includes('carpintería') || nome.includes('detalle')) return '🪚';\r\n              if (nome.includes('forro') || nome.includes('teto') || nome.includes('ceiling') || nome.includes('techo')) return '💡';\r\n              if (nome === \"#{obter_texto(:sem_grupo)}\") return '📁';\r\n              return '📂';\r\n            }\r\n\r\n            let cenasAlvoContextMenu = [];\r\n            let modalAcao = \"\";\r\n            let modalAlvo = \"\";\r\n            let cenaCopiada = null;\r\n            let tipoCopiado = null;\r\n            let gruposAtuais = []; \r\n\r\n            window.onload = function() { \r\n              if (localStorage.getItem('hd_theme') === 'dark') {\r\n                document.body.classList.add('dark-mode');\r\n                document.getElementById('btnTheme').textContent = '☀️';\r\n              }\r\n              sketchup.carregar_dados_iniciais(); \r\n            };\r\n            function handleEnter(e) { if(e.key === 'Enter') criarCena(); }\r\n\r\n            document.addEventListener('click', function(e) {\r\n              const menu = document.getElementById('contextMenu');\r\n              if (!menu.contains(e.target)) { menu.style.display = 'none'; }\r\n            });\r\n            document.getElementById('selectGrupo').addEventListener('change', function() {\r\n              if (this.value === 'novo') {\r\n                document.getElementById('inputNovoGrupo').style.display = 'block';\r\n                document.getElementById('inputNovoGrupo').focus();\r\n              } else {\r\n                document.getElementById('inputNovoGrupo').style.display = 'none';\r\n              }\r\n            });\r\n\r\n            function mostrarToast(mensagem) {\r\n              const toast = document.getElementById(\"toast\");\r\n              toast.textContent = mensagem;\r\n              toast.className = \"show\";\r\n              setTimeout(function(){ toast.className = toast.className.replace(\"show\", \"\"); }, 2500);\r\n            }\r\n\r\n            function prepararNovaCenaNoGrupo(grupo) {\r\n              const grupoAlvo = (grupo === \"#{obter_texto(:sem_grupo)}\") ? \"\" : grupo;\r\n              document.getElementById('grupoInput').value = grupoAlvo;\r\n              document.getElementById('nomeInput').focus();\r\n            }\r\n\r\n            function atualizarSelectTemplates(templatesHash) {\r\n              objetoTemplates = templatesHash;\r\n              const nomesTemplates = Object.keys(templatesHash);\r\n              \r\n              const select = document.getElementById('selectTemplateAtual');\r\n              select.innerHTML = '';\r\n              if (nomesTemplates.length === 0) {\r\n                const opt = document.createElement('option');\r\n                opt.textContent = \"#{obter_texto(:js_nenhum_template)}\";\r\n                select.appendChild(opt);\r\n                return;\r\n              }\r\n\r\n              nomesTemplates.forEach(t => {\r\n                const opt = document.createElement('option');\r\n                opt.value = t;\r\n                opt.textContent = `📁 ${t}`;\r\n                select.appendChild(opt);\r\n              });\r\n            }\r\n\r\n            function acionarGerarTemplate() {\r\n              const select = document.getElementById('selectTemplateAtual');\r\n              if (select.value && select.value !== \"#{obter_texto(:js_nenhum_template)}\") {\r\n                sketchup.gerar_template_selecionado(select.value);\r\n              }\r\n            }\r\n\r\n            function abrirModalSalvarTemplate() {\r\n              modalAcao = \"salvar_template\";\r\n              document.getElementById('modalTitle').textContent = \"#{obter_texto(:btn_salvar_modelo)}\";\r\n              document.getElementById('modalText').style.display = 'block';\r\n              document.getElementById('modalText').textContent = \"#{obter_texto(:js_estrutura_atual)}\";\r\n              document.getElementById('modalInput').style.display = 'block';\r\n              document.getElementById('modalInput').value = '';\r\n              document.getElementById('moverContainer').style.display = 'none';\r\n              \r\n              const btn = document.getElementById('modalBtnConfirm');\r\n              btn.className = 'btn-confirm-modal';\r\n              btn.textContent = \"#{obter_texto(:js_salvar_template)}\";\r\n              document.getElementById('modalOverlay').style.display = 'flex';\r\n              document.getElementById('modalInput').focus();\r\n            }\r\n\r\n            function abrirModalGerenciarTemplates() {\r\n              const container = document.getElementById('listaGerenciarTemplates');\r\n              container.innerHTML = '';\r\n              const nomes = Object.keys(objetoTemplates);\r\n\r\n              if (nomes.length === 0) {\r\n                container.innerHTML = `<p style=\"font-size: 12px; color: var(--text-muted); text-align: center; padding: 10px;\">#{obter_texto(:js_vazio)}</p>`;\r\n              } else {\r\n                nomes.forEach(t => {\r\n                  const div = document.createElement('div');\r\n                  div.className = 'tpl-list-item';\r\n                  \r\n                  const span = document.createElement('span');\r\n                  span.textContent = t;\r\n                  span.style.fontWeight = \"bold\";\r\n                  \r\n                  const actions = document.createElement('div');\r\n                  actions.className = 'tpl-actions';\r\n\r\n                  const btnEdit = document.createElement('span');\r\n                  btnEdit.className = 'tpl-btn-edit';\r\n                  btnEdit.innerHTML = \"#{obter_texto(:js_editar)}\";\r\n                  btnEdit.onclick = () => {\r\n                    fecharModalTemplates();\r\n                    abrirEditorVisual(t);\r\n                  };\r\n                  \r\n                  const btnExcluir = document.createElement('span');\r\n                  btnExcluir.className = 'tpl-btn-delete';\r\n                  btnExcluir.innerHTML = '🗑️';\r\n                  btnExcluir.title = \"#{obter_texto(:js_excluir_template_title)}\";\r\n                  btnExcluir.onclick = () => {\r\n                    fecharModalTemplates();\r\n                    modalAcao = \"excluir_template\";\r\n                    modalAlvo = t;\r\n                    document.getElementById('modalTitle').textContent = \"#{obter_texto(:js_aviso_exclusao)}\";\r\n                    document.getElementById('modalText').style.display = 'block';\r\n                    document.getElementById('modalText').textContent = `#{obter_texto(:js_msg_excluir_template)}`;\r\n                    document.getElementById('modalInput').style.display = 'none';\r\n                    document.getElementById('moverContainer').style.display = 'none';\r\n                    const btnConf = document.getElementById('modalBtnConfirm');\r\n                    btnConf.className = 'btn-danger-modal';\r\n                    btnConf.textContent = \"#{obter_texto(:js_excluir)}\";\r\n                    document.getElementById('modalOverlay').style.display = 'flex';\r\n                  };\r\n\r\n                  actions.appendChild(btnEdit);\r\n                  actions.appendChild(btnExcluir);\r\n                  div.appendChild(span);\r\n                  div.appendChild(actions);\r\n                  container.appendChild(div);\r\n                });\r\n              }\r\n              document.getElementById('modalGerenciarTemplates').style.display = 'flex';\r\n            }\r\n\r\n            function fecharModalTemplates() {\r\n              document.getElementById('modalGerenciarTemplates').style.display = 'none';\r\n            }\r\n\r\n            function abrirEditorVisual(nomeTpl) {\r\n              nomeTemplateEmEdicao = nomeTpl;\r\n              document.getElementById('editTplName').value = nomeTpl;\r\n              \r\n              const estrutura = objetoTemplates[nomeTpl];\r\n              const container = document.getElementById('editTplContent');\r\n              container.innerHTML = '';\r\n              for (const [grupo, cenas] of Object.entries(estrutura)) {\r\n                if (grupo === \"#{obter_texto(:sem_grupo)}\") continue;\r\n                container.appendChild(criarBlocoGrupoEditor(grupo, cenas));\r\n              }\r\n              \r\n              document.getElementById('modalEditorVisual').style.display = 'flex';\r\n            }\r\n\r\n            function criarBlocoGrupoEditor(nomeGrupo, arrayCenas) {\r\n              const divGrp = document.createElement('div');\r\n              divGrp.className = 'edit-grp-block';\r\n\r\n              const header = document.createElement('div');\r\n              header.className = 'edit-grp-header';\r\n              \r\n              const inputGrp = document.createElement('input');\r\n              inputGrp.type = 'text';\r\n              inputGrp.className = 'edit-grp-input';\r\n              inputGrp.value = nomeGrupo;\r\n              inputGrp.placeholder = \"#{obter_texto(:js_nome_grupo)}\";\r\n\r\n              const btnDelGrp = document.createElement('button');\r\n              btnDelGrp.className = 'btn-icon-del';\r\n              btnDelGrp.innerHTML = '🗑️';\r\n              btnDelGrp.title = \"#{obter_texto(:js_apagar_grupo)}\";\r\n              btnDelGrp.onclick = () => divGrp.remove();\r\n\r\n              header.appendChild(inputGrp);\r\n              header.appendChild(btnDelGrp);\r\n              divGrp.appendChild(header);\r\n\r\n              const divList = document.createElement('div');\r\n              divList.className = 'edit-scn-list';\r\n              arrayCenas.forEach(cena => {\r\n                divList.appendChild(criarLinhaCenaEditor(cena));\r\n              });\r\n              divGrp.appendChild(divList);\r\n\r\n              const btnAddScn = document.createElement('button');\r\n              btnAddScn.className = 'btn-add-mini';\r\n              btnAddScn.innerHTML = \"#{obter_texto(:js_nova_cena_grupo)}\";\r\n              btnAddScn.onclick = () => {\r\n                const novaLinha = criarLinhaCenaEditor(\"\");\r\n                divList.appendChild(novaLinha);\r\n                novaLinha.querySelector('input').focus();\r\n              };\r\n              divGrp.appendChild(btnAddScn);\r\n\r\n              return divGrp;\r\n            }\r\n\r\n            function criarLinhaCenaEditor(nomeCena) {\r\n              const item = document.createElement('div');\r\n              item.className = 'edit-scn-item';\r\n\r\n              const inputScn = document.createElement('input');\r\n              inputScn.type = 'text';\r\n              inputScn.className = 'edit-scn-input';\r\n              inputScn.value = nomeCena;\r\n              inputScn.placeholder = \"#{obter_texto(:js_nome_cena)}\";\r\n\r\n              const btnDelScn = document.createElement('button');\r\n              btnDelScn.className = 'btn-icon-del';\r\n              btnDelScn.innerHTML = '✕';\r\n              btnDelScn.onclick = () => item.remove();\r\n              item.appendChild(inputScn);\r\n              item.appendChild(btnDelScn);\r\n              return item;\r\n            }\r\n\r\n            function adicionarGrupoVazioNoEditor() {\r\n              const container = document.getElementById('editTplContent');\r\n              const novoGrp = criarBlocoGrupoEditor(\"\", [\"\"]);\r\n              container.appendChild(novoGrp);\r\n              novoGrp.querySelector('.edit-grp-input').focus();\r\n              container.scrollTop = container.scrollHeight;\r\n            }\r\n\r\n            function fecharEditorVisual() {\r\n              document.getElementById('modalEditorVisual').style.display = 'none';\r\n            }\r\n\r\n            function salvarEditorVisual() {\r\n              const nomeNovo = document.getElementById('editTplName').value.trim();\r\n              if (!nomeNovo) {\r\n                mostrarToast(\"#{obter_texto(:js_template_sem_nome)}\");\r\n                return;\r\n              }\r\n\r\n              const novoJSON = {};\r\n              const blocosGrupo = document.querySelectorAll('.edit-grp-block');\r\n              \r\n              blocosGrupo.forEach(bloco => {\r\n                const nomeGrp = bloco.querySelector('.edit-grp-input').value.trim();\r\n                if (!nomeGrp) return; \r\n                \r\n                if (!novoJSON[nomeGrp]) novoJSON[nomeGrp] = [];\r\n                \r\n                const inputsCena = bloco.querySelectorAll('.edit-scn-input');\r\n                inputsCena.forEach(input => {\r\n                  const val = input.value.trim();\r\n                  if (val) novoJSON[nomeGrp].push(val);\r\n                });\r\n              });\r\n              sketchup.salvar_edicao_template(nomeTemplateEmEdicao, nomeNovo, JSON.stringify(novoJSON));\r\n              fecharEditorVisual();\r\n            }\r\n\r\n            function atualizarUI(dados) {\r\n              const container = document.getElementById('listaCenas');\r\n              container.innerHTML = '';\r\n              gruposAtuais = Object.keys(dados);\r\n\r\n              if (gruposAtuais.length === 0) {\r\n                container.innerHTML = `<p style=\"font-size: 13px; color: var(--text-muted); text-align: center; padding: 20px 0;\">#{obter_texto(:js_nenhuma_cena)}</p>`;\r\n                return;\r\n              }\r\n\r\n              for (const [grupo, cenas] of Object.entries(dados)) {\r\n                const details = document.createElement('details');\r\n                details.open = true;\r\n                \r\n                const summary = document.createElement('summary');\r\n                const icone = obterIcone(grupo);\r\n                \r\n                const divContent = document.createElement('div');\r\n                divContent.className = 'summary-content';\r\n                if(grupo === \"#{obter_texto(:sem_grupo)}\") {\r\n                  divContent.innerHTML = `${icone} #{obter_texto(:js_cenas_soltas)} <span style=\"color:var(--text-muted); font-size:12px; font-weight:normal;\">(${cenas.length})</span>`;\r\n                } else {\r\n                  divContent.innerHTML = `${icone} ${grupo} <span style=\"color:var(--text-muted); font-size:12px; font-weight:normal;\">(${cenas.length})</span>`;\r\n                }\r\n\r\n                const rightWrapper = document.createElement('div');\r\n                rightWrapper.style.display = 'flex';\r\n                rightWrapper.style.alignItems = 'center';\r\n\r\n                if(grupo !== \"#{obter_texto(:sem_grupo)}\") {\r\n                  const btnAddInline = document.createElement('button');\r\n                  btnAddInline.className = 'btn-inline-add';\r\n                  btnAddInline.textContent = \"#{obter_texto(:js_nova)}\";\r\n                  btnAddInline.title = `#{obter_texto(:js_add_nova_cena_em)}`;\r\n                  btnAddInline.onclick = (e) => {\r\n                    e.stopPropagation();\r\n                    prepararNovaCenaNoGrupo(grupo);\r\n                  };\r\n                  rightWrapper.appendChild(btnAddInline);\r\n                }\r\n\r\n                const arrow = document.createElement('span');\r\n                arrow.className = 'summary-arrow';\r\n                arrow.textContent = '▾';\r\n                rightWrapper.appendChild(arrow);\r\n\r\n                summary.appendChild(divContent);\r\n                summary.appendChild(rightWrapper);\r\n                details.appendChild(summary);\r\n\r\n                const ul = document.createElement('ul');\r\n                cenas.forEach(cena => {\r\n                  const li = document.createElement('li');\r\n                  \r\n                  const cb = document.createElement('input');\r\n                  cb.type = 'checkbox';\r\n                  cb.className = 'scene-cb';\r\n          \r\n                  cb.value = cena;\r\n                  cb.onclick = (e) => e.stopPropagation();\r\n                  \r\n                  const nomeSpan = document.createElement('span');\r\n                  nomeSpan.className = 'cena-nome';\r\n                  nomeSpan.textContent = cena;\r\n                  \r\n                  li.appendChild(cb);\r\n                  li.appendChild(nomeSpan);\r\n                  \r\n                  nomeSpan.onclick = () => sketchup.ativar_cena(cena);\r\n                 \r\n                  li.oncontextmenu = (e) => {\r\n                    e.preventDefault();\r\n                    const marcadas = Array.from(document.querySelectorAll('.scene-cb:checked')).map(el => el.value);\r\n                    \r\n                    if (marcadas.includes(cena) && marcadas.length > 1) {\r\n                      cenasAlvoContextMenu = marcadas;\r\n                      configurarMenuEmMassa(marcadas.length);\r\n                    } else {\r\n                      cenasAlvoContextMenu = [cena];\r\n                      configurarMenuSimples(cena);\r\n                    }\r\n\r\n                    const menu = document.getElementById('contextMenu');\r\n                    menu.style.display = 'block';\r\n                    \r\n                    let posX = e.pageX;\r\n                    let posY = e.pageY;\r\n                    if (posX + 190 > window.innerWidth) posX = window.innerWidth - 200;\r\n                    \r\n                    menu.style.left = posX + 'px';\r\n                    menu.style.top = posY + 'px';\r\n                  };\r\n                  \r\n                  ul.appendChild(li);\r\n                });\r\n                details.appendChild(ul);\r\n\r\n                if (grupo !== \"#{obter_texto(:sem_grupo)}\") {\r\n                  const actionsDiv = document.createElement('div');\r\n                  actionsDiv.className = 'actions';\r\n                  \r\n                  const btnCam = document.createElement('button');\r\n                  btnCam.className = 'btn-sync';\r\n                  btnCam.textContent = \"#{obter_texto(:js_sync_cam)}\";\r\n                  btnCam.onclick = () => sketchup.sincronizar_grupo(grupo, 'camera');\r\n\r\n                  const btnEstilo = document.createElement('button');\r\n                  btnEstilo.className = 'btn-sync';\r\n                  btnEstilo.textContent = \"#{obter_texto(:js_sync_estilos)}\";\r\n                  btnEstilo.onclick = () => sketchup.sincronizar_grupo(grupo, 'estilo_tags');\r\n\r\n                  actionsDiv.appendChild(btnCam);\r\n                  actionsDiv.appendChild(btnEstilo);\r\n                  details.appendChild(actionsDiv);\r\n                }\r\n                container.appendChild(details);\r\n              }\r\n            }\r\n\r\n            function configurarMenuEmMassa(qtd) {\r\n              document.getElementById('cm-agrupar').style.display = 'flex';\r\n              document.getElementById('cm-agrupar').innerHTML = `#{obter_texto(:js_criar_grupo_qtd)}`;\r\n              document.getElementById('cm-mover').innerHTML = `#{obter_texto(:js_mover_qtd)}`;\r\n              document.getElementById('cm-excluir').innerHTML = `#{obter_texto(:js_excluir_qtd)}`;\r\n              document.getElementById('cm-renomear').style.display = 'none';\r\n              document.getElementById('cm-copiar').style.display = 'none';\r\n              document.getElementById('menuColar').style.display = 'none';\r\n            }\r\n\r\n            function configurarMenuSimples(cenaAlvo) {\r\n              document.getElementById('cm-agrupar').style.display = 'none';\r\n              document.getElementById('cm-mover').innerHTML = \"#{obter_texto(:menu_mover_grupo)}\";\r\n              document.getElementById('cm-excluir').innerHTML = \"#{obter_texto(:menu_excluir_cena)}\";\r\n              document.getElementById('cm-renomear').style.display = 'flex';\r\n              document.getElementById('cm-copiar').style.display = 'flex';\r\n              const btnColar = document.getElementById('menuColar');\r\n              if (cenaCopiada && cenaCopiada !== cenaAlvo) {\r\n                btnColar.style.display = 'flex';\r\n                const txt = (tipoCopiado === 'camera') ? \"#{obter_texto(:js_camera)}\" : \"#{obter_texto(:js_estilo)}\";\r\n                btnColar.innerHTML = `#{obter_texto(:js_colar_de)}`;\r\n              } else {\r\n                btnColar.style.display = 'none';\r\n              }\r\n            }\r\n\r\n            function criarCena() {\r\n              const grupo = document.getElementById('grupoInput').value.trim();\r\n              const nome = document.getElementById('nomeInput').value.trim();\r\n              if (grupo && nome) {\r\n                sketchup.criar_cena(grupo, nome);\r\n                document.getElementById('nomeInput').value = ''; \r\n              }\r\n            }\r\n\r\n            function acionarCopiar(tipo) {\r\n              document.getElementById('contextMenu').style.display = 'none';\r\n              cenaCopiada = cenasAlvoContextMenu[0];\r\n              tipoCopiado = tipo;\r\n              const txt = (tipo === 'camera') ? \"#{obter_texto(:js_camera)}\" : \"#{obter_texto(:js_estilos_tags)}\";\r\n              mostrarToast(`#{obter_texto(:js_copiada_de)}`);\r\n            }\r\n\r\n            function acionarColar() {\r\n              document.getElementById('contextMenu').style.display = 'none';\r\n              if (cenaCopiada && tipoCopiado && cenasAlvoContextMenu.length === 1) {\r\n                mostrarToast(`#{obter_texto(:js_colando_em)}`);\r\n                setTimeout(() => { sketchup.copiar_propriedades(cenaCopiada, cenasAlvoContextMenu[0], tipoCopiado); }, 100);\r\n              }\r\n            }\r\n\r\n            function acionarMenu(acao) {\r\n              document.getElementById('contextMenu').style.display = 'none';\r\n              document.getElementById('modalInput').style.display = 'none';\r\n              document.getElementById('modalText').style.display = 'none';\r\n              document.getElementById('moverContainer').style.display = 'none';\r\n              \r\n              if (acao === 'excluir') {\r\n                modalAcao = \"excluir_cena\";\r\n                document.getElementById('modalTitle').textContent = cenasAlvoContextMenu.length > 1 ? \"#{obter_texto(:js_exclusao_massa)}\" : \"#{obter_texto(:js_aviso_exclusao)}\";\r\n                document.getElementById('modalText').style.display = 'block';\r\n                document.getElementById('modalText').textContent = cenasAlvoContextMenu.length > 1 \r\n                  ? `#{obter_texto(:js_msg_excluir_massa)}`\r\n                  : `#{obter_texto(:js_msg_excluir_unica)}`;\r\n                const btn = document.getElementById('modalBtnConfirm');\r\n                btn.className = 'btn-danger-modal';\r\n                btn.textContent = \"#{obter_texto(:js_excluir)}\";\r\n                document.getElementById('modalOverlay').style.display = 'flex';\r\n              } \r\n              else if (acao === 'renomear') {\r\n                modalAcao = \"renomear\";\r\n                document.getElementById('modalTitle').textContent = \"#{obter_texto(:js_renomear_cena)}\";\r\n                document.getElementById('modalInput').style.display = 'block';\r\n                document.getElementById('modalInput').value = cenasAlvoContextMenu[0];\r\n                \r\n                const btn = document.getElementById('modalBtnConfirm');\r\n                btn.className = 'btn-confirm-modal';\r\n                btn.textContent = \"#{obter_texto(:js_guardar)}\";\r\n                document.getElementById('modalOverlay').style.display = 'flex';\r\n                document.getElementById('modalInput').focus();\r\n              }\r\n              else if (acao === 'mover') {\r\n                modalAcao = \"mover\";\r\n                document.getElementById('modalTitle').textContent = cenasAlvoContextMenu.length > 1 ? `#{obter_texto(:js_mover_cenas_qtd)}` : \"#{obter_texto(:js_mover_para_grupo)}\";\r\n                document.getElementById('modalText').style.display = 'block';\r\n                document.getElementById('modalText').textContent = \"#{obter_texto(:js_selecione_destino)}\";\r\n                \r\n                const select = document.getElementById('selectGrupo');\r\n                select.innerHTML = '';\r\n                gruposAtuais.forEach(g => {\r\n                  if(g !== \"#{obter_texto(:sem_grupo)}\") {\r\n                    const opt = document.createElement('option');\r\n                    opt.value = g;\r\n                    opt.textContent = g;\r\n                    select.appendChild(opt);\r\n                  }\r\n                });\r\n                const optNovo = document.createElement('option');\r\n                optNovo.value = 'novo';\r\n                optNovo.textContent = \"#{obter_texto(:js_criar_novo_grupo_opt)}\";\r\n                select.appendChild(optNovo);\r\n                \r\n                document.getElementById('inputNovoGrupo').style.display = 'none';\r\n                document.getElementById('inputNovoGrupo').value = '';\r\n                document.getElementById('moverContainer').style.display = 'block';\r\n                \r\n                const btn = document.getElementById('modalBtnConfirm');\r\n                btn.className = 'btn-confirm-modal';\r\n                btn.textContent = \"#{obter_texto(:js_mover)}\";\r\n                document.getElementById('modalOverlay').style.display = 'flex';\r\n              }\r\n              else if (acao === 'agrupar_bulk') {\r\n                modalAcao = \"agrupar_bulk\";\r\n                document.getElementById('modalTitle').textContent = `#{obter_texto(:js_agrupar_qtd)}`;\r\n                document.getElementById('modalText').style.display = 'block';\r\n                document.getElementById('modalText').textContent = \"#{obter_texto(:js_nome_novo_grupo)}\";\r\n                \r\n                document.getElementById('modalInput').style.display = 'block';\r\n                document.getElementById('modalInput').value = '';\r\n                const btn = document.getElementById('modalBtnConfirm');\r\n                btn.className = 'btn-confirm-modal';\r\n                btn.textContent = \"#{obter_texto(:js_criar_mover)}\";\r\n                document.getElementById('modalOverlay').style.display = 'flex';\r\n                document.getElementById('modalInput').focus();\r\n              }\r\n            }\r\n\r\n            function fecharModal() {\r\n              document.getElementById('modalOverlay').style.display = 'none';\r\n            }\r\n\r\n            function confirmarModal() {\r\n              fecharModal();\r\n              if (modalAcao === 'salvar_template') {\r\n                const novoNome = document.getElementById('modalInput').value.trim();\r\n                if (novoNome) setTimeout(() => { sketchup.salvar_template_atual(novoNome); }, 200);\r\n              }\r\n              else if (modalAcao === 'excluir_template') {\r\n                setTimeout(() => { sketchup.excluir_template(modalAlvo); }, 200);\r\n              }\r\n              else if (modalAcao === 'renomear') {\r\n                const novoNome = document.getElementById('modalInput').value.trim();\r\n                if (novoNome && novoNome !== cenasAlvoContextMenu[0]) {\r\n                  setTimeout(() => { sketchup.renomear_cena_confirmada(cenasAlvoContextMenu[0], novoNome); }, 200);\r\n                }\r\n              } \r\n              else if (modalAcao === 'excluir_cena') {\r\n                setTimeout(() => { \r\n                  if (cenasAlvoContextMenu.length > 1) { sketchup.excluir_cenas_confirmadas(cenasAlvoContextMenu); } \r\n                  else { sketchup.excluir_cena_confirmada(cenasAlvoContextMenu[0]); }\r\n                }, 200);\r\n              }\r\n              else if (modalAcao === 'mover') {\r\n                const select = document.getElementById('selectGrupo');\r\n                let novoGrupo = select.value;\r\n                if (novoGrupo === 'novo') novoGrupo = document.getElementById('inputNovoGrupo').value.trim();\r\n                if (novoGrupo) setTimeout(() => { sketchup.mover_cenas_confirmadas(cenasAlvoContextMenu, novoGrupo); }, 200);\r\n              }\r\n              else if (modalAcao === 'agrupar_bulk') {\r\n                const novoGrupo = document.getElementById('modalInput').value.trim();\r\n                if (novoGrupo) setTimeout(() => { sketchup.mover_cenas_confirmadas(cenasAlvoContextMenu, novoGrupo); }, 200);\r\n              }\r\n            }\r\n          </script>\r\n        </body>\r\n        </html>\r\n      HTML\r\n    end\r\n  end\r\nend\r\n\r\nScriptUpComunidade::GerenciadorCenas.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "canetas-de-vetorizacao-96sei",
    "title": {
      "pt": "Canetas de Vetorização",
      "en": "Vectorization Pens",
      "es": "Bolígrafos de vectorización"
    },
    "author": "Igor Terra Tozzi",
    "version": "6.0",
    "description": {
      "pt": "Sabe quando você precisa desenhar uma logo (como a da Brahma) ou uma forma cheia de curvas no SketchUp e sofre porque o SketchUp só gosta de fazer linhas retas?\n\nEsse script é como um papel vegetal mágico. Ele cria uma caixinha com duas canetas especiais para você contornar qualquer imagem rapidinho e já deixar pronto para virar 3D.\n\nQuando você ativa a ferramenta, ela te pergunta qual caneta você quer usar:\n\n1️⃣ Caneta Curva (Para quem quer controle)\nComo funciona: Você vai clicando para fazer o contorno da logo.\n\nO truque: Quando você fecha o desenho (clicando na bolinha verde inicial), ele não acaba! O script acende uma luz em todas as \"quinas\" (pontas afiadas) do seu desenho.\n\nA mágica: Basta você passar o mouse nessas pontas e dar um clique. Ele \"lixa\" a ponta e transforma num canto arredondado perfeito. Quando terminar, é só apertar a tecla ENTER.\n\n2️⃣ Curvatura Automática (Para quem quer rapidez)\nComo funciona: Essa é a caneta preguiçosa (no bom sentido!). Você só precisa ir clicando em volta do desenho.\n\nO truque: Você não precisa se preocupar com as curvas. Conforme você vai clicando, o próprio código vai entortando a linha e criando curvas suaves de um ponto até o outro, sozinho!\n\nA mágica: Chegou no final? Clicou na bolinha verde? Pronto, ele finaliza tudo sozinho.",
      "en": "Do you know when you need to draw a logo (like Brahma's) or a shape full of curves in SketchUp and you struggle because SketchUp only likes to draw straight lines?\n\nThis script is like a magic tracing paper. It creates a box with two special pens so you can quickly outline any image and get it ready to become 3D.\n\nWhen you activate the tool, it asks you which pen you want to use:\n\n1️⃣ Curve Pen (For those who want control)\nHow it works: You click to outline the logo.\n\nThe trick: When you close the drawing (by clicking on the initial green circle), it doesn't end! The script lights up all the \"corners\" (sharp points) of your drawing.\n\nThe magic: Just hover your mouse over these points and click. It \"sands\" the point and transforms it into a perfect rounded corner. When you're finished, just press the ENTER key.\n\n2️⃣ Automatic Curvature (For those who want speed)\nHow it works: This is the lazy pen (in a good way!). You just need to click around the drawing.\n\nThe trick: You don't need to worry about the curves. As you click, the code itself will bend the line and create smooth curves from one point to another, all by itself!\n\nThe magic: Reached the end? Clicked the green dot? Done, it finishes everything automatically.",
      "es": "¿Sabes cuándo necesitas dibujar un logotipo (como el de Brahma) o una forma llena de curvas en SketchUp y te cuesta porque SketchUp solo dibuja líneas rectas?\n\nEste script es como un papel de calco mágico. Crea un recuadro con dos plumas especiales para que puedas delinear rápidamente cualquier imagen y prepararla para convertirla en 3D.\n\nAl activar la herramienta, te pregunta qué pluma quieres usar:\n\n1️⃣ Pluma de curva (para quienes buscan control)\nCómo funciona: Haz clic para delinear el logotipo.\n\nEl truco: Al cerrar el dibujo (haciendo clic en el círculo verde inicial), ¡no termina! El script ilumina todas las esquinas (puntos afilados) de tu dibujo.\n\nLa magia: Simplemente pasa el ratón sobre estos puntos y haz clic. Lija el punto y lo transforma en una esquina redondeada perfecta. Cuando termines, simplemente pulsa la tecla INTRO.\n\n2️⃣ Curvatura automática (para quienes buscan velocidad)\nCómo funciona: Este es el lápiz perezoso (¡en el buen sentido!). Solo tienes que hacer clic alrededor del dibujo.\n\nEl truco: No te preocupes por las curvas. Al hacer clic, el código doblará la línea y creará curvas suaves de un punto a otro, ¡por sí solo!\n\nLa magia: ¿Llegaste al final? ¿Hiciste clic en el punto verde? Listo, todo termina automáticamente."
    },
    "keywords": {
      "pt": [
        "canea - curva / automática"
      ],
      "en": [
        "canea - curved / automatic"
      ],
      "es": [
        "canea - curva / automática"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module CanetasDeVetorizacao\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :titulo_menu      => \"Canetas de Vetorização\",\r\n        :label_escolha    => \"Escolha a ferramenta:\",\r\n        :op_caneta_curva  => \"1 - Caneta Curva (Suavizacao Manual)\",\r\n        :op_curva_auto    => \"2 - Curvatura (Suavizacao Automatica)\",\r\n        :fase0            => \"Caneta Curva: Clique para definir o PRIMEIRO PONTO.\",\r\n        :fase1            => \"Caneta Curva: Clique para definir o SEGUNDO PONTO da reta (ou clique no ponto verde para fechar).\",\r\n        :fase2            => \"Caneta Curva: Mova o mouse para PUXAR A CURVA e clique para confirmar.\",\r\n        :fase3            => \"Modo Suavizar: Clique nos cantos (pontas) para arredondar. Aperte ENTER (ou clique duplo) para finalizar.\",\r\n        :msg_suavizar     => \"Contorno fechado! \\n\\nAgora você está no MODO SUAVIZAR.\\nPasse o mouse sobre os cantos afiados e clique para arredondá-los.\\n\\nQuando terminar, aperte a tecla ENTER para criar a face final.\",\r\n        :sucesso_manual   => \"Vetor finalizado! Curva contínua e face criadas com sucesso.\",\r\n        :erro_manual      => \"Erro ao criar face. Tente desenhar em um plano único.\",\r\n        :cancelado_manual => \"Traçado manual cancelado.\",\r\n        :instrucao_auto   => \"Curva Automática: Vá clicando para contornar a imagem. A curva se arredonda sozinha! Clique no ponto verde inicial para fechar.\",\r\n        :sucesso_auto     => \"Vetor fechado, curvas suavizadas e face criada com sucesso!\",\r\n        :erro_auto        => \"Erro ao criar a face. Tente desenhar no mesmo plano.\",\r\n        :cancelado_auto   => \"Traçado automático cancelado.\"\r\n      },\r\n      'en-US' => {\r\n        :titulo_menu      => \"Vectorization Pens\",\r\n        :label_escolha    => \"Choose the tool:\",\r\n        :op_caneta_curva  => \"1 - Curve Pen (Manual Smoothing)\",\r\n        :op_curva_auto    => \"2 - Auto Curve (Automatic Smoothing)\",\r\n        :fase0            => \"Curve Pen: Click to set the FIRST POINT.\",\r\n        :fase1            => \"Curve Pen: Click to set the SECOND POINT of the line (or click the green dot to close).\",\r\n        :fase2            => \"Curve Pen: Move mouse to PULL THE CURVE and click to confirm.\",\r\n        :fase3            => \"Smoothing Mode: Click on sharp corners to round them. Press ENTER (or double-click) to finish.\",\r\n        :msg_suavizar     => \"Path closed! \\n\\nYou are now in SMOOTHING MODE.\\nHover over sharp corners and click to round them.\\n\\nWhen done, press the ENTER key to create the final face.\",\r\n        :sucesso_manual   => \"Vector finalized! Continuous curve and face created successfully.\",\r\n        :erro_manual      => \"Error creating face. Try drawing on a single plane.\",\r\n        :cancelado_manual => \"Manual tracing canceled.\",\r\n        :instrucao_auto   => \"Auto Curve: Click to outline the image. The curve rounds itself automatically! Click the initial green dot to close.\",\r\n        :sucesso_auto     => \"Vector closed, curves smoothed, and face created successfully!\",\r\n        :erro_auto        => \"Error creating face. Try drawing on the same plane.\",\r\n        :cancelado_auto   => \"Auto tracing canceled.\"\r\n      },\r\n      'es' => {\r\n        :titulo_menu      => \"Plumas de Vectorización\",\r\n        :label_escolha    => \"Elija la herramienta:\",\r\n        :op_caneta_curva  => \"1 - Pluma Curva (Suavizado Manual)\",\r\n        :op_curva_auto    => \"2 - Curvatura (Suavizado Automático)\",\r\n        :fase0            => \"Pluma Curva: Haga clic para definir el PRIMER PUNTO.\",\r\n        :fase1            => \"Pluma Curva: Haga clic para definir el SEGUNDO PUNTO de la línea (o clic en el punto verde para cerrar).\",\r\n        :fase2            => \"Pluma Curva: Mueva el ratón para TIRAR DE LA CURVA y haga clic para confirmar.\",\r\n        :fase3            => \"Modo Suavizar: Haga clic en las esquinas (puntas) para redondear. Presione ENTER (o doble clic) para finalizar.\",\r\n        :msg_suavizar     => \"¡Contorno cerrado! \\n\\nAhora está en el MODO SUAVIZAR.\\nPase el ratón sobre las esquinas afiladas y haga clic para redondearlas.\\n\\nCuando termine, presione la tecla ENTER para crear la cara final.\",\r\n        :sucesso_manual   => \"¡Vector finalizado! Curva continua y cara creadas con éxito.\",\r\n        :erro_manual      => \"Error al crear la cara. Intente dibujar en un solo plano.\",\r\n        :cancelado_manual => \"Trazado manual cancelado.\",\r\n        :instrucao_auto   => \"Curva Automática: Haga clic para contornar la imagen. ¡La curva se redondea sola! Clic en el punto verde inicial para cerrar.\",\r\n        :sucesso_auto     => \"¡Vector cerrado, curvas suavizadas y cara creada con éxito!\",\r\n        :erro_auto        => \"Error al crear la cara. Intente dibujar en el mismo plano.\",\r\n        :cancelado_auto   => \"Trazado automático cancelado.\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    class FerramentaCanetaCurva\r\n      def activate\r\n        @grupo_preview = nil\r\n        reiniciar_ferramenta\r\n      end\r\n\r\n      def reiniciar_ferramenta\r\n        if @grupo_preview && @grupo_preview.valid?\r\n          @grupo_preview.erase!\r\n        end\r\n        @grupo_preview = nil\r\n        @pontos_desenhados = []\r\n        @estado = 0\r\n        @p1 = nil\r\n        @p2 = nil\r\n        @ponto_inicial = nil\r\n        @fechando = false\r\n        @ponto_suavizar_hover = nil\r\n        @ip = Sketchup::InputPoint.new\r\n        atualizar_status\r\n      end\r\n\r\n      def atualizar_status\r\n        case @estado\r\n        when 0 then Sketchup.set_status_text(ScriptUpComunidade::CanetasDeVetorizacao.obter_texto(:fase0))\r\n        when 1 then Sketchup.set_status_text(ScriptUpComunidade::CanetasDeVetorizacao.obter_texto(:fase1))\r\n        when 2 then Sketchup.set_status_text(ScriptUpComunidade::CanetasDeVetorizacao.obter_texto(:fase2))\r\n        when 3 then Sketchup.set_status_text(ScriptUpComunidade::CanetasDeVetorizacao.obter_texto(:fase3))\r\n        end\r\n      end\r\n\r\n      def onMouseMove(flags, x, y, view)\r\n        if @estado == 3\r\n          @ponto_suavizar_hover = nil\r\n          min_dist = 20\r\n          \r\n          @pontos_desenhados.each_with_index do |pt, i|\r\n            pt_tela = view.screen_coords(pt)\r\n            d = pt_tela.distance([x, y])\r\n            if d < min_dist\r\n              min_dist = d\r\n              @ponto_suavizar_hover = i\r\n            end\r\n          end\r\n          view.invalidate\r\n        else\r\n          @ip.pick(view, x, y)\r\n          view.tooltip = @ip.tooltip if @ip.valid?\r\n          view.invalidate\r\n        end\r\n      end\r\n\r\n      def onLButtonDown(flags, x, y, view)\r\n        if @estado == 3\r\n          if @ponto_suavizar_hover\r\n            arredondar_canto(@ponto_suavizar_hover)\r\n            desenhar_geometria_temporaria\r\n          end\r\n          return\r\n        end\r\n\r\n        @ip.pick(view, x, y)\r\n        return unless @ip.valid?\r\n\r\n        pos = @ip.position.clone\r\n\r\n        if @estado == 0\r\n          @p1 = pos\r\n          @ponto_inicial = pos\r\n          @pontos_desenhados << pos\r\n          @estado = 1\r\n          atualizar_status\r\n\r\n        elsif @estado == 1\r\n          pt_tela = view.screen_coords(@ponto_inicial)\r\n          if @pontos_desenhados.length > 1 && pt_tela.distance([x, y]) < 20\r\n            @p2 = @ponto_inicial\r\n            @fechando = true\r\n          else\r\n            @p2 = pos\r\n            @fechando = false\r\n          end\r\n          @estado = 2\r\n          atualizar_status\r\n\r\n        elsif @estado == 2\r\n          p_controle = pos\r\n          \r\n          segmentos_curva = calcular_curva_oval(@p1, p_controle, @p2, 96)\r\n          \r\n          segmentos_curva[1..-1].each { |pt| @pontos_desenhados << pt }\r\n\r\n          if @fechando\r\n            iniciar_modo_suavizar\r\n          else\r\n            @p1 = @p2\r\n            @estado = 1\r\n            atualizar_status\r\n          end\r\n        end\r\n        view.invalidate\r\n      end\r\n\r\n      def onLButtonDoubleClick(flags, x, y, view)\r\n        if @estado == 3\r\n          finalizar_geometria\r\n        end\r\n      end\r\n\r\n      def onReturn(view)\r\n        if @estado == 3\r\n          finalizar_geometria\r\n        end\r\n      end\r\n\r\n      def calcular_curva_oval(p0, p_controle, p2, segmentos)\r\n        pontos = []\r\n        tensao = 0.85 \r\n\r\n        c1_x = p0.x + tensao * (p_controle.x - p0.x)\r\n        c1_y = p0.y + tensao * (p_controle.y - p0.y)\r\n        c1_z = p0.z + tensao * (p_controle.z - p0.z)\r\n\r\n        c2_x = p2.x + tensao * (p_controle.x - p2.x)\r\n        c2_y = p2.y + tensao * (p_controle.y - p2.y)\r\n        c2_z = p2.z + tensao * (p_controle.z - p2.z)\r\n\r\n        (0..segmentos).each do |i|\r\n          t = i.to_f / segmentos\r\n          inv_t = 1.0 - t\r\n\r\n          x = (inv_t**3 * p0.x) + (3 * inv_t**2 * t * c1_x) + (3 * inv_t * t**2 * c2_x) + (t**3 * p2.x)\r\n          y = (inv_t**3 * p0.y) + (3 * inv_t**2 * t * c1_y) + (3 * inv_t * t**2 * c2_y) + (t**3 * p2.y)\r\n          z = (inv_t**3 * p0.z) + (3 * inv_t**2 * t * c1_z) + (3 * inv_t * t**2 * c2_z) + (t**3 * p2.z)\r\n\r\n          pontos << Geom::Point3d.new(x, y, z)\r\n        end\r\n        pontos\r\n      end\r\n\r\n      def arredondar_canto(indice)\r\n        tamanho = @pontos_desenhados.length\r\n        \r\n        idx_prev = (indice - 1) % tamanho\r\n        idx_next = (indice + 1) % tamanho\r\n\r\n        p_prev = @pontos_desenhados[idx_prev]\r\n        p_curr = @pontos_desenhados[indice]\r\n        p_next = @pontos_desenhados[idx_next]\r\n\r\n        d1 = p_curr.distance(p_prev)\r\n        d2 = p_curr.distance(p_next)\r\n        raio = [d1, d2].min * 0.3\r\n\r\n        vec1 = p_curr.vector_to(p_prev)\r\n        vec1.length = raio\r\n        pt_A = p_curr.offset(vec1)\r\n\r\n        vec2 = p_curr.vector_to(p_next)\r\n        vec2.length = raio\r\n        pt_B = p_curr.offset(vec2)\r\n\r\n        curva_suavizada = calcular_curva_oval(pt_A, p_curr, pt_B, 64)\r\n\r\n        @pontos_desenhados[indice, 1] = curva_suavizada\r\n        @ponto_suavizar_hover = nil \r\n      end\r\n\r\n      def iniciar_modo_suavizar\r\n        if @pontos_desenhados.last.distance(@pontos_desenhados.first) < 0.001\r\n          @pontos_desenhados.pop\r\n        end\r\n\r\n        Sketchup.active_model.start_operation(\"Vetorizando Logo\", true)\r\n        \r\n        @estado = 3\r\n        atualizar_status\r\n        desenhar_geometria_temporaria\r\n        \r\n        UI.messagebox(ScriptUpComunidade::CanetasDeVetorizacao.obter_texto(:msg_suavizar))\r\n      end\r\n\r\n      def desenhar_geometria_temporaria\r\n        model = Sketchup.active_model\r\n        \r\n        if @grupo_preview && @grupo_preview.valid?\r\n          @grupo_preview.erase!\r\n        end\r\n\r\n        @grupo_preview = model.active_entities.add_group\r\n        ents = @grupo_preview.entities\r\n        arestas = []\r\n        \r\n        tamanho = @pontos_desenhados.length\r\n        (0...tamanho).each do |i|\r\n          p1 = @pontos_desenhados[i]\r\n          p2 = @pontos_desenhados[(i + 1) % tamanho]\r\n          \r\n          if p1.distance(p2) > 0.001\r\n            arestas << ents.add_line(p1, p2)\r\n          end\r\n        end\r\n        \r\n        begin\r\n          if ents.respond_to?(:weld) && arestas.length > 0\r\n            ents.weld(arestas)\r\n          end\r\n\r\n          if arestas.length > 0 && arestas[0].valid?\r\n            arestas[0].find_faces\r\n          end\r\n        rescue\r\n        end\r\n      end\r\n\r\n      def finalizar_geometria\r\n        if @grupo_preview && @grupo_preview.valid?\r\n          @grupo_preview.explode\r\n        end\r\n        Sketchup.active_model.commit_operation\r\n        UI.messagebox(ScriptUpComunidade::CanetasDeVetorizacao.obter_texto(:sucesso_manual))\r\n        reiniciar_ferramenta\r\n      end\r\n\r\n      def draw(view)\r\n        if @estado < 3\r\n          @ip.draw(view) if @ip.valid?\r\n          \r\n          if @pontos_desenhados.size > 1\r\n            view.drawing_color = \"black\"\r\n            view.line_width = 2\r\n            view.draw(GL_LINE_STRIP, @pontos_desenhados)\r\n          end\r\n          \r\n          if @estado > 0 && @ponto_inicial\r\n            view.draw_points([@ponto_inicial], 15, 4, \"green\")\r\n          end\r\n\r\n          if @estado == 1 && @p1 && @ip.valid?\r\n            view.drawing_color = \"red\"\r\n            view.line_width = 2\r\n            view.draw(GL_LINES, @p1, @ip.position)\r\n          elsif @estado == 2 && @p1 && @p2 && @ip.valid?\r\n            view.drawing_color = \"blue\"\r\n            view.line_width = 2\r\n            curva_previa = calcular_curva_oval(@p1, @ip.position, @p2, 96)\r\n            view.draw(GL_LINE_STRIP, curva_previa)\r\n            \r\n            view.drawing_color = \"gray\"\r\n            view.line_stipple = \"-\"\r\n            view.draw(GL_LINES, @p1, @ip.position)\r\n            view.draw(GL_LINES, @p2, @ip.position)\r\n            view.line_stipple = \"\"\r\n          end\r\n\r\n        elsif @estado == 3\r\n          if @ponto_suavizar_hover && @pontos_desenhados[@ponto_suavizar_hover]\r\n            view.draw_points([@pontos_desenhados[@ponto_suavizar_hover]], 18, 2, \"magenta\")\r\n          end\r\n        end\r\n      end\r\n\r\n      def onCancel(reason, view)\r\n        if @estado == 3\r\n          Sketchup.active_model.abort_operation\r\n        end\r\n        reiniciar_ferramenta\r\n        Sketchup.set_status_text(ScriptUpComunidade::CanetasDeVetorizacao.obter_texto(:cancelado_manual))\r\n        view.invalidate\r\n      end\r\n    end\r\n\r\n    class FerramentaCanetaSpline\r\n      def activate\r\n        reiniciar_ferramenta\r\n      end\r\n\r\n      def reiniciar_ferramenta\r\n        @pontos = []\r\n        @ip = Sketchup::InputPoint.new\r\n        Sketchup.set_status_text(ScriptUpComunidade::CanetasDeVetorizacao.obter_texto(:instrucao_auto))\r\n      end\r\n\r\n      def onMouseMove(flags, x, y, view)\r\n        @ip.pick(view, x, y)\r\n        view.tooltip = @ip.tooltip if @ip.valid?\r\n        view.invalidate\r\n      end\r\n\r\n      def onLButtonDown(flags, x, y, view)\r\n        @ip.pick(view, x, y)\r\n        return unless @ip.valid?\r\n\r\n        pos = @ip.position.clone\r\n\r\n        if @pontos.empty?\r\n          @pontos << pos\r\n        else\r\n          pt_tela = view.screen_coords(@pontos[0])\r\n          if @pontos.length > 2 && pt_tela.distance([x, y]) < 20\r\n            @pontos << @pontos[0].clone \r\n            fechar_forma(view)\r\n            return\r\n          else\r\n            @pontos << pos\r\n          end\r\n        end\r\n        view.invalidate\r\n      end\r\n\r\n      def calcular_spline(pontos_base, fechado = false)\r\n        return pontos_base if pontos_base.length < 3\r\n        \r\n        pontos = pontos_base.dup\r\n        \r\n        if fechado && pontos.last.distance(pontos.first) > 0.001\r\n           pontos << pontos.first.clone\r\n        end\r\n\r\n        spline_pts = []\r\n        segmentos_por_curva = 64\r\n\r\n        if fechado\r\n          pts = [pontos[-2]] + pontos + [pontos[1]]\r\n        else\r\n          pts = [pontos[0]] + pontos + [pontos[-1]]\r\n        end\r\n\r\n        (1..pts.length - 3).each do |i|\r\n          p0 = pts[i-1]\r\n          p1 = pts[i]\r\n          p2 = pts[i+1]\r\n          p3 = pts[i+2]\r\n\r\n          (0...segmentos_por_curva).each do |j|\r\n            t = j.to_f / segmentos_por_curva\r\n            t2 = t * t\r\n            t3 = t2 * t\r\n\r\n            x = 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3)\r\n            y = 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3)\r\n            z = 0.5 * ((2 * p1.z) + (-p0.z + p2.z) * t + (2 * p0.z - 5 * p1.z + 4 * p2.z - p3.z) * t2 + (-p0.z + 3 * p1.z - 3 * p2.z + p3.z) * t3)\r\n\r\n            spline_pts << Geom::Point3d.new(x, y, z)\r\n          end\r\n        end\r\n        \r\n        spline_pts << pontos.last \r\n        spline_pts\r\n      end\r\n\r\n      def fechar_forma(view)\r\n        model = Sketchup.active_model\r\n        model.start_operation(\"Vetor Spline Automático\", true)\r\n        \r\n        ents = model.active_entities\r\n        arestas = []\r\n        \r\n        curva_final = calcular_spline(@pontos, true)\r\n        \r\n        (0...curva_final.length - 1).each do |i|\r\n          p1 = curva_final[i]\r\n          p2 = curva_final[i+1]\r\n          if p1.distance(p2) > 0.001\r\n            arestas << ents.add_line(p1, p2)\r\n          end\r\n        end\r\n        \r\n        begin\r\n          if ents.respond_to?(:weld) && arestas.length > 0\r\n            ents.weld(arestas)\r\n          end\r\n\r\n          if arestas.length > 0 && arestas[0].valid?\r\n            arestas[0].find_faces\r\n          end\r\n\r\n          UI.messagebox(ScriptUpComunidade::CanetasDeVetorizacao.obter_texto(:sucesso_auto))\r\n        rescue\r\n          UI.messagebox(ScriptUpComunidade::CanetasDeVetorizacao.obter_texto(:erro_auto))\r\n        end\r\n        \r\n        model.commit_operation\r\n        reiniciar_ferramenta\r\n        view.invalidate\r\n      end\r\n\r\n      def draw(view)\r\n        @ip.draw(view) if @ip.valid?\r\n        \r\n        pontos_preview = @pontos.dup\r\n        pontos_preview << @ip.position if @ip.valid? && @pontos.size > 0\r\n\r\n        if pontos_preview.size > 2\r\n          curva_preview = calcular_spline(pontos_preview, false)\r\n          \r\n          view.drawing_color = \"black\"\r\n          view.line_width = 2\r\n          view.draw(GL_LINE_STRIP, curva_preview)\r\n        elsif pontos_preview.size == 2\r\n          view.drawing_color = \"black\"\r\n          view.line_width = 2\r\n          view.draw(GL_LINES, pontos_preview[0], pontos_preview[1])\r\n        end\r\n        \r\n        if @pontos.size > 0\r\n          view.draw_points(@pontos, 8, 1, \"blue\")\r\n          view.draw_points([@pontos[0]], 15, 4, \"green\")\r\n        end\r\n      end\r\n\r\n      def onCancel(reason, view)\r\n        reiniciar_ferramenta\r\n        Sketchup.set_status_text(ScriptUpComunidade::CanetasDeVetorizacao.obter_texto(:cancelado_auto))\r\n        view.invalidate\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      op_1 = obter_texto(:op_caneta_curva)\r\n      op_2 = obter_texto(:op_curva_auto)\r\n      \r\n      prompts  = [obter_texto(:label_escolha)]\r\n      defaults = [op_1]\r\n      lista    = [\"#{op_1}|#{op_2}\"]\r\n      titulo   = obter_texto(:titulo_menu)\r\n      \r\n      resultado = UI.inputbox(prompts, defaults, lista, titulo)\r\n      \r\n      if resultado\r\n        escolha = resultado[0]\r\n        if escolha == op_1\r\n          Sketchup.active_model.select_tool(FerramentaCanetaCurva.new)\r\n        elsif escolha == op_2\r\n          Sketchup.active_model.select_tool(FerramentaCanetaSpline.new)\r\n        end\r\n      end\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::CanetasDeVetorizacao.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "mapeamento-uv-em-malha-curva-96v28",
    "title": {
      "pt": "Mapeamento UV em Malha Curva",
      "en": "UV Mapping on Curved Mesh",
      "es": "Mapeo UV en malla curva"
    },
    "author": "Fábio Coutinho",
    "version": "1.8",
    "description": {
      "pt": "Promove o mapeamento UV de texturas aplicadas em superfície curva, com controle de rotação e escala.\n1 - Clique em qualquer lugar da superfície para iniciar o mapeamento e habilitar os controles;\n2 - Deslize os sliders de rotação ou escala para deixar o mapeamento como precisa;\n3 - Clique em outra superfície para realizar um novo mapeamento ou apenas feche a janela para finalizar a ferramenta.",
      "en": "Promotes UV mapping of textures applied to curved surfaces, with rotation and scale control.\n1 - Click anywhere on the surface to start mapping and enable the controls;\n2 - Slide the rotation or scale sliders to adjust the mapping as needed;\n\n3 - Click on another surface to perform a new mapping or simply close the window to finish the tool.",
      "es": "Permite el mapeo UV de texturas aplicadas a superficies curvas, con control de rotación y escala.\n1 - Haga clic en cualquier parte de la superficie para iniciar el mapeo y activar los controles.\n2 - Deslice los controles deslizantes de rotación o escala para ajustar el mapeo según sea necesario.\n\n3 - Haga clic en otra superficie para realizar un nuevo mapeo o simplemente cierre la ventana para finalizar la herramienta."
    },
    "keywords": {
      "pt": [
        "uv map",
        "textura",
        "mapeamento"
      ],
      "en": [
        "uv map",
        "texture",
        "mapping"
      ],
      "es": [
        "mapa uv",
        "textura",
        "cartografía"
      ]
    },
    "code": {
      "pt": "require 'sketchup.rb'\r\n\r\nmodule ScriptUpComunidade\r\n  module PropagarUV\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :op_name             => \"Propagar UV (slider)\",\r\n        :dialog_title        => \"Propagar UV\",\r\n        :html_rotacao        => \"Rotação\",\r\n        :html_escala         => \"Escala\",\r\n        :html_status_inativo => \"Clique em uma face no modelo para ativar.\",\r\n        :html_status_ativo   => \"Controles ativos — ajuste em tempo real.\",\r\n        :status_text         => \"Clique em 1 face da malha (aceita a face mais profunda sob o cursor).\",\r\n        :err_no_face         => \"Não achei uma face sob o cursor.\",\r\n        :err_outside_group   => \"Clique numa face que esteja DENTRO do grupo/componente selecionado.\",\r\n        :err_outside_sel     => \"Clique em uma FACE que esteja dentro da seleção atual.\",\r\n        :err_no_texture      => \"A face clicada não possui material com textura.\",\r\n        :err_prefix          => \"Erro:\"\r\n      },\r\n      'en-US' => {\r\n        :op_name             => \"Propagate UV (slider)\",\r\n        :dialog_title        => \"Propagate UV\",\r\n        :html_rotacao        => \"Rotation\",\r\n        :html_escala         => \"Scale\",\r\n        :html_status_inativo => \"Click on a face in the model to activate.\",\r\n        :html_status_ativo   => \"Active controls — real-time adjustment.\",\r\n        :status_text         => \"Click 1 face of the mesh (accepts the deepest face under the cursor).\",\r\n        :err_no_face         => \"Could not find a face under the cursor.\",\r\n        :err_outside_group   => \"Click on a face INSIDE the selected group/component.\",\r\n        :err_outside_sel     => \"Click on a FACE inside the current selection.\",\r\n        :err_no_texture      => \"The clicked face does not have a textured material.\",\r\n        :err_prefix          => \"Error:\"\r\n      },\r\n      'es' => {\r\n        :op_name             => \"Propagar UV (control deslizante)\",\r\n        :dialog_title        => \"Propagar UV\",\r\n        :html_rotacao        => \"Rotación\",\r\n        :html_escala         => \"Escala\",\r\n        :html_status_inativo => \"Haga clic en una cara en el modelo para activar.\",\r\n        :html_status_ativo   => \"Controles activos — ajuste en tiempo real.\",\r\n        :status_text         => \"Haga clic en 1 cara de la malla (acepta la cara más profunda bajo el cursor).\",\r\n        :err_no_face         => \"No se encontró una cara bajo el cursor.\",\r\n        :err_outside_group   => \"Haga clic en una cara DENTRO del grupo/componente seleccionado.\",\r\n        :err_outside_sel     => \"Haga clic en una CARA dentro de la selección actual.\",\r\n        :err_no_texture      => \"La cara cliqueada no tiene un material con textura.\",\r\n        :err_prefix          => \"Error:\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    # Limpar constantes anteriores para permitir redefinição ao colar novamente\r\n    self.constants.grep(/^UVPROP_/).each { |c| self.send(:remove_const, c) }\r\n\r\n    UVPROP_DEBUG ||= false\r\n    UVPROP_EPS ||= 1e-9\r\n    UVPROP_REF_SIZE ||= 100.mm\r\n    UVPROP_BASE_K ||= 0.254\r\n\r\n    UVPROP_LOG ||= lambda do |msg|\r\n      puts(\"[UVPROP] #{msg}\") if UVPROP_DEBUG\r\n    end\r\n\r\n    # ---- Detecção de world-space ----\r\n\r\n    UVPROP_NEEDS_WORLD_SPACE ||= lambda do |model, path|\r\n      ap = model.active_path\r\n      outside = ap.nil? || ap.empty?\r\n      deep = path && path.length.to_i > 1\r\n      outside && deep\r\n    end\r\n\r\n    # ---- Aplicar position_material com contexto ----\r\n\r\n    UVPROP_POSITION_MATERIAL_CTX ||= lambda do |face, mat, pairs, front, proj_vec, model, t_total, needs_world|\r\n      pairs2 = pairs\r\n      proj2 = proj_vec\r\n\r\n      if needs_world\r\n        pairs2 = pairs.each_slice(2).flat_map { |p, uv|\r\n          [p.transform(t_total), uv] }\r\n        proj2 = proj_vec.transform(t_total)\r\n      end\r\n\r\n      ar = face.method(:position_material).arity\r\n      ok =\r\n        if ar == 4\r\n          face.position_material(mat, pairs2, front, proj2)\r\n        else\r\n          face.position_material(mat, pairs2, front)\r\n        end\r\n\r\n      ok ? true : false\r\n    rescue => e\r\n      UVPROP_LOG.call(\"position_material_ctx ERRO: #{e.class} - #{e.message}\")\r\n      false\r\n    end\r\n\r\n    # ---- Extrair direção U atual do UV ----\r\n\r\n    UVPROP_CURRENT_U_DIR_FROM_UV ||= lambda do |face, front, tw|\r\n      uvh = face.get_UVHelper(front, !front, tw)\r\n\r\n      verts = face.vertices\r\n      return nil if verts.length < 3\r\n\r\n      n = face.normal\r\n      xaxis = nil\r\n      face.edges.each do |e|\r\n        v = e.line[1].clone\r\n        next if v.length < UVPROP_EPS\r\n        v.normalize!\r\n        next if v.dot(n).abs > 1e-6\r\n        xaxis = v\r\n        break\r\n      end\r\n      return nil unless xaxis\r\n      xaxis.normalize!\r\n      yaxis = n * xaxis\r\n      return nil if yaxis.length < UVPROP_EPS\r\n      yaxis.normalize!\r\n      p1 = verts[0].position\r\n      p2 = verts[1].position\r\n      p3 = verts[2].position\r\n\r\n      uv1q = front ? uvh.get_front_UVQ(p1) : uvh.get_back_UVQ(p1)\r\n      uv2q = front ? uvh.get_front_UVQ(p2) : uvh.get_back_UVQ(p2)\r\n      uv3q = front ? uvh.get_front_UVQ(p3) : uvh.get_back_UVQ(p3)\r\n\r\n      u1 = uv1q.x / uv1q.z\r\n      v1 = uv1q.y / uv1q.z\r\n      u2 = uv2q.x / uv2q.z\r\n      v2 = uv2q.y / uv2q.z\r\n      u3 = uv3q.x / uv3q.z\r\n      v3 = uv3q.y / uv3q.z\r\n\r\n      v12 = p2 - p1\r\n      v13 = p3 - p1\r\n      s1 = 0.0\r\n      t1 = 0.0\r\n      s2 = v12.dot(xaxis)\r\n      t2 = v12.dot(yaxis)\r\n      s3 = v13.dot(xaxis)\r\n      t3 = v13.dot(yaxis)\r\n\r\n      det = (s2 - s1) * (t3 - t1) - (s3 - s1) * (t2 - t1)\r\n      return nil if det.abs < 1e-12\r\n\r\n      a = ((u2 - u1) * (t3 - t1) - (u3 - u1) * (t2 - t1)) / det\r\n      b = (-(u2 - u1) * (s3 - s1) + (u3 - u1) * (s2 - s1)) / det\r\n\r\n      d = ((v2 - v1) * (t3 - t1) - (v3 - v1) * (t2 - t1)) / det\r\n      e = (-(v2 - v1) * (s3 - s1) + (v3 - v1) * (s2 - s1)) / det\r\n\r\n      detj = a * e - b * d\r\n      return nil if detj.abs < 1e-12\r\n\r\n      delta_s = e / detj\r\n      delta_t = -d / detj\r\n\r\n      u_dir = (xaxis.clone.tap { |vx| vx.length = delta_s } +\r\n               yaxis.clone.tap { |vy| vy.length = delta_t })\r\n\r\n      return nil if u_dir.length < UVPROP_EPS\r\n      u_dir.normalize!\r\n      u_dir\r\n    rescue\r\n      nil\r\n    end\r\n\r\n    # ---- Reset + fit da face seed (com rotação absoluta e escala) ----\r\n    # angle_deg: nil = preservar rotação existente;\r\n    # número = ângulo absoluto a partir da aresta base\r\n    # scale_factor: multiplicador de escala da textura (1.0 = tamanho original)\r\n\r\n    UVPROP_RESET_AND_FIT_SEED_INPLACE ||= lambda do |face, t_total, tw, model, needs_world, angle_deg = nil, scale_factor = 1.0|\r\n      fm = face.material\r\n      bm = face.back_material\r\n\r\n      if fm && fm.texture\r\n        front = true\r\n        mat = fm\r\n      elsif bm && bm.texture\r\n        front = false\r\n        mat = bm\r\n      else\r\n        return false\r\n      end\r\n\r\n      tex = mat.texture\r\n      tex_w = tex.width\r\n      tex_h = tex.height\r\n      return false if tex_w.to_f <= UVPROP_EPS || tex_h.to_f <= UVPROP_EPS\r\n\r\n      k_u = UVPROP_BASE_K * (UVPROP_REF_SIZE.to_f / tex_w.to_f)\r\n      k_v = UVPROP_BASE_K * (UVPROP_REF_SIZE.to_f / tex_h.to_f)\r\n\r\n      u_dir_preserve = UVPROP_CURRENT_U_DIR_FROM_UV.call(face, front, tw)\r\n\r\n      if face.respond_to?(:clear_texture_position)\r\n        face.clear_texture_position(front) rescue nil\r\n      end\r\n\r\n      if front\r\n        face.material = nil\r\n        face.material = mat\r\n      else\r\n        face.back_material = nil\r\n        face.back_material = mat\r\n      end\r\n\r\n      edges = face.edges\r\n      return false if edges.empty?\r\n      u_dir =\r\n        if angle_deg.nil? && u_dir_preserve && u_dir_preserve.length > UVPROP_EPS\r\n          u_dir_preserve\r\n        else\r\n          best = edges.max_by { |e| e.length.to_f }\r\n          v = best.line[1].clone\r\n          return false if v.length < UVPROP_EPS\r\n          v.length = 1.0\r\n          v\r\n        end\r\n\r\n      if angle_deg && angle_deg.to_f.abs > UVPROP_EPS\r\n        angle_rad = angle_deg.to_f * Math::PI / 180.0\r\n        rot = Geom::Transformation.rotation(ORIGIN, face.normal, angle_rad)\r\n        u_dir = u_dir.transform(rot)\r\n      end\r\n\r\n      u_dir = u_dir.clone\r\n      return false if u_dir.length < UVPROP_EPS\r\n      u_dir.length = 1.0\r\n\r\n      n = face.normal\r\n      v_dir = n.cross(u_dir)\r\n      return false if v_dir.length < UVPROP_EPS\r\n      v_dir.length = 1.0\r\n\r\n      if needs_world\r\n        su = 1.0\r\n        sv = 1.0\r\n      else\r\n        su = u_dir.transform(t_total).length\r\n        sv = v_dir.transform(t_total).length\r\n        su = 1.0 if su.abs < UVPROP_EPS\r\n        sv = 1.0 if sv.abs < UVPROP_EPS\r\n      end\r\n\r\n      sf = scale_factor.to_f\r\n      sf = 1.0 if sf < UVPROP_EPS\r\n\r\n      step_u_local = tex_w * sf / su\r\n      step_v_local = tex_h * sf / sv\r\n\r\n      p0 = face.outer_loop.vertices.first.position\r\n      p_u = p0.offset(u_dir, step_u_local)\r\n      p_v = p0.offset(v_dir, step_v_local)\r\n\r\n      uv0 = Geom::Point3d.new(0.0, 0.0, 0.0)\r\n      uvu = Geom::Point3d.new(tex_w.to_f * k_u, 0.0, 0.0)\r\n      uvv = Geom::Point3d.new(0.0, tex_h.to_f * k_v, 0.0)\r\n\r\n      pairs = [p0, uv0, p_u, uvu, p_v, uvv]\r\n\r\n      UVPROP_LOG.call(\r\n        \"RESET: needs_world=#{needs_world} front=#{front} \" \\\r\n        \"tex=#{tex_w.to_f.round(3)}x#{tex_h.to_f.round(3)} \" \\\r\n        \"k_u=#{k_u.round(6)} k_v=#{k_v.round(6)} \" \\\r\n        \"su=#{su.round(6)} sv=#{sv.round(6)} \" \\\r\n        \"step_u=#{step_u_local.to_f.round(6)} step_v=#{step_v_local.to_f.round(6)} \" \\\r\n        \"angle=#{angle_deg} scale=#{sf}\"\r\n      )\r\n\r\n      UVPROP_POSITION_MATERIAL_CTX.call(face, mat, pairs, front, n, model, t_total, needs_world)\r\n    rescue => e\r\n      UVPROP_LOG.call(\"reset_and_fit_seed_inplace ERRO: #{e.class} - #{e.message}\")\r\n      false\r\n    end\r\n\r\n    # ---- Randomizar origem do UV no seed ----\r\n\r\n    UVPROP_RANDOMIZE_SEED_ORIGIN_INPLACE ||= lambda do |face, tw, model, t_total, needs_world|\r\n      fm = face.material\r\n      bm = face.back_material\r\n\r\n      if fm && fm.texture\r\n        front = true\r\n        mat = fm\r\n      elsif bm && bm.texture\r\n        front = false\r\n        mat = bm\r\n      else\r\n        return false\r\n      end\r\n\r\n      tex = mat.texture\r\n      tex_w = tex.width\r\n      tex_h = tex.height\r\n      return false if tex_w.to_f <= UVPROP_EPS || tex_h.to_f <= UVPROP_EPS\r\n\r\n      k_u = UVPROP_BASE_K * (UVPROP_REF_SIZE.to_f / tex_w.to_f)\r\n      k_v = UVPROP_BASE_K * (UVPROP_REF_SIZE.to_f / tex_h.to_f)\r\n      tile_u = (tex_w.to_f * k_u).abs\r\n      tile_v = (tex_h.to_f * k_v).abs\r\n      tile_u = 1.0 if tile_u < UVPROP_EPS\r\n      tile_v = 1.0 if tile_v < UVPROP_EPS\r\n\r\n      du = rand * tile_u\r\n      dv = rand * tile_v\r\n\r\n      uvh = face.get_UVHelper(front, !front, tw)\r\n\r\n      verts = face.vertices\r\n      return false if verts.length < 3\r\n\r\n      pA = pB = pC = nil\r\n      found = false\r\n      verts.combination(3) do |a, b, c|\r\n        va = a.position\r\n        vb = b.position\r\n        vc = c.position\r\n        area = (vb - va).cross(vc - va).length\r\n        if area > 1e-8\r\n          pA = va\r\n          pB = vb\r\n          pC = vc\r\n          found = true\r\n          break\r\n        end\r\n      end\r\n      return false unless found\r\n\r\n      uvAq = front ? uvh.get_front_UVQ(pA) : uvh.get_back_UVQ(pA)\r\n      uvBq = front ? uvh.get_front_UVQ(pB) : uvh.get_back_UVQ(pB)\r\n      uvCq = front ? uvh.get_front_UVQ(pC) : uvh.get_back_UVQ(pC)\r\n\r\n      uA = uvAq.x / uvAq.z\r\n      vA = uvAq.y / uvAq.z\r\n      uB = uvBq.x / uvBq.z\r\n      vB = uvBq.y / uvBq.z\r\n      uC = uvCq.x / uvCq.z\r\n      vC = uvCq.y / uvCq.z\r\n\r\n      pairs = [\r\n        pA, Geom::Point3d.new(uA + du, vA + dv, 0),\r\n        pB, Geom::Point3d.new(uB + du, vB + dv, 0),\r\n        pC, Geom::Point3d.new(uC + du, vC + dv, 0)\r\n      ]\r\n\r\n      UVPROP_LOG.call(\r\n        \"RAND: needs_world=#{needs_world} du=#{du.round(6)} dv=#{dv.round(6)} \" \\\r\n        \"tile_u=#{tile_u.round(6)} tile_v=#{tile_v.round(6)}\"\r\n      )\r\n\r\n      UVPROP_POSITION_MATERIAL_CTX.call(face, mat, pairs, front, face.normal, model, t_total, needs_world)\r\n    rescue => e\r\n      UVPROP_LOG.call(\"randomize_seed_origin_inplace ERRO: #{e.class} - #{e.message}\")\r\n      false\r\n    end\r\n\r\n    # ---- Transformação acumulada para pick path ----\r\n\r\n    UVPROP_TOTAL_TRANSFORM_FOR_PICK_PATH ||= lambda do |model, path|\r\n      t_active =\r\n        if model.active_path && !model.active_path.empty?\r\n          model.active_path.inject(Geom::Transformation.new) { |t, inst| t * inst.transformation }\r\n        else\r\n          Geom::Transformation.new\r\n        end\r\n\r\n      insts_pick = (path || [])[0..-2].to_a.select { |e| e.respond_to?(:transformation) }\r\n      t_pick = insts_pick.inject(Geom::Transformation.new) { |t, inst| t * inst.transformation }\r\n\r\n      t_active * t_pick\r\n    end\r\n\r\n    # ---- Utilitários de geometria ----\r\n\r\n    UVPROP_SIGNED_ANGLE_AROUND_AXIS ||= lambda do |n1, n2, axis|\r\n      a = axis.clone\r\n      return 0.0 if a.length == 0.0\r\n      a.normalize!\r\n      c = n1 * n2\r\n      s = a.dot(c)\r\n      d = [[n1.dot(n2), -1.0].max, 1.0].min\r\n      Math.atan2(s, d)\r\n    end\r\n\r\n    UVPROP_ROTATE_VEC ||= lambda do |v, axis, angle|\r\n      t = Geom::Transformation.rotation(ORIGIN, axis, angle)\r\n      v.transform(t)\r\n    end\r\n\r\n    # ---- Adjacência ----\r\n\r\n    UVPROP_SHARED_VERTICES ||= lambda do |f1, f2|\r\n      h = {}\r\n      f1.vertices.each { |v| h[v] = true }\r\n      f2.vertices.select { |v| h[v] }\r\n    end\r\n\r\n    UVPROP_EDGE_BLOCKS_PROPAGATION ||= lambda do |edge|\r\n      hard = !edge.soft? && !edge.smooth?\r\n      visible =\r\n        if edge.respond_to?(:visible?)\r\n          edge.visible?\r\n        else\r\n          !edge.hidden?\r\n        end\r\n      hard && visible\r\n    end\r\n\r\n    UVPROP_NEIGHBORS_IN_SET ||= lambda do |face, face_set_hash|\r\n      neigh = []\r\n      face.edges.each do |e|\r\n        next if UVPROP_EDGE_BLOCKS_PROPAGATION.call(e)\r\n        e.faces.each do |f|\r\n          next if f == face\r\n          neigh << f if face_set_hash[f]\r\n        end\r\n      end\r\n      neigh.uniq\r\n    end\r\n\r\n    # ---- Copiar UV de face para vizinha ----\r\n\r\n    UVPROP_COPY_FACE_TO_NEIGHBOR ||= lambda do |src, dst, face_set_hash, tw, t_total, needs_world|\r\n      src_front = src.material\r\n      src_back = src.back_material\r\n      front_ok = src_front && src_front.texture\r\n      back_ok = src_back && src_back.texture\r\n      return false unless front_ok || back_ok\r\n\r\n      use_front = front_ok\r\n      mat = use_front ? src_front : src_back\r\n\r\n      uvh = src.get_UVHelper(use_front, !use_front, tw)\r\n\r\n      shared = UVPROP_SHARED_VERTICES.call(src, dst)\r\n      return false if shared.length < 2\r\n\r\n      vA = shared[0]\r\n      vB = shared[1]\r\n      pA = vA.position\r\n      pB = vB.position\r\n\r\n      pA_calc = needs_world ? pA.transform(t_total) : pA\r\n      pB_calc = needs_world ? pB.transform(t_total) : pB\r\n\r\n      edge = pB_calc - pA_calc\r\n      return false if edge.length == 0.0\r\n      e_dir = edge.clone\r\n      e_dir.normalize!\r\n      if needs_world\r\n        src_pts = src.vertices.take(3).map { |v| v.position.transform(t_total) }\r\n        dst_pts = dst.vertices.take(3).map { |v| v.position.transform(t_total) }\r\n        n_src = (src_pts[1] - src_pts[0]).cross(src_pts[2] - src_pts[0])\r\n        n_dst = (dst_pts[1] - dst_pts[0]).cross(dst_pts[2] - dst_pts[0])\r\n        return false if n_src.length < UVPROP_EPS || n_dst.length < UVPROP_EPS\r\n        n_src.normalize!\r\n        n_dst.normalize!\r\n      else\r\n        n_src = src.normal\r\n        n_dst = dst.normal\r\n      end\r\n\r\n      t_src = n_src * e_dir\r\n      return false if t_src.length == 0.0\r\n      t_src.normalize!\r\n      ang = UVPROP_SIGNED_ANGLE_AROUND_AXIS.call(n_src, n_dst, e_dir)\r\n      t_dst = UVPROP_ROTATE_VEC.call(t_src, e_dir, ang)\r\n      return false if t_dst.length == 0.0\r\n      t_dst.normalize!\r\n      vC_src = src.vertices.find { |vv| vv != vA && vv != vB }\r\n      return false unless vC_src\r\n      pC_src = vC_src.position\r\n      pC_src_calc = needs_world ? pC_src.transform(t_total) : pC_src\r\n\r\n      uvAq = use_front ? uvh.get_front_UVQ(pA) : uvh.get_back_UVQ(pA)\r\n      uvBq = use_front ? uvh.get_front_UVQ(pB) : uvh.get_back_UVQ(pB)\r\n      uvCq = use_front ? uvh.get_front_UVQ(pC_src) : uvh.get_back_UVQ(pC_src)\r\n\r\n      uA = uvAq.x / uvAq.z\r\n      vAuv = uvAq.y / uvAq.z\r\n      uB = uvBq.x / uvBq.z\r\n      vBuv = uvBq.y / uvBq.z\r\n      uC = uvCq.x / uvCq.z\r\n      vCuv = uvCq.y / uvCq.z\r\n\r\n      sB = (pB_calc - pA_calc).dot(e_dir)\r\n      return false if sB.abs < 1e-12\r\n\r\n      vAC = (pC_src_calc - pA_calc)\r\n      sC = vAC.dot(e_dir)\r\n      tC = vAC.dot(t_src)\r\n\r\n      if tC.abs < 1e-9\r\n        vC_src = src.vertices.find do |vv|\r\n          next false if vv == vA || vv == vB\r\n          ((vv.position - pA).dot(t_src)).abs >= 1e-9\r\n        end\r\n        return false unless vC_src\r\n        pC_src = vC_src.position\r\n        pC_src_calc = needs_world ? pC_src.transform(t_total) : pC_src\r\n        uvCq = use_front ? uvh.get_front_UVQ(pC_src) : uvh.get_back_UVQ(pC_src)\r\n        uC = uvCq.x / uvCq.z\r\n        vCuv = uvCq.y / uvCq.z\r\n        vAC = (pC_src_calc - pA_calc)\r\n        sC = vAC.dot(e_dir)\r\n        tC = vAC.dot(t_src)\r\n        return false if tC.abs < 1e-9\r\n      end\r\n\r\n      u_s = (uB - uA) / sB\r\n      v_s = (vBuv - vAuv) / sB\r\n\r\n      u_t = (uC - uA - u_s * sC) / tC\r\n      v_t = (vCuv - vAuv - v_s * sC) / tC\r\n\r\n      vC_dst = dst.vertices.find { |vv| vv != vA && vv != vB } || dst.vertices[0]\r\n      pC_dst = vC_dst.position\r\n      pC_dst_calc = needs_world ? pC_dst.transform(t_total) : pC_dst\r\n\r\n      vAD = (pC_dst_calc - pA_calc)\r\n      sD = vAD.dot(e_dir)\r\n      tD = vAD.dot(t_dst)\r\n\r\n      uD = uA + u_s * sD + u_t * tD\r\n      vD = vAuv + v_s * sD + v_t * tD\r\n\r\n      pairs = [\r\n        pA, Geom::Point3d.new(uA, vAuv, 0),\r\n        pB, Geom::Point3d.new(uB, vBuv, 0),\r\n        pC_dst, Geom::Point3d.new(uD, vD, 0)\r\n      ]\r\n\r\n      if use_front\r\n        dst.material = mat\r\n        dst.position_material(mat, pairs, true)\r\n      else\r\n        dst.back_material = mat\r\n        dst.position_material(mat, pairs, false)\r\n      end\r\n\r\n      true\r\n    rescue => e\r\n      UVPROP_LOG.call(\"copy_face_to_neighbor ERRO: #{e.class} - #{e.message}\")\r\n      false\r\n    end\r\n\r\n    # ---- Pick da face mais profunda ----\r\n\r\n    UVPROP_DEEPEST_FACE_PICK ||= lambda do |ph|\r\n      best_face = nil\r\n      best_path = nil\r\n      best_depth = -1\r\n\r\n      c = ph.count\r\n      c.times do |i|\r\n        path = ph.path_at(i)\r\n        next unless path && !path.empty?\r\n        face = path.reverse_each.find { |e| e.is_a?(Sketchup::Face) }\r\n        next unless face\r\n        depth = path.length\r\n        if depth > best_depth\r\n          best_depth = depth\r\n          best_face = face\r\n          best_path = path\r\n        end\r\n      end\r\n\r\n      if !best_face\r\n        picked = ph.best_picked\r\n        if picked.is_a?(Sketchup::Face)\r\n          best_face = picked\r\n          best_path = ph.path_at(0)\r\n        end\r\n      end\r\n\r\n      [best_face, best_path]\r\n    rescue\r\n      [nil, nil]\r\n    end\r\n\r\n    # ---- BFS para faces conectadas ----\r\n\r\n    UVPROP_CONNECTED_FACES_FROM ||= lambda do |seed_face|\r\n      visited = {}\r\n      queue = [seed_face]\r\n      visited[seed_face] = true\r\n\r\n      while (f = queue.shift)\r\n        f.edges.each do |e|\r\n          next if UVPROP_EDGE_BLOCKS_PROPAGATION.call(e)\r\n          e.faces.each do |nf|\r\n            next if visited[nf]\r\n            next unless nf.parent == seed_face.parent\r\n            visited[nf] = true\r\n            queue << nf\r\n          end\r\n        end\r\n      end\r\n\r\n      visited\r\n    rescue\r\n      { seed_face => true }\r\n    end\r\n\r\n    # ---- Propagação completa a partir do seed ----\r\n\r\n    UVPROP_DO_PROPAGATION ||= lambda do |face, path, face_set, angle_deg, scale_factor, randomize|\r\n      model = Sketchup.active_model\r\n      tw = Sketchup.create_texture_writer\r\n      needs_world = UVPROP_NEEDS_WORLD_SPACE.call(model, path)\r\n      t_total = UVPROP_TOTAL_TRANSFORM_FOR_PICK_PATH.call(model, path)\r\n      seed_needs_world = false\r\n\r\n      ap_len = model.active_path ? model.active_path.length : 0\r\n      UVPROP_LOG.call(\r\n        \"PROPAGATE: active_path_len=#{ap_len} path_len=#{path.length} \" \\\r\n        \"needs_world=#{needs_world} angle=#{angle_deg} scale=#{scale_factor} rand=#{randomize}\"\r\n      )\r\n\r\n      model.start_operation(ScriptUpComunidade::PropagarUV.obter_texto(:op_name), true)\r\n\r\n      # Se a face não tem material com textura, herdar do grupo/componente pai\r\n      fm = face.material\r\n      bm = face.back_material\r\n      unless (fm && fm.texture) || (bm && bm.texture)\r\n        parents = (path || []).select { |e|\r\n          e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance)\r\n        }\r\n        parents.reverse_each do |parent|\r\n          pmat = parent.material\r\n          if pmat && pmat.texture\r\n            face.material = pmat\r\n            UVPROP_LOG.call(\"INHERIT: material '#{pmat.display_name}' de #{parent.class}\")\r\n            break\r\n          end\r\n        end\r\n      end\r\n\r\n      ok_reset = UVPROP_RESET_AND_FIT_SEED_INPLACE.call(\r\n        face, t_total, tw, model, seed_needs_world, angle_deg, scale_factor\r\n      )\r\n      UVPROP_LOG.call(\"RESET_OK=#{ok_reset}\")\r\n\r\n      unless ok_reset\r\n        model.abort_operation rescue nil\r\n        return false\r\n      end\r\n\r\n      if randomize\r\n        ok_rand = UVPROP_RANDOMIZE_SEED_ORIGIN_INPLACE.call(face, tw, model, t_total, seed_needs_world)\r\n        UVPROP_LOG.call(\"RAND_OK=#{ok_rand}\")\r\n      end\r\n\r\n      visited = {}\r\n      visited[face] = true\r\n      queue = [face]\r\n\r\n      while (src = queue.shift)\r\n        UVPROP_NEIGHBORS_IN_SET.call(src, face_set).each do |dst|\r\n          next if visited[dst]\r\n          UVPROP_COPY_FACE_TO_NEIGHBOR.call(src, dst, face_set, tw, t_total, needs_world)\r\n          visited[dst] = true\r\n          queue << dst\r\n        end\r\n      end\r\n\r\n      model.commit_operation\r\n      true\r\n    rescue => e\r\n      model.abort_operation rescue nil\r\n      UVPROP_LOG.call(\"do_propagation ERRO: #{e.class} - #{e.message}\")\r\n      false\r\n    end\r\n\r\n    # ---- HTML da janela de sliders ----\r\n\r\n    UVPROP_SLIDER_HTML ||= <<-HTML\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n<meta charset=\"UTF-8\">\r\n<style>\r\n  * { margin: 0; padding: 0; box-sizing: border-box; }\r\n  body {\r\n    font-family: \"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;\r\n    padding: 12px 18px 8px;\r\n    background: #f7f8fa;\r\n    color: #333;\r\n    -webkit-user-select: none;\r\n    user-select: none;\r\n  }\r\n  .control {\r\n    background: #fff;\r\n    border: 1px solid #e0e0e0;\r\n    border-radius: 8px;\r\n    padding: 10px 14px 12px;\r\n    margin-bottom: 10px;\r\n  }\r\n  .control-header {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: baseline;\r\n    margin-bottom: 8px;\r\n  }\r\n  .control-label {\r\n    font-size: 12px;\r\n    font-weight: 600;\r\n    color: #555;\r\n  }\r\n  .control-value {\r\n    font-size: 14px;\r\n    font-weight: 700;\r\n    color: #1565c0;\r\n    min-width: 55px;\r\n    text-align: right;\r\n    transition: color 0.2s;\r\n  }\r\n  .control-value.disabled {\r\n    color: #bbb;\r\n  }\r\n  input[type=range] {\r\n    -webkit-appearance: none;\r\n    width: 100%;\r\n    height: 6px;\r\n    border-radius: 3px;\r\n    background: linear-gradient(to right, #d0d0d0, #b0b0b0);\r\n    outline: none;\r\n    transition: opacity 0.25s;\r\n    margin: 0;\r\n  }\r\n  input[type=range]:not(:disabled) {\r\n    background: linear-gradient(to right, #90caf9, #1565c0);\r\n  }\r\n  input[type=range]:disabled {\r\n    opacity: 0.35;\r\n  }\r\n  input[type=range]::-webkit-slider-thumb {\r\n    -webkit-appearance: none;\r\n    width: 20px;\r\n    height: 20px;\r\n    border-radius: 50%;\r\n    background: #1565c0;\r\n    cursor: pointer;\r\n    border: 2.5px solid #fff;\r\n    box-shadow: 0 1px 5px rgba(0,0,0,0.3);\r\n    transition: transform 0.1s;\r\n  }\r\n  input[type=range]::-webkit-slider-thumb:hover {\r\n    transform: scale(1.15);\r\n  }\r\n  input[type=range]:disabled::-webkit-slider-thumb {\r\n    background: #aaa;\r\n    cursor: default;\r\n    box-shadow: none;\r\n  }\r\n  #status {\r\n    font-size: 11px;\r\n    text-align: center;\r\n    color: #aaa;\r\n    padding: 8px 10px;\r\n    background: #ededef;\r\n    border-radius: 6px;\r\n    line-height: 1.4;\r\n  }\r\n  #status.active {\r\n    color: #2e7d32;\r\n    background: #e8f5e9;\r\n  }\r\n</style>\r\n</head>\r\n<body>\r\n  <div class=\"control\">\r\n    <div class=\"control-header\">\r\n      <span class=\"control-label\">#{ScriptUpComunidade::PropagarUV.obter_texto(:html_rotacao)}</span>\r\n      <span class=\"control-value disabled\" id=\"rot-val\">0&deg;</span>\r\n    </div>\r\n    <input type=\"range\" id=\"rotation\" min=\"0\" max=\"180\" value=\"0\" step=\"1\" disabled>\r\n  </div>\r\n\r\n  <div class=\"control\">\r\n    <div class=\"control-header\">\r\n      <span class=\"control-label\">#{ScriptUpComunidade::PropagarUV.obter_texto(:html_escala)}</span>\r\n      <span class=\"control-value disabled\" id=\"scale-val\">1.0x</span>\r\n    </div>\r\n    <input type=\"range\" id=\"scale\" min=\"1\" max=\"10\" value=\"1\" step=\"0.1\" disabled>\r\n  </div>\r\n\r\n  <div id=\"status\">#{ScriptUpComunidade::PropagarUV.obter_texto(:html_status_inativo)}</div>\r\n\r\n  <script>\r\n    var rotSlider   = document.getElementById(\"rotation\");\r\n    var scaleSlider = document.getElementById(\"scale\");\r\n    var rotVal      = document.getElementById(\"rot-val\");\r\n    var scaleVal    = document.getElementById(\"scale-val\");\r\n    var statusEl    = document.getElementById(\"status\");\r\n    var pending     = false;\r\n\r\n    function updateLabels() {\r\n      rotVal.textContent   = rotSlider.value + \"\\u00b0\";\r\n      scaleVal.textContent = parseFloat(scaleSlider.value).toFixed(1) + \"x\";\r\n    }\r\n\r\n    function sendToRuby() {\r\n      if (pending) return;\r\n      pending = true;\r\n      requestAnimationFrame(function() {\r\n        sketchup.on_slider_change(\r\n          parseFloat(rotSlider.value),\r\n          parseFloat(scaleSlider.value)\r\n        );\r\n        pending = false;\r\n      });\r\n    }\r\n\r\n    rotSlider.addEventListener(\"input\", function() {\r\n      updateLabels();\r\n      sendToRuby();\r\n    });\r\n\r\n    scaleSlider.addEventListener(\"input\", function() {\r\n      updateLabels();\r\n      sendToRuby();\r\n    });\r\n\r\n    function enableControls() {\r\n      rotSlider.disabled   = false;\r\n      scaleSlider.disabled = false;\r\n      rotVal.className     = \"control-value\";\r\n      scaleVal.className   = \"control-value\";\r\n      statusEl.textContent = \"#{ScriptUpComunidade::PropagarUV.obter_texto(:html_status_ativo)}\";\r\n      statusEl.className   = \"active\";\r\n    }\r\n  </script>\r\n</body>\r\n</html>\r\nHTML\r\n\r\n    # ============================================================\r\n    # FERRAMENTA INTERATIVA COM JANELA DE SLIDERS\r\n    # ============================================================\r\n\r\n    UVPROP_TOOL_CLASS ||= Class.new do\r\n      define_method(:initialize) do |preselected_faces_hash, allowed_insts|\r\n        @preselected_faces = preselected_faces_hash\r\n        @allowed_insts = allowed_insts\r\n        @last_face = nil\r\n        @last_path = nil\r\n        @last_face_set = nil\r\n        @current_rotation = 0.0\r\n        @current_scale = 1.0\r\n        @controls_enabled = false\r\n        @dialog = nil\r\n        @deactivating = false\r\n      end\r\n\r\n      define_method(:activate) do\r\n        @deactivating = false\r\n\r\n        @dialog = UI::HtmlDialog.new(\r\n          :dialog_title    => ScriptUpComunidade::PropagarUV.obter_texto(:dialog_title),\r\n          :preferences_key => \"uvprop_slider_v06\",\r\n          :width           => 320,\r\n          :height          => 270,\r\n          :left            => 120,\r\n          :top             => 120,\r\n          :resizable       => false,\r\n          :style           => UI::HtmlDialog::STYLE_DIALOG\r\n        )\r\n\r\n        @dialog.set_html(ScriptUpComunidade::PropagarUV.const_get(:UVPROP_SLIDER_HTML))\r\n\r\n        me = self\r\n\r\n        @dialog.add_action_callback(\"on_slider_change\") do |_ctx, rot, scl|\r\n          me.instance_variable_set(:@current_rotation, rot.to_f)\r\n          me.instance_variable_set(:@current_scale, scl.to_f)\r\n\r\n          face     = me.instance_variable_get(:@last_face)\r\n          path     = me.instance_variable_get(:@last_path)\r\n          face_set = me.instance_variable_get(:@last_face_set)\r\n\r\n          if face && path && face_set\r\n            UVPROP_DO_PROPAGATION.call(face, path, face_set, rot.to_f, scl.to_f, false)\r\n            Sketchup.active_model.active_view.invalidate\r\n          end\r\n        end\r\n\r\n        @dialog.set_on_closed do\r\n          dlg_ref = me.instance_variable_get(:@dialog)\r\n         \r\n          if dlg_ref\r\n            me.instance_variable_set(:@dialog, nil)\r\n            Sketchup.active_model.select_tool(nil)\r\n          end\r\n        end\r\n\r\n        @dialog.show\r\n\r\n        Sketchup.status_text = ScriptUpComunidade::PropagarUV.obter_texto(:status_text)\r\n      end\r\n\r\n      define_method(:deactivate) do |view|\r\n        return if @deactivating\r\n        @deactivating = true\r\n        if @dialog\r\n          dlg = @dialog\r\n          @dialog = nil\r\n          begin\r\n            dlg.set_on_closed {}\r\n            dlg.close\r\n          rescue\r\n          end\r\n        end\r\n        Sketchup.status_text = \"\"\r\n      end\r\n\r\n      define_method(:onCancel) do |_reason, _view|\r\n        Sketchup.active_model.select_tool(nil)\r\n      end\r\n\r\n      define_method(:onLButtonDown) do |_flags, x, y, view|\r\n        ph = view.pick_helper\r\n        ph.do_pick(x, y)\r\n\r\n        face, path = UVPROP_DEEPEST_FACE_PICK.call(ph)\r\n        unless face && path\r\n          UI.messagebox(ScriptUpComunidade::PropagarUV.obter_texto(:err_no_face))\r\n          return\r\n        end\r\n\r\n        if @allowed_insts && !@allowed_insts.empty?\r\n          inside = @allowed_insts.any? { |inst| path.include?(inst) }\r\n          unless inside\r\n            UI.messagebox(ScriptUpComunidade::PropagarUV.obter_texto(:err_outside_group))\r\n            return\r\n          end\r\n        end\r\n\r\n        face_set =\r\n          if @preselected_faces && !@preselected_faces.empty?\r\n            unless @preselected_faces[face]\r\n              UI.messagebox(ScriptUpComunidade::PropagarUV.obter_texto(:err_outside_sel))\r\n              return\r\n            end\r\n            @preselected_faces\r\n          else\r\n            UVPROP_CONNECTED_FACES_FROM.call(face)\r\n          end\r\n\r\n        @last_face = face\r\n        @last_path = path\r\n        @last_face_set = face_set\r\n\r\n        ok = UVPROP_DO_PROPAGATION.call(\r\n          face, path, face_set, @current_rotation, @current_scale, true\r\n        )\r\n\r\n        unless ok\r\n          UI.messagebox(ScriptUpComunidade::PropagarUV.obter_texto(:err_no_texture))\r\n          return\r\n        end\r\n\r\n        unless @controls_enabled\r\n          @controls_enabled = true\r\n          @dialog.execute_script(\"enableControls()\") if @dialog\r\n        end\r\n\r\n        Sketchup.status_text = ScriptUpComunidade::PropagarUV.obter_texto(:status_text)\r\n      rescue => e\r\n        Sketchup.active_model.abort_operation rescue nil\r\n        UI.messagebox(\"#{ScriptUpComunidade::PropagarUV.obter_texto(:err_prefix)} #{e.class}\\n#{e.message}\")\r\n      end\r\n    end\r\n\r\n    # ============================================================\r\n    # INICIALIZAÇÃO\r\n    # ============================================================\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      sel = model.selection\r\n\r\n      faces = sel.grep(Sketchup::Face)\r\n      insts = sel.grep(Sketchup::Group) + sel.grep(Sketchup::ComponentInstance)\r\n\r\n      if !faces.empty?\r\n        face_hash = faces.to_h { |f| [f, true] }\r\n        model.select_tool(UVPROP_TOOL_CLASS.new(face_hash, []))\r\n      elsif !insts.empty?\r\n        model.select_tool(UVPROP_TOOL_CLASS.new(nil, insts))\r\n      else\r\n        model.select_tool(UVPROP_TOOL_CLASS.new(nil, nil))\r\n      end\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::PropagarUV.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "tour-virtual-96wtf",
    "title": {
      "pt": "Tour Virtual",
      "en": "Virtual Tour",
      "es": "Visita virtual"
    },
    "author": "Fábio Coutinho",
    "version": "2.7",
    "description": {
      "pt": "Permite criar e gerenciar a criação de cenas em linha de tempo, várias linhas de tempo, apresentar a transição entre elas de forma suave e sem impacto de troca de cena e exportação de vídeo com FFMPEG de forma rápida por captura de tela enquanto apresenta.",
      "en": "It allows you to create and manage timeline scenes, multiple timelines, present the transition between them smoothly and without scene change impact, and quickly export video with FFMPEG by screen capture while presenting.",
      "es": "Le permite crear y administrar escenas de línea de tiempo, múltiples líneas de tiempo, presentar la transición entre ellas sin problemas y sin impacto en el cambio de escena, y exportar rápidamente video con FFMPEG mediante captura de pantalla mientras se presenta."
    },
    "keywords": {
      "pt": [
        "tour",
        "apresentação",
        "vídeo"
      ],
      "en": [
        "tour",
        "presentation",
        "video"
      ],
      "es": [
        "recorrido",
        "presentación",
        "video"
      ]
    },
    "code": {
      "pt": "require 'json'\r\nrequire 'sketchup.rb'\r\nrequire 'base64'\r\nrequire 'tmpdir'\r\nrequire 'fiddle/import'\r\nrequire 'fileutils'\r\nrequire 'open3'\r\nrequire 'etc'\r\nrequire 'open-uri'\r\nif Sketchup.platform == :platform_win\r\n  require 'win32ole'\r\nend\r\n\r\nmodule ScriptUpComunidade\r\nmodule TourVirtual\r\n\r\n# --- Definições de Diretórios ---\r\nplugins_root = Sketchup.find_support_file(\"Plugins\")\r\nPLUGIN_DIR = if plugins_root\r\n               File.expand_path(File.join(plugins_root, 'ScriptUp'))\r\n             else\r\n               File.expand_path(File.dirname(__FILE__))\r\n             end\r\n\r\nIDIOMAS = {\r\n  'pt-BR' => {\r\n    :status_clicar_arrastar  => \"CLIQUE E ARRASTE para definir a área de gravação do vídeo.\",\r\n    :area_pequena            => \"Área muito pequena. Tente novamente.\",\r\n    :selecionar_pasta        => \"Selecione a pasta para salvar\",\r\n    :ffmpeg_nao_encontrado   => \"FFmpeg não encontrado.\",\r\n    :erro_gravador           => \"Erro ao iniciar gravador: \",\r\n    :gravacao_finalizada     => \"Gravação finalizada!\\nSalvo em: \",\r\n    :ffmpeg_instalado        => \"FFmpeg instalado. Execute o Tour Virtual novamente.\",\r\n    :titulo_dialogo          => \"Tour Virtual\",\r\n    :ffmpeg_plugins_erro     => \"Não foi possível resolver a pasta Plugins automaticamente.\",\r\n    :ffmpeg_instalar_em      => \"Instalar FFmpeg em:\",\r\n    :ffmpeg_origem           => \"Origem:\",\r\n    :ffmpeg_continuar        => \"Continuar?\",\r\n    :ffmpeg_cancelada        => \"Instalação cancelada.\",\r\n    :ffmpeg_ja_existe        => \"Já existe:\",\r\n    :ffmpeg_sobrescrever     => \"Deseja sobrescrever?\",\r\n    :ffmpeg_falha_expand     => \"Falha no Expand-Archive (PowerShell).\",\r\n    :ffmpeg_falha_unzip      => \"Falha no unzip (macOS).\",\r\n    :ffmpeg_exe_nao_encontrado => \"Executável ffmpeg não encontrado no pacote baixado.\",\r\n    :ffmpeg_sucesso          => \"FFmpeg instalado com sucesso em:\",\r\n    :ffmpeg_falhou           => \"Falhou:\",\r\n    :ffmpeg_abrindo_nav      => \"Abrindo o link no navegador...\",\r\n    :titulo                  => \"Tour Virtual\",\r\n    :subtitulo               => \"Linha do Tempo\",\r\n    :total                   => \"Total:\",\r\n    :visao                   => \"Visão\",\r\n    :play                    => \"Play\",\r\n    :stop                    => \"Stop\",\r\n    :play_all                => \"Play All\",\r\n    :stop_all                => \"Stop All\",\r\n    :atalho                  => \"Atalho\",\r\n    :pressione               => \"Pressione...\",\r\n    :ok                      => \"Ok\",\r\n    :loop                    => \"Loop\",\r\n    :easing                  => \"Easing\",\r\n    :visoes_salvas           => \"Visões salvas\",\r\n    :gerenciar_timeline      => \"Gerenciar Time Line\",\r\n    :nova                    => \"Nova\",\r\n    :exportar_atual          => \"Exportar Atual\",\r\n    :exportar_projeto        => \"Exportar Projeto\",\r\n    :importar                => \"Importar\",\r\n    :exportar_video          => \"Exportar Vídeo\",\r\n    :selecione_formato       => \"Selecione o formato…\",\r\n    :largura                 => \"Largura\",\r\n    :altura                  => \"Altura\",\r\n    :gravar_projeto          => \"Gravar todo o projeto (todas as Time Lines)\",\r\n    :iniciar_quadro1         => \"Iniciar do quadro 1\",\r\n    :iniciar_gravacao        => \"Iniciar Gravação\",\r\n    :gravando                => \"Gravando...\",\r\n    :ffmpeg_necessario       => \"FFmpeg necessário para gravar vídeo.\",\r\n    :instalar_ffmpeg         => \"Instalar FFmpeg\",\r\n    :nome_arquivo            => \"Nome do arquivo\",\r\n    :extensao_mp4            => \"A extensão .mp4 será adicionada automaticamente.\",\r\n    :cancelar                => \"Cancelar\",\r\n    :salvar                  => \"Salvar\",\r\n    :viewport_atual          => \"Viewport atual:\",\r\n    :paisagem                => \"Paisagem\",\r\n    :retrato                 => \"Retrato\",\r\n    :quadrado                => \"Quadrado\",\r\n    :classico                => \"Clássico\",\r\n    :ultra_wide              => \"Ultra-wide\",\r\n    :viewport_inteira        => \"Viewport Inteira\",\r\n    :personalizado           => \"Personalizado\",\r\n    :nome_timeline           => \"Nome da Time Line:\",\r\n    :nenhuma_visao           => \"Nenhuma visão adicionada.\",\r\n    :dica_visao              => \"Posicione a câmera e clique em <b>+ Visão</b>.\",\r\n    :ancora                  => \"Âncora\",\r\n    :excluir                 => \"Excluir\",\r\n    :min_duas_visoes         => \"Adicione pelo menos duas visões.\",\r\n    :sem_tl_2mais            => \"Nenhuma Time Line com 2+ visões.\",\r\n    :sem_visoes_exportar     => \"Nenhuma visão para exportar.\",\r\n    :sem_tl_exportar         => \"Nenhuma Time Line para exportar.\",\r\n    :importada               => \"Importada\",\r\n    :formato_invalido        => \"Formato inválido.\",\r\n    :erro_importar           => \"Erro ao importar: \",\r\n    :visoes                  => \"visões\",\r\n    :nova_timeline           => \"Nome da nova Time Line:\",\r\n    :area_gravacao           => \"Área de gravação: \",\r\n    :sem_tl_min_duas         => \"Nenhuma Time Line com pelo menos duas visões.\",\r\n    :dims_invalidas          => \"Dimensões inválidas (mínimo 50 x 50 px).\",\r\n    :digite_nome             => \"Digite um nome para o arquivo.\",\r\n  },\r\n  'en-US' => {\r\n    :status_clicar_arrastar  => \"CLICK AND DRAG to define the video recording area.\",\r\n    :area_pequena            => \"Area too small. Try again.\",\r\n    :selecionar_pasta        => \"Select folder to save\",\r\n    :ffmpeg_nao_encontrado   => \"FFmpeg not found.\",\r\n    :erro_gravador           => \"Error starting recorder: \",\r\n    :gravacao_finalizada     => \"Recording finished!\\nSaved to: \",\r\n    :ffmpeg_instalado        => \"FFmpeg installed. Run Virtual Tour again.\",\r\n    :titulo_dialogo          => \"Virtual Tour\",\r\n    :ffmpeg_plugins_erro     => \"Could not resolve the Plugins folder automatically.\",\r\n    :ffmpeg_instalar_em      => \"Install FFmpeg to:\",\r\n    :ffmpeg_origem           => \"Source:\",\r\n    :ffmpeg_continuar        => \"Continue?\",\r\n    :ffmpeg_cancelada        => \"Installation cancelled.\",\r\n    :ffmpeg_ja_existe        => \"Already exists:\",\r\n    :ffmpeg_sobrescrever     => \"Overwrite?\",\r\n    :ffmpeg_falha_expand     => \"Expand-Archive failed (PowerShell).\",\r\n    :ffmpeg_falha_unzip      => \"unzip failed (macOS).\",\r\n    :ffmpeg_exe_nao_encontrado => \"FFmpeg executable not found in downloaded package.\",\r\n    :ffmpeg_sucesso          => \"FFmpeg successfully installed to:\",\r\n    :ffmpeg_falhou           => \"Failed:\",\r\n    :ffmpeg_abrindo_nav      => \"Opening the link in browser...\",\r\n    :titulo                  => \"Virtual Tour\",\r\n    :subtitulo               => \"Timeline\",\r\n    :total                   => \"Total:\",\r\n    :visao                   => \"Vision\",\r\n    :play                    => \"Play\",\r\n    :stop                    => \"Stop\",\r\n    :play_all                => \"Play All\",\r\n    :stop_all                => \"Stop All\",\r\n    :atalho                  => \"Hotkey\",\r\n    :pressione               => \"Press a key...\",\r\n    :ok                      => \"Ok\",\r\n    :loop                    => \"Loop\",\r\n    :easing                  => \"Easing\",\r\n    :visoes_salvas           => \"Saved visions\",\r\n    :gerenciar_timeline      => \"Manage Timeline\",\r\n    :nova                    => \"New\",\r\n    :exportar_atual          => \"Export Current\",\r\n    :exportar_projeto        => \"Export Project\",\r\n    :importar                => \"Import\",\r\n    :exportar_video          => \"Export Video\",\r\n    :selecione_formato       => \"Select format…\",\r\n    :largura                 => \"Width\",\r\n    :altura                  => \"Height\",\r\n    :gravar_projeto          => \"Record entire project (all Timelines)\",\r\n    :iniciar_quadro1         => \"Start from frame 1\",\r\n    :iniciar_gravacao        => \"Start Recording\",\r\n    :gravando                => \"Recording...\",\r\n    :ffmpeg_necessario       => \"FFmpeg is required to record video.\",\r\n    :instalar_ffmpeg         => \"Install FFmpeg\",\r\n    :nome_arquivo            => \"File name\",\r\n    :extensao_mp4            => \"The .mp4 extension will be added automatically.\",\r\n    :cancelar                => \"Cancel\",\r\n    :salvar                  => \"Save\",\r\n    :viewport_atual          => \"Current viewport:\",\r\n    :paisagem                => \"Landscape\",\r\n    :retrato                 => \"Portrait\",\r\n    :quadrado                => \"Square\",\r\n    :classico                => \"Classic\",\r\n    :ultra_wide              => \"Ultra-wide\",\r\n    :viewport_inteira        => \"Full Viewport\",\r\n    :personalizado           => \"Custom\",\r\n    :nome_timeline           => \"Timeline name:\",\r\n    :nenhuma_visao           => \"No visions added.\",\r\n    :dica_visao              => \"Position the camera and click <b>+ Vision</b>.\",\r\n    :ancora                  => \"Anchor\",\r\n    :excluir                 => \"Delete\",\r\n    :min_duas_visoes         => \"Add at least two visions.\",\r\n    :sem_tl_2mais            => \"No Timeline with 2+ visions.\",\r\n    :sem_visoes_exportar     => \"No visions to export.\",\r\n    :sem_tl_exportar         => \"No Timeline to export.\",\r\n    :importada               => \"Imported\",\r\n    :formato_invalido        => \"Invalid format.\",\r\n    :erro_importar           => \"Import error: \",\r\n    :visoes                  => \"visions\",\r\n    :nova_timeline           => \"New Timeline name:\",\r\n    :area_gravacao           => \"Recording area: \",\r\n    :sem_tl_min_duas         => \"No Timeline with at least two visions.\",\r\n    :dims_invalidas          => \"Invalid dimensions (minimum 50 x 50 px).\",\r\n    :digite_nome             => \"Enter a file name.\",\r\n  },\r\n  'es' => {\r\n    :status_clicar_arrastar  => \"HAZ CLIC Y ARRASTRA para definir el área de grabación del video.\",\r\n    :area_pequena            => \"Área demasiado pequeña. Inténtalo de nuevo.\",\r\n    :selecionar_pasta        => \"Selecciona la carpeta para guardar\",\r\n    :ffmpeg_nao_encontrado   => \"FFmpeg no encontrado.\",\r\n    :erro_gravador           => \"Error al iniciar grabador: \",\r\n    :gravacao_finalizada     => \"¡Grabación finalizada!\\nGuardado en: \",\r\n    :ffmpeg_instalado        => \"FFmpeg instalado. Ejecuta Tour Virtual de nuevo.\",\r\n    :titulo_dialogo          => \"Tour Virtual\",\r\n    :ffmpeg_plugins_erro     => \"No se pudo resolver la carpeta Plugins automáticamente.\",\r\n    :ffmpeg_instalar_em      => \"Instalar FFmpeg en:\",\r\n    :ffmpeg_origem           => \"Origen:\",\r\n    :ffmpeg_continuar        => \"¿Continuar?\",\r\n    :ffmpeg_cancelada        => \"Instalación cancelada.\",\r\n    :ffmpeg_ja_existe        => \"Ya existe:\",\r\n    :ffmpeg_sobrescrever     => \"¿Sobrescribir?\",\r\n    :ffmpeg_falha_expand     => \"Error en Expand-Archive (PowerShell).\",\r\n    :ffmpeg_falha_unzip      => \"Error en unzip (macOS).\",\r\n    :ffmpeg_exe_nao_encontrado => \"Ejecutable FFmpeg no encontrado en el paquete descargado.\",\r\n    :ffmpeg_sucesso          => \"FFmpeg instalado con éxito en:\",\r\n    :ffmpeg_falhou           => \"Falló:\",\r\n    :ffmpeg_abrindo_nav      => \"Abriendo el enlace en el navegador...\",\r\n    :titulo                  => \"Tour Virtual\",\r\n    :subtitulo               => \"Línea de Tiempo\",\r\n    :total                   => \"Total:\",\r\n    :visao                   => \"Visión\",\r\n    :play                    => \"Play\",\r\n    :stop                    => \"Stop\",\r\n    :play_all                => \"Play All\",\r\n    :stop_all                => \"Stop All\",\r\n    :atalho                  => \"Atajo\",\r\n    :pressione               => \"Presiona...\",\r\n    :ok                      => \"Ok\",\r\n    :loop                    => \"Loop\",\r\n    :easing                  => \"Easing\",\r\n    :visoes_salvas           => \"Visiones guardadas\",\r\n    :gerenciar_timeline      => \"Gestionar Línea de Tiempo\",\r\n    :nova                    => \"Nueva\",\r\n    :exportar_atual          => \"Exportar Actual\",\r\n    :exportar_projeto        => \"Exportar Proyecto\",\r\n    :importar                => \"Importar\",\r\n    :exportar_video          => \"Exportar Video\",\r\n    :selecione_formato       => \"Selecciona el formato…\",\r\n    :largura                 => \"Ancho\",\r\n    :altura                  => \"Alto\",\r\n    :gravar_projeto          => \"Grabar todo el proyecto (todas las Líneas de Tiempo)\",\r\n    :iniciar_quadro1         => \"Iniciar desde el cuadro 1\",\r\n    :iniciar_gravacao        => \"Iniciar Grabación\",\r\n    :gravando                => \"Grabando...\",\r\n    :ffmpeg_necessario       => \"FFmpeg necesario para grabar video.\",\r\n    :instalar_ffmpeg         => \"Instalar FFmpeg\",\r\n    :nome_arquivo            => \"Nombre del archivo\",\r\n    :extensao_mp4            => \"La extensión .mp4 se añadirá automáticamente.\",\r\n    :cancelar                => \"Cancelar\",\r\n    :salvar                  => \"Guardar\",\r\n    :viewport_atual          => \"Viewport actual:\",\r\n    :paisagem                => \"Paisaje\",\r\n    :retrato                 => \"Retrato\",\r\n    :quadrado                => \"Cuadrado\",\r\n    :classico                => \"Clásico\",\r\n    :ultra_wide              => \"Ultra-wide\",\r\n    :viewport_inteira        => \"Viewport Completa\",\r\n    :personalizado           => \"Personalizado\",\r\n    :nome_timeline           => \"Nombre de la Línea de Tiempo:\",\r\n    :nenhuma_visao           => \"Ninguna visión añadida.\",\r\n    :dica_visao              => \"Posiciona la cámara y haz clic en <b>+ Visión</b>.\",\r\n    :ancora                  => \"Ancla\",\r\n    :excluir                 => \"Eliminar\",\r\n    :min_duas_visoes         => \"Añade al menos dos visiones.\",\r\n    :sem_tl_2mais            => \"Ninguna Línea de Tiempo con 2+ visiones.\",\r\n    :sem_visoes_exportar     => \"Ninguna visión para exportar.\",\r\n    :sem_tl_exportar         => \"Ninguna Línea de Tiempo para exportar.\",\r\n    :importada               => \"Importada\",\r\n    :formato_invalido        => \"Formato inválido.\",\r\n    :erro_importar           => \"Error al importar: \",\r\n    :visoes                  => \"visiones\",\r\n    :nova_timeline           => \"Nombre de la nueva Línea de Tiempo:\",\r\n    :area_gravacao           => \"Área de grabación: \",\r\n    :sem_tl_min_duas         => \"Ninguna Línea de Tiempo con al menos dos visiones.\",\r\n    :dims_invalidas          => \"Dimensiones inválidas (mínimo 50 x 50 px).\",\r\n    :digite_nome             => \"Escribe un nombre para el archivo.\",\r\n  },\r\n}\r\n\r\ndef self.obter_texto(chave)\r\n  locale = Sketchup.get_locale\r\n  lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n  IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\nend\r\n\r\n# --- Script de Instalação do FFmpeg (Mantido) ---\r\nFFMPEG_INSTALL_SCRIPT ||= <<~'RUBY'\r\n  require 'sketchup'\r\n  require 'open-uri'\r\n  require 'fileutils'\r\n  require 'tmpdir'\r\n\r\n  URL_WIN ||= 'https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-master-latest-win64-gpl.zip'\r\n  URL_MAC ||= 'https://evermeet.cx/ffmpeg/getrelease/zip'\r\n\r\n  win = Sketchup.platform == :platform_win\r\n  major = Sketchup.version.to_s[/^\\d+/].to_i\r\n  sketchup_year = 2000 + major\r\n\r\n  plugins_dir = Sketchup.find_support_file('Plugins')\r\n  if !plugins_dir || plugins_dir.empty? || !Dir.exist?(plugins_dir)\r\n    if win\r\n      base = ENV['APPDATA'].to_s\r\n      plugins_dir = File.join(base, 'SketchUp', \"SketchUp #{sketchup_year}\", 'SketchUp', 'Plugins')\r\n    else\r\n      plugins_dir = File.expand_path(\"~/Library/Application Support/SketchUp #{sketchup_year}/SketchUp/Plugins\")\r\n    end\r\n  end\r\n\r\n  target_dir = File.join(plugins_dir, 'ScriptUp', 'ffmpeg')\r\n  target_exe = File.join(target_dir, win ? 'ffmpeg.exe' : 'ffmpeg')\r\n  url = win ? URL_WIN : URL_MAC\r\n  default_zip_name = win ? 'ffmpeg-win64-gpl-latest.zip' : 'ffmpeg-macos-release.zip'\r\n\r\n  proceed = true\r\n\r\n  unless plugins_dir && !plugins_dir.empty?\r\n    UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_plugins_erro))\r\n    proceed = false\r\n  end\r\n\r\n  if proceed\r\n    msg = \"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_instalar_em)}\\n#{target_dir}\\n\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_origem)}\\n#{url}\\n\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_continuar)}\"\r\n    if UI.messagebox(msg, MB_YESNO) != IDYES\r\n      UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_cancelada))\r\n      proceed = false\r\n    end\r\n  end\r\n\r\n  if proceed && File.exist?(target_exe)\r\n    overwrite = UI.messagebox(\"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_ja_existe)}\\n#{target_exe}\\n\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_sobrescrever)}\", MB_YESNO)\r\n    if overwrite != IDYES\r\n      UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_cancelada))\r\n      proceed = false\r\n    end\r\n  end\r\n\r\n  if proceed\r\n    Dir.mktmpdir('ffmpeg_dl_') do |tmp|\r\n      zip_path = File.join(tmp, default_zip_name)\r\n      extract_dir = File.join(tmp, 'unzipped')\r\n      begin\r\n        URI.open(url, 'rb') do |io|\r\n          File.open(zip_path, 'wb') { |f| IO.copy_stream(io, f) }\r\n        end\r\n        Dir.mkdir(extract_dir)\r\n        if win\r\n          ps = 'powershell -NoProfile -ExecutionPolicy Bypass -Command'\r\n          cmd = \"#{ps} \\\"Expand-Archive -LiteralPath '#{zip_path}' -DestinationPath '#{extract_dir}' -Force\\\"\"\r\n          ok = system(cmd)\r\n          raise ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_falha_expand) unless ok\r\n        else\r\n          ok = system(\"unzip -o -q '#{zip_path}' -d '#{extract_dir}'\")\r\n          raise ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_falha_unzip) unless ok\r\n        end\r\n\r\n        pattern = win ? '**/ffmpeg.exe' : '**/ffmpeg'\r\n        bin = Dir.glob(File.join(extract_dir, pattern)).find { |p| File.file?(p) }\r\n        raise ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_exe_nao_encontrado) unless bin\r\n\r\n        FileUtils.mkdir_p(target_dir) unless Dir.exist?(target_dir)\r\n        FileUtils.cp(bin, target_exe)\r\n        unless win\r\n          FileUtils.chmod(0o755, target_exe)\r\n          system(\"xattr -d com.apple.quarantine '#{target_exe}' 2>/dev/null\")\r\n        end\r\n\r\n        UI.messagebox(\"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_sucesso)}\\n#{target_exe}\")\r\n        puts \"OK: #{target_exe}\"\r\n      rescue => e\r\n        UI.messagebox(\"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_falhou)} #{e.message}\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_abrindo_nav)}\")\r\n        UI.openURL(url)\r\n      end\r\n    end\r\n  end\r\nRUBY\r\n\r\n# --- Módulo WindowUtils ---\r\nmodule WindowUtils\r\n  extend Fiddle::Importer\r\n  dlload 'user32.dll' if Sketchup.platform == :platform_win\r\n\r\n  if Sketchup.platform == :platform_win\r\n    typealias 'HWND', 'void*'\r\n    extern 'HWND GetActiveWindow()'\r\n    extern 'HWND GetForegroundWindow()'\r\n    extern 'HWND GetWindow(HWND, int)'\r\n    extern 'int GetWindowRect(HWND, void*)'\r\n    extern 'HWND GetParent(HWND)'\r\n    \r\n    GW_CHILD = 5\r\n    GW_HWNDNEXT = 2\r\n    Rect = struct ['long left', 'long top', 'long right', 'long bottom']\r\n  end\r\n\r\n  def self.get_viewport_rect_deep(view)\r\n    return nil unless Sketchup.platform == :platform_win\r\n    \r\n    hwnd = GetForegroundWindow()\r\n    return nil if hwnd.nil? || hwnd == 0\r\n\r\n    vw = view.vpwidth\r\n    vh = view.vpheight\r\n    \r\n    found = find_recursive(hwnd, vw, vh)\r\n    return found if found\r\n\r\n    parent = GetParent(hwnd)\r\n    if parent && parent != 0\r\n      found = find_recursive(parent, vw, vh)\r\n      return found if found\r\n    end\r\n\r\n    nil\r\n  end\r\n\r\n  def self.find_recursive(parent_hwnd, target_w, target_h)\r\n    child = GetWindow(parent_hwnd, GW_CHILD)\r\n    while child && child.to_i != 0\r\n      rect = Rect.malloc\r\n      if GetWindowRect(child, rect) != 0\r\n        w = rect.right - rect.left\r\n        h = rect.bottom - rect.top\r\n        match = check_match(w, h, target_w, target_h, rect)\r\n        return match if match\r\n      end\r\n      found_in_child = find_recursive(child, target_w, target_h)\r\n      return found_in_child if found_in_child\r\n      child = GetWindow(child, GW_HWNDNEXT)\r\n    end\r\n    nil\r\n  end\r\n\r\n  def self.check_match(w, h, target_w, target_h, rect)\r\n    tol = 30\r\n    [1.0, 1.25, 1.5, 2.0].each do |scale|\r\n      if (w - target_w * scale).abs <= tol && (h - target_h * scale).abs <= tol\r\n        return { :x => rect.left, :y => rect.top, :w => w, :h => h, :scale => scale }\r\n      end\r\n    end\r\n    nil\r\n  end\r\nend\r\n\r\n# --- Módulo ScreenCapture (GDI32) ---\r\n# Captures the SketchUp viewport via Win32 GDI and produces a BMP thumbnail\r\n# encoded as Base64, suitable for embedding in an HTML <img> tag.\r\n#\r\n# Uses Fiddle::Importer (Ruby stdlib) to call gdi32.dll and user32.dll functions.\r\n# Also declares PrintWindow from user32.dll as a fallback for occluded windows.\r\n#\r\n# Fiddle type mapping reference (from fiddle/types.rb Win32Types):\r\n#   HANDLE / HDC / HWND / HBITMAP  ->  void*   (pointer-sized, correct for 32/64-bit)\r\n#   DWORD                          ->  unsigned long\r\n#   BOOL                           ->  int\r\n#   UINT                           ->  unsigned int\r\n#\r\n# The extern signatures below use 'void*' directly for all handle types\r\n# (HDC, HBITMAP, HGDIOBJ) so we do not need to include Fiddle::Win32Types\r\n# or add custom typealiases beyond what WindowUtils already defines.\r\nmodule ScreenCapture\r\n  extend Fiddle::Importer\r\n\r\n  if Sketchup.platform == :platform_win\r\n    dlload 'gdi32.dll', 'user32.dll'\r\n\r\n    # --- user32.dll functions ---\r\n    # HDC GetDC(HWND hWnd)\r\n    #   hWnd=NULL(0) returns DC for entire screen\r\n    extern 'void* GetDC(void*)'\r\n\r\n    # int ReleaseDC(HWND hWnd, HDC hDC)\r\n    extern 'int ReleaseDC(void*, void*)'\r\n\r\n    # BOOL PrintWindow(HWND hwnd, HDC hdcBlt, UINT nFlags)\r\n    #   Asks the window to paint itself into the given DC.\r\n    #   Works even when the window is partially occluded (unlike BitBlt from screen DC).\r\n    extern 'int PrintWindow(void*, void*, unsigned int)'\r\n\r\n    # --- gdi32.dll functions ---\r\n    # HDC CreateCompatibleDC(HDC hdc)\r\n    extern 'void* CreateCompatibleDC(void*)'\r\n\r\n    # HBITMAP CreateCompatibleBitmap(HDC hdc, int cx, int cy)\r\n    extern 'void* CreateCompatibleBitmap(void*, int, int)'\r\n\r\n    # HGDIOBJ SelectObject(HDC hdc, HGDIOBJ h)\r\n    extern 'void* SelectObject(void*, void*)'\r\n\r\n    # BOOL BitBlt(HDC hdc, int x, int y, int cx, int cy,\r\n    #             HDC hdcSrc, int x1, int y1, DWORD rop)\r\n    extern 'int BitBlt(void*, int, int, int, int, void*, int, int, unsigned long)'\r\n\r\n    # BOOL StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest,\r\n    #                 HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop)\r\n    extern 'int StretchBlt(void*, int, int, int, int, void*, int, int, int, int, unsigned long)'\r\n\r\n    # int SetStretchBltMode(HDC hdc, int mode)\r\n    extern 'int SetStretchBltMode(void*, int)'\r\n\r\n    # int GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines,\r\n    #               LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage)\r\n    #   lpvBits and lpbmi are both void* (raw pointers to caller-allocated buffers)\r\n    extern 'int GetDIBits(void*, void*, unsigned int, unsigned int, void*, void*, unsigned int)'\r\n\r\n    # BOOL DeleteDC(HDC hdc)\r\n    extern 'int DeleteDC(void*)'\r\n\r\n    # BOOL DeleteObject(HGDIOBJ ho)\r\n    extern 'int DeleteObject(void*)'\r\n\r\n    # --- Raster-operation and mode constants ---\r\n    SRCCOPY        = 0x00CC0020\r\n    HALFTONE       = 4          # SetStretchBltMode mode for high-quality shrinking\r\n    DIB_RGB_COLORS = 0          # GetDIBits color table usage\r\n\r\n    # --- PrintWindow flags ---\r\n    PW_CLIENTONLY          = 0x00000001  # capture client area only (no title bar)\r\n    PW_RENDERFULLCONTENT   = 0x00000002  # Win 8.1+: captures DirectX/DWM content\r\n  end\r\n\r\n  # Build a 40-byte BITMAPINFOHEADER as a packed binary string.\r\n  #\r\n  # The BITMAPINFOHEADER struct layout (40 bytes total):\r\n  #   DWORD  biSize          (4 bytes, unsigned 32-bit LE)   = 40\r\n  #   LONG   biWidth         (4 bytes, signed   32-bit LE)\r\n  #   LONG   biHeight        (4 bytes, signed   32-bit LE)   negative = top-down DIB\r\n  #   WORD   biPlanes        (2 bytes, unsigned 16-bit LE)   = 1\r\n  #   WORD   biBitCount      (2 bytes, unsigned 16-bit LE)   = 24 for RGB\r\n  #   DWORD  biCompression   (4 bytes, unsigned 32-bit LE)   = 0 (BI_RGB)\r\n  #   DWORD  biSizeImage     (4 bytes, unsigned 32-bit LE)\r\n  #   LONG   biXPelsPerMeter (4 bytes, signed   32-bit LE)   = 0\r\n  #   LONG   biYPelsPerMeter (4 bytes, signed   32-bit LE)   = 0\r\n  #   DWORD  biClrUsed       (4 bytes, unsigned 32-bit LE)   = 0\r\n  #   DWORD  biClrImportant  (4 bytes, unsigned 32-bit LE)   = 0\r\n  #\r\n  # Pack template: 'L<' = uint32 LE, 'l<' = int32 LE, 'S<' = uint16 LE\r\n  # Combined: 'L< l< l< S< S< L< L< l< l< L< L<'  (spaces for clarity)\r\n  #\r\n  # Using negative biHeight produces a top-down DIB, which means:\r\n  #  - Row 0 in memory is the top row of the image\r\n  #  - No vertical flip is needed when writing the BMP file\r\n  #  - The BMP file header must also use the negative height to match\r\n  def self.pack_bitmapinfoheader(width, height, image_size)\r\n    [\r\n      40,           # biSize\r\n      width,        # biWidth\r\n      -height,      # biHeight (negative = top-down)\r\n      1,            # biPlanes\r\n      24,           # biBitCount (24-bit RGB)\r\n      0,            # biCompression (BI_RGB = uncompressed)\r\n      image_size,   # biSizeImage\r\n      0,            # biXPelsPerMeter\r\n      0,            # biYPelsPerMeter\r\n      0,            # biClrUsed\r\n      0             # biClrImportant\r\n    ].pack('L<l<l<S<S<L<L<l<l<L<L<')\r\n  end\r\n\r\n  # Build the 14-byte BMP file header (BITMAPFILEHEADER).\r\n  #\r\n  # Layout:\r\n  #   WORD   bfType      = 0x4D42 (\"BM\")\r\n  #   DWORD  bfSize      = total file size in bytes\r\n  #   WORD   bfReserved1 = 0\r\n  #   WORD   bfReserved2 = 0\r\n  #   DWORD  bfOffBits   = offset to pixel data = 14 + 40 = 54\r\n  #\r\n  # Pack template: 'S< L< S< S< L<'\r\n  def self.pack_bmp_file_header(pixel_data_size)\r\n    file_size = 14 + 40 + pixel_data_size\r\n    [\r\n      0x4D42,       # bfType (\"BM\")\r\n      file_size,    # bfSize\r\n      0,            # bfReserved1\r\n      0,            # bfReserved2\r\n      54            # bfOffBits (14-byte file header + 40-byte info header)\r\n    ].pack('S<L<S<S<L<')\r\n  end\r\n\r\n  # Capture the SketchUp viewport as a scaled-down BMP thumbnail and return\r\n  # a Base64-encoded string. Returns nil on failure (non-Windows, HWND not found, etc.).\r\n  #\r\n  # Strategy:\r\n  #   1. StretchBlt from screen DC (fast, works when viewport is visible)\r\n  #   2. If vp[:hwnd] is available, PrintWindow can be used as alternative\r\n  #\r\n  # Parameters:\r\n  #   view     - Sketchup::View instance\r\n  #   thumb_w  - desired thumbnail width  in pixels (default 96)\r\n  #   thumb_h  - desired thumbnail height in pixels (default 60)\r\n  #\r\n  # Returns: Base64-encoded BMP string, or nil on failure.\r\n  def self.capture_viewport(view, thumb_w = 96, thumb_h = 60)\r\n    return nil unless Sketchup.platform == :platform_win\r\n\r\n    vp = WindowUtils.get_viewport_rect_deep(view)\r\n    return nil unless vp\r\n\r\n    src_w = vp[:w]\r\n    src_h = vp[:h]\r\n\r\n    # Get screen DC -- needed for CreateCompatibleBitmap color depth\r\n    screen_dc = GetDC(0)\r\n    return nil if screen_dc.nil? || screen_dc.to_i == 0\r\n\r\n    begin\r\n      # Create a memory DC compatible with the screen\r\n      mem_dc = CreateCompatibleDC(screen_dc)\r\n      return nil if mem_dc.nil? || mem_dc.to_i == 0\r\n\r\n      begin\r\n        # Create a bitmap at the desired thumbnail size\r\n        bmp = CreateCompatibleBitmap(screen_dc, thumb_w, thumb_h)\r\n        return nil if bmp.nil? || bmp.to_i == 0\r\n\r\n        begin\r\n          old = SelectObject(mem_dc, bmp)\r\n          SetStretchBltMode(mem_dc, HALFTONE)\r\n\r\n          # StretchBlt from the screen DC directly into the thumbnail-sized bitmap.\r\n          # This both captures AND scales in a single operation.\r\n          ok = StretchBlt(\r\n            mem_dc, 0, 0, thumb_w, thumb_h,\r\n            screen_dc, vp[:x], vp[:y], src_w, src_h,\r\n            SRCCOPY\r\n          )\r\n          return nil if ok == 0\r\n\r\n          # IMPORTANT: Deselect the bitmap from the DC before calling GetDIBits.\r\n          # Per MSDN: \"The bitmap identified by hbmp must not be selected into\r\n          # a device context when the application calls this function.\"\r\n          SelectObject(mem_dc, old)\r\n          old = nil\r\n\r\n          # Calculate row stride (BMP rows must be padded to 4-byte boundaries)\r\n          stride     = ((thumb_w * 3 + 3) & ~3)\r\n          pixel_size = stride * thumb_h\r\n\r\n          # Pack the BITMAPINFOHEADER into a Fiddle::Pointer buffer.\r\n          # GetDIBits may modify the header (e.g., filling in biSizeImage),\r\n          # so we use a mutable native buffer rather than a Ruby String.\r\n          bmi_bytes = pack_bitmapinfoheader(thumb_w, thumb_h, pixel_size)\r\n          bmi_ptr   = Fiddle::Pointer.malloc(bmi_bytes.bytesize)\r\n          bmi_ptr[0, bmi_bytes.bytesize] = bmi_bytes\r\n\r\n          # Allocate the pixel data buffer\r\n          buf = Fiddle::Pointer.malloc(pixel_size)\r\n\r\n          begin\r\n            # GetDIBits(hdc, hbm, start, cLines, lpvBits, lpbmi, usage)\r\n            # hdc: a DC compatible with the bitmap (mem_dc works)\r\n            # hbm: the bitmap handle (NOT selected into any DC)\r\n            rows = GetDIBits(mem_dc, bmp, 0, thumb_h, buf, bmi_ptr, DIB_RGB_COLORS)\r\n            return nil if rows == 0\r\n\r\n            # Read the raw pixel bytes from the Fiddle::Pointer buffer.\r\n            # ptr[offset, length] returns a Ruby String (binary safe, works since Ruby 2.0).\r\n            pixel_data = buf[0, pixel_size]\r\n\r\n            # Assemble the complete BMP file: file header + info header + pixel data\r\n            file_hdr = pack_bmp_file_header(pixel_size)\r\n            info_hdr = pack_bitmapinfoheader(thumb_w, thumb_h, pixel_size)\r\n\r\n            Base64.strict_encode64(file_hdr + info_hdr + pixel_data)\r\n          ensure\r\n            Fiddle.free(bmi_ptr) if bmi_ptr\r\n            Fiddle.free(buf)     if buf\r\n          end\r\n        ensure\r\n          SelectObject(mem_dc, old) if old\r\n          DeleteObject(bmp)\r\n        end\r\n      ensure\r\n        DeleteDC(mem_dc)\r\n      end\r\n    ensure\r\n      ReleaseDC(0, screen_dc)\r\n    end\r\n  rescue => e\r\n    puts \"ScreenCapture error: #{e.message}\"\r\n    puts e.backtrace.first(5).join(\"\\n\")\r\n    nil\r\n  end\r\nend\r\n\r\nmodule TourPlugin\r\n  class AreaSelectorTool\r\n    def initialize(callback)\r\n      @callback = callback\r\n      @start_x = nil; @start_y = nil; @current_x = nil; @current_y = nil\r\n      @drawing = false\r\n    end\r\n\r\n    def activate\r\n      Sketchup.active_model.active_view.invalidate\r\n      Sketchup.status_text = ScriptUpComunidade::TourVirtual.obter_texto(:status_clicar_arrastar)\r\n    end\r\n\r\n    def onLButtonDown(flags, x, y, view)\r\n      @start_x = x; @start_y = y; @current_x = x; @current_y = y\r\n      @drawing = true\r\n    end\r\n\r\n    def onMouseMove(flags, x, y, view)\r\n      if @drawing\r\n        @current_x = x; @current_y = y\r\n        view.invalidate\r\n      end\r\n    end\r\n\r\n    def onLButtonUp(flags, x, y, view)\r\n      return unless @drawing\r\n      @drawing = false\r\n      x1 = [@start_x, @current_x].min\r\n      y1 = [@start_y, @current_y].min\r\n      x2 = [@start_x, @current_x].max\r\n      y2 = [@start_y, @current_y].max\r\n      width = x2 - x1\r\n      height = y2 - y1\r\n\r\n      if width < 50 || height < 50\r\n        UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:area_pequena))\r\n        Sketchup.active_model.select_tool(nil)\r\n        return\r\n      end\r\n\r\n      @callback.call({ :x => x1, :y => y1, :w => width, :h => height })\r\n      Sketchup.active_model.select_tool(nil) \r\n    end\r\n\r\n    def draw(view)\r\n      return unless @drawing && @start_x && @current_x\r\n      points = [\r\n        Geom::Point3d.new(@start_x, @start_y, 0),\r\n        Geom::Point3d.new(@current_x, @start_y, 0),\r\n        Geom::Point3d.new(@current_x, @current_y, 0),\r\n        Geom::Point3d.new(@start_x, @current_y, 0)\r\n      ]\r\n      view.line_width = 3\r\n      view.drawing_color = 'red'\r\n      view.draw2d(GL_LINE_LOOP, points)\r\n    end\r\n  end\r\n\r\n  class ExportPreviewTool\r\n    def initialize(target_w, target_h)\r\n      @target_w = target_w\r\n      @target_h = target_h\r\n    end\r\n\r\n    def activate\r\n      Sketchup.active_model.active_view.invalidate\r\n    end\r\n\r\n    def deactivate(view)\r\n      view.invalidate\r\n    end\r\n\r\n    def draw(view)\r\n      vw = view.vpwidth\r\n      vh = view.vpheight\r\n      ew = [@target_w, vw].min\r\n      eh = [@target_h, vh].min\r\n      ox = (vw - ew) / 2\r\n      oy = (vh - eh) / 2\r\n\r\n      # Escurecer áreas fora da gravação (letterbox/pillarbox)\r\n      view.drawing_color = Sketchup::Color.new(0, 0, 0, 120)\r\n      if oy > 0\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(0, 0, 0), Geom::Point3d.new(vw, 0, 0),\r\n          Geom::Point3d.new(vw, oy, 0), Geom::Point3d.new(0, oy, 0)\r\n        ])\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(0, oy + eh, 0), Geom::Point3d.new(vw, oy + eh, 0),\r\n          Geom::Point3d.new(vw, vh, 0), Geom::Point3d.new(0, vh, 0)\r\n        ])\r\n      end\r\n      if ox > 0\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(0, oy, 0), Geom::Point3d.new(ox, oy, 0),\r\n          Geom::Point3d.new(ox, oy + eh, 0), Geom::Point3d.new(0, oy + eh, 0)\r\n        ])\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(ox + ew, oy, 0), Geom::Point3d.new(vw, oy, 0),\r\n          Geom::Point3d.new(vw, oy + eh, 0), Geom::Point3d.new(ox + ew, oy + eh, 0)\r\n        ])\r\n      end\r\n\r\n      # Borda branca ao redor da área de gravação\r\n      view.line_width = 2\r\n      view.drawing_color = Sketchup::Color.new(255, 255, 255, 200)\r\n      view.draw2d(GL_LINE_LOOP, [\r\n        Geom::Point3d.new(ox, oy, 0), Geom::Point3d.new(ox + ew, oy, 0),\r\n        Geom::Point3d.new(ox + ew, oy + eh, 0), Geom::Point3d.new(ox, oy + eh, 0)\r\n      ])\r\n    end\r\n  end\r\n\r\n  module CameraTimeline\r\n    def self.obter_texto(chave)\r\n      ScriptUpComunidade::TourVirtual.obter_texto(chave)\r\n    end\r\n\r\n    module GlobalKey\r\n      extend Fiddle::Importer\r\n      if Sketchup.platform == :platform_win\r\n        dlload 'user32.dll'\r\n        extern 'short GetAsyncKeyState(int)'\r\n      else\r\n        dlload '/System/Library/Frameworks/ApplicationServices.framework/ApplicationServices'\r\n        extern 'bool CGEventSourceKeyState(int, int)'\r\n      end\r\n\r\n      DEFAULT_HOTKEY = Sketchup.platform == :platform_win ? 0x6B : 69\r\n      @key_code = Sketchup.read_default(\"TourVirtual\", \"Hotkey\", DEFAULT_HOTKEY).to_i\r\n      @ctrl = Sketchup.read_default(\"TourVirtual\", \"HotkeyCtrl\", false)\r\n      @alt = Sketchup.read_default(\"TourVirtual\", \"HotkeyAlt\", false)\r\n      @shift = Sketchup.read_default(\"TourVirtual\", \"HotkeyShift\", false)\r\n\r\n      # Windows virtual key codes for modifiers\r\n      VK_CONTROL = 0x11\r\n      VK_MENU    = 0x12\r\n      VK_SHIFT   = 0x10\r\n      # macOS key codes for modifiers\r\n      MAC_CTRL  = 59\r\n      MAC_SHIFT = 56\r\n      MAC_ALT   = 58\r\n\r\n      def self.set_hotkey(code, ctrl, alt, shift)\r\n        @key_code = code.to_i\r\n        @ctrl = ctrl\r\n        @alt = alt\r\n        @shift = shift\r\n      end\r\n\r\n      def self.key_code; @key_code; end\r\n      def self.ctrl; @ctrl; end\r\n      def self.alt; @alt; end\r\n      def self.shift; @shift; end\r\n\r\n      def self.key_pressed?(code)\r\n        if Sketchup.platform == :platform_win\r\n          GetAsyncKeyState(code) & 0x8000 != 0\r\n        else\r\n          CGEventSourceKeyState(0, code)\r\n        end\r\n      end\r\n\r\n      def self.space_pressed?\r\n        return false unless key_pressed?(@key_code)\r\n        if Sketchup.platform == :platform_win\r\n          return false if @ctrl && !key_pressed?(VK_CONTROL)\r\n          return false if @alt && !key_pressed?(VK_MENU)\r\n          return false if @shift && !key_pressed?(VK_SHIFT)\r\n        else\r\n          return false if @ctrl && !key_pressed?(MAC_CTRL)\r\n          return false if @alt && !key_pressed?(MAC_ALT)\r\n          return false if @shift && !key_pressed?(MAC_SHIFT)\r\n        end\r\n        true\r\n      end\r\n    end\r\n\r\n    def self.start_space_timer\r\n      return if defined?(@space_timer) && @space_timer\r\n      @space_down = false\r\n      @space_timer = UI.start_timer(0.1, true) do\r\n        if GlobalKey.space_pressed?\r\n          unless @space_down\r\n            @space_down = true\r\n            @dialog.execute_script('triggerSpaceFromRuby()')\r\n          end\r\n        else\r\n          @space_down = false\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.stop_space_timer\r\n      if defined?(@space_timer) && @space_timer\r\n        UI.stop_timer(@space_timer)\r\n        @space_timer = nil\r\n      end\r\n    end\r\n\r\n    def self.capture_thumbnail\r\n      view = Sketchup.active_model.active_view\r\n      # Tentar screen capture instantâneo via GDI32 (Windows)\r\n      result = ScreenCapture.capture_viewport(view, 96, 60) rescue nil\r\n      return result if result && result.length > 0\r\n      # Fallback: write_image (lento, mas funciona em qualquer plataforma)\r\n      path = File.join(Dir.tmpdir, \"thumb_#{Time.now.to_i}.jpg\")\r\n      view.write_image(path, 96, 60, false, 0.5)\r\n      encoded = Base64.strict_encode64(File.binread(path))\r\n      File.delete(path) if File.exist?(path)\r\n      encoded\r\n    end\r\n\r\n    # --- Lógica de Exportação ---\r\n    def self.calcular_rect_gravacao(export_width, export_height)\r\n      view = Sketchup.active_model.active_view\r\n      viewport_global = WindowUtils.get_viewport_rect_deep(view)\r\n\r\n      unless viewport_global\r\n        viewport_global = { :x => 0, :y => 0, :w => view.vpwidth, :h => view.vpheight, :scale => 1.0 }\r\n      end\r\n\r\n      vp_w = viewport_global[:w]\r\n      vp_h = viewport_global[:h]\r\n\r\n      final_w = [export_width.to_i, vp_w].min\r\n      final_h = [export_height.to_i, vp_h].min\r\n\r\n      offset_x = viewport_global[:x] + ((vp_w - final_w) / 2).to_i\r\n      offset_y = viewport_global[:y] + ((vp_h - final_h) / 2).to_i\r\n\r\n      final_w -= 1 if final_w.odd?\r\n      final_h -= 1 if final_h.odd?\r\n\r\n      { :x => offset_x, :y => offset_y, :w => final_w, :h => final_h }\r\n    end\r\n\r\n    def self.iniciar_processo_exportacao(json_data, use_easing, start_index_from_js, export_width, export_height, filename)\r\n      effective_index = start_index_from_js.to_i\r\n\r\n      if effective_index == 0\r\n        @dialog.execute_script(\"currentIndex = 0; updateTime(0); sketchup.goto_camera(JSON.stringify(visoes[0]));\")\r\n        sleep(0.5)\r\n      end\r\n\r\n      rect = calcular_rect_gravacao(export_width, export_height)\r\n      executar_gravacao_ffmpeg(json_data, use_easing, rect, effective_index, filename)\r\n    end\r\n\r\n    def self.iniciar_processo_exportacao_projeto(all_timelines_json, use_easing, active_tl_index, start_vision_index, export_width, export_height, filename)\r\n      timelines = JSON.parse(all_timelines_json, symbolize_names: true)\r\n      rect = calcular_rect_gravacao(export_width, export_height)\r\n\r\n      start_tl = active_tl_index.to_i\r\n      start_vision = start_vision_index.to_i\r\n\r\n      # Calcular duração total a partir do ponto de início\r\n      total_time = 0.0\r\n      timelines.each_with_index do |tl, i|\r\n        next if i < start_tl\r\n        next unless tl[:visoes] && tl[:visoes].length >= 2\r\n        sorted = tl[:visoes].sort_by { |v| v[:time] }\r\n        first_v = (i == start_tl && start_vision > 0 && start_vision < sorted.length) ? start_vision : 0\r\n        if first_v < sorted.length - 1\r\n          total_time += sorted.last[:time] - sorted[first_v][:time]\r\n          total_time += 0.5\r\n        end\r\n      end\r\n\r\n      play_cmd = \"startRecordingPlayAll(#{start_tl}, #{start_vision})\"\r\n      executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, play_cmd)\r\n    end\r\n\r\n    def self.executar_gravacao_ffmpeg(json_data, use_easing, rect, start_index, filename)\r\n      camera_keys = JSON.parse(json_data, symbolize_names: true)\r\n      camera_keys.sort_by! { |v| v[:time] }\r\n\r\n      total_time = 0\r\n      if start_index < camera_keys.length - 1\r\n        relevant_keys = camera_keys[start_index..-1]\r\n        relevant_keys.each_cons(2) { |c, n| total_time += (n[:time] - c[:time]).abs }\r\n      end\r\n\r\n      executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, \"triggerSpaceFromRuby()\")\r\n    end\r\n\r\n    def self.executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, play_command)\r\n      folder = UI.select_directory(title: obter_texto(:selecionar_pasta))\r\n      return unless folder\r\n\r\n      output_path = File.join(folder, \"#{filename}.mp4\")\r\n\r\n      is_win = Sketchup.platform == :platform_win\r\n      ffmpeg_path = File.join(PLUGIN_DIR, 'ffmpeg', is_win ? 'ffmpeg.exe' : 'ffmpeg')\r\n\r\n      unless File.exist?(ffmpeg_path)\r\n        UI.messagebox(obter_texto(:ffmpeg_nao_encontrado))\r\n        return\r\n      end\r\n\r\n      duration_padding = 4.0\r\n      recording_duration = total_time + duration_padding\r\n\r\n      input_format = is_win ? 'gdigrab' : 'avfoundation'\r\n      input_source = is_win ? 'desktop' : '1:none'\r\n\r\n      cmd_array = [\r\n        \"\\\"#{ffmpeg_path}\\\"\",\r\n        '-y',\r\n        '-f', input_format,\r\n        '-framerate', '30',\r\n        '-t', recording_duration.to_s\r\n      ]\r\n\r\n      if is_win\r\n        cmd_array.concat([\r\n          '-draw_mouse', '0',\r\n          '-offset_x', rect[:x].to_s,\r\n          '-offset_y', rect[:y].to_s,\r\n          '-video_size', \"#{rect[:w]}x#{rect[:h]}\",\r\n          '-i', input_source\r\n        ])\r\n      else\r\n        cmd_array.concat([\r\n          '-i', input_source,\r\n          '-vf', \"crop=#{rect[:w]}:#{rect[:h]}:#{rect[:x]}:#{rect[:y]}\"\r\n        ])\r\n      end\r\n\r\n      cmd_array.concat([\r\n        '-c:v', 'libx264',\r\n        '-preset', 'ultrafast',\r\n        '-pix_fmt', 'yuv420p',\r\n        \"\\\"#{output_path}\\\"\"\r\n      ])\r\n\r\n      cmd = cmd_array.join(' ')\r\n\r\n      begin\r\n        if is_win\r\n           WIN32OLE.new('WScript.Shell').Run(cmd, 0, false)\r\n        else\r\n           pid = spawn(cmd)\r\n           Process.detach(pid)\r\n        end\r\n      rescue => e\r\n        UI.messagebox(\"#{obter_texto(:erro_gravador)}#{e.message}\")\r\n        return\r\n      end\r\n\r\n      sleep(1.5)\r\n\r\n      @dialog.execute_script(\"showRecordingIndicator()\")\r\n      @dialog.execute_script(play_command)\r\n\r\n      UI.start_timer(recording_duration + 1.0, false) do\r\n        @dialog.execute_script(\"hideRecordingIndicator()\")\r\n        UI.messagebox(\"#{obter_texto(:gravacao_finalizada)}#{output_path}\")\r\n        @dialog.execute_script(\"resetPlayButton(); resetPlayAll();\")\r\n      end\r\n    end\r\n\r\n    def self.start_ui\r\n      current_hotkey = GlobalKey.key_code\r\n      hotkey_ctrl = GlobalKey.ctrl ? 'true' : 'false'\r\n      hotkey_alt = GlobalKey.alt ? 'true' : 'false'\r\n      hotkey_shift = GlobalKey.shift ? 'true' : 'false'\r\n      ffmpeg_path = File.join(PLUGIN_DIR, 'ffmpeg', Sketchup.platform == :platform_win ? 'ffmpeg.exe' : 'ffmpeg')\r\n      \r\n      has_ffmpeg = File.exist?(ffmpeg_path)\r\n\r\n      view = Sketchup.active_model.active_view\r\n      vp_width = view.vpwidth\r\n      vp_height = view.vpheight\r\n\r\n      js_i18n_hash = {}\r\n      IDIOMAS[IDIOMAS.key?(Sketchup.get_locale) ? Sketchup.get_locale : 'en-US'].each { |k, v| js_i18n_hash[k] = v }\r\n      js_i18n_json = js_i18n_hash.to_json\r\n\r\n      html = <<-HTML\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n  <meta charset=\"utf-8\">\r\n  <title>#{obter_texto(:titulo)}</title>\r\n  <style>\r\n    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }\r\n    body {\r\n      font-family: system-ui, -apple-system, 'Segoe UI', sans-serif;\r\n      background: #f5f5f5; color: #333; font-size: 13px;\r\n      padding: 16px; line-height: 1.4;\r\n    }\r\n\r\n    /* Header */\r\n    .header {\r\n      display: flex; align-items: center; gap: 10px;\r\n      padding-bottom: 14px; border-bottom: 2px solid #0066cc;\r\n      margin-bottom: 16px;\r\n    }\r\n    .header svg { flex-shrink: 0; }\r\n    .header h1 { font-size: 17px; font-weight: 700; color: #1a1a1a; }\r\n    .header .subtitle { font-size: 11px; color: #888; font-weight: 400; }\r\n\r\n    /* Cards */\r\n    .card {\r\n      background: #fff; border: 1px solid #e0e0e0; border-radius: 8px;\r\n      box-shadow: 0 1px 3px rgba(0,0,0,0.06); margin-bottom: 12px;\r\n      overflow: hidden;\r\n    }\r\n    .card-header {\r\n      display: flex; align-items: center; justify-content: space-between;\r\n      padding: 10px 14px; background: #fafafa; border-bottom: 1px solid #eee;\r\n      cursor: pointer; user-select: none;\r\n    }\r\n    .card-header h2 { font-size: 13px; font-weight: 600; color: #444; }\r\n    .card-header .toggle-icon { font-size: 11px; color: #999; transition: transform 0.2s; }\r\n    .card-header.collapsed .toggle-icon { transform: rotate(-90deg); }\r\n    .card-body { padding: 14px; }\r\n    .card-body.collapsed { display: none; }\r\n\r\n    /* Timeline */\r\n    .timeline-wrapper { position: relative; padding: 8px 0 20px; }\r\n    .timeline-track {\r\n      position: absolute; top: 20px; left: 6px; right: 6px; height: 4px;\r\n      background: #ddd; border-radius: 2px; z-index: 0;\r\n    }\r\n    #timeline_range {\r\n      -webkit-appearance: none; appearance: none; width: 100%;\r\n      height: 6px; background: transparent; outline: none;\r\n      position: relative; z-index: 2; cursor: pointer;\r\n    }\r\n    #timeline_range::-webkit-slider-runnable-track {\r\n      height: 6px; background: linear-gradient(90deg, #0066cc 0%, #4da6ff 100%);\r\n      border-radius: 3px;\r\n    }\r\n    #timeline_range::-webkit-slider-thumb {\r\n      -webkit-appearance: none; width: 16px; height: 16px;\r\n      background: #0066cc; border: 2px solid #fff; border-radius: 50%;\r\n      margin-top: -5px; cursor: grab; box-shadow: 0 1px 4px rgba(0,0,0,0.2);\r\n    }\r\n    #timeline_range::-webkit-slider-thumb:active { cursor: grabbing; transform: scale(1.15); }\r\n    #markers_layer {\r\n      position: absolute; top: 0; left: 0; width: 100%; height: 40px;\r\n      pointer-events: none; z-index: 3;\r\n    }\r\n    .marker {\r\n      position: absolute; top: 26px; width: 14px; height: 14px;\r\n      background: #0066cc; border-radius: 50%; border: 2px solid #fff;\r\n      transform: translateX(-50%); pointer-events: auto; cursor: pointer;\r\n      box-shadow: 0 1px 3px rgba(0,0,0,0.15); transition: transform 0.15s, background 0.15s;\r\n    }\r\n    .marker:hover { transform: translateX(-50%) scale(1.25); }\r\n    .marker.anchor { background: #dc3545; }\r\n    .marker .marker-tooltip {\r\n      position: absolute; bottom: 18px; left: 50%; transform: translateX(-50%);\r\n      background: #333; color: #fff; font-size: 10px; padding: 2px 6px;\r\n      border-radius: 3px; white-space: nowrap; opacity: 0;\r\n      pointer-events: none; transition: opacity 0.15s;\r\n    }\r\n    .marker:hover .marker-tooltip { opacity: 1; }\r\n    .time-row {\r\n      display: flex; align-items: center; justify-content: space-between;\r\n      margin-top: 8px; gap: 12px;\r\n    }\r\n    .time-display { font-size: 20px; font-weight: 700; color: #0066cc; font-variant-numeric: tabular-nums; }\r\n    .time-display small { font-size: 12px; color: #888; font-weight: 400; }\r\n    .time-input-group { display: flex; align-items: center; gap: 6px; }\r\n    .time-input-group label { font-size: 11px; color: #666; }\r\n\r\n    /* Buttons */\r\n    .btn {\r\n      display: inline-flex; align-items: center; justify-content: center; gap: 6px;\r\n      padding: 7px 14px; border: 1px solid transparent; border-radius: 6px;\r\n      font-size: 12px; font-weight: 500; cursor: pointer;\r\n      transition: all 0.15s; outline: none; font-family: inherit;\r\n    }\r\n    .btn:active { transform: scale(0.97); }\r\n    .btn-primary { background: #0066cc; color: #fff; }\r\n    .btn-primary:hover { background: #0052a3; }\r\n    .btn-success { background: #28a745; color: #fff; }\r\n    .btn-success:hover { background: #218838; }\r\n    .btn-danger { background: #dc3545; color: #fff; }\r\n    .btn-danger:hover { background: #c82333; }\r\n    .btn-outline { background: transparent; border: 1px solid #ccc; color: #555; }\r\n    .btn-outline:hover { background: #f0f0f0; border-color: #aaa; }\r\n    .btn-sm { padding: 4px 10px; font-size: 11px; }\r\n    .btn-record { background: #dc3545; color: #fff; padding: 10px 20px; font-size: 13px; font-weight: 600; }\r\n    .btn-record:hover { background: #c82333; }\r\n    .btn-record:disabled { background: #ccc; color: #888; cursor: not-allowed; }\r\n\r\n    .btn-group { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }\r\n\r\n    /* Checkboxes */\r\n    .check-group { display: flex; align-items: center; gap: 16px; margin-top: 10px; }\r\n    .check-item { display: flex; align-items: center; gap: 5px; }\r\n    .check-item input[type=\"checkbox\"] {\r\n      width: 15px; height: 15px; accent-color: #0066cc; cursor: pointer;\r\n    }\r\n    .check-item label { font-size: 12px; color: #555; cursor: pointer; }\r\n\r\n    /* Hotkey */\r\n    .hotkey-editor {\r\n      display: none; align-items: center; gap: 6px;\r\n      background: #f9f9f9; padding: 6px 10px; border-radius: 6px; border: 1px solid #ddd;\r\n    }\r\n    .hotkey-editor.visible { display: inline-flex; }\r\n    .hotkey-editor input {\r\n      width: 100px; padding: 4px 8px; border: 1px solid #ccc;\r\n      border-radius: 4px; font-size: 12px; font-family: monospace;\r\n      outline: none;\r\n    }\r\n    .hotkey-editor input:focus { border-color: #0066cc; }\r\n\r\n    /* Vision List */\r\n    .vision-list { max-height: 350px; overflow-y: auto; }\r\n    .vision-list::-webkit-scrollbar { width: 6px; }\r\n    .vision-list::-webkit-scrollbar-track { background: #f0f0f0; border-radius: 3px; }\r\n    .vision-list::-webkit-scrollbar-thumb { background: #ccc; border-radius: 3px; }\r\n    .vision-list::-webkit-scrollbar-thumb:hover { background: #aaa; }\r\n    .vision-item {\r\n      display: flex; align-items: center; gap: 10px; padding: 8px 10px;\r\n      border-bottom: 1px solid #f0f0f0; cursor: pointer;\r\n      transition: background 0.12s;\r\n    }\r\n    .vision-item:hover { background: #f7faff; }\r\n    .vision-item:last-child { border-bottom: none; }\r\n    .vision-item .vision-num {\r\n      font-size: 11px; font-weight: 700; color: #999; width: 20px;\r\n      text-align: center; flex-shrink: 0;\r\n    }\r\n    .vision-item img {\r\n      width: 72px; height: 45px; object-fit: cover; border-radius: 4px;\r\n      border: 1px solid #ddd; flex-shrink: 0;\r\n    }\r\n    .vision-item img.thumb-placeholder {\r\n      background: linear-gradient(135deg, #e0e0e0 0%, #c0c0c0 100%);\r\n      animation: pulse-placeholder 1s ease-in-out infinite alternate;\r\n    }\r\n    @keyframes pulse-placeholder {\r\n      from { opacity: 0.6; }\r\n      to { opacity: 1.0; }\r\n    }\r\n    .vision-item .vision-info { flex: 1; min-width: 0; }\r\n    .vision-item .vision-time-input {\r\n      width: 58px; padding: 3px 6px; border: 1px solid #ddd; border-radius: 4px;\r\n      font-size: 12px; text-align: center; outline: none; font-family: inherit;\r\n    }\r\n    .vision-item .vision-time-input:focus { border-color: #0066cc; }\r\n    .vision-item .vision-time-input:disabled { background: #f5f5f5; color: #999; }\r\n    .vision-actions { display: flex; align-items: center; gap: 6px; flex-shrink: 0; }\r\n    .anchor-toggle {\r\n      width: 26px; height: 26px; border-radius: 50%; border: 2px solid #ddd;\r\n      background: transparent; cursor: pointer; display: flex;\r\n      align-items: center; justify-content: center; transition: all 0.15s;\r\n      font-size: 12px; color: #ccc;\r\n    }\r\n    .anchor-toggle:hover { border-color: #dc3545; color: #dc3545; }\r\n    .anchor-toggle.active { background: #dc3545; border-color: #dc3545; color: #fff; }\r\n    .delete-btn {\r\n      width: 26px; height: 26px; border-radius: 50%; border: 1px solid #eee;\r\n      background: transparent; cursor: pointer; display: flex;\r\n      align-items: center; justify-content: center; transition: all 0.15s;\r\n      font-size: 14px; color: #ccc;\r\n    }\r\n    .delete-btn:hover { background: #fee; border-color: #dc3545; color: #dc3545; }\r\n    .empty-state {\r\n      text-align: center; padding: 30px 16px; color: #aaa;\r\n    }\r\n    .empty-state svg { margin-bottom: 8px; opacity: 0.4; }\r\n    .empty-state p { font-size: 12px; }\r\n\r\n    /* Export Section */\r\n    .preset-select {\r\n      width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px;\r\n      font-size: 12px; font-family: inherit; outline: none; background: #fff;\r\n      cursor: pointer; color: #333;\r\n    }\r\n    .preset-select:focus { border-color: #0066cc; }\r\n    .preset-preview {\r\n      display: flex; align-items: center; justify-content: center;\r\n      padding: 8px; margin-top: 8px; background: #f7faff;\r\n      border: 1px dashed #b3d4fc; border-radius: 6px;\r\n      font-size: 12px; color: #0066cc; font-weight: 600;\r\n    }\r\n    .custom-dims {\r\n      display: none; gap: 8px; align-items: center; margin-top: 8px;\r\n    }\r\n    .custom-dims.visible { display: flex; }\r\n    .custom-dims input {\r\n      width: 80px; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px;\r\n      font-size: 12px; text-align: center; outline: none; font-family: inherit;\r\n    }\r\n    .custom-dims input:focus { border-color: #0066cc; }\r\n    .custom-dims span { color: #999; font-weight: 600; }\r\n\r\n    /* Recording indicator */\r\n    .recording-bar {\r\n      display: none; align-items: center; gap: 8px; padding: 10px 14px;\r\n      background: #fff5f5; border: 1px solid #f5c6cb; border-radius: 6px;\r\n      margin-top: 10px;\r\n    }\r\n    .recording-bar.active { display: flex; }\r\n    .recording-dot {\r\n      width: 10px; height: 10px; background: #dc3545; border-radius: 50%;\r\n      animation: pulse 1s infinite;\r\n    }\r\n    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }\r\n    .recording-bar span { font-size: 12px; color: #dc3545; font-weight: 600; }\r\n\r\n    /* Playing overlay */\r\n    body.playing .card { opacity: 0.6; pointer-events: none; }\r\n    body.playing .card.playback-card { opacity: 1; pointer-events: auto; }\r\n    body.playing .card.playback-card .btn:not(#play_button):not(#play_all_button) { pointer-events: none; opacity: 0.4; }\r\n    body.playing #play_button, body.playing #play_all_button { pointer-events: auto !important; opacity: 1 !important; }\r\n\r\n    /* Input base */\r\n    input[type=\"number\"] {\r\n      -moz-appearance: textfield;\r\n    }\r\n    input[type=\"number\"]::-webkit-inner-spin-button {\r\n      -webkit-appearance: none;\r\n    }\r\n\r\n    /* Draggable markers */\r\n    .marker { cursor: grab; }\r\n    .marker.dragging {\r\n      transform: translateX(-50%) scale(1.3);\r\n      z-index: 20;\r\n      cursor: grabbing;\r\n    }\r\n    .marker.no-drag { cursor: default; }\r\n\r\n    /* Saved timelines list */\r\n    .saved-timelines-list { margin-top: 10px; }\r\n    .saved-timelines-list:empty { display: none; }\r\n    .tl-item {\r\n      display: flex; align-items: center; gap: 8px;\r\n      padding: 6px 10px; border-bottom: 1px solid #f0f0f0;\r\n      cursor: pointer; transition: background 0.12s; font-size: 12px;\r\n    }\r\n    .tl-item:hover { background: #f7faff; }\r\n    .tl-item:last-child { border-bottom: none; }\r\n    .tl-item .tl-indicator {\r\n      width: 8px; height: 8px; border-radius: 50%;\r\n      background: #ccc; flex-shrink: 0;\r\n    }\r\n    .tl-item.active .tl-indicator { background: #0066cc; }\r\n    .tl-item .tl-name { flex: 1; font-weight: 500; color: #333; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }\r\n    .tl-item .tl-count { color: #999; font-size: 11px; flex-shrink: 0; }\r\n    .tl-item .tl-delete {\r\n      width: 20px; height: 20px; border-radius: 50%; border: 1px solid #eee;\r\n      background: transparent; cursor: pointer; display: flex;\r\n      align-items: center; justify-content: center; font-size: 12px; color: #ccc;\r\n      flex-shrink: 0; transition: all 0.15s;\r\n    }\r\n    .tl-item .tl-delete:hover { background: #fee; border-color: #dc3545; color: #dc3545; }\r\n\r\n    /* Drag-and-drop for timeline reordering */\r\n    .tl-drag-handle {\r\n      cursor: grab; flex-shrink: 0; color: #ccc; font-size: 14px;\r\n      padding: 0 4px; user-select: none;\r\n    }\r\n    .tl-drag-handle:active { cursor: grabbing; }\r\n    .tl-item.dragging { opacity: 0.4; }\r\n    .tl-item.drag-over-top { border-top: 2px solid #0066cc; }\r\n    .tl-item.drag-over-bottom { border-bottom: 2px solid #0066cc; }\r\n\r\n    /* Viewport info */\r\n    .viewport-info {\r\n      font-size: 11px; color: #666; margin-bottom: 10px;\r\n      padding: 6px 10px; background: #f9f9f9; border-radius: 4px; border: 1px solid #eee;\r\n    }\r\n\r\n    /* Misc */\r\n    .hidden { display: none !important; }\r\n    .mt-8 { margin-top: 8px; }\r\n  </style>\r\n</head>\r\n<body>\r\n\r\n<!-- Header -->\r\n<div class=\"header\">\r\n  <svg width=\"28\" height=\"28\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"#0066cc\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <path d=\"M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z\"/>\r\n    <circle cx=\"12\" cy=\"13\" r=\"4\"/>\r\n  </svg>\r\n  <div>\r\n    <h1>#{obter_texto(:titulo)}</h1>\r\n    <span class=\"subtitle\">#{obter_texto(:subtitulo)}</span>\r\n  </div>\r\n</div>\r\n\r\n<!-- Timeline Card -->\r\n<div class=\"card\">\r\n  <div class=\"card-body\">\r\n    <div class=\"timeline-wrapper\">\r\n      <div class=\"timeline-track\"></div>\r\n      <input type=\"range\" min=\"0\" max=\"60\" step=\"0.1\" value=\"0\" id=\"timeline_range\" oninput=\"updateTime(this.value)\">\r\n      <div id=\"markers_layer\"></div>\r\n    </div>\r\n    <div class=\"time-row\">\r\n      <div class=\"time-display\"><span id=\"current_time\">0.0</span><small>s</small></div>\r\n      <div class=\"time-input-group\">\r\n        <label>#{obter_texto(:total)}</label>\r\n        <input id=\"max_time\" type=\"number\" step=\"1\" value=\"60\" min=\"1\" onchange=\"atualizarTempoTotal()\"\r\n          style=\"width:65px; padding:4px 8px; border:1px solid #ddd; border-radius:4px; font-size:12px; text-align:center; outline:none; font-family:inherit;\">\r\n        <small style=\"color:#888;\">s</small>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Playback Controls Card -->\r\n<div class=\"card playback-card\">\r\n  <div class=\"card-body\">\r\n    <div class=\"btn-group\">\r\n      <button class=\"btn btn-primary\" onclick=\"addVision()\">\r\n        <svg width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2.5\"><line x1=\"12\" y1=\"5\" x2=\"12\" y2=\"19\"/><line x1=\"5\" y1=\"12\" x2=\"19\" y2=\"12\"/></svg>\r\n        #{obter_texto(:visao)}\r\n      </button>\r\n      <button id=\"play_button\" class=\"btn btn-success\" onclick=\"togglePlay()\">&#9654; #{obter_texto(:play)}</button>\r\n      <button id=\"play_all_button\" class=\"btn btn-outline btn-sm hidden\" onclick=\"togglePlayAll()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><polygon points=\"5 3 19 12 5 21 5 3\"/><line x1=\"19\" y1=\"3\" x2=\"19\" y2=\"21\"/></svg>\r\n        #{obter_texto(:play_all)}\r\n      </button>\r\n      <button class=\"btn btn-outline btn-sm\" onclick=\"mostrarCampoAtalho()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><rect x=\"2\" y=\"4\" width=\"20\" height=\"16\" rx=\"2\"/><line x1=\"6\" y1=\"8\" x2=\"6\" y2=\"8\"/><line x1=\"10\" y1=\"8\" x2=\"10\" y2=\"8\"/><line x1=\"14\" y1=\"8\" x2=\"14\" y2=\"8\"/><line x1=\"18\" y1=\"8\" x2=\"18\" y2=\"8\"/><line x1=\"8\" y1=\"16\" x2=\"16\" y2=\"16\"/></svg>\r\n        #{obter_texto(:atalho)}\r\n      </button>\r\n      <span id=\"hotkey_edit\" class=\"hotkey-editor\">\r\n        <input id=\"hotkey_input\" type=\"text\" placeholder=\"#{obter_texto(:pressione)}\" onkeydown=\"capturarAtalhoInput(event)\">\r\n        <button class=\"btn btn-primary btn-sm\" onclick=\"confirmarAtalho()\">#{obter_texto(:ok)}</button>\r\n      </span>\r\n    </div>\r\n    <div class=\"check-group\">\r\n      <div class=\"check-item\">\r\n        <input type=\"checkbox\" id=\"loop_checkbox\">\r\n        <label for=\"loop_checkbox\">#{obter_texto(:loop)}</label>\r\n      </div>\r\n      <div class=\"check-item\">\r\n        <input type=\"checkbox\" id=\"easing_checkbox\">\r\n        <label for=\"easing_checkbox\">#{obter_texto(:easing)}</label>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Visions Card -->\r\n<div class=\"card\">\r\n  <div class=\"card-header\" onclick=\"toggleSection('visions')\">\r\n    <h2>#{obter_texto(:visoes_salvas)} <span id=\"vision_count\" style=\"color:#999; font-weight:400;\"></span></h2>\r\n    <span class=\"toggle-icon\" id=\"visions_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body\" id=\"visions_body\">\r\n    <div class=\"vision-list\" id=\"lista_visoes\"></div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Gerenciar Time Line Card -->\r\n<div class=\"card\">\r\n  <div class=\"card-header\" onclick=\"toggleSection('timeline_mgr')\">\r\n    <h2>#{obter_texto(:gerenciar_timeline)}</h2>\r\n    <span class=\"toggle-icon\" id=\"timeline_mgr_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body\" id=\"timeline_mgr_body\">\r\n    <div class=\"btn-group\">\r\n      <button class=\"btn btn-outline\" onclick=\"novaTimeline()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z\"/><polyline points=\"14 2 14 8 20 8\"/><line x1=\"12\" y1=\"18\" x2=\"12\" y2=\"12\"/><line x1=\"9\" y1=\"15\" x2=\"15\" y2=\"15\"/></svg>\r\n        #{obter_texto(:nova)}\r\n      </button>\r\n      <button class=\"btn btn-outline\" onclick=\"exportarTimeline()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\"/><polyline points=\"7 10 12 15 17 10\"/><line x1=\"12\" y1=\"15\" x2=\"12\" y2=\"3\"/></svg>\r\n        #{obter_texto(:exportar_atual)}\r\n      </button>\r\n      <button class=\"btn btn-outline\" onclick=\"exportarProjeto()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z\"/><polyline points=\"9 14 12 17 15 14\"/><line x1=\"12\" y1=\"17\" x2=\"12\" y2=\"10\"/></svg>\r\n        #{obter_texto(:exportar_projeto)}\r\n      </button>\r\n      <input type=\"file\" id=\"import_file\" class=\"hidden\" accept=\".json\" onchange=\"importarTimeline(this)\">\r\n      <button class=\"btn btn-outline\" onclick=\"document.getElementById('import_file').click()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\"/><polyline points=\"17 8 12 3 7 8\"/><line x1=\"12\" y1=\"3\" x2=\"12\" y2=\"15\"/></svg>\r\n        #{obter_texto(:importar)}\r\n      </button>\r\n    </div>\r\n    <div id=\"saved_timelines_list\" class=\"saved-timelines-list\"></div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Exportar Vídeo Card (colapsado por padrão) -->\r\n<div class=\"card\">\r\n  <div class=\"card-header collapsed\" onclick=\"toggleSection('export')\">\r\n    <h2>#{obter_texto(:exportar_video)}</h2>\r\n    <span class=\"toggle-icon\" id=\"export_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body collapsed\" id=\"export_body\">\r\n    <div id=\"ffmpeg_section\" class=\"#{has_ffmpeg ? '' : 'hidden'}\">\r\n      <div class=\"viewport-info\">\r\n        #{obter_texto(:viewport_atual)} <strong>#{vp_width} x #{vp_height} px</strong>\r\n      </div>\r\n\r\n      <select id=\"preset_select\" class=\"preset-select\" onchange=\"onPresetChange()\">\r\n        <option value=\"\" disabled selected>#{obter_texto(:selecione_formato)}</option>\r\n      </select>\r\n\r\n      <div class=\"custom-dims\" id=\"custom_dims\">\r\n        <input type=\"number\" id=\"custom_w\" min=\"50\" placeholder=\"#{obter_texto(:largura)}\" value=\"1280\">\r\n        <span>x</span>\r\n        <input type=\"number\" id=\"custom_h\" min=\"50\" placeholder=\"#{obter_texto(:altura)}\" value=\"720\">\r\n        <small style=\"color:#888;\">px</small>\r\n      </div>\r\n\r\n      <div class=\"preset-preview\" id=\"preset_preview\" style=\"display:none;\"></div>\r\n\r\n      <div class=\"check-group\" style=\"margin-top:12px; flex-direction:column; align-items:flex-start; gap:8px;\">\r\n        <div class=\"check-item\">\r\n          <input type=\"checkbox\" id=\"rec_projeto\">\r\n          <label for=\"rec_projeto\">#{obter_texto(:gravar_projeto)}</label>\r\n        </div>\r\n        <div class=\"check-item\">\r\n          <input type=\"checkbox\" id=\"rec_inicio\" checked>\r\n          <label for=\"rec_inicio\">#{obter_texto(:iniciar_quadro1)}</label>\r\n        </div>\r\n      </div>\r\n\r\n      <button class=\"btn btn-record mt-8\" id=\"btn_record\" onclick=\"iniciarGravacao()\" disabled style=\"width:100%; margin-top:12px;\">\r\n        <svg width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><circle cx=\"12\" cy=\"12\" r=\"4\" fill=\"currentColor\"/></svg>\r\n        #{obter_texto(:iniciar_gravacao)}\r\n      </button>\r\n\r\n      <div class=\"recording-bar\" id=\"recording_bar\">\r\n        <div class=\"recording-dot\"></div>\r\n        <span>#{obter_texto(:gravando)}</span>\r\n      </div>\r\n    </div>\r\n\r\n    <div id=\"ffmpeg_install\" class=\"#{has_ffmpeg ? 'hidden' : ''}\" style=\"text-align:center; padding:12px 0;\">\r\n      <p style=\"color:#888; font-size:12px; margin-bottom:10px;\">#{obter_texto(:ffmpeg_necessario)}</p>\r\n      <button class=\"btn btn-primary\" onclick=\"instalarExportacao()\">#{obter_texto(:instalar_ffmpeg)}</button>\r\n    </div>\r\n\r\n    <!-- Modal de nome do arquivo -->\r\n    <div id=\"filename_modal\" style=\"display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.4);z-index:100;align-items:center;justify-content:center;\">\r\n      <div style=\"background:#fff;border-radius:10px;padding:24px;width:320px;box-shadow:0 8px 30px rgba(0,0,0,0.2);\">\r\n        <h3 style=\"font-size:14px;font-weight:600;color:#333;margin-bottom:12px;\">#{obter_texto(:nome_arquivo)}</h3>\r\n        <input id=\"filename_input\" type=\"text\" value=\"tour_final\" style=\"width:100%;padding:8px 12px;border:1px solid #ddd;border-radius:6px;font-size:13px;font-family:inherit;outline:none;margin-bottom:6px;\">\r\n        <small style=\"color:#888;\">#{obter_texto(:extensao_mp4)}</small>\r\n        <div style=\"display:flex;gap:8px;margin-top:16px;justify-content:flex-end;\">\r\n          <button class=\"btn btn-outline btn-sm\" onclick=\"fecharModalFilename()\">#{obter_texto(:cancelar)}</button>\r\n          <button class=\"btn btn-primary btn-sm\" onclick=\"confirmarFilename()\">#{obter_texto(:salvar)}</button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<script>\r\n    const I18N = #{js_i18n_json};\r\n    let visoes = [], playing = false, currentIndex = 0;\r\n    let hotkey = { keyCode: #{current_hotkey}, ctrl: #{hotkey_ctrl}, alt: #{hotkey_alt}, shift: #{hotkey_shift} };\r\n    let capturingHotkey = false, pendingHotkey = null;\r\n    let savedTimelines = [];\r\n    let activeTimelineIndex = -1;\r\n    let playingAll = false, playAllQueue = [], playAllCurrentIdx = 0;\r\n    var viewportW = #{vp_width}, viewportH = #{vp_height};\r\n\r\n    if (window.sketchup) { window.sketchup.set_hotkey(hotkey.keyCode, hotkey.ctrl, hotkey.alt, hotkey.shift); }\r\n\r\n    /* --- Export Formats (aspect ratios) --- */\r\n    const EXPORT_FORMATS = [\r\n      { label: '16:9 ' + I18N.paisagem, ratio: [16, 9] },\r\n      { label: '9:16 ' + I18N.retrato, ratio: [9, 16] },\r\n      { label: '1:1 ' + I18N.quadrado, ratio: [1, 1] },\r\n      { label: '4:3 ' + I18N.classico, ratio: [4, 3] },\r\n      { label: '21:9 ' + I18N.ultra_wide, ratio: [21, 9] },\r\n      { label: I18N.viewport_inteira, ratio: null },\r\n      { label: I18N.personalizado, ratio: null, custom: true }\r\n    ];\r\n\r\n    function calcEffectiveDims(ratioW, ratioH, vpW, vpH) {\r\n      const scaleW = vpW / ratioW;\r\n      const scaleH = vpH / ratioH;\r\n      const scale = Math.min(scaleW, scaleH);\r\n      let w = Math.floor(ratioW * scale);\r\n      let h = Math.floor(ratioH * scale);\r\n      w = w % 2 === 0 ? w : w - 1;\r\n      h = h % 2 === 0 ? h : h - 1;\r\n      return { w: w, h: h };\r\n    }\r\n\r\n    function populatePresets() {\r\n      const sel = document.getElementById(\"preset_select\");\r\n      sel.innerHTML = '<option value=\"\" disabled selected>' + I18N.selecione_formato + '</option>';\r\n      EXPORT_FORMATS.forEach((fmt, i) => {\r\n        const opt = document.createElement(\"option\");\r\n        opt.value = i.toString();\r\n        if (fmt.custom) {\r\n          opt.textContent = fmt.label;\r\n        } else if (fmt.ratio) {\r\n          const dims = calcEffectiveDims(fmt.ratio[0], fmt.ratio[1], viewportW, viewportH);\r\n          opt.textContent = fmt.label + \" (\" + dims.w + \" x \" + dims.h + \" px)\";\r\n        } else {\r\n          let w = viewportW % 2 === 0 ? viewportW : viewportW - 1;\r\n          let h = viewportH % 2 === 0 ? viewportH : viewportH - 1;\r\n          opt.textContent = fmt.label + \" (\" + w + \" x \" + h + \" px)\";\r\n        }\r\n        sel.appendChild(opt);\r\n      });\r\n    }\r\n\r\n    /* --- Section Toggle --- */\r\n    function toggleSection(name) {\r\n      const body = document.getElementById(name + '_body');\r\n      const icon = document.getElementById(name + '_toggle');\r\n      const header = icon.parentElement;\r\n      const wasCollapsed = body.classList.contains('collapsed');\r\n      if (wasCollapsed) {\r\n        body.classList.remove('collapsed');\r\n        header.classList.remove('collapsed');\r\n      } else {\r\n        body.classList.add('collapsed');\r\n        header.classList.add('collapsed');\r\n      }\r\n      /* Hide viewport preview when closing export card */\r\n      if (name === 'export' && !wasCollapsed) {\r\n        if (window.sketchup) window.sketchup.hide_export_preview();\r\n      }\r\n    }\r\n\r\n    /* --- Timeline --- */\r\n    function updateTime(val) {\r\n      document.getElementById(\"current_time\").innerText = parseFloat(val).toFixed(1);\r\n    }\r\n\r\n    function atualizarTempoTotal() {\r\n      const novoMax = parseFloat(document.getElementById(\"max_time\").value);\r\n      if (isNaN(novoMax) || novoMax <= 0) return;\r\n      document.getElementById(\"timeline_range\").max = novoMax;\r\n      visoes.forEach(v => { if (v.time > novoMax) v.time = novoMax - 0.1; });\r\n      renderMarkers();\r\n    }\r\n\r\n    /* --- Visions --- */\r\n    function addVision() {\r\n      if (savedTimelines.length === 0 && visoes.length === 0) {\r\n        var name = prompt(I18N.nome_timeline, \"Time Line 1\");\r\n        if (!name) return;\r\n        savedTimelines.push({ name: name, visoes: [], maxTime: 60 });\r\n        activeTimelineIndex = 0;\r\n        renderSavedTimelines();\r\n      }\r\n      const time = parseFloat(document.getElementById(\"timeline_range\").value);\r\n      sketchup.capture_camera(time);\r\n    }\r\n\r\n    function captureVisionFromRuby(camJson) {\r\n      const obj = JSON.parse(camJson);\r\n      obj.walk = false; obj.anchor = false;\r\n      visoes = visoes.filter(v => v.time !== obj.time);\r\n      visoes.push(obj);\r\n      visoes.sort((a, b) => a.time - b.time);\r\n      visoes[0].time = 0.0;\r\n      syncActiveTimeline();\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    /* --- Draggable markers --- */\r\n    function setupMarkerDrag(marker, visionIndex, slider, maxTime) {\r\n      if (visionIndex === 0) {\r\n        marker.classList.add(\"no-drag\");\r\n        return;\r\n      }\r\n      marker.addEventListener(\"mousedown\", function(e) {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        marker.classList.add(\"dragging\");\r\n        const sliderPadding = 8;\r\n\r\n        function onMove(ev) {\r\n          const sliderRect = slider.getBoundingClientRect();\r\n          const usableWidth = sliderRect.width - sliderPadding * 2;\r\n          const relativeX = Math.max(0, Math.min(ev.clientX - sliderRect.left - sliderPadding, usableWidth));\r\n          const newTime = parseFloat(((relativeX / usableWidth) * maxTime).toFixed(1));\r\n          marker.style.left = (relativeX + sliderPadding) + \"px\";\r\n          const tooltip = marker.querySelector(\".marker-tooltip\");\r\n          if (tooltip) tooltip.textContent = newTime.toFixed(1) + \"s\";\r\n        }\r\n\r\n        function onUp(ev) {\r\n          marker.classList.remove(\"dragging\");\r\n          document.removeEventListener(\"mousemove\", onMove);\r\n          document.removeEventListener(\"mouseup\", onUp);\r\n          const sliderRect = slider.getBoundingClientRect();\r\n          const usableWidth = sliderRect.width - sliderPadding * 2;\r\n          const relativeX = Math.max(0, Math.min(ev.clientX - sliderRect.left - sliderPadding, usableWidth));\r\n          const newTime = parseFloat(((relativeX / usableWidth) * maxTime).toFixed(1));\r\n          visoes[visionIndex].time = Math.max(0.1, newTime);\r\n          visoes.sort((a, b) => a.time - b.time);\r\n          if (visoes.length > 0) visoes[0].time = 0.0;\r\n          renderMarkers();\r\n        }\r\n\r\n        document.addEventListener(\"mousemove\", onMove);\r\n        document.addEventListener(\"mouseup\", onUp);\r\n      });\r\n    }\r\n\r\n    function syncActiveTimeline() {\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n    }\r\n\r\n    function renderMarkers() {\r\n      const layer = document.getElementById(\"markers_layer\");\r\n      const lista = document.getElementById(\"lista_visoes\");\r\n      const slider = document.getElementById(\"timeline_range\");\r\n      const max = parseFloat(slider.max);\r\n      const width = slider.offsetWidth;\r\n      const countEl = document.getElementById(\"vision_count\");\r\n\r\n      layer.innerHTML = \"\"; lista.innerHTML = \"\";\r\n      countEl.textContent = visoes.length > 0 ? \"(\" + visoes.length + \")\" : \"\";\r\n\r\n      if (visoes.length === 0) {\r\n        lista.innerHTML = '<div class=\"empty-state\">' +\r\n          '<svg width=\"36\" height=\"36\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"#ccc\" stroke-width=\"1.5\"><path d=\"M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z\"/><circle cx=\"12\" cy=\"13\" r=\"4\"/></svg>' +\r\n          '<p>' + I18N.nenhuma_visao + '<br>' + I18N.dica_visao + '</p></div>';\r\n        return;\r\n      }\r\n\r\n      visoes.forEach((v, i) => {\r\n        /* Marker on timeline */\r\n        const percent = max > 0 ? v.time / max : 0;\r\n        const marker = document.createElement(\"div\");\r\n        marker.className = \"marker\" + (v.anchor ? \" anchor\" : \"\");\r\n        const sliderPadding = 8;\r\n        const usableWidth = width - sliderPadding * 2;\r\n        marker.style.left = (percent * usableWidth + sliderPadding) + \"px\";\r\n        const tooltip = document.createElement(\"span\");\r\n        tooltip.className = \"marker-tooltip\";\r\n        tooltip.textContent = v.time.toFixed(1) + \"s\";\r\n        marker.appendChild(tooltip);\r\n        marker.onclick = () => {\r\n          slider.value = v.time; updateTime(v.time); currentIndex = i;\r\n          resetPlayButton(); sketchup.goto_camera(JSON.stringify(v));\r\n        };\r\n        /* Draggable */\r\n        setupMarkerDrag(marker, i, slider, max);\r\n        layer.appendChild(marker);\r\n\r\n        /* Vision list item */\r\n        const item = document.createElement(\"div\");\r\n        item.className = \"vision-item\";\r\n        item.onclick = () => {\r\n          slider.value = v.time; updateTime(v.time); currentIndex = i;\r\n          resetPlayButton(); sketchup.goto_camera(JSON.stringify(v));\r\n        };\r\n\r\n        const num = document.createElement(\"span\");\r\n        num.className = \"vision-num\";\r\n        num.textContent = (i + 1);\r\n\r\n        const img = document.createElement(\"img\");\r\n        if (v.thumb && v.thumb.length > 0) {\r\n          const mime = v.thumb.startsWith(\"/9j/\") ? \"image/jpeg\" : \"image/bmp\";\r\n          img.src = \"data:\" + mime + \";base64,\" + v.thumb;\r\n        } else {\r\n          img.src = \"\";\r\n          img.className = \"thumb-placeholder\";\r\n        }\r\n\r\n        const info = document.createElement(\"div\");\r\n        info.className = \"vision-info\";\r\n        const timeInput = document.createElement(\"input\");\r\n        timeInput.type = \"number\"; timeInput.step = \"0.1\";\r\n        timeInput.value = v.time.toFixed(1);\r\n        timeInput.className = \"vision-time-input\";\r\n        timeInput.disabled = (i === 0);\r\n        timeInput.onclick = (e) => e.stopPropagation();\r\n        timeInput.onchange = () => {\r\n          v.time = parseFloat(timeInput.value);\r\n          visoes.sort((a, b) => a.time - b.time);\r\n          renderMarkers();\r\n        };\r\n        info.appendChild(timeInput);\r\n\r\n        const actions = document.createElement(\"div\");\r\n        actions.className = \"vision-actions\";\r\n\r\n        const anchorBtn = document.createElement(\"button\");\r\n        anchorBtn.className = \"anchor-toggle\" + (v.anchor ? \" active\" : \"\");\r\n        anchorBtn.innerHTML = \"&#9875;\";\r\n        anchorBtn.title = I18N.ancora;\r\n        anchorBtn.onclick = (e) => {\r\n          e.stopPropagation();\r\n          v.anchor = !v.anchor;\r\n          renderMarkers();\r\n        };\r\n        actions.appendChild(anchorBtn);\r\n\r\n        const delBtn = document.createElement(\"button\");\r\n        delBtn.className = \"delete-btn\";\r\n        delBtn.innerHTML = \"&times;\";\r\n        delBtn.title = I18N.excluir;\r\n        delBtn.onclick = (e) => {\r\n          e.stopPropagation();\r\n          visoes.splice(i, 1);\r\n          if (visoes.length > 0) visoes[0].time = 0.0;\r\n          syncActiveTimeline();\r\n          renderMarkers();\r\n          renderSavedTimelines();\r\n        };\r\n        actions.appendChild(delBtn);\r\n\r\n        item.appendChild(num);\r\n        item.appendChild(img);\r\n        item.appendChild(info);\r\n        item.appendChild(actions);\r\n        lista.appendChild(item);\r\n      });\r\n    }\r\n\r\n    /* --- Playback --- */\r\n    function togglePlay() {\r\n      if (!playing) {\r\n        if (visoes.length < 2) return alert(I18N.min_duas_visoes);\r\n        if (currentIndex >= visoes.length - 1) currentIndex = 0;\r\n        playing = true;\r\n        document.body.classList.add(\"playing\");\r\n        document.getElementById(\"play_button\").innerHTML = \"&#9724; \" + I18N.stop;\r\n        document.getElementById(\"play_button\").className = \"btn btn-danger\";\r\n        sketchup.play_tour(JSON.stringify(visoes), document.getElementById(\"loop_checkbox\").checked, false, document.getElementById(\"easing_checkbox\").checked, currentIndex);\r\n      } else {\r\n        resetPlayButton();\r\n        sketchup.stop_tour();\r\n      }\r\n    }\r\n\r\n    function resetPlayButton() {\r\n      playing = false;\r\n      document.body.classList.remove(\"playing\");\r\n      document.getElementById(\"play_button\").innerHTML = \"&#9654; \" + I18N.play;\r\n      document.getElementById(\"play_button\").className = \"btn btn-success\";\r\n    }\r\n\r\n    function togglePlayAll() {\r\n      if (playingAll) {\r\n        resetPlayAll();\r\n        sketchup.stop_tour();\r\n        return;\r\n      }\r\n      if (savedTimelines.length < 2) return;\r\n      /* Save current timeline state */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n      /* Build queue of timelines with 2+ visions */\r\n      playAllQueue = savedTimelines.map(function(tl, i) { return i; }).filter(function(i) { return savedTimelines[i].visoes.length >= 2; });\r\n      if (playAllQueue.length < 1) { alert(I18N.sem_tl_2mais); return; }\r\n      playingAll = true;\r\n      playAllCurrentIdx = 0;\r\n      document.body.classList.add(\"playing\");\r\n      document.getElementById(\"play_all_button\").innerHTML = \"&#9724; \" + I18N.stop_all;\r\n      document.getElementById(\"play_all_button\").className = \"btn btn-danger btn-sm\";\r\n      playTimelineAtQueueIndex(0);\r\n    }\r\n\r\n    function playTimelineAtQueueIndex(qIdx) {\r\n      var tlIdx = playAllQueue[qIdx];\r\n      var tl = savedTimelines[tlIdx];\r\n      visoes = JSON.parse(JSON.stringify(tl.visoes));\r\n      document.getElementById(\"max_time\").value = tl.maxTime;\r\n      document.getElementById(\"timeline_range\").max = tl.maxTime;\r\n      activeTimelineIndex = tlIdx;\r\n      currentIndex = 0;\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n      sketchup.play_tour(\r\n        JSON.stringify(visoes),\r\n        false,\r\n        false,\r\n        document.getElementById(\"easing_checkbox\").checked,\r\n        0\r\n      );\r\n    }\r\n\r\n    function resetPlayAll() {\r\n      playingAll = false;\r\n      playAllQueue = [];\r\n      playAllCurrentIdx = 0;\r\n      document.body.classList.remove(\"playing\");\r\n      var btn = document.getElementById(\"play_all_button\");\r\n      btn.innerHTML = '<svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><polygon points=\"5 3 19 12 5 21 5 3\"/><line x1=\"19\" y1=\"3\" x2=\"19\" y2=\"21\"/></svg> ' + I18N.play_all;\r\n      btn.className = \"btn btn-outline btn-sm\";\r\n      playing = false;\r\n      document.getElementById(\"play_button\").innerHTML = \"&#9654; \" + I18N.play;\r\n      document.getElementById(\"play_button\").className = \"btn btn-success\";\r\n    }\r\n\r\n    function startRecordingPlayAll(startTlIdx, startVisionIdx) {\r\n      syncActiveTimeline();\r\n      /* Montar fila de timelines com 2+ visões, a partir de startTlIdx */\r\n      playAllQueue = [];\r\n      for (var i = startTlIdx; i < savedTimelines.length; i++) {\r\n        if (savedTimelines[i].visoes.length >= 2) playAllQueue.push(i);\r\n      }\r\n      if (playAllQueue.length === 0) return;\r\n\r\n      playingAll = true;\r\n      playAllCurrentIdx = 0;\r\n      playing = true;\r\n      document.body.classList.add(\"playing\");\r\n      document.getElementById(\"play_button\").innerHTML = \"&#9724; \" + I18N.stop;\r\n      document.getElementById(\"play_button\").className = \"btn btn-danger\";\r\n\r\n      /* Carregar a primeira timeline da fila */\r\n      var firstTlIdx = playAllQueue[0];\r\n      var tl = savedTimelines[firstTlIdx];\r\n      visoes = JSON.parse(JSON.stringify(tl.visoes));\r\n      document.getElementById(\"max_time\").value = tl.maxTime;\r\n      document.getElementById(\"timeline_range\").max = tl.maxTime;\r\n      activeTimelineIndex = firstTlIdx;\r\n      currentIndex = startVisionIdx;\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n\r\n      sketchup.play_tour(\r\n        JSON.stringify(visoes),\r\n        false,\r\n        false,\r\n        document.getElementById(\"easing_checkbox\").checked,\r\n        startVisionIdx\r\n      );\r\n    }\r\n\r\n    function updatePlayAllButton() {\r\n      var btn = document.getElementById(\"play_all_button\");\r\n      if (savedTimelines.length > 1) {\r\n        btn.classList.remove(\"hidden\");\r\n      } else {\r\n        btn.classList.add(\"hidden\");\r\n      }\r\n    }\r\n\r\n    function pauseAtIndex(idx) {\r\n      currentIndex = idx;\r\n      if (playingAll) {\r\n        playAllCurrentIdx++;\r\n        if (playAllCurrentIdx < playAllQueue.length) {\r\n          playTimelineAtQueueIndex(playAllCurrentIdx);\r\n          return;\r\n        } else {\r\n          resetPlayAll();\r\n          return;\r\n        }\r\n      }\r\n      resetPlayButton();\r\n    }\r\n    function triggerSpaceFromRuby() { togglePlay(); }\r\n    function updatePlayhead(time) {\r\n      var slider = document.getElementById(\"timeline_range\");\r\n      slider.value = time;\r\n      document.getElementById(\"current_time\").innerText = parseFloat(time).toFixed(1);\r\n    }\r\n\r\n    /* --- Timeline Management --- */\r\n    function exportarTimeline() {\r\n      if (visoes.length === 0) { alert(I18N.sem_visoes_exportar); return; }\r\n      var tlName = (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length)\r\n        ? savedTimelines[activeTimelineIndex].name : \"Time Line\";\r\n      /* Download JSON */\r\n      var dataStr = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(visoes, null, 2));\r\n      var a = document.createElement(\"a\");\r\n      a.setAttribute(\"href\", dataStr);\r\n      a.setAttribute(\"download\", tlName.replace(/[^a-zA-Z0-9_-]/g, \"_\") + \".json\");\r\n      document.body.appendChild(a); a.click(); a.remove();\r\n      /* Salvar na lista */\r\n      saveCurrentToTimelines(tlName);\r\n    }\r\n\r\n    function exportarProjeto() {\r\n      syncActiveTimeline();\r\n      if (savedTimelines.length === 0) { alert(I18N.sem_tl_exportar); return; }\r\n      var projeto = { type: \"tour_virtual_project\", timelines: savedTimelines };\r\n      var dataStr = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(projeto, null, 2));\r\n      var a = document.createElement(\"a\");\r\n      a.setAttribute(\"href\", dataStr);\r\n      a.setAttribute(\"download\", \"projeto_tour_virtual.json\");\r\n      document.body.appendChild(a); a.click(); a.remove();\r\n    }\r\n\r\n    function saveCurrentToTimelines(name) {\r\n      var maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      var entry = { name: name, visoes: JSON.parse(JSON.stringify(visoes)), maxTime: maxTime };\r\n      /* Atualizar existente se ativo, senão adicionar novo */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex] = entry;\r\n      } else {\r\n        savedTimelines.push(entry);\r\n        activeTimelineIndex = savedTimelines.length - 1;\r\n      }\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    function importarTimeline(input) {\r\n      var file = input.files[0];\r\n      if (!file) return;\r\n      var reader = new FileReader();\r\n      reader.onload = function(e) {\r\n        try {\r\n          var imported = JSON.parse(e.target.result);\r\n          /* Detectar se é um projeto completo */\r\n          if (imported && imported.type === \"tour_virtual_project\" && Array.isArray(imported.timelines)) {\r\n            syncActiveTimeline();\r\n            imported.timelines.forEach(function(tl) {\r\n              if (tl.visoes) {\r\n                tl.visoes.sort(function(a, b) { return a.time - b.time; });\r\n                if (tl.visoes.length > 0) tl.visoes[0].time = 0.0;\r\n              }\r\n              savedTimelines.push({ name: tl.name || I18N.importada, visoes: tl.visoes || [], maxTime: tl.maxTime || 60 });\r\n            });\r\n            if (savedTimelines.length > 0 && activeTimelineIndex < 0) {\r\n              activeTimelineIndex = 0;\r\n              var first = savedTimelines[0];\r\n              visoes = JSON.parse(JSON.stringify(first.visoes));\r\n              document.getElementById(\"max_time\").value = first.maxTime;\r\n              document.getElementById(\"timeline_range\").max = first.maxTime;\r\n              renderMarkers();\r\n            }\r\n            renderSavedTimelines();\r\n            return;\r\n          }\r\n          /* Time Line única */\r\n          if (!Array.isArray(imported)) throw I18N.formato_invalido;\r\n          imported.sort(function(a, b) { return a.time - b.time; });\r\n          if (imported.length > 0) imported[0].time = 0.0;\r\n          var maxTime = imported.length > 0 ? Math.ceil(imported[imported.length - 1].time + 1) : 60;\r\n          var name = file.name.replace(/\\\\.json$/i, \"\");\r\n          savedTimelines.push({ name: name, visoes: imported, maxTime: maxTime });\r\n          renderSavedTimelines();\r\n        } catch (err) { alert(I18N.erro_importar + err); }\r\n      };\r\n      reader.readAsText(file);\r\n      input.value = \"\";\r\n    }\r\n\r\n    function switchTimeline(index) {\r\n      if (index === activeTimelineIndex) return;\r\n      /* Save current state if there's an active timeline */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n      /* Load selected timeline */\r\n      const tl = savedTimelines[index];\r\n      visoes = JSON.parse(JSON.stringify(tl.visoes));\r\n      document.getElementById(\"max_time\").value = tl.maxTime;\r\n      document.getElementById(\"timeline_range\").max = tl.maxTime;\r\n      activeTimelineIndex = index;\r\n      currentIndex = 0;\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    function deleteTimeline(index) {\r\n      if (index === activeTimelineIndex) return;\r\n      savedTimelines.splice(index, 1);\r\n      if (activeTimelineIndex > index) activeTimelineIndex--;\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    function renderSavedTimelines() {\r\n      var container = document.getElementById(\"saved_timelines_list\");\r\n      container.innerHTML = \"\";\r\n      if (savedTimelines.length === 0) { updatePlayAllButton(); return; }\r\n      var dragSrcIndex = null;\r\n\r\n      savedTimelines.forEach(function(tl, i) {\r\n        var item = document.createElement(\"div\");\r\n        item.className = \"tl-item\" + (i === activeTimelineIndex ? \" active\" : \"\");\r\n        item.draggable = true;\r\n        item.dataset.index = i;\r\n\r\n        /* Drag handle */\r\n        var handle = document.createElement(\"span\");\r\n        handle.className = \"tl-drag-handle\";\r\n        handle.innerHTML = \"&#9776;\";\r\n        item.appendChild(handle);\r\n\r\n        /* Drag events */\r\n        item.addEventListener(\"dragstart\", function(e) {\r\n          dragSrcIndex = i;\r\n          item.classList.add(\"dragging\");\r\n          e.dataTransfer.effectAllowed = \"move\";\r\n        });\r\n        item.addEventListener(\"dragover\", function(e) {\r\n          e.preventDefault();\r\n          e.dataTransfer.dropEffect = \"move\";\r\n          var rect = item.getBoundingClientRect();\r\n          var midY = rect.top + rect.height / 2;\r\n          item.classList.remove(\"drag-over-top\", \"drag-over-bottom\");\r\n          item.classList.add(e.clientY < midY ? \"drag-over-top\" : \"drag-over-bottom\");\r\n        });\r\n        item.addEventListener(\"dragleave\", function() {\r\n          item.classList.remove(\"drag-over-top\", \"drag-over-bottom\");\r\n        });\r\n        item.addEventListener(\"drop\", function(e) {\r\n          e.preventDefault();\r\n          item.classList.remove(\"drag-over-top\", \"drag-over-bottom\");\r\n          if (dragSrcIndex === null || dragSrcIndex === i) return;\r\n          var rect = item.getBoundingClientRect();\r\n          var midY = rect.top + rect.height / 2;\r\n          var targetIndex = e.clientY < midY ? i : i + 1;\r\n          if (dragSrcIndex < targetIndex) targetIndex--;\r\n          var moved = savedTimelines.splice(dragSrcIndex, 1)[0];\r\n          savedTimelines.splice(targetIndex, 0, moved);\r\n          if (activeTimelineIndex === dragSrcIndex) {\r\n            activeTimelineIndex = targetIndex;\r\n          } else if (dragSrcIndex < activeTimelineIndex && targetIndex >= activeTimelineIndex) {\r\n            activeTimelineIndex--;\r\n          } else if (dragSrcIndex > activeTimelineIndex && targetIndex <= activeTimelineIndex) {\r\n            activeTimelineIndex++;\r\n          }\r\n          renderSavedTimelines();\r\n        });\r\n        item.addEventListener(\"dragend\", function() {\r\n          item.classList.remove(\"dragging\");\r\n          dragSrcIndex = null;\r\n        });\r\n\r\n        item.onclick = function() { switchTimeline(i); };\r\n\r\n        var indicator = document.createElement(\"span\");\r\n        indicator.className = \"tl-indicator\";\r\n        item.appendChild(indicator);\r\n\r\n        var nameEl = document.createElement(\"span\");\r\n        nameEl.className = \"tl-name\";\r\n        nameEl.textContent = tl.name;\r\n        item.appendChild(nameEl);\r\n\r\n        var count = document.createElement(\"span\");\r\n        count.className = \"tl-count\";\r\n        count.textContent = tl.visoes.length + \" \" + I18N.visoes;\r\n        item.appendChild(count);\r\n\r\n        if (i !== activeTimelineIndex) {\r\n          var del = document.createElement(\"button\");\r\n          del.className = \"tl-delete\";\r\n          del.innerHTML = \"&times;\";\r\n          del.title = I18N.excluir;\r\n          del.onclick = function(e) { e.stopPropagation(); deleteTimeline(i); };\r\n          item.appendChild(del);\r\n        }\r\n\r\n        container.appendChild(item);\r\n      });\r\n\r\n      updatePlayAllButton();\r\n    }\r\n\r\n    function novaTimeline() {\r\n      var name = prompt(I18N.nova_timeline, \"Time Line \" + (savedTimelines.length + 1));\r\n      if (!name) return;\r\n      /* Salvar timeline atual na lista se pertencer a uma timeline salva */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n      /* Criar nova timeline vazia e adicioná-la à lista */\r\n      savedTimelines.push({ name: name, visoes: [], maxTime: 60 });\r\n      activeTimelineIndex = savedTimelines.length - 1;\r\n      /* Limpar estado */\r\n      visoes = [];\r\n      currentIndex = 0;\r\n      document.getElementById(\"max_time\").value = 60;\r\n      document.getElementById(\"timeline_range\").max = 60;\r\n      document.getElementById(\"timeline_range\").value = 0;\r\n      updateTime(0);\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    /* --- Video Export with Proportional Presets --- */\r\n    function onPresetChange() {\r\n      const sel = document.getElementById(\"preset_select\");\r\n      const preview = document.getElementById(\"preset_preview\");\r\n      const customDims = document.getElementById(\"custom_dims\");\r\n      const btnRecord = document.getElementById(\"btn_record\");\r\n      const idx = parseInt(sel.value);\r\n\r\n      if (isNaN(idx)) {\r\n        customDims.classList.remove(\"visible\");\r\n        preview.style.display = \"none\";\r\n        btnRecord.disabled = true;\r\n        if (window.sketchup) window.sketchup.hide_export_preview();\r\n        return;\r\n      }\r\n\r\n      const fmt = EXPORT_FORMATS[idx];\r\n      btnRecord.disabled = false;\r\n\r\n      if (fmt.custom) {\r\n        customDims.classList.add(\"visible\");\r\n        preview.style.display = \"none\";\r\n        if (window.sketchup) window.sketchup.hide_export_preview();\r\n      } else {\r\n        customDims.classList.remove(\"visible\");\r\n        let dims;\r\n        if (fmt.ratio) {\r\n          dims = calcEffectiveDims(fmt.ratio[0], fmt.ratio[1], viewportW, viewportH);\r\n        } else {\r\n          dims = { w: viewportW % 2 === 0 ? viewportW : viewportW - 1, h: viewportH % 2 === 0 ? viewportH : viewportH - 1 };\r\n        }\r\n        preview.textContent = I18N.area_gravacao + dims.w + \" x \" + dims.h + \" px\";\r\n        preview.style.display = \"flex\";\r\n        /* Show preview overlay in viewport */\r\n        if (window.sketchup) window.sketchup.show_export_preview(dims.w, dims.h);\r\n      }\r\n    }\r\n\r\n    function getExportDimensions() {\r\n      const sel = document.getElementById(\"preset_select\");\r\n      const idx = parseInt(sel.value);\r\n      if (isNaN(idx)) return null;\r\n      const fmt = EXPORT_FORMATS[idx];\r\n      if (fmt.custom) {\r\n        return {\r\n          w: parseInt(document.getElementById(\"custom_w\").value) || 1280,\r\n          h: parseInt(document.getElementById(\"custom_h\").value) || 720\r\n        };\r\n      }\r\n      if (fmt.ratio) {\r\n        return calcEffectiveDims(fmt.ratio[0], fmt.ratio[1], viewportW, viewportH);\r\n      }\r\n      return { w: viewportW % 2 === 0 ? viewportW : viewportW - 1, h: viewportH % 2 === 0 ? viewportH : viewportH - 1 };\r\n    }\r\n\r\n    function iniciarGravacao() {\r\n      var gravarProjeto = document.getElementById(\"rec_projeto\").checked;\r\n      var desdeInicio = document.getElementById(\"rec_inicio\").checked;\r\n\r\n      if (gravarProjeto) {\r\n        syncActiveTimeline();\r\n        var temVisoes = savedTimelines.some(function(tl) { return tl.visoes.length >= 2; });\r\n        if (!temVisoes) { alert(I18N.sem_tl_min_duas); return; }\r\n      } else {\r\n        if (visoes.length < 2) { alert(I18N.min_duas_visoes); return; }\r\n      }\r\n      var dims = getExportDimensions();\r\n      if (!dims || dims.w < 50 || dims.h < 50) { alert(I18N.dims_invalidas); return; }\r\n\r\n      /* Mostrar modal de nome */\r\n      document.getElementById(\"filename_input\").value = gravarProjeto ? \"projeto_tour\" : \"tour_final\";\r\n      document.getElementById(\"filename_modal\").style.display = \"flex\";\r\n      document.getElementById(\"filename_input\").focus();\r\n      document.getElementById(\"filename_input\").select();\r\n    }\r\n\r\n    function fecharModalFilename() {\r\n      document.getElementById(\"filename_modal\").style.display = \"none\";\r\n    }\r\n\r\n    function confirmarFilename() {\r\n      var nome = document.getElementById(\"filename_input\").value.trim();\r\n      if (!nome) { alert(I18N.digite_nome); return; }\r\n      document.getElementById(\"filename_modal\").style.display = \"none\";\r\n\r\n      var gravarProjeto = document.getElementById(\"rec_projeto\").checked;\r\n      var desdeInicio = document.getElementById(\"rec_inicio\").checked;\r\n      var dims = getExportDimensions();\r\n      var startIdx = desdeInicio ? 0 : currentIndex;\r\n\r\n      if (window.sketchup) window.sketchup.hide_export_preview();\r\n\r\n      if (gravarProjeto) {\r\n        syncActiveTimeline();\r\n        var allTimelines = JSON.stringify(savedTimelines);\r\n        var startTl = desdeInicio ? 0 : activeTimelineIndex;\r\n        var startVision = desdeInicio ? 0 : currentIndex;\r\n        if (window.sketchup) {\r\n          window.sketchup.start_export_project(\r\n            allTimelines,\r\n            document.getElementById(\"easing_checkbox\").checked,\r\n            startTl,\r\n            startVision,\r\n            dims.w,\r\n            dims.h,\r\n            nome\r\n          );\r\n        }\r\n      } else {\r\n        if (window.sketchup) {\r\n          window.sketchup.start_export_process(\r\n            JSON.stringify(visoes),\r\n            document.getElementById(\"easing_checkbox\").checked,\r\n            startIdx,\r\n            dims.w,\r\n            dims.h,\r\n            nome\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    function showRecordingIndicator() {\r\n      document.getElementById(\"recording_bar\").classList.add(\"active\");\r\n    }\r\n    function hideRecordingIndicator() {\r\n      document.getElementById(\"recording_bar\").classList.remove(\"active\");\r\n    }\r\n\r\n    function instalarExportacao() {\r\n      if (window.sketchup) { window.sketchup.install_ffmpeg(); }\r\n    }\r\n\r\n    /* --- Hotkey --- */\r\n    function mostrarCampoAtalho() {\r\n      capturingHotkey = true; pendingHotkey = null;\r\n      document.getElementById(\"hotkey_input\").value = \"\";\r\n      document.getElementById(\"hotkey_edit\").classList.add(\"visible\");\r\n      document.getElementById(\"hotkey_input\").focus();\r\n    }\r\n    function capturarAtalhoInput(e) {\r\n      e.preventDefault();\r\n      /* Ignorar teclas modificadoras sozinhas */\r\n      if ([16, 17, 18, 91, 93].includes(e.keyCode)) return;\r\n      pendingHotkey = {\r\n        keyCode: e.keyCode,\r\n        ctrl: e.ctrlKey,\r\n        alt: e.altKey,\r\n        shift: e.shiftKey\r\n      };\r\n      /* Montar label legivel */\r\n      var parts = [];\r\n      if (e.ctrlKey) parts.push(\"Ctrl\");\r\n      if (e.altKey) parts.push(\"Alt\");\r\n      if (e.shiftKey) parts.push(\"Shift\");\r\n      parts.push(e.code.replace(\"Key\", \"\").replace(\"Digit\", \"\"));\r\n      document.getElementById(\"hotkey_input\").value = parts.join(\" + \");\r\n    }\r\n    function confirmarAtalho() {\r\n      if (pendingHotkey !== null) {\r\n        hotkey = pendingHotkey;\r\n        if (window.sketchup) {\r\n          window.sketchup.set_hotkey(hotkey.keyCode, hotkey.ctrl, hotkey.alt, hotkey.shift);\r\n        }\r\n      }\r\n      capturingHotkey = false;\r\n      document.getElementById(\"hotkey_edit\").classList.remove(\"visible\");\r\n    }\r\n\r\n    /* --- Global bindings --- */\r\n    window.captureVisionFromRuby = captureVisionFromRuby;\r\n    window.resetPlayButton = resetPlayButton;\r\n    window.pauseAtIndex = pauseAtIndex;\r\n    window.triggerSpaceFromRuby = triggerSpaceFromRuby;\r\n    window.showRecordingIndicator = showRecordingIndicator;\r\n    window.hideRecordingIndicator = hideRecordingIndicator;\r\n    window.updatePlayhead = updatePlayhead;\r\n    window.resetPlayAll = resetPlayAll;\r\n    window.startRecordingPlayAll = startRecordingPlayAll;\r\n    window.addEventListener(\"resize\", () => { renderMarkers(); });\r\n\r\n    document.addEventListener(\"keydown\", (e) => {\r\n      if (!capturingHotkey &&\r\n          e.keyCode === hotkey.keyCode &&\r\n          e.ctrlKey === hotkey.ctrl &&\r\n          e.altKey === hotkey.alt &&\r\n          e.shiftKey === hotkey.shift &&\r\n          ![\"INPUT\", \"TEXTAREA\"].includes(e.target.tagName)) {\r\n        e.preventDefault(); togglePlay();\r\n      }\r\n    });\r\n\r\n    /* Init */\r\n    populatePresets();\r\n    renderMarkers();\r\n</script>\r\n</body>\r\n</html>\r\nHTML\r\n\r\n      @dialog ||= UI::HtmlDialog.new({\r\n        :dialog_title => obter_texto(:titulo_dialogo),\r\n        :preferences_key => \"com.example.tour\",\r\n        :scrollable => true,\r\n        :resizable => true,\r\n        :width => 430,\r\n        :height => 790,\r\n        :style => UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n\r\n      @dialog.set_html(html)\r\n      start_space_timer\r\n\r\n      @dialog.add_action_callback(\"set_hotkey\") do |_, key_code, ctrl, alt, shift|\r\n        GlobalKey.set_hotkey(key_code.to_i, ctrl, alt, shift)\r\n        Sketchup.write_default(\"TourVirtual\", \"Hotkey\", key_code.to_i)\r\n        Sketchup.write_default(\"TourVirtual\", \"HotkeyCtrl\", ctrl ? true : false)\r\n        Sketchup.write_default(\"TourVirtual\", \"HotkeyAlt\", alt ? true : false)\r\n        Sketchup.write_default(\"TourVirtual\", \"HotkeyShift\", shift ? true : false)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"capture_camera\") do |_, time_code|\r\n        cam = Sketchup.active_model.active_view.camera\r\n        thumb = capture_thumbnail\r\n        camera_data = {\r\n          time: time_code.to_f,\r\n          eye: cam.eye.to_a,\r\n          target: cam.target.to_a,\r\n          up: cam.up.to_a,\r\n          fov: cam.fov,\r\n          perspective: cam.perspective?,\r\n          thumb: thumb,\r\n          anchor: false\r\n        }\r\n        json_str = camera_data.to_json.gsub('\"', '\\\"')\r\n        @dialog.execute_script(\"captureVisionFromRuby(\\\"#{json_str}\\\")\")\r\n      end\r\n\r\n      @dialog.add_action_callback(\"goto_camera\") do |_, cam_json|\r\n        cam_data = JSON.parse(cam_json, symbolize_names: true)\r\n        cam = Sketchup::Camera.new(cam_data[:eye], cam_data[:target], cam_data[:up], cam_data[:perspective])\r\n        cam.fov = cam_data[:fov]\r\n        Sketchup.active_model.active_view.camera = cam\r\n      end\r\n\r\n      @dialog.add_action_callback(\"play_tour\") do |_, json_data, loop_enabled, inverse_mode, use_easing, start_index|\r\n        @camera_keys = JSON.parse(json_data, symbolize_names: true)\r\n        view = Sketchup.active_model.active_view\r\n        return if @camera_keys.length < 2\r\n        @camera_keys.sort_by! { |v| v[:time] }\r\n        @index = start_index.to_i\r\n        @direction = 1\r\n        @ping_pong = loop_enabled && inverse_mode\r\n\r\n        define_singleton_method(:ease_in_out_quad) do |t|\r\n          t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t\r\n        end\r\n\r\n        define_singleton_method(:catmull_rom) do |p0, p1, p2, p3, t|\r\n          t2 = t * t\r\n          t3 = t2 * t\r\n          [\r\n            0.5 * ((2 * p1[0]) + (-p0[0] + p2[0]) * t + (2*p0[0] - 5*p1[0] + 4*p2[0] - p3[0]) * t2 + (-p0[0] + 3*p1[0] - 3*p2[0] + p3[0]) * t3),\r\n            0.5 * ((2 * p1[1]) + (-p0[1] + p2[1]) * t + (2*p0[1] - 5*p1[1] + 4*p2[1] - p3[1]) * t2 + (-p0[1] + 3*p1[1] - 3*p2[1] + p3[1]) * t3),\r\n            0.5 * ((2 * p1[2]) + (-p0[2] + p2[2]) * t + (2*p0[2] - 5*p1[2] + 4*p2[2] - p3[2]) * t2 + (-p0[2] + 3*p1[2] - 3*p2[2] + p3[2]) * t3)\r\n          ]\r\n        end\r\n\r\n        define_singleton_method(:catmull_rom_1d) do |p0, p1, p2, p3, t|\r\n          t2 = t * t\r\n          t3 = t2 * t\r\n          0.5 * ((2 * p1) + (-p0 + p2) * t + (2*p0 - 5*p1 + 4*p2 - p3) * t2 + (-p0 + 3*p1 - 3*p2 + p3) * t3)\r\n        end\r\n\r\n        define_singleton_method(:play_transition) do\r\n          current = @camera_keys[@index]\r\n          next_index = @index + @direction\r\n\r\n          if next_index >= @camera_keys.size || next_index < 0\r\n            if loop_enabled\r\n               @index = 0\r\n               UI.start_timer(0.01) { play_transition }\r\n               return\r\n            else\r\n              @dialog.execute_script(\"pauseAtIndex(0)\")\r\n              return\r\n            end\r\n          end\r\n\r\n          next_cam = @camera_keys[next_index]\r\n          duration = (next_cam[:time] - current[:time]).abs\r\n          t_start = Time.now\r\n\r\n          p0 = @camera_keys[[@index - 1, 0].max]\r\n          p1 = current\r\n          p2 = next_cam\r\n          p3 = @camera_keys[[@index + 2, @camera_keys.size - 1].min]\r\n\r\n          @walk_shake = {\r\n            z_phase: rand * Math::PI * 2, x_phase: rand * Math::PI * 2,\r\n            z_amp: 0.8 + rand * 0.4, x_amp: 0.3 + rand * 0.4\r\n          }\r\n          playhead_counter = 0\r\n\r\n          @timer_id = UI.start_timer(0.03, true) do\r\n            t_elapsed = Time.now - t_start\r\n            t = duration.zero? ? 1.0 : [t_elapsed / duration, 1.0].min\r\n            t = use_easing ? ease_in_out_quad(t) : t\r\n\r\n            # Atualizar playhead na timeline (~a cada 0.09s)\r\n            playhead_counter += 1\r\n            if playhead_counter % 3 == 0\r\n              interpolated_time = current[:time] + t * (next_cam[:time] - current[:time])\r\n              @dialog.execute_script(\"updatePlayhead(#{interpolated_time.round(1)})\")\r\n            end\r\n\r\n            eye    = catmull_rom(p0[:eye],    p1[:eye],    p2[:eye],    p3[:eye],    t)\r\n            target = catmull_rom(p0[:target], p1[:target], p2[:target], p3[:target], t)\r\n            up     = catmull_rom(p0[:up],     p1[:up],     p2[:up],     p3[:up],     t)\r\n\r\n            # Interpolação Catmull-Rom para o FOV: suavidade total acompanhando a curva da câmera\r\n            fov = catmull_rom_1d(p0[:fov], p1[:fov], p2[:fov], p3[:fov], t)\r\n\r\n            if current[:walk]\r\n              eye[2] += Math.sin(t * Math::PI * 6 + @walk_shake[:z_phase]) * @walk_shake[:z_amp]\r\n              eye[0] += Math.sin(t * Math::PI * 3 + @walk_shake[:x_phase]) * @walk_shake[:x_amp]\r\n            end\r\n\r\n            cam = Sketchup::Camera.new(eye, target, up, current[:perspective])\r\n            cam.fov = fov\r\n            view.camera = cam\r\n            view.refresh\r\n\r\n            if t >= 1.0\r\n              UI.stop_timer(@timer_id)\r\n              @index = next_index\r\n              if @camera_keys[@index][:anchor] && @index > 0\r\n                @dialog.execute_script(\"pauseAtIndex(#{@index})\")\r\n              else\r\n                play_transition\r\n              end\r\n            end\r\n          end\r\n        end\r\n\r\n        play_transition\r\n      end\r\n\r\n      # Callback de exportação com presets de resolução\r\n      @dialog.add_action_callback(\"start_export_process\") do |_, json_data, use_easing, start_index, width, height, filename|\r\n        iniciar_processo_exportacao(json_data, use_easing, start_index, width.to_i, height.to_i, filename.to_s)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"start_export_project\") do |_, all_timelines_json, use_easing, active_tl_index, start_vision_index, width, height, filename|\r\n        iniciar_processo_exportacao_projeto(all_timelines_json, use_easing, active_tl_index.to_i, start_vision_index.to_i, width.to_i, height.to_i, filename.to_s)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"install_ffmpeg\") do |_|\r\n        eval(FFMPEG_INSTALL_SCRIPT)\r\n        UI.messagebox(obter_texto(:ffmpeg_instalado))\r\n      end\r\n\r\n      @dialog.add_action_callback(\"stop_tour\") do |_|\r\n        UI.stop_timer(@timer_id) if @timer_id\r\n        @dialog.execute_script(\"resetPlayButton()\")\r\n      end\r\n\r\n      @dialog.add_action_callback(\"show_export_preview\") do |_, width, height|\r\n        @preview_tool = ExportPreviewTool.new(width.to_i, height.to_i)\r\n        Sketchup.active_model.select_tool(@preview_tool)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"hide_export_preview\") do |_|\r\n        Sketchup.active_model.select_tool(nil)\r\n        @preview_tool = nil\r\n      end\r\n\r\n      @dialog.set_on_closed {\r\n        UI.stop_timer(@timer_id) if defined?(@timer_id) && @timer_id\r\n        stop_space_timer\r\n        if @preview_tool\r\n          Sketchup.active_model.select_tool(nil)\r\n          @preview_tool = nil\r\n        end\r\n      }\r\n\r\n      @dialog.show\r\n    end\r\n  end\r\nend\r\n\r\ndef self.executar\r\n  TourPlugin::CameraTimeline.start_ui\r\nend\r\n\r\nend # module TourVirtual\r\nend # module ScriptUpComunidade\r\n\r\nScriptUpComunidade::TourVirtual.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "tour-virtual-96z4s",
    "title": {
      "pt": "Tour Virtual",
      "en": "Virtual Tour",
      "es": "Visita virtual"
    },
    "author": "Fábio Coutinho",
    "version": "2.8",
    "description": {
      "pt": "Permite criar e gerenciar a criação de cenas em linha de tempo, várias linhas de tempo, apresentar a transição entre elas de forma suave e sem impacto de troca de cena e exportação de vídeo com FFMPEG de forma rápida por captura de tela enquanto apresenta.",
      "en": "It allows you to create and manage timeline scenes, multiple timelines, present the transition between them smoothly and without scene change impact, and quickly export video with FFMPEG by screen capture while presenting.",
      "es": "Le permite crear y administrar escenas de línea de tiempo, múltiples líneas de tiempo, presentar la transición entre ellas sin problemas y sin impacto en el cambio de escena, y exportar rápidamente video con FFMPEG mediante captura de pantalla mientras se presenta."
    },
    "keywords": {
      "pt": [
        "tour",
        "apresentação",
        "vídeo"
      ],
      "en": [
        "tour",
        "presentation",
        "video"
      ],
      "es": [
        "recorrido",
        "presentación",
        "video"
      ]
    },
    "code": {
      "pt": "require 'json'\r\nrequire 'sketchup.rb'\r\nrequire 'base64'\r\nrequire 'tmpdir'\r\nrequire 'fiddle/import'\r\nrequire 'fileutils'\r\nrequire 'open3'\r\nrequire 'etc'\r\nrequire 'open-uri'\r\nif Sketchup.platform == :platform_win\r\n  require 'win32ole'\r\nend\r\n\r\nmodule ScriptUpComunidade\r\nmodule TourVirtual\r\n\r\n# --- Definições de Diretórios ---\r\nplugins_root = Sketchup.find_support_file(\"Plugins\")\r\nPLUGIN_DIR = if plugins_root\r\n               File.expand_path(File.join(plugins_root, 'ScriptUp'))\r\n             else\r\n               File.expand_path(File.dirname(__FILE__))\r\n             end unless defined?(PLUGIN_DIR)\r\n\r\nIDIOMAS ||= {\r\n  'pt-BR' => {\r\n    :status_clicar_arrastar  => \"CLIQUE E ARRASTE para definir a área de gravação do vídeo.\",\r\n    :area_pequena            => \"Área muito pequena. Tente novamente.\",\r\n    :selecionar_pasta        => \"Selecione a pasta para salvar\",\r\n    :ffmpeg_nao_encontrado   => \"FFmpeg não encontrado.\",\r\n    :erro_gravador           => \"Erro ao iniciar gravador: \",\r\n    :gravacao_finalizada     => \"Gravação finalizada!\\nSalvo em: \",\r\n    :ffmpeg_instalado        => \"FFmpeg instalado. Execute o Tour Virtual novamente.\",\r\n    :titulo_dialogo          => \"Tour Virtual\",\r\n    :ffmpeg_plugins_erro     => \"Não foi possível resolver a pasta Plugins automaticamente.\",\r\n    :ffmpeg_instalar_em      => \"Instalar FFmpeg em:\",\r\n    :ffmpeg_origem           => \"Origem:\",\r\n    :ffmpeg_continuar        => \"Continuar?\",\r\n    :ffmpeg_cancelada        => \"Instalação cancelada.\",\r\n    :ffmpeg_ja_existe        => \"Já existe:\",\r\n    :ffmpeg_sobrescrever     => \"Deseja sobrescrever?\",\r\n    :ffmpeg_falha_expand     => \"Falha no Expand-Archive (PowerShell).\",\r\n    :ffmpeg_falha_unzip      => \"Falha no unzip (macOS).\",\r\n    :ffmpeg_exe_nao_encontrado => \"Executável ffmpeg não encontrado no pacote baixado.\",\r\n    :ffmpeg_sucesso          => \"FFmpeg instalado com sucesso em:\",\r\n    :ffmpeg_falhou           => \"Falhou:\",\r\n    :ffmpeg_abrindo_nav      => \"Abrindo o link no navegador...\",\r\n    :titulo                  => \"Tour Virtual\",\r\n    :subtitulo               => \"Linha do Tempo\",\r\n    :total                   => \"Total:\",\r\n    :visao                   => \"Visão\",\r\n    :play                    => \"Play\",\r\n    :stop                    => \"Stop\",\r\n    :play_all                => \"Play All\",\r\n    :stop_all                => \"Stop All\",\r\n    :atalho                  => \"Atalho\",\r\n    :pressione               => \"Pressione...\",\r\n    :ok                      => \"Ok\",\r\n    :loop                    => \"Loop\",\r\n    :easing                  => \"Easing\",\r\n    :visoes_salvas           => \"Visões salvas\",\r\n    :gerenciar_timeline      => \"Gerenciar Time Line\",\r\n    :nova                    => \"Nova\",\r\n    :exportar_atual          => \"Exportar Atual\",\r\n    :exportar_projeto        => \"Exportar Projeto\",\r\n    :importar                => \"Importar\",\r\n    :exportar_video          => \"Exportar Vídeo\",\r\n    :selecione_formato       => \"Selecione o formato…\",\r\n    :largura                 => \"Largura\",\r\n    :altura                  => \"Altura\",\r\n    :gravar_projeto          => \"Gravar todo o projeto (todas as Time Lines)\",\r\n    :iniciar_quadro1         => \"Iniciar do quadro 1\",\r\n    :iniciar_gravacao        => \"Iniciar Gravação\",\r\n    :gravando                => \"Gravando...\",\r\n    :ffmpeg_necessario       => \"FFmpeg necessário para gravar vídeo.\",\r\n    :instalar_ffmpeg         => \"Instalar FFmpeg\",\r\n    :nome_arquivo            => \"Nome do arquivo\",\r\n    :extensao_mp4            => \"A extensão .mp4 será adicionada automaticamente.\",\r\n    :cancelar                => \"Cancelar\",\r\n    :salvar                  => \"Salvar\",\r\n    :viewport_atual          => \"Viewport atual:\",\r\n    :paisagem                => \"Paisagem\",\r\n    :retrato                 => \"Retrato\",\r\n    :quadrado                => \"Quadrado\",\r\n    :classico                => \"Clássico\",\r\n    :ultra_wide              => \"Ultra-wide\",\r\n    :viewport_inteira        => \"Viewport Inteira\",\r\n    :personalizado           => \"Personalizado\",\r\n    :nome_timeline           => \"Nome da Time Line:\",\r\n    :nenhuma_visao           => \"Nenhuma visão adicionada.\",\r\n    :dica_visao              => \"Posicione a câmera e clique em <b>+ Visão</b>.\",\r\n    :ancora                  => \"Âncora\",\r\n    :excluir                 => \"Excluir\",\r\n    :min_duas_visoes         => \"Adicione pelo menos duas visões.\",\r\n    :sem_tl_2mais            => \"Nenhuma Time Line com 2+ visões.\",\r\n    :sem_visoes_exportar     => \"Nenhuma visão para exportar.\",\r\n    :sem_tl_exportar         => \"Nenhuma Time Line para exportar.\",\r\n    :importada               => \"Importada\",\r\n    :formato_invalido        => \"Formato inválido.\",\r\n    :erro_importar           => \"Erro ao importar: \",\r\n    :visoes                  => \"visões\",\r\n    :nova_timeline           => \"Nome da nova Time Line:\",\r\n    :area_gravacao           => \"Área de gravação: \",\r\n    :sem_tl_min_duas         => \"Nenhuma Time Line com pelo menos duas visões.\",\r\n    :dims_invalidas          => \"Dimensões inválidas (mínimo 50 x 50 px).\",\r\n    :digite_nome             => \"Digite um nome para o arquivo.\",\r\n  },\r\n  'en-US' => {\r\n    :status_clicar_arrastar  => \"CLICK AND DRAG to define the video recording area.\",\r\n    :area_pequena            => \"Area too small. Try again.\",\r\n    :selecionar_pasta        => \"Select folder to save\",\r\n    :ffmpeg_nao_encontrado   => \"FFmpeg not found.\",\r\n    :erro_gravador           => \"Error starting recorder: \",\r\n    :gravacao_finalizada     => \"Recording finished!\\nSaved to: \",\r\n    :ffmpeg_instalado        => \"FFmpeg installed. Run Virtual Tour again.\",\r\n    :titulo_dialogo          => \"Virtual Tour\",\r\n    :ffmpeg_plugins_erro     => \"Could not resolve the Plugins folder automatically.\",\r\n    :ffmpeg_instalar_em      => \"Install FFmpeg to:\",\r\n    :ffmpeg_origem           => \"Source:\",\r\n    :ffmpeg_continuar        => \"Continue?\",\r\n    :ffmpeg_cancelada        => \"Installation cancelled.\",\r\n    :ffmpeg_ja_existe        => \"Already exists:\",\r\n    :ffmpeg_sobrescrever     => \"Overwrite?\",\r\n    :ffmpeg_falha_expand     => \"Expand-Archive failed (PowerShell).\",\r\n    :ffmpeg_falha_unzip      => \"unzip failed (macOS).\",\r\n    :ffmpeg_exe_nao_encontrado => \"FFmpeg executable not found in downloaded package.\",\r\n    :ffmpeg_sucesso          => \"FFmpeg successfully installed to:\",\r\n    :ffmpeg_falhou           => \"Failed:\",\r\n    :ffmpeg_abrindo_nav      => \"Opening the link in browser...\",\r\n    :titulo                  => \"Virtual Tour\",\r\n    :subtitulo               => \"Timeline\",\r\n    :total                   => \"Total:\",\r\n    :visao                   => \"Vision\",\r\n    :play                    => \"Play\",\r\n    :stop                    => \"Stop\",\r\n    :play_all                => \"Play All\",\r\n    :stop_all                => \"Stop All\",\r\n    :atalho                  => \"Hotkey\",\r\n    :pressione               => \"Press a key...\",\r\n    :ok                      => \"Ok\",\r\n    :loop                    => \"Loop\",\r\n    :easing                  => \"Easing\",\r\n    :visoes_salvas           => \"Saved visions\",\r\n    :gerenciar_timeline      => \"Manage Timeline\",\r\n    :nova                    => \"New\",\r\n    :exportar_atual          => \"Export Current\",\r\n    :exportar_projeto        => \"Export Project\",\r\n    :importar                => \"Import\",\r\n    :exportar_video          => \"Export Video\",\r\n    :selecione_formato       => \"Select format…\",\r\n    :largura                 => \"Width\",\r\n    :altura                  => \"Height\",\r\n    :gravar_projeto          => \"Record entire project (all Timelines)\",\r\n    :iniciar_quadro1         => \"Start from frame 1\",\r\n    :iniciar_gravacao        => \"Start Recording\",\r\n    :gravando                => \"Recording...\",\r\n    :ffmpeg_necessario       => \"FFmpeg is required to record video.\",\r\n    :instalar_ffmpeg         => \"Install FFmpeg\",\r\n    :nome_arquivo            => \"File name\",\r\n    :extensao_mp4            => \"The .mp4 extension will be added automatically.\",\r\n    :cancelar                => \"Cancel\",\r\n    :salvar                  => \"Save\",\r\n    :viewport_atual          => \"Current viewport:\",\r\n    :paisagem                => \"Landscape\",\r\n    :retrato                 => \"Portrait\",\r\n    :quadrado                => \"Square\",\r\n    :classico                => \"Classic\",\r\n    :ultra_wide              => \"Ultra-wide\",\r\n    :viewport_inteira        => \"Full Viewport\",\r\n    :personalizado           => \"Custom\",\r\n    :nome_timeline           => \"Timeline name:\",\r\n    :nenhuma_visao           => \"No visions added.\",\r\n    :dica_visao              => \"Position the camera and click <b>+ Vision</b>.\",\r\n    :ancora                  => \"Anchor\",\r\n    :excluir                 => \"Delete\",\r\n    :min_duas_visoes         => \"Add at least two visions.\",\r\n    :sem_tl_2mais            => \"No Timeline with 2+ visions.\",\r\n    :sem_visoes_exportar     => \"No visions to export.\",\r\n    :sem_tl_exportar         => \"No Timeline to export.\",\r\n    :importada               => \"Imported\",\r\n    :formato_invalido        => \"Invalid format.\",\r\n    :erro_importar           => \"Import error: \",\r\n    :visoes                  => \"visions\",\r\n    :nova_timeline           => \"New Timeline name:\",\r\n    :area_gravacao           => \"Recording area: \",\r\n    :sem_tl_min_duas         => \"No Timeline with at least two visions.\",\r\n    :dims_invalidas          => \"Invalid dimensions (minimum 50 x 50 px).\",\r\n    :digite_nome             => \"Enter a file name.\",\r\n  },\r\n  'es' => {\r\n    :status_clicar_arrastar  => \"HAZ CLIC Y ARRASTRA para definir el área de grabación del video.\",\r\n    :area_pequena            => \"Área demasiado pequeña. Inténtalo de nuevo.\",\r\n    :selecionar_pasta        => \"Selecciona la carpeta para guardar\",\r\n    :ffmpeg_nao_encontrado   => \"FFmpeg no encontrado.\",\r\n    :erro_gravador           => \"Error al iniciar grabador: \",\r\n    :gravacao_finalizada     => \"¡Grabación finalizada!\\nGuardado en: \",\r\n    :ffmpeg_instalado        => \"FFmpeg instalado. Ejecuta Tour Virtual de nuevo.\",\r\n    :titulo_dialogo          => \"Tour Virtual\",\r\n    :ffmpeg_plugins_erro     => \"No se pudo resolver la carpeta Plugins automáticamente.\",\r\n    :ffmpeg_instalar_em      => \"Instalar FFmpeg en:\",\r\n    :ffmpeg_origem           => \"Origen:\",\r\n    :ffmpeg_continuar        => \"¿Continuar?\",\r\n    :ffmpeg_cancelada        => \"Instalación cancelada.\",\r\n    :ffmpeg_ja_existe        => \"Ya existe:\",\r\n    :ffmpeg_sobrescrever     => \"¿Sobrescribir?\",\r\n    :ffmpeg_falha_expand     => \"Error en Expand-Archive (PowerShell).\",\r\n    :ffmpeg_falha_unzip      => \"Error en unzip (macOS).\",\r\n    :ffmpeg_exe_nao_encontrado => \"Ejecutable FFmpeg no encontrado en el paquete descargado.\",\r\n    :ffmpeg_sucesso          => \"FFmpeg instalado con éxito en:\",\r\n    :ffmpeg_falhou           => \"Falló:\",\r\n    :ffmpeg_abrindo_nav      => \"Abriendo el enlace en el navegador...\",\r\n    :titulo                  => \"Tour Virtual\",\r\n    :subtitulo               => \"Línea de Tiempo\",\r\n    :total                   => \"Total:\",\r\n    :visao                   => \"Visión\",\r\n    :play                    => \"Play\",\r\n    :stop                    => \"Stop\",\r\n    :play_all                => \"Play All\",\r\n    :stop_all                => \"Stop All\",\r\n    :atalho                  => \"Atajo\",\r\n    :pressione               => \"Presiona...\",\r\n    :ok                      => \"Ok\",\r\n    :loop                    => \"Loop\",\r\n    :easing                  => \"Easing\",\r\n    :visoes_salvas           => \"Visiones guardadas\",\r\n    :gerenciar_timeline      => \"Gestionar Línea de Tiempo\",\r\n    :nova                    => \"Nueva\",\r\n    :exportar_atual          => \"Exportar Actual\",\r\n    :exportar_projeto        => \"Exportar Proyecto\",\r\n    :importar                => \"Importar\",\r\n    :exportar_video          => \"Exportar Video\",\r\n    :selecione_formato       => \"Selecciona el formato…\",\r\n    :largura                 => \"Ancho\",\r\n    :altura                  => \"Alto\",\r\n    :gravar_projeto          => \"Grabar todo el proyecto (todas las Líneas de Tiempo)\",\r\n    :iniciar_quadro1         => \"Iniciar desde el cuadro 1\",\r\n    :iniciar_gravacao        => \"Iniciar Grabación\",\r\n    :gravando                => \"Grabando...\",\r\n    :ffmpeg_necessario       => \"FFmpeg necesario para grabar video.\",\r\n    :instalar_ffmpeg         => \"Instalar FFmpeg\",\r\n    :nome_arquivo            => \"Nombre del archivo\",\r\n    :extensao_mp4            => \"La extensión .mp4 se añadirá automáticamente.\",\r\n    :cancelar                => \"Cancelar\",\r\n    :salvar                  => \"Guardar\",\r\n    :viewport_atual          => \"Viewport actual:\",\r\n    :paisagem                => \"Paisaje\",\r\n    :retrato                 => \"Retrato\",\r\n    :quadrado                => \"Cuadrado\",\r\n    :classico                => \"Clásico\",\r\n    :ultra_wide              => \"Ultra-wide\",\r\n    :viewport_inteira        => \"Viewport Completa\",\r\n    :personalizado           => \"Personalizado\",\r\n    :nome_timeline           => \"Nombre de la Línea de Tiempo:\",\r\n    :nenhuma_visao           => \"Ninguna visión añadida.\",\r\n    :dica_visao              => \"Posiciona la cámara y haz clic en <b>+ Visión</b>.\",\r\n    :ancora                  => \"Ancla\",\r\n    :excluir                 => \"Eliminar\",\r\n    :min_duas_visoes         => \"Añade al menos dos visiones.\",\r\n    :sem_tl_2mais            => \"Ninguna Línea de Tiempo con 2+ visiones.\",\r\n    :sem_visoes_exportar     => \"Ninguna visión para exportar.\",\r\n    :sem_tl_exportar         => \"Ninguna Línea de Tiempo para exportar.\",\r\n    :importada               => \"Importada\",\r\n    :formato_invalido        => \"Formato inválido.\",\r\n    :erro_importar           => \"Error al importar: \",\r\n    :visoes                  => \"visiones\",\r\n    :nova_timeline           => \"Nombre de la nueva Línea de Tiempo:\",\r\n    :area_gravacao           => \"Área de grabación: \",\r\n    :sem_tl_min_duas         => \"Ninguna Línea de Tiempo con al menos dos visiones.\",\r\n    :dims_invalidas          => \"Dimensiones inválidas (mínimo 50 x 50 px).\",\r\n    :digite_nome             => \"Escribe un nombre para el archivo.\",\r\n  },\r\n}\r\n\r\ndef self.obter_texto(chave)\r\n  locale = Sketchup.get_locale\r\n  lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n  IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\nend\r\n\r\n# --- Script de Instalação do FFmpeg (Mantido) ---\r\nFFMPEG_INSTALL_SCRIPT ||= <<~'RUBY'\r\n  require 'sketchup'\r\n  require 'open-uri'\r\n  require 'fileutils'\r\n  require 'tmpdir'\r\n\r\n  URL_WIN ||= 'https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-master-latest-win64-gpl.zip'\r\n  URL_MAC ||= 'https://evermeet.cx/ffmpeg/getrelease/zip'\r\n\r\n  win = Sketchup.platform == :platform_win\r\n  major = Sketchup.version.to_s[/^\\d+/].to_i\r\n  sketchup_year = 2000 + major\r\n\r\n  plugins_dir = Sketchup.find_support_file('Plugins')\r\n  if !plugins_dir || plugins_dir.empty? || !Dir.exist?(plugins_dir)\r\n    if win\r\n      base = ENV['APPDATA'].to_s\r\n      plugins_dir = File.join(base, 'SketchUp', \"SketchUp #{sketchup_year}\", 'SketchUp', 'Plugins')\r\n    else\r\n      plugins_dir = File.expand_path(\"~/Library/Application Support/SketchUp #{sketchup_year}/SketchUp/Plugins\")\r\n    end\r\n  end\r\n\r\n  target_dir = File.join(plugins_dir, 'ScriptUp', 'ffmpeg')\r\n  target_exe = File.join(target_dir, win ? 'ffmpeg.exe' : 'ffmpeg')\r\n  url = win ? URL_WIN : URL_MAC\r\n  default_zip_name = win ? 'ffmpeg-win64-gpl-latest.zip' : 'ffmpeg-macos-release.zip'\r\n\r\n  proceed = true\r\n\r\n  unless plugins_dir && !plugins_dir.empty?\r\n    UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_plugins_erro))\r\n    proceed = false\r\n  end\r\n\r\n  if proceed\r\n    msg = \"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_instalar_em)}\\n#{target_dir}\\n\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_origem)}\\n#{url}\\n\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_continuar)}\"\r\n    if UI.messagebox(msg, MB_YESNO) != IDYES\r\n      UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_cancelada))\r\n      proceed = false\r\n    end\r\n  end\r\n\r\n  if proceed && File.exist?(target_exe)\r\n    overwrite = UI.messagebox(\"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_ja_existe)}\\n#{target_exe}\\n\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_sobrescrever)}\", MB_YESNO)\r\n    if overwrite != IDYES\r\n      UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_cancelada))\r\n      proceed = false\r\n    end\r\n  end\r\n\r\n  if proceed\r\n    Dir.mktmpdir('ffmpeg_dl_') do |tmp|\r\n      zip_path = File.join(tmp, default_zip_name)\r\n      extract_dir = File.join(tmp, 'unzipped')\r\n      begin\r\n        URI.open(url, 'rb') do |io|\r\n          File.open(zip_path, 'wb') { |f| IO.copy_stream(io, f) }\r\n        end\r\n        Dir.mkdir(extract_dir)\r\n        if win\r\n          ps = 'powershell -NoProfile -ExecutionPolicy Bypass -Command'\r\n          cmd = \"#{ps} \\\"Expand-Archive -LiteralPath '#{zip_path}' -DestinationPath '#{extract_dir}' -Force\\\"\"\r\n          ok = system(cmd)\r\n          raise ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_falha_expand) unless ok\r\n        else\r\n          ok = system(\"unzip -o -q '#{zip_path}' -d '#{extract_dir}'\")\r\n          raise ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_falha_unzip) unless ok\r\n        end\r\n\r\n        pattern = win ? '**/ffmpeg.exe' : '**/ffmpeg'\r\n        bin = Dir.glob(File.join(extract_dir, pattern)).find { |p| File.file?(p) }\r\n        raise ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_exe_nao_encontrado) unless bin\r\n\r\n        FileUtils.mkdir_p(target_dir) unless Dir.exist?(target_dir)\r\n        FileUtils.cp(bin, target_exe)\r\n        unless win\r\n          FileUtils.chmod(0o755, target_exe)\r\n          system(\"xattr -d com.apple.quarantine '#{target_exe}' 2>/dev/null\")\r\n        end\r\n\r\n        UI.messagebox(\"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_sucesso)}\\n#{target_exe}\")\r\n        puts \"OK: #{target_exe}\"\r\n      rescue => e\r\n        UI.messagebox(\"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_falhou)} #{e.message}\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_abrindo_nav)}\")\r\n        UI.openURL(url)\r\n      end\r\n    end\r\n  end\r\nRUBY\r\n\r\n# --- Módulo WindowUtils ---\r\nmodule WindowUtils\r\n  extend Fiddle::Importer\r\n  dlload 'user32.dll' if Sketchup.platform == :platform_win\r\n\r\n  if Sketchup.platform == :platform_win\r\n    typealias 'HWND', 'void*'\r\n    extern 'HWND GetActiveWindow()'\r\n    extern 'HWND GetForegroundWindow()'\r\n    extern 'HWND GetWindow(HWND, int)'\r\n    extern 'int GetWindowRect(HWND, void*)'\r\n    extern 'HWND GetParent(HWND)'\r\n    \r\n    GW_CHILD = 5 unless defined?(GW_CHILD)\r\n    GW_HWNDNEXT = 2 unless defined?(GW_HWNDNEXT)\r\n    Rect = struct ['long left', 'long top', 'long right', 'long bottom'] unless defined?(Rect)\r\n  end\r\n\r\n  def self.get_viewport_rect_deep(view)\r\n    return nil unless Sketchup.platform == :platform_win\r\n    \r\n    hwnd = GetForegroundWindow()\r\n    return nil if hwnd.nil? || hwnd == 0\r\n\r\n    vw = view.vpwidth\r\n    vh = view.vpheight\r\n    \r\n    found = find_recursive(hwnd, vw, vh)\r\n    return found if found\r\n\r\n    parent = GetParent(hwnd)\r\n    if parent && parent != 0\r\n      found = find_recursive(parent, vw, vh)\r\n      return found if found\r\n    end\r\n\r\n    nil\r\n  end\r\n\r\n  def self.find_recursive(parent_hwnd, target_w, target_h)\r\n    child = GetWindow(parent_hwnd, GW_CHILD)\r\n    while child && child.to_i != 0\r\n      rect = Rect.malloc\r\n      if GetWindowRect(child, rect) != 0\r\n        w = rect.right - rect.left\r\n        h = rect.bottom - rect.top\r\n        match = check_match(w, h, target_w, target_h, rect)\r\n        return match if match\r\n      end\r\n      found_in_child = find_recursive(child, target_w, target_h)\r\n      return found_in_child if found_in_child\r\n      child = GetWindow(child, GW_HWNDNEXT)\r\n    end\r\n    nil\r\n  end\r\n\r\n  def self.check_match(w, h, target_w, target_h, rect)\r\n    tol = 30\r\n    [1.0, 1.25, 1.5, 2.0].each do |scale|\r\n      if (w - target_w * scale).abs <= tol && (h - target_h * scale).abs <= tol\r\n        return { :x => rect.left, :y => rect.top, :w => w, :h => h, :scale => scale }\r\n      end\r\n    end\r\n    nil\r\n  end\r\nend\r\n\r\n# --- Módulo ScreenCapture (GDI32) ---\r\n# Captures the SketchUp viewport via Win32 GDI and produces a BMP thumbnail\r\n# encoded as Base64, suitable for embedding in an HTML <img> tag.\r\n#\r\n# Uses Fiddle::Importer (Ruby stdlib) to call gdi32.dll and user32.dll functions.\r\n# Also declares PrintWindow from user32.dll as a fallback for occluded windows.\r\n#\r\n# Fiddle type mapping reference (from fiddle/types.rb Win32Types):\r\n#   HANDLE / HDC / HWND / HBITMAP  ->  void*   (pointer-sized, correct for 32/64-bit)\r\n#   DWORD                          ->  unsigned long\r\n#   BOOL                           ->  int\r\n#   UINT                           ->  unsigned int\r\n#\r\n# The extern signatures below use 'void*' directly for all handle types\r\n# (HDC, HBITMAP, HGDIOBJ) so we do not need to include Fiddle::Win32Types\r\n# or add custom typealiases beyond what WindowUtils already defines.\r\nmodule ScreenCapture\r\n  extend Fiddle::Importer\r\n\r\n  if Sketchup.platform == :platform_win\r\n    dlload 'gdi32.dll', 'user32.dll'\r\n\r\n    # --- user32.dll functions ---\r\n    # HDC GetDC(HWND hWnd)\r\n    #   hWnd=NULL(0) returns DC for entire screen\r\n    extern 'void* GetDC(void*)'\r\n\r\n    # int ReleaseDC(HWND hWnd, HDC hDC)\r\n    extern 'int ReleaseDC(void*, void*)'\r\n\r\n    # BOOL PrintWindow(HWND hwnd, HDC hdcBlt, UINT nFlags)\r\n    #   Asks the window to paint itself into the given DC.\r\n    #   Works even when the window is partially occluded (unlike BitBlt from screen DC).\r\n    extern 'int PrintWindow(void*, void*, unsigned int)'\r\n\r\n    # --- gdi32.dll functions ---\r\n    # HDC CreateCompatibleDC(HDC hdc)\r\n    extern 'void* CreateCompatibleDC(void*)'\r\n\r\n    # HBITMAP CreateCompatibleBitmap(HDC hdc, int cx, int cy)\r\n    extern 'void* CreateCompatibleBitmap(void*, int, int)'\r\n\r\n    # HGDIOBJ SelectObject(HDC hdc, HGDIOBJ h)\r\n    extern 'void* SelectObject(void*, void*)'\r\n\r\n    # BOOL BitBlt(HDC hdc, int x, int y, int cx, int cy,\r\n    #             HDC hdcSrc, int x1, int y1, DWORD rop)\r\n    extern 'int BitBlt(void*, int, int, int, int, void*, int, int, unsigned long)'\r\n\r\n    # BOOL StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest,\r\n    #                 HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop)\r\n    extern 'int StretchBlt(void*, int, int, int, int, void*, int, int, int, int, unsigned long)'\r\n\r\n    # int SetStretchBltMode(HDC hdc, int mode)\r\n    extern 'int SetStretchBltMode(void*, int)'\r\n\r\n    # int GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines,\r\n    #               LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage)\r\n    #   lpvBits and lpbmi are both void* (raw pointers to caller-allocated buffers)\r\n    extern 'int GetDIBits(void*, void*, unsigned int, unsigned int, void*, void*, unsigned int)'\r\n\r\n    # BOOL DeleteDC(HDC hdc)\r\n    extern 'int DeleteDC(void*)'\r\n\r\n    # BOOL DeleteObject(HGDIOBJ ho)\r\n    extern 'int DeleteObject(void*)'\r\n\r\n    # --- Raster-operation and mode constants ---\r\n    SRCCOPY        = 0x00CC0020 unless defined?(SRCCOPY)\r\n    HALFTONE       = 4 unless defined?(HALFTONE)          # SetStretchBltMode mode for high-quality shrinking\r\n    DIB_RGB_COLORS = 0 unless defined?(DIB_RGB_COLORS)    # GetDIBits color table usage\r\n\r\n    # --- PrintWindow flags ---\r\n    PW_CLIENTONLY          = 0x00000001 unless defined?(PW_CLIENTONLY)          # capture client area only (no title bar)\r\n    PW_RENDERFULLCONTENT   = 0x00000002 unless defined?(PW_RENDERFULLCONTENT)  # Win 8.1+: captures DirectX/DWM content\r\n  end\r\n\r\n  # Build a 40-byte BITMAPINFOHEADER as a packed binary string.\r\n  #\r\n  # The BITMAPINFOHEADER struct layout (40 bytes total):\r\n  #   DWORD  biSize          (4 bytes, unsigned 32-bit LE)   = 40\r\n  #   LONG   biWidth         (4 bytes, signed   32-bit LE)\r\n  #   LONG   biHeight        (4 bytes, signed   32-bit LE)   negative = top-down DIB\r\n  #   WORD   biPlanes        (2 bytes, unsigned 16-bit LE)   = 1\r\n  #   WORD   biBitCount      (2 bytes, unsigned 16-bit LE)   = 24 for RGB\r\n  #   DWORD  biCompression   (4 bytes, unsigned 32-bit LE)   = 0 (BI_RGB)\r\n  #   DWORD  biSizeImage     (4 bytes, unsigned 32-bit LE)\r\n  #   LONG   biXPelsPerMeter (4 bytes, signed   32-bit LE)   = 0\r\n  #   LONG   biYPelsPerMeter (4 bytes, signed   32-bit LE)   = 0\r\n  #   DWORD  biClrUsed       (4 bytes, unsigned 32-bit LE)   = 0\r\n  #   DWORD  biClrImportant  (4 bytes, unsigned 32-bit LE)   = 0\r\n  #\r\n  # Pack template: 'L<' = uint32 LE, 'l<' = int32 LE, 'S<' = uint16 LE\r\n  # Combined: 'L< l< l< S< S< L< L< l< l< L< L<'  (spaces for clarity)\r\n  #\r\n  # Using negative biHeight produces a top-down DIB, which means:\r\n  #  - Row 0 in memory is the top row of the image\r\n  #  - No vertical flip is needed when writing the BMP file\r\n  #  - The BMP file header must also use the negative height to match\r\n  def self.pack_bitmapinfoheader(width, height, image_size)\r\n    [\r\n      40,           # biSize\r\n      width,        # biWidth\r\n      -height,      # biHeight (negative = top-down)\r\n      1,            # biPlanes\r\n      24,           # biBitCount (24-bit RGB)\r\n      0,            # biCompression (BI_RGB = uncompressed)\r\n      image_size,   # biSizeImage\r\n      0,            # biXPelsPerMeter\r\n      0,            # biYPelsPerMeter\r\n      0,            # biClrUsed\r\n      0             # biClrImportant\r\n    ].pack('L<l<l<S<S<L<L<l<l<L<L<')\r\n  end\r\n\r\n  # Build the 14-byte BMP file header (BITMAPFILEHEADER).\r\n  #\r\n  # Layout:\r\n  #   WORD   bfType      = 0x4D42 (\"BM\")\r\n  #   DWORD  bfSize      = total file size in bytes\r\n  #   WORD   bfReserved1 = 0\r\n  #   WORD   bfReserved2 = 0\r\n  #   DWORD  bfOffBits   = offset to pixel data = 14 + 40 = 54\r\n  #\r\n  # Pack template: 'S< L< S< S< L<'\r\n  def self.pack_bmp_file_header(pixel_data_size)\r\n    file_size = 14 + 40 + pixel_data_size\r\n    [\r\n      0x4D42,       # bfType (\"BM\")\r\n      file_size,    # bfSize\r\n      0,            # bfReserved1\r\n      0,            # bfReserved2\r\n      54            # bfOffBits (14-byte file header + 40-byte info header)\r\n    ].pack('S<L<S<S<L<')\r\n  end\r\n\r\n  # Capture the SketchUp viewport as a scaled-down BMP thumbnail and return\r\n  # a Base64-encoded string. Returns nil on failure (non-Windows, HWND not found, etc.).\r\n  #\r\n  # Strategy:\r\n  #   1. StretchBlt from screen DC (fast, works when viewport is visible)\r\n  #   2. If vp[:hwnd] is available, PrintWindow can be used as alternative\r\n  #\r\n  # Parameters:\r\n  #   view     - Sketchup::View instance\r\n  #   thumb_w  - desired thumbnail width  in pixels (default 96)\r\n  #   thumb_h  - desired thumbnail height in pixels (default 60)\r\n  #\r\n  # Returns: Base64-encoded BMP string, or nil on failure.\r\n  def self.capture_viewport(view, thumb_w = 96, thumb_h = 60)\r\n    return nil unless Sketchup.platform == :platform_win\r\n\r\n    vp = WindowUtils.get_viewport_rect_deep(view)\r\n    return nil unless vp\r\n\r\n    src_w = vp[:w]\r\n    src_h = vp[:h]\r\n\r\n    # Get screen DC -- needed for CreateCompatibleBitmap color depth\r\n    screen_dc = GetDC(0)\r\n    return nil if screen_dc.nil? || screen_dc.to_i == 0\r\n\r\n    begin\r\n      # Create a memory DC compatible with the screen\r\n      mem_dc = CreateCompatibleDC(screen_dc)\r\n      return nil if mem_dc.nil? || mem_dc.to_i == 0\r\n\r\n      begin\r\n        # Create a bitmap at the desired thumbnail size\r\n        bmp = CreateCompatibleBitmap(screen_dc, thumb_w, thumb_h)\r\n        return nil if bmp.nil? || bmp.to_i == 0\r\n\r\n        begin\r\n          old = SelectObject(mem_dc, bmp)\r\n          SetStretchBltMode(mem_dc, HALFTONE)\r\n\r\n          # StretchBlt from the screen DC directly into the thumbnail-sized bitmap.\r\n          # This both captures AND scales in a single operation.\r\n          ok = StretchBlt(\r\n            mem_dc, 0, 0, thumb_w, thumb_h,\r\n            screen_dc, vp[:x], vp[:y], src_w, src_h,\r\n            SRCCOPY\r\n          )\r\n          return nil if ok == 0\r\n\r\n          # IMPORTANT: Deselect the bitmap from the DC before calling GetDIBits.\r\n          # Per MSDN: \"The bitmap identified by hbmp must not be selected into\r\n          # a device context when the application calls this function.\"\r\n          SelectObject(mem_dc, old)\r\n          old = nil\r\n\r\n          # Calculate row stride (BMP rows must be padded to 4-byte boundaries)\r\n          stride     = ((thumb_w * 3 + 3) & ~3)\r\n          pixel_size = stride * thumb_h\r\n\r\n          # Pack the BITMAPINFOHEADER into a Fiddle::Pointer buffer.\r\n          # GetDIBits may modify the header (e.g., filling in biSizeImage),\r\n          # so we use a mutable native buffer rather than a Ruby String.\r\n          bmi_bytes = pack_bitmapinfoheader(thumb_w, thumb_h, pixel_size)\r\n          bmi_ptr   = Fiddle::Pointer.malloc(bmi_bytes.bytesize)\r\n          bmi_ptr[0, bmi_bytes.bytesize] = bmi_bytes\r\n\r\n          # Allocate the pixel data buffer\r\n          buf = Fiddle::Pointer.malloc(pixel_size)\r\n\r\n          begin\r\n            # GetDIBits(hdc, hbm, start, cLines, lpvBits, lpbmi, usage)\r\n            # hdc: a DC compatible with the bitmap (mem_dc works)\r\n            # hbm: the bitmap handle (NOT selected into any DC)\r\n            rows = GetDIBits(mem_dc, bmp, 0, thumb_h, buf, bmi_ptr, DIB_RGB_COLORS)\r\n            return nil if rows == 0\r\n\r\n            # Read the raw pixel bytes from the Fiddle::Pointer buffer.\r\n            # ptr[offset, length] returns a Ruby String (binary safe, works since Ruby 2.0).\r\n            pixel_data = buf[0, pixel_size]\r\n\r\n            # Assemble the complete BMP file: file header + info header + pixel data\r\n            file_hdr = pack_bmp_file_header(pixel_size)\r\n            info_hdr = pack_bitmapinfoheader(thumb_w, thumb_h, pixel_size)\r\n\r\n            Base64.strict_encode64(file_hdr + info_hdr + pixel_data)\r\n          ensure\r\n            Fiddle.free(bmi_ptr) if bmi_ptr\r\n            Fiddle.free(buf)     if buf\r\n          end\r\n        ensure\r\n          SelectObject(mem_dc, old) if old\r\n          DeleteObject(bmp)\r\n        end\r\n      ensure\r\n        DeleteDC(mem_dc)\r\n      end\r\n    ensure\r\n      ReleaseDC(0, screen_dc)\r\n    end\r\n  rescue => e\r\n    puts \"ScreenCapture error: #{e.message}\"\r\n    puts e.backtrace.first(5).join(\"\\n\")\r\n    nil\r\n  end\r\nend\r\n\r\nmodule TourPlugin\r\n  class AreaSelectorTool\r\n    def initialize(callback)\r\n      @callback = callback\r\n      @start_x = nil; @start_y = nil; @current_x = nil; @current_y = nil\r\n      @drawing = false\r\n    end\r\n\r\n    def activate\r\n      Sketchup.active_model.active_view.invalidate\r\n      Sketchup.status_text = ScriptUpComunidade::TourVirtual.obter_texto(:status_clicar_arrastar)\r\n    end\r\n\r\n    def onLButtonDown(flags, x, y, view)\r\n      @start_x = x; @start_y = y; @current_x = x; @current_y = y\r\n      @drawing = true\r\n    end\r\n\r\n    def onMouseMove(flags, x, y, view)\r\n      if @drawing\r\n        @current_x = x; @current_y = y\r\n        view.invalidate\r\n      end\r\n    end\r\n\r\n    def onLButtonUp(flags, x, y, view)\r\n      return unless @drawing\r\n      @drawing = false\r\n      x1 = [@start_x, @current_x].min\r\n      y1 = [@start_y, @current_y].min\r\n      x2 = [@start_x, @current_x].max\r\n      y2 = [@start_y, @current_y].max\r\n      width = x2 - x1\r\n      height = y2 - y1\r\n\r\n      if width < 50 || height < 50\r\n        UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:area_pequena))\r\n        Sketchup.active_model.select_tool(nil)\r\n        return\r\n      end\r\n\r\n      @callback.call({ :x => x1, :y => y1, :w => width, :h => height })\r\n      Sketchup.active_model.select_tool(nil) \r\n    end\r\n\r\n    def draw(view)\r\n      return unless @drawing && @start_x && @current_x\r\n      points = [\r\n        Geom::Point3d.new(@start_x, @start_y, 0),\r\n        Geom::Point3d.new(@current_x, @start_y, 0),\r\n        Geom::Point3d.new(@current_x, @current_y, 0),\r\n        Geom::Point3d.new(@start_x, @current_y, 0)\r\n      ]\r\n      view.line_width = 3\r\n      view.drawing_color = 'red'\r\n      view.draw2d(GL_LINE_LOOP, points)\r\n    end\r\n  end\r\n\r\n  class ExportPreviewTool\r\n    def initialize(target_w, target_h)\r\n      @target_w = target_w\r\n      @target_h = target_h\r\n    end\r\n\r\n    def activate\r\n      Sketchup.active_model.active_view.invalidate\r\n    end\r\n\r\n    def deactivate(view)\r\n      view.invalidate\r\n    end\r\n\r\n    def draw(view)\r\n      vw = view.vpwidth\r\n      vh = view.vpheight\r\n      ew = [@target_w, vw].min\r\n      eh = [@target_h, vh].min\r\n      ox = (vw - ew) / 2\r\n      oy = (vh - eh) / 2\r\n\r\n      # Escurecer áreas fora da gravação (letterbox/pillarbox)\r\n      view.drawing_color = Sketchup::Color.new(0, 0, 0, 120)\r\n      if oy > 0\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(0, 0, 0), Geom::Point3d.new(vw, 0, 0),\r\n          Geom::Point3d.new(vw, oy, 0), Geom::Point3d.new(0, oy, 0)\r\n        ])\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(0, oy + eh, 0), Geom::Point3d.new(vw, oy + eh, 0),\r\n          Geom::Point3d.new(vw, vh, 0), Geom::Point3d.new(0, vh, 0)\r\n        ])\r\n      end\r\n      if ox > 0\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(0, oy, 0), Geom::Point3d.new(ox, oy, 0),\r\n          Geom::Point3d.new(ox, oy + eh, 0), Geom::Point3d.new(0, oy + eh, 0)\r\n        ])\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(ox + ew, oy, 0), Geom::Point3d.new(vw, oy, 0),\r\n          Geom::Point3d.new(vw, oy + eh, 0), Geom::Point3d.new(ox + ew, oy + eh, 0)\r\n        ])\r\n      end\r\n\r\n      # Borda branca ao redor da área de gravação\r\n      view.line_width = 2\r\n      view.drawing_color = Sketchup::Color.new(255, 255, 255, 200)\r\n      view.draw2d(GL_LINE_LOOP, [\r\n        Geom::Point3d.new(ox, oy, 0), Geom::Point3d.new(ox + ew, oy, 0),\r\n        Geom::Point3d.new(ox + ew, oy + eh, 0), Geom::Point3d.new(ox, oy + eh, 0)\r\n      ])\r\n    end\r\n  end\r\n\r\n  module CameraTimeline\r\n    def self.obter_texto(chave)\r\n      ScriptUpComunidade::TourVirtual.obter_texto(chave)\r\n    end\r\n\r\n    module GlobalKey\r\n      extend Fiddle::Importer\r\n      if Sketchup.platform == :platform_win\r\n        dlload 'user32.dll'\r\n        extern 'short GetAsyncKeyState(int)'\r\n      else\r\n        dlload '/System/Library/Frameworks/ApplicationServices.framework/ApplicationServices'\r\n        extern 'bool CGEventSourceKeyState(int, int)'\r\n      end\r\n\r\n      DEFAULT_HOTKEY = (Sketchup.platform == :platform_win ? 0x6B : 69) unless defined?(DEFAULT_HOTKEY)\r\n      @key_code = Sketchup.read_default(\"TourVirtual\", \"Hotkey\", DEFAULT_HOTKEY).to_i\r\n      @ctrl = Sketchup.read_default(\"TourVirtual\", \"HotkeyCtrl\", false)\r\n      @alt = Sketchup.read_default(\"TourVirtual\", \"HotkeyAlt\", false)\r\n      @shift = Sketchup.read_default(\"TourVirtual\", \"HotkeyShift\", false)\r\n\r\n      # Windows virtual key codes for modifiers\r\n      VK_CONTROL = 0x11 unless defined?(VK_CONTROL)\r\n      VK_MENU    = 0x12 unless defined?(VK_MENU)\r\n      VK_SHIFT   = 0x10 unless defined?(VK_SHIFT)\r\n      # macOS key codes for modifiers\r\n      MAC_CTRL  = 59 unless defined?(MAC_CTRL)\r\n      MAC_SHIFT = 56 unless defined?(MAC_SHIFT)\r\n      MAC_ALT   = 58 unless defined?(MAC_ALT)\r\n\r\n      def self.set_hotkey(code, ctrl, alt, shift)\r\n        @key_code = code.to_i\r\n        @ctrl = ctrl\r\n        @alt = alt\r\n        @shift = shift\r\n      end\r\n\r\n      def self.key_code; @key_code; end\r\n      def self.ctrl; @ctrl; end\r\n      def self.alt; @alt; end\r\n      def self.shift; @shift; end\r\n\r\n      def self.key_pressed?(code)\r\n        if Sketchup.platform == :platform_win\r\n          GetAsyncKeyState(code) & 0x8000 != 0\r\n        else\r\n          CGEventSourceKeyState(0, code)\r\n        end\r\n      end\r\n\r\n      def self.space_pressed?\r\n        return false unless key_pressed?(@key_code)\r\n        if Sketchup.platform == :platform_win\r\n          return false if @ctrl && !key_pressed?(VK_CONTROL)\r\n          return false if @alt && !key_pressed?(VK_MENU)\r\n          return false if @shift && !key_pressed?(VK_SHIFT)\r\n        else\r\n          return false if @ctrl && !key_pressed?(MAC_CTRL)\r\n          return false if @alt && !key_pressed?(MAC_ALT)\r\n          return false if @shift && !key_pressed?(MAC_SHIFT)\r\n        end\r\n        true\r\n      end\r\n    end\r\n\r\n    def self.start_space_timer\r\n      return if defined?(@space_timer) && @space_timer\r\n      @space_down = false\r\n      @space_timer = UI.start_timer(0.1, true) do\r\n        if GlobalKey.space_pressed?\r\n          unless @space_down\r\n            @space_down = true\r\n            @dialog.execute_script('triggerSpaceFromRuby()')\r\n          end\r\n        else\r\n          @space_down = false\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.stop_space_timer\r\n      if defined?(@space_timer) && @space_timer\r\n        UI.stop_timer(@space_timer)\r\n        @space_timer = nil\r\n      end\r\n    end\r\n\r\n    def self.capture_thumbnail\r\n      view = Sketchup.active_model.active_view\r\n      # Tentar screen capture instantâneo via GDI32 (Windows)\r\n      result = ScreenCapture.capture_viewport(view, 96, 60) rescue nil\r\n      return result if result && result.length > 0\r\n      # Fallback: write_image (lento, mas funciona em qualquer plataforma)\r\n      path = File.join(Dir.tmpdir, \"thumb_#{Time.now.to_i}.jpg\")\r\n      view.write_image(path, 96, 60, false, 0.5)\r\n      encoded = Base64.strict_encode64(File.binread(path))\r\n      File.delete(path) if File.exist?(path)\r\n      encoded\r\n    end\r\n\r\n    # --- Lógica de Exportação ---\r\n    def self.calcular_rect_gravacao(export_width, export_height)\r\n      view = Sketchup.active_model.active_view\r\n      viewport_global = WindowUtils.get_viewport_rect_deep(view)\r\n\r\n      unless viewport_global\r\n        viewport_global = { :x => 0, :y => 0, :w => view.vpwidth, :h => view.vpheight, :scale => 1.0 }\r\n      end\r\n\r\n      vp_w = viewport_global[:w]\r\n      vp_h = viewport_global[:h]\r\n\r\n      final_w = [export_width.to_i, vp_w].min\r\n      final_h = [export_height.to_i, vp_h].min\r\n\r\n      offset_x = viewport_global[:x] + ((vp_w - final_w) / 2).to_i\r\n      offset_y = viewport_global[:y] + ((vp_h - final_h) / 2).to_i\r\n\r\n      final_w -= 1 if final_w.odd?\r\n      final_h -= 1 if final_h.odd?\r\n\r\n      { :x => offset_x, :y => offset_y, :w => final_w, :h => final_h }\r\n    end\r\n\r\n    def self.iniciar_processo_exportacao(json_data, use_easing, start_index_from_js, export_width, export_height, filename)\r\n      effective_index = start_index_from_js.to_i\r\n\r\n      if effective_index == 0\r\n        @dialog.execute_script(\"currentIndex = 0; updateTime(0); sketchup.goto_camera(JSON.stringify(visoes[0]));\")\r\n        sleep(0.5)\r\n      end\r\n\r\n      rect = calcular_rect_gravacao(export_width, export_height)\r\n      executar_gravacao_ffmpeg(json_data, use_easing, rect, effective_index, filename)\r\n    end\r\n\r\n    def self.iniciar_processo_exportacao_projeto(all_timelines_json, use_easing, active_tl_index, start_vision_index, export_width, export_height, filename)\r\n      timelines = JSON.parse(all_timelines_json, symbolize_names: true)\r\n      rect = calcular_rect_gravacao(export_width, export_height)\r\n\r\n      start_tl = active_tl_index.to_i\r\n      start_vision = start_vision_index.to_i\r\n\r\n      # Calcular duração total a partir do ponto de início\r\n      total_time = 0.0\r\n      timelines.each_with_index do |tl, i|\r\n        next if i < start_tl\r\n        next unless tl[:visoes] && tl[:visoes].length >= 2\r\n        sorted = tl[:visoes].sort_by { |v| v[:time] }\r\n        first_v = (i == start_tl && start_vision > 0 && start_vision < sorted.length) ? start_vision : 0\r\n        if first_v < sorted.length - 1\r\n          total_time += sorted.last[:time] - sorted[first_v][:time]\r\n          total_time += 0.5\r\n        end\r\n      end\r\n\r\n      play_cmd = \"startRecordingPlayAll(#{start_tl}, #{start_vision})\"\r\n      executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, play_cmd)\r\n    end\r\n\r\n    def self.executar_gravacao_ffmpeg(json_data, use_easing, rect, start_index, filename)\r\n      camera_keys = JSON.parse(json_data, symbolize_names: true)\r\n      camera_keys.sort_by! { |v| v[:time] }\r\n\r\n      total_time = 0\r\n      if start_index < camera_keys.length - 1\r\n        relevant_keys = camera_keys[start_index..-1]\r\n        relevant_keys.each_cons(2) { |c, n| total_time += (n[:time] - c[:time]).abs }\r\n      end\r\n\r\n      executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, \"triggerSpaceFromRuby()\")\r\n    end\r\n\r\n    def self.executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, play_command)\r\n      folder = UI.select_directory(title: obter_texto(:selecionar_pasta))\r\n      return unless folder\r\n\r\n      output_path = File.join(folder, \"#{filename}.mp4\")\r\n\r\n      is_win = Sketchup.platform == :platform_win\r\n      ffmpeg_path = File.join(PLUGIN_DIR, 'ffmpeg', is_win ? 'ffmpeg.exe' : 'ffmpeg')\r\n\r\n      unless File.exist?(ffmpeg_path)\r\n        UI.messagebox(obter_texto(:ffmpeg_nao_encontrado))\r\n        return\r\n      end\r\n\r\n      duration_padding = 4.0\r\n      recording_duration = total_time + duration_padding\r\n\r\n      input_format = is_win ? 'gdigrab' : 'avfoundation'\r\n      input_source = is_win ? 'desktop' : '1:none'\r\n\r\n      cmd_array = [\r\n        \"\\\"#{ffmpeg_path}\\\"\",\r\n        '-y',\r\n        '-f', input_format,\r\n        '-framerate', '30',\r\n        '-t', recording_duration.to_s\r\n      ]\r\n\r\n      if is_win\r\n        cmd_array.concat([\r\n          '-draw_mouse', '0',\r\n          '-offset_x', rect[:x].to_s,\r\n          '-offset_y', rect[:y].to_s,\r\n          '-video_size', \"#{rect[:w]}x#{rect[:h]}\",\r\n          '-i', input_source\r\n        ])\r\n      else\r\n        cmd_array.concat([\r\n          '-i', input_source,\r\n          '-vf', \"crop=#{rect[:w]}:#{rect[:h]}:#{rect[:x]}:#{rect[:y]}\"\r\n        ])\r\n      end\r\n\r\n      cmd_array.concat([\r\n        '-c:v', 'libx264',\r\n        '-preset', 'ultrafast',\r\n        '-pix_fmt', 'yuv420p',\r\n        \"\\\"#{output_path}\\\"\"\r\n      ])\r\n\r\n      cmd = cmd_array.join(' ')\r\n\r\n      begin\r\n        if is_win\r\n           WIN32OLE.new('WScript.Shell').Run(cmd, 0, false)\r\n        else\r\n           pid = spawn(cmd)\r\n           Process.detach(pid)\r\n        end\r\n      rescue => e\r\n        UI.messagebox(\"#{obter_texto(:erro_gravador)}#{e.message}\")\r\n        return\r\n      end\r\n\r\n      sleep(1.5)\r\n\r\n      @dialog.execute_script(\"showRecordingIndicator()\")\r\n      @dialog.execute_script(play_command)\r\n\r\n      UI.start_timer(recording_duration + 1.0, false) do\r\n        @dialog.execute_script(\"hideRecordingIndicator()\")\r\n        UI.messagebox(\"#{obter_texto(:gravacao_finalizada)}#{output_path}\")\r\n        @dialog.execute_script(\"resetPlayButton(); resetPlayAll();\")\r\n      end\r\n    end\r\n\r\n    def self.start_ui\r\n      current_hotkey = GlobalKey.key_code\r\n      hotkey_ctrl = GlobalKey.ctrl ? 'true' : 'false'\r\n      hotkey_alt = GlobalKey.alt ? 'true' : 'false'\r\n      hotkey_shift = GlobalKey.shift ? 'true' : 'false'\r\n      ffmpeg_path = File.join(PLUGIN_DIR, 'ffmpeg', Sketchup.platform == :platform_win ? 'ffmpeg.exe' : 'ffmpeg')\r\n      \r\n      has_ffmpeg = File.exist?(ffmpeg_path)\r\n\r\n      view = Sketchup.active_model.active_view\r\n      vp_width = view.vpwidth\r\n      vp_height = view.vpheight\r\n\r\n      js_i18n_hash = {}\r\n      IDIOMAS[IDIOMAS.key?(Sketchup.get_locale) ? Sketchup.get_locale : 'en-US'].each { |k, v| js_i18n_hash[k] = v }\r\n      js_i18n_json = js_i18n_hash.to_json\r\n\r\n      html = <<-HTML\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n  <meta charset=\"utf-8\">\r\n  <title>#{obter_texto(:titulo)}</title>\r\n  <style>\r\n    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }\r\n    body {\r\n      font-family: system-ui, -apple-system, 'Segoe UI', sans-serif;\r\n      background: #f5f5f5; color: #333; font-size: 13px;\r\n      padding: 16px; line-height: 1.4;\r\n    }\r\n\r\n    /* Header */\r\n    .header {\r\n      display: flex; align-items: center; gap: 10px;\r\n      padding-bottom: 14px; border-bottom: 2px solid #0066cc;\r\n      margin-bottom: 16px;\r\n    }\r\n    .header svg { flex-shrink: 0; }\r\n    .header h1 { font-size: 17px; font-weight: 700; color: #1a1a1a; }\r\n    .header .subtitle { font-size: 11px; color: #888; font-weight: 400; }\r\n\r\n    /* Cards */\r\n    .card {\r\n      background: #fff; border: 1px solid #e0e0e0; border-radius: 8px;\r\n      box-shadow: 0 1px 3px rgba(0,0,0,0.06); margin-bottom: 12px;\r\n      overflow: hidden;\r\n    }\r\n    .card-header {\r\n      display: flex; align-items: center; justify-content: space-between;\r\n      padding: 10px 14px; background: #fafafa; border-bottom: 1px solid #eee;\r\n      cursor: pointer; user-select: none;\r\n    }\r\n    .card-header h2 { font-size: 13px; font-weight: 600; color: #444; }\r\n    .card-header .toggle-icon { font-size: 11px; color: #999; transition: transform 0.2s; }\r\n    .card-header.collapsed .toggle-icon { transform: rotate(-90deg); }\r\n    .card-body { padding: 14px; }\r\n    .card-body.collapsed { display: none; }\r\n\r\n    /* Timeline */\r\n    .timeline-wrapper { position: relative; padding: 8px 0 20px; }\r\n    .timeline-track {\r\n      position: absolute; top: 20px; left: 6px; right: 6px; height: 4px;\r\n      background: #ddd; border-radius: 2px; z-index: 0;\r\n    }\r\n    #timeline_range {\r\n      -webkit-appearance: none; appearance: none; width: 100%;\r\n      height: 6px; background: transparent; outline: none;\r\n      position: relative; z-index: 2; cursor: pointer;\r\n    }\r\n    #timeline_range::-webkit-slider-runnable-track {\r\n      height: 6px; background: linear-gradient(90deg, #0066cc 0%, #4da6ff 100%);\r\n      border-radius: 3px;\r\n    }\r\n    #timeline_range::-webkit-slider-thumb {\r\n      -webkit-appearance: none; width: 16px; height: 16px;\r\n      background: #0066cc; border: 2px solid #fff; border-radius: 50%;\r\n      margin-top: -5px; cursor: grab; box-shadow: 0 1px 4px rgba(0,0,0,0.2);\r\n    }\r\n    #timeline_range::-webkit-slider-thumb:active { cursor: grabbing; transform: scale(1.15); }\r\n    #markers_layer {\r\n      position: absolute; top: 0; left: 0; width: 100%; height: 40px;\r\n      pointer-events: none; z-index: 3;\r\n    }\r\n    .marker {\r\n      position: absolute; top: 26px; width: 14px; height: 14px;\r\n      background: #0066cc; border-radius: 50%; border: 2px solid #fff;\r\n      transform: translateX(-50%); pointer-events: auto; cursor: pointer;\r\n      box-shadow: 0 1px 3px rgba(0,0,0,0.15); transition: transform 0.15s, background 0.15s;\r\n    }\r\n    .marker:hover { transform: translateX(-50%) scale(1.25); }\r\n    .marker.anchor { background: #dc3545; }\r\n    .marker .marker-tooltip {\r\n      position: absolute; bottom: 18px; left: 50%; transform: translateX(-50%);\r\n      background: #333; color: #fff; font-size: 10px; padding: 2px 6px;\r\n      border-radius: 3px; white-space: nowrap; opacity: 0;\r\n      pointer-events: none; transition: opacity 0.15s;\r\n    }\r\n    .marker:hover .marker-tooltip { opacity: 1; }\r\n    .time-row {\r\n      display: flex; align-items: center; justify-content: space-between;\r\n      margin-top: 8px; gap: 12px;\r\n    }\r\n    .time-display { font-size: 20px; font-weight: 700; color: #0066cc; font-variant-numeric: tabular-nums; }\r\n    .time-display small { font-size: 12px; color: #888; font-weight: 400; }\r\n    .time-input-group { display: flex; align-items: center; gap: 6px; }\r\n    .time-input-group label { font-size: 11px; color: #666; }\r\n\r\n    /* Buttons */\r\n    .btn {\r\n      display: inline-flex; align-items: center; justify-content: center; gap: 6px;\r\n      padding: 7px 14px; border: 1px solid transparent; border-radius: 6px;\r\n      font-size: 12px; font-weight: 500; cursor: pointer;\r\n      transition: all 0.15s; outline: none; font-family: inherit;\r\n    }\r\n    .btn:active { transform: scale(0.97); }\r\n    .btn-primary { background: #0066cc; color: #fff; }\r\n    .btn-primary:hover { background: #0052a3; }\r\n    .btn-success { background: #28a745; color: #fff; }\r\n    .btn-success:hover { background: #218838; }\r\n    .btn-danger { background: #dc3545; color: #fff; }\r\n    .btn-danger:hover { background: #c82333; }\r\n    .btn-outline { background: transparent; border: 1px solid #ccc; color: #555; }\r\n    .btn-outline:hover { background: #f0f0f0; border-color: #aaa; }\r\n    .btn-sm { padding: 4px 10px; font-size: 11px; }\r\n    .btn-record { background: #dc3545; color: #fff; padding: 10px 20px; font-size: 13px; font-weight: 600; }\r\n    .btn-record:hover { background: #c82333; }\r\n    .btn-record:disabled { background: #ccc; color: #888; cursor: not-allowed; }\r\n\r\n    .btn-group { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }\r\n\r\n    /* Checkboxes */\r\n    .check-group { display: flex; align-items: center; gap: 16px; margin-top: 10px; }\r\n    .check-item { display: flex; align-items: center; gap: 5px; }\r\n    .check-item input[type=\"checkbox\"] {\r\n      width: 15px; height: 15px; accent-color: #0066cc; cursor: pointer;\r\n    }\r\n    .check-item label { font-size: 12px; color: #555; cursor: pointer; }\r\n\r\n    /* Hotkey */\r\n    .hotkey-editor {\r\n      display: none; align-items: center; gap: 6px;\r\n      background: #f9f9f9; padding: 6px 10px; border-radius: 6px; border: 1px solid #ddd;\r\n    }\r\n    .hotkey-editor.visible { display: inline-flex; }\r\n    .hotkey-editor input {\r\n      width: 100px; padding: 4px 8px; border: 1px solid #ccc;\r\n      border-radius: 4px; font-size: 12px; font-family: monospace;\r\n      outline: none;\r\n    }\r\n    .hotkey-editor input:focus { border-color: #0066cc; }\r\n\r\n    /* Vision List */\r\n    .vision-list { max-height: 350px; overflow-y: auto; }\r\n    .vision-list::-webkit-scrollbar { width: 6px; }\r\n    .vision-list::-webkit-scrollbar-track { background: #f0f0f0; border-radius: 3px; }\r\n    .vision-list::-webkit-scrollbar-thumb { background: #ccc; border-radius: 3px; }\r\n    .vision-list::-webkit-scrollbar-thumb:hover { background: #aaa; }\r\n    .vision-item {\r\n      display: flex; align-items: center; gap: 10px; padding: 8px 10px;\r\n      border-bottom: 1px solid #f0f0f0; cursor: pointer;\r\n      transition: background 0.12s;\r\n    }\r\n    .vision-item:hover { background: #f7faff; }\r\n    .vision-item:last-child { border-bottom: none; }\r\n    .vision-item .vision-num {\r\n      font-size: 11px; font-weight: 700; color: #999; width: 20px;\r\n      text-align: center; flex-shrink: 0;\r\n    }\r\n    .vision-item img {\r\n      width: 72px; height: 45px; object-fit: cover; border-radius: 4px;\r\n      border: 1px solid #ddd; flex-shrink: 0;\r\n    }\r\n    .vision-item img.thumb-placeholder {\r\n      background: linear-gradient(135deg, #e0e0e0 0%, #c0c0c0 100%);\r\n      animation: pulse-placeholder 1s ease-in-out infinite alternate;\r\n    }\r\n    @keyframes pulse-placeholder {\r\n      from { opacity: 0.6; }\r\n      to { opacity: 1.0; }\r\n    }\r\n    .vision-item .vision-info { flex: 1; min-width: 0; }\r\n    .vision-item .vision-time-input {\r\n      width: 58px; padding: 3px 6px; border: 1px solid #ddd; border-radius: 4px;\r\n      font-size: 12px; text-align: center; outline: none; font-family: inherit;\r\n    }\r\n    .vision-item .vision-time-input:focus { border-color: #0066cc; }\r\n    .vision-item .vision-time-input:disabled { background: #f5f5f5; color: #999; }\r\n    .vision-actions { display: flex; align-items: center; gap: 6px; flex-shrink: 0; }\r\n    .anchor-toggle {\r\n      width: 26px; height: 26px; border-radius: 50%; border: 2px solid #ddd;\r\n      background: transparent; cursor: pointer; display: flex;\r\n      align-items: center; justify-content: center; transition: all 0.15s;\r\n      font-size: 12px; color: #ccc;\r\n    }\r\n    .anchor-toggle:hover { border-color: #dc3545; color: #dc3545; }\r\n    .anchor-toggle.active { background: #dc3545; border-color: #dc3545; color: #fff; }\r\n    .delete-btn {\r\n      width: 26px; height: 26px; border-radius: 50%; border: 1px solid #eee;\r\n      background: transparent; cursor: pointer; display: flex;\r\n      align-items: center; justify-content: center; transition: all 0.15s;\r\n      font-size: 14px; color: #ccc;\r\n    }\r\n    .delete-btn:hover { background: #fee; border-color: #dc3545; color: #dc3545; }\r\n    .empty-state {\r\n      text-align: center; padding: 30px 16px; color: #aaa;\r\n    }\r\n    .empty-state svg { margin-bottom: 8px; opacity: 0.4; }\r\n    .empty-state p { font-size: 12px; }\r\n\r\n    /* Export Section */\r\n    .preset-select {\r\n      width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px;\r\n      font-size: 12px; font-family: inherit; outline: none; background: #fff;\r\n      cursor: pointer; color: #333;\r\n    }\r\n    .preset-select:focus { border-color: #0066cc; }\r\n    .preset-preview {\r\n      display: flex; align-items: center; justify-content: center;\r\n      padding: 8px; margin-top: 8px; background: #f7faff;\r\n      border: 1px dashed #b3d4fc; border-radius: 6px;\r\n      font-size: 12px; color: #0066cc; font-weight: 600;\r\n    }\r\n    .custom-dims {\r\n      display: none; gap: 8px; align-items: center; margin-top: 8px;\r\n    }\r\n    .custom-dims.visible { display: flex; }\r\n    .custom-dims input {\r\n      width: 80px; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px;\r\n      font-size: 12px; text-align: center; outline: none; font-family: inherit;\r\n    }\r\n    .custom-dims input:focus { border-color: #0066cc; }\r\n    .custom-dims span { color: #999; font-weight: 600; }\r\n\r\n    /* Recording indicator */\r\n    .recording-bar {\r\n      display: none; align-items: center; gap: 8px; padding: 10px 14px;\r\n      background: #fff5f5; border: 1px solid #f5c6cb; border-radius: 6px;\r\n      margin-top: 10px;\r\n    }\r\n    .recording-bar.active { display: flex; }\r\n    .recording-dot {\r\n      width: 10px; height: 10px; background: #dc3545; border-radius: 50%;\r\n      animation: pulse 1s infinite;\r\n    }\r\n    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }\r\n    .recording-bar span { font-size: 12px; color: #dc3545; font-weight: 600; }\r\n\r\n    /* Playing overlay */\r\n    body.playing .card { opacity: 0.6; pointer-events: none; }\r\n    body.playing .card.playback-card { opacity: 1; pointer-events: auto; }\r\n    body.playing .card.playback-card .btn:not(#play_button):not(#play_all_button) { pointer-events: none; opacity: 0.4; }\r\n    body.playing #play_button, body.playing #play_all_button { pointer-events: auto !important; opacity: 1 !important; }\r\n\r\n    /* Input base */\r\n    input[type=\"number\"] {\r\n      -moz-appearance: textfield;\r\n    }\r\n    input[type=\"number\"]::-webkit-inner-spin-button {\r\n      -webkit-appearance: none;\r\n    }\r\n\r\n    /* Draggable markers */\r\n    .marker { cursor: grab; }\r\n    .marker.dragging {\r\n      transform: translateX(-50%) scale(1.3);\r\n      z-index: 20;\r\n      cursor: grabbing;\r\n    }\r\n    .marker.no-drag { cursor: default; }\r\n\r\n    /* Saved timelines list */\r\n    .saved-timelines-list { margin-top: 10px; }\r\n    .saved-timelines-list:empty { display: none; }\r\n    .tl-item {\r\n      display: flex; align-items: center; gap: 8px;\r\n      padding: 6px 10px; border-bottom: 1px solid #f0f0f0;\r\n      cursor: pointer; transition: background 0.12s; font-size: 12px;\r\n    }\r\n    .tl-item:hover { background: #f7faff; }\r\n    .tl-item:last-child { border-bottom: none; }\r\n    .tl-item .tl-indicator {\r\n      width: 8px; height: 8px; border-radius: 50%;\r\n      background: #ccc; flex-shrink: 0;\r\n    }\r\n    .tl-item.active .tl-indicator { background: #0066cc; }\r\n    .tl-item .tl-name { flex: 1; font-weight: 500; color: #333; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }\r\n    .tl-item .tl-count { color: #999; font-size: 11px; flex-shrink: 0; }\r\n    .tl-item .tl-delete {\r\n      width: 20px; height: 20px; border-radius: 50%; border: 1px solid #eee;\r\n      background: transparent; cursor: pointer; display: flex;\r\n      align-items: center; justify-content: center; font-size: 12px; color: #ccc;\r\n      flex-shrink: 0; transition: all 0.15s;\r\n    }\r\n    .tl-item .tl-delete:hover { background: #fee; border-color: #dc3545; color: #dc3545; }\r\n\r\n    /* Drag-and-drop for timeline reordering */\r\n    .tl-drag-handle {\r\n      cursor: grab; flex-shrink: 0; color: #ccc; font-size: 14px;\r\n      padding: 0 4px; user-select: none;\r\n    }\r\n    .tl-drag-handle:active { cursor: grabbing; }\r\n    .tl-item.dragging { opacity: 0.4; }\r\n    .tl-item.drag-over-top { border-top: 2px solid #0066cc; }\r\n    .tl-item.drag-over-bottom { border-bottom: 2px solid #0066cc; }\r\n\r\n    /* Viewport info */\r\n    .viewport-info {\r\n      font-size: 11px; color: #666; margin-bottom: 10px;\r\n      padding: 6px 10px; background: #f9f9f9; border-radius: 4px; border: 1px solid #eee;\r\n    }\r\n\r\n    /* Misc */\r\n    .hidden { display: none !important; }\r\n    .mt-8 { margin-top: 8px; }\r\n  </style>\r\n</head>\r\n<body>\r\n\r\n<!-- Header -->\r\n<div class=\"header\">\r\n  <svg width=\"28\" height=\"28\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"#0066cc\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <path d=\"M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z\"/>\r\n    <circle cx=\"12\" cy=\"13\" r=\"4\"/>\r\n  </svg>\r\n  <div>\r\n    <h1>#{obter_texto(:titulo)}</h1>\r\n    <span class=\"subtitle\">#{obter_texto(:subtitulo)}</span>\r\n  </div>\r\n</div>\r\n\r\n<!-- Timeline Card -->\r\n<div class=\"card\">\r\n  <div class=\"card-body\">\r\n    <div class=\"timeline-wrapper\">\r\n      <div class=\"timeline-track\"></div>\r\n      <input type=\"range\" min=\"0\" max=\"60\" step=\"0.1\" value=\"0\" id=\"timeline_range\" oninput=\"updateTime(this.value)\">\r\n      <div id=\"markers_layer\"></div>\r\n    </div>\r\n    <div class=\"time-row\">\r\n      <div class=\"time-display\"><span id=\"current_time\">0.0</span><small>s</small></div>\r\n      <div class=\"time-input-group\">\r\n        <label>#{obter_texto(:total)}</label>\r\n        <input id=\"max_time\" type=\"number\" step=\"1\" value=\"60\" min=\"1\" onchange=\"atualizarTempoTotal()\"\r\n          style=\"width:65px; padding:4px 8px; border:1px solid #ddd; border-radius:4px; font-size:12px; text-align:center; outline:none; font-family:inherit;\">\r\n        <small style=\"color:#888;\">s</small>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Playback Controls Card -->\r\n<div class=\"card playback-card\">\r\n  <div class=\"card-body\">\r\n    <div class=\"btn-group\">\r\n      <button class=\"btn btn-primary\" onclick=\"addVision()\">\r\n        <svg width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2.5\"><line x1=\"12\" y1=\"5\" x2=\"12\" y2=\"19\"/><line x1=\"5\" y1=\"12\" x2=\"19\" y2=\"12\"/></svg>\r\n        #{obter_texto(:visao)}\r\n      </button>\r\n      <button id=\"play_button\" class=\"btn btn-success\" onclick=\"togglePlay()\">&#9654; #{obter_texto(:play)}</button>\r\n      <button id=\"play_all_button\" class=\"btn btn-outline btn-sm hidden\" onclick=\"togglePlayAll()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><polygon points=\"5 3 19 12 5 21 5 3\"/><line x1=\"19\" y1=\"3\" x2=\"19\" y2=\"21\"/></svg>\r\n        #{obter_texto(:play_all)}\r\n      </button>\r\n      <button class=\"btn btn-outline btn-sm\" onclick=\"mostrarCampoAtalho()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><rect x=\"2\" y=\"4\" width=\"20\" height=\"16\" rx=\"2\"/><line x1=\"6\" y1=\"8\" x2=\"6\" y2=\"8\"/><line x1=\"10\" y1=\"8\" x2=\"10\" y2=\"8\"/><line x1=\"14\" y1=\"8\" x2=\"14\" y2=\"8\"/><line x1=\"18\" y1=\"8\" x2=\"18\" y2=\"8\"/><line x1=\"8\" y1=\"16\" x2=\"16\" y2=\"16\"/></svg>\r\n        #{obter_texto(:atalho)}\r\n      </button>\r\n      <span id=\"hotkey_edit\" class=\"hotkey-editor\">\r\n        <input id=\"hotkey_input\" type=\"text\" placeholder=\"#{obter_texto(:pressione)}\" onkeydown=\"capturarAtalhoInput(event)\">\r\n        <button class=\"btn btn-primary btn-sm\" onclick=\"confirmarAtalho()\">#{obter_texto(:ok)}</button>\r\n      </span>\r\n    </div>\r\n    <div class=\"check-group\">\r\n      <div class=\"check-item\">\r\n        <input type=\"checkbox\" id=\"loop_checkbox\">\r\n        <label for=\"loop_checkbox\">#{obter_texto(:loop)}</label>\r\n      </div>\r\n      <div class=\"check-item\">\r\n        <input type=\"checkbox\" id=\"easing_checkbox\">\r\n        <label for=\"easing_checkbox\">#{obter_texto(:easing)}</label>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Visions Card -->\r\n<div class=\"card\">\r\n  <div class=\"card-header\" onclick=\"toggleSection('visions')\">\r\n    <h2>#{obter_texto(:visoes_salvas)} <span id=\"vision_count\" style=\"color:#999; font-weight:400;\"></span></h2>\r\n    <span class=\"toggle-icon\" id=\"visions_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body\" id=\"visions_body\">\r\n    <div class=\"vision-list\" id=\"lista_visoes\"></div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Gerenciar Time Line Card -->\r\n<div class=\"card\">\r\n  <div class=\"card-header\" onclick=\"toggleSection('timeline_mgr')\">\r\n    <h2>#{obter_texto(:gerenciar_timeline)}</h2>\r\n    <span class=\"toggle-icon\" id=\"timeline_mgr_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body\" id=\"timeline_mgr_body\">\r\n    <div class=\"btn-group\">\r\n      <button class=\"btn btn-outline\" onclick=\"novaTimeline()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z\"/><polyline points=\"14 2 14 8 20 8\"/><line x1=\"12\" y1=\"18\" x2=\"12\" y2=\"12\"/><line x1=\"9\" y1=\"15\" x2=\"15\" y2=\"15\"/></svg>\r\n        #{obter_texto(:nova)}\r\n      </button>\r\n      <button class=\"btn btn-outline\" onclick=\"exportarTimeline()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\"/><polyline points=\"7 10 12 15 17 10\"/><line x1=\"12\" y1=\"15\" x2=\"12\" y2=\"3\"/></svg>\r\n        #{obter_texto(:exportar_atual)}\r\n      </button>\r\n      <button class=\"btn btn-outline\" onclick=\"exportarProjeto()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z\"/><polyline points=\"9 14 12 17 15 14\"/><line x1=\"12\" y1=\"17\" x2=\"12\" y2=\"10\"/></svg>\r\n        #{obter_texto(:exportar_projeto)}\r\n      </button>\r\n      <input type=\"file\" id=\"import_file\" class=\"hidden\" accept=\".json\" onchange=\"importarTimeline(this)\">\r\n      <button class=\"btn btn-outline\" onclick=\"document.getElementById('import_file').click()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\"/><polyline points=\"17 8 12 3 7 8\"/><line x1=\"12\" y1=\"3\" x2=\"12\" y2=\"15\"/></svg>\r\n        #{obter_texto(:importar)}\r\n      </button>\r\n    </div>\r\n    <div id=\"saved_timelines_list\" class=\"saved-timelines-list\"></div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Exportar Vídeo Card (colapsado por padrão) -->\r\n<div class=\"card\">\r\n  <div class=\"card-header collapsed\" onclick=\"toggleSection('export')\">\r\n    <h2>#{obter_texto(:exportar_video)}</h2>\r\n    <span class=\"toggle-icon\" id=\"export_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body collapsed\" id=\"export_body\">\r\n    <div id=\"ffmpeg_section\" class=\"#{has_ffmpeg ? '' : 'hidden'}\">\r\n      <div class=\"viewport-info\">\r\n        #{obter_texto(:viewport_atual)} <strong>#{vp_width} x #{vp_height} px</strong>\r\n      </div>\r\n\r\n      <select id=\"preset_select\" class=\"preset-select\" onchange=\"onPresetChange()\">\r\n        <option value=\"\" disabled selected>#{obter_texto(:selecione_formato)}</option>\r\n      </select>\r\n\r\n      <div class=\"custom-dims\" id=\"custom_dims\">\r\n        <input type=\"number\" id=\"custom_w\" min=\"50\" placeholder=\"#{obter_texto(:largura)}\" value=\"1280\">\r\n        <span>x</span>\r\n        <input type=\"number\" id=\"custom_h\" min=\"50\" placeholder=\"#{obter_texto(:altura)}\" value=\"720\">\r\n        <small style=\"color:#888;\">px</small>\r\n      </div>\r\n\r\n      <div class=\"preset-preview\" id=\"preset_preview\" style=\"display:none;\"></div>\r\n\r\n      <div class=\"check-group\" style=\"margin-top:12px; flex-direction:column; align-items:flex-start; gap:8px;\">\r\n        <div class=\"check-item\">\r\n          <input type=\"checkbox\" id=\"rec_projeto\">\r\n          <label for=\"rec_projeto\">#{obter_texto(:gravar_projeto)}</label>\r\n        </div>\r\n        <div class=\"check-item\">\r\n          <input type=\"checkbox\" id=\"rec_inicio\" checked>\r\n          <label for=\"rec_inicio\">#{obter_texto(:iniciar_quadro1)}</label>\r\n        </div>\r\n      </div>\r\n\r\n      <button class=\"btn btn-record mt-8\" id=\"btn_record\" onclick=\"iniciarGravacao()\" disabled style=\"width:100%; margin-top:12px;\">\r\n        <svg width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><circle cx=\"12\" cy=\"12\" r=\"4\" fill=\"currentColor\"/></svg>\r\n        #{obter_texto(:iniciar_gravacao)}\r\n      </button>\r\n\r\n      <div class=\"recording-bar\" id=\"recording_bar\">\r\n        <div class=\"recording-dot\"></div>\r\n        <span>#{obter_texto(:gravando)}</span>\r\n      </div>\r\n    </div>\r\n\r\n    <div id=\"ffmpeg_install\" class=\"#{has_ffmpeg ? 'hidden' : ''}\" style=\"text-align:center; padding:12px 0;\">\r\n      <p style=\"color:#888; font-size:12px; margin-bottom:10px;\">#{obter_texto(:ffmpeg_necessario)}</p>\r\n      <button class=\"btn btn-primary\" onclick=\"instalarExportacao()\">#{obter_texto(:instalar_ffmpeg)}</button>\r\n    </div>\r\n\r\n    <!-- Modal de nome do arquivo -->\r\n    <div id=\"filename_modal\" style=\"display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.4);z-index:100;align-items:center;justify-content:center;\">\r\n      <div style=\"background:#fff;border-radius:10px;padding:24px;width:320px;box-shadow:0 8px 30px rgba(0,0,0,0.2);\">\r\n        <h3 style=\"font-size:14px;font-weight:600;color:#333;margin-bottom:12px;\">#{obter_texto(:nome_arquivo)}</h3>\r\n        <input id=\"filename_input\" type=\"text\" value=\"tour_final\" style=\"width:100%;padding:8px 12px;border:1px solid #ddd;border-radius:6px;font-size:13px;font-family:inherit;outline:none;margin-bottom:6px;\">\r\n        <small style=\"color:#888;\">#{obter_texto(:extensao_mp4)}</small>\r\n        <div style=\"display:flex;gap:8px;margin-top:16px;justify-content:flex-end;\">\r\n          <button class=\"btn btn-outline btn-sm\" onclick=\"fecharModalFilename()\">#{obter_texto(:cancelar)}</button>\r\n          <button class=\"btn btn-primary btn-sm\" onclick=\"confirmarFilename()\">#{obter_texto(:salvar)}</button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Modal de nome da timeline -->\r\n<div id=\"timeline_name_modal\" style=\"display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.4);z-index:100;align-items:center;justify-content:center;\">\r\n  <div style=\"background:#fff;border-radius:10px;padding:24px;width:320px;box-shadow:0 8px 30px rgba(0,0,0,0.2);\">\r\n    <h3 id=\"timeline_name_title\" style=\"font-size:14px;font-weight:600;color:#333;margin-bottom:12px;\"></h3>\r\n    <input id=\"timeline_name_input\" type=\"text\" onkeydown=\"if(event.keyCode===13){confirmarModalTimeline();}\" style=\"width:100%;padding:8px 12px;border:1px solid #ddd;border-radius:6px;font-size:13px;font-family:inherit;outline:none;margin-bottom:6px;\">\r\n    <div style=\"display:flex;gap:8px;margin-top:16px;justify-content:flex-end;\">\r\n      <button class=\"btn btn-outline btn-sm\" onclick=\"fecharModalTimeline()\">#{obter_texto(:cancelar)}</button>\r\n      <button class=\"btn btn-primary btn-sm\" onclick=\"confirmarModalTimeline()\">#{obter_texto(:ok)}</button>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<script>\r\n    const I18N = #{js_i18n_json};\r\n    let visoes = [], playing = false, currentIndex = 0;\r\n    let hotkey = { keyCode: #{current_hotkey}, ctrl: #{hotkey_ctrl}, alt: #{hotkey_alt}, shift: #{hotkey_shift} };\r\n    let capturingHotkey = false, pendingHotkey = null;\r\n    let savedTimelines = [];\r\n    let activeTimelineIndex = -1;\r\n    let playingAll = false, playAllQueue = [], playAllCurrentIdx = 0;\r\n    var viewportW = #{vp_width}, viewportH = #{vp_height};\r\n\r\n    if (window.sketchup) { window.sketchup.set_hotkey(hotkey.keyCode, hotkey.ctrl, hotkey.alt, hotkey.shift); }\r\n\r\n    /* --- Export Formats (aspect ratios) --- */\r\n    const EXPORT_FORMATS = [\r\n      { label: '16:9 ' + I18N.paisagem, ratio: [16, 9] },\r\n      { label: '9:16 ' + I18N.retrato, ratio: [9, 16] },\r\n      { label: '1:1 ' + I18N.quadrado, ratio: [1, 1] },\r\n      { label: '4:3 ' + I18N.classico, ratio: [4, 3] },\r\n      { label: '21:9 ' + I18N.ultra_wide, ratio: [21, 9] },\r\n      { label: I18N.viewport_inteira, ratio: null },\r\n      { label: I18N.personalizado, ratio: null, custom: true }\r\n    ];\r\n\r\n    function calcEffectiveDims(ratioW, ratioH, vpW, vpH) {\r\n      const scaleW = vpW / ratioW;\r\n      const scaleH = vpH / ratioH;\r\n      const scale = Math.min(scaleW, scaleH);\r\n      let w = Math.floor(ratioW * scale);\r\n      let h = Math.floor(ratioH * scale);\r\n      w = w % 2 === 0 ? w : w - 1;\r\n      h = h % 2 === 0 ? h : h - 1;\r\n      return { w: w, h: h };\r\n    }\r\n\r\n    function populatePresets() {\r\n      const sel = document.getElementById(\"preset_select\");\r\n      sel.innerHTML = '<option value=\"\" disabled selected>' + I18N.selecione_formato + '</option>';\r\n      EXPORT_FORMATS.forEach((fmt, i) => {\r\n        const opt = document.createElement(\"option\");\r\n        opt.value = i.toString();\r\n        if (fmt.custom) {\r\n          opt.textContent = fmt.label;\r\n        } else if (fmt.ratio) {\r\n          const dims = calcEffectiveDims(fmt.ratio[0], fmt.ratio[1], viewportW, viewportH);\r\n          opt.textContent = fmt.label + \" (\" + dims.w + \" x \" + dims.h + \" px)\";\r\n        } else {\r\n          let w = viewportW % 2 === 0 ? viewportW : viewportW - 1;\r\n          let h = viewportH % 2 === 0 ? viewportH : viewportH - 1;\r\n          opt.textContent = fmt.label + \" (\" + w + \" x \" + h + \" px)\";\r\n        }\r\n        sel.appendChild(opt);\r\n      });\r\n    }\r\n\r\n    /* --- Section Toggle --- */\r\n    function toggleSection(name) {\r\n      const body = document.getElementById(name + '_body');\r\n      const icon = document.getElementById(name + '_toggle');\r\n      const header = icon.parentElement;\r\n      const wasCollapsed = body.classList.contains('collapsed');\r\n      if (wasCollapsed) {\r\n        body.classList.remove('collapsed');\r\n        header.classList.remove('collapsed');\r\n      } else {\r\n        body.classList.add('collapsed');\r\n        header.classList.add('collapsed');\r\n      }\r\n      /* Hide viewport preview when closing export card */\r\n      if (name === 'export' && !wasCollapsed) {\r\n        if (window.sketchup) window.sketchup.hide_export_preview();\r\n      }\r\n    }\r\n\r\n    /* --- Timeline --- */\r\n    function updateTime(val) {\r\n      document.getElementById(\"current_time\").innerText = parseFloat(val).toFixed(1);\r\n    }\r\n\r\n    function atualizarTempoTotal() {\r\n      const novoMax = parseFloat(document.getElementById(\"max_time\").value);\r\n      if (isNaN(novoMax) || novoMax <= 0) return;\r\n      document.getElementById(\"timeline_range\").max = novoMax;\r\n      visoes.forEach(v => { if (v.time > novoMax) v.time = novoMax - 0.1; });\r\n      renderMarkers();\r\n    }\r\n\r\n    /* --- Timeline Name Modal --- */\r\n    var _timelineModalCallback = null;\r\n\r\n    function abrirModalTimeline(titulo, valorPadrao, callback) {\r\n      _timelineModalCallback = callback;\r\n      document.getElementById(\"timeline_name_title\").textContent = titulo;\r\n      var input = document.getElementById(\"timeline_name_input\");\r\n      input.value = valorPadrao;\r\n      var modal = document.getElementById(\"timeline_name_modal\");\r\n      modal.style.display = \"flex\";\r\n      setTimeout(function() { input.focus(); input.select(); }, 50);\r\n    }\r\n\r\n    function fecharModalTimeline() {\r\n      document.getElementById(\"timeline_name_modal\").style.display = \"none\";\r\n      _timelineModalCallback = null;\r\n    }\r\n\r\n    function confirmarModalTimeline() {\r\n      var name = document.getElementById(\"timeline_name_input\").value.trim();\r\n      if (!name) return;\r\n      document.getElementById(\"timeline_name_modal\").style.display = \"none\";\r\n      if (_timelineModalCallback) {\r\n        _timelineModalCallback(name);\r\n        _timelineModalCallback = null;\r\n      }\r\n    }\r\n\r\n    /* --- Visions --- */\r\n    function addVision() {\r\n      if (savedTimelines.length === 0 && visoes.length === 0) {\r\n        abrirModalTimeline(I18N.nome_timeline, \"Time Line 1\", function(name) {\r\n          savedTimelines.push({ name: name, visoes: [], maxTime: 60 });\r\n          activeTimelineIndex = 0;\r\n          renderSavedTimelines();\r\n          var time = parseFloat(document.getElementById(\"timeline_range\").value);\r\n          sketchup.capture_camera(time);\r\n        });\r\n        return;\r\n      }\r\n      var time = parseFloat(document.getElementById(\"timeline_range\").value);\r\n      sketchup.capture_camera(time);\r\n    }\r\n\r\n    function captureVisionFromRuby(camJson) {\r\n      const obj = JSON.parse(camJson);\r\n      obj.walk = false; obj.anchor = false;\r\n      visoes = visoes.filter(v => v.time !== obj.time);\r\n      visoes.push(obj);\r\n      visoes.sort((a, b) => a.time - b.time);\r\n      visoes[0].time = 0.0;\r\n      syncActiveTimeline();\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    /* --- Draggable markers --- */\r\n    function setupMarkerDrag(marker, visionIndex, slider, maxTime) {\r\n      if (visionIndex === 0) {\r\n        marker.classList.add(\"no-drag\");\r\n        return;\r\n      }\r\n      marker.addEventListener(\"mousedown\", function(e) {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        marker.classList.add(\"dragging\");\r\n        const sliderPadding = 8;\r\n\r\n        function onMove(ev) {\r\n          const sliderRect = slider.getBoundingClientRect();\r\n          const usableWidth = sliderRect.width - sliderPadding * 2;\r\n          const relativeX = Math.max(0, Math.min(ev.clientX - sliderRect.left - sliderPadding, usableWidth));\r\n          const newTime = parseFloat(((relativeX / usableWidth) * maxTime).toFixed(1));\r\n          marker.style.left = (relativeX + sliderPadding) + \"px\";\r\n          const tooltip = marker.querySelector(\".marker-tooltip\");\r\n          if (tooltip) tooltip.textContent = newTime.toFixed(1) + \"s\";\r\n        }\r\n\r\n        function onUp(ev) {\r\n          marker.classList.remove(\"dragging\");\r\n          document.removeEventListener(\"mousemove\", onMove);\r\n          document.removeEventListener(\"mouseup\", onUp);\r\n          const sliderRect = slider.getBoundingClientRect();\r\n          const usableWidth = sliderRect.width - sliderPadding * 2;\r\n          const relativeX = Math.max(0, Math.min(ev.clientX - sliderRect.left - sliderPadding, usableWidth));\r\n          const newTime = parseFloat(((relativeX / usableWidth) * maxTime).toFixed(1));\r\n          visoes[visionIndex].time = Math.max(0.1, newTime);\r\n          visoes.sort((a, b) => a.time - b.time);\r\n          if (visoes.length > 0) visoes[0].time = 0.0;\r\n          renderMarkers();\r\n        }\r\n\r\n        document.addEventListener(\"mousemove\", onMove);\r\n        document.addEventListener(\"mouseup\", onUp);\r\n      });\r\n    }\r\n\r\n    function syncActiveTimeline() {\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n    }\r\n\r\n    function renderMarkers() {\r\n      const layer = document.getElementById(\"markers_layer\");\r\n      const lista = document.getElementById(\"lista_visoes\");\r\n      const slider = document.getElementById(\"timeline_range\");\r\n      const max = parseFloat(slider.max);\r\n      const width = slider.offsetWidth;\r\n      const countEl = document.getElementById(\"vision_count\");\r\n\r\n      layer.innerHTML = \"\"; lista.innerHTML = \"\";\r\n      countEl.textContent = visoes.length > 0 ? \"(\" + visoes.length + \")\" : \"\";\r\n\r\n      if (visoes.length === 0) {\r\n        lista.innerHTML = '<div class=\"empty-state\">' +\r\n          '<svg width=\"36\" height=\"36\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"#ccc\" stroke-width=\"1.5\"><path d=\"M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z\"/><circle cx=\"12\" cy=\"13\" r=\"4\"/></svg>' +\r\n          '<p>' + I18N.nenhuma_visao + '<br>' + I18N.dica_visao + '</p></div>';\r\n        return;\r\n      }\r\n\r\n      visoes.forEach((v, i) => {\r\n        /* Marker on timeline */\r\n        const percent = max > 0 ? v.time / max : 0;\r\n        const marker = document.createElement(\"div\");\r\n        marker.className = \"marker\" + (v.anchor ? \" anchor\" : \"\");\r\n        const sliderPadding = 8;\r\n        const usableWidth = width - sliderPadding * 2;\r\n        marker.style.left = (percent * usableWidth + sliderPadding) + \"px\";\r\n        const tooltip = document.createElement(\"span\");\r\n        tooltip.className = \"marker-tooltip\";\r\n        tooltip.textContent = v.time.toFixed(1) + \"s\";\r\n        marker.appendChild(tooltip);\r\n        marker.onclick = () => {\r\n          slider.value = v.time; updateTime(v.time); currentIndex = i;\r\n          resetPlayButton(); sketchup.goto_camera(JSON.stringify(v));\r\n        };\r\n        /* Draggable */\r\n        setupMarkerDrag(marker, i, slider, max);\r\n        layer.appendChild(marker);\r\n\r\n        /* Vision list item */\r\n        const item = document.createElement(\"div\");\r\n        item.className = \"vision-item\";\r\n        item.onclick = () => {\r\n          slider.value = v.time; updateTime(v.time); currentIndex = i;\r\n          resetPlayButton(); sketchup.goto_camera(JSON.stringify(v));\r\n        };\r\n\r\n        const num = document.createElement(\"span\");\r\n        num.className = \"vision-num\";\r\n        num.textContent = (i + 1);\r\n\r\n        const img = document.createElement(\"img\");\r\n        if (v.thumb && v.thumb.length > 0) {\r\n          const mime = v.thumb.startsWith(\"/9j/\") ? \"image/jpeg\" : \"image/bmp\";\r\n          img.src = \"data:\" + mime + \";base64,\" + v.thumb;\r\n        } else {\r\n          img.src = \"\";\r\n          img.className = \"thumb-placeholder\";\r\n        }\r\n\r\n        const info = document.createElement(\"div\");\r\n        info.className = \"vision-info\";\r\n        const timeInput = document.createElement(\"input\");\r\n        timeInput.type = \"number\"; timeInput.step = \"0.1\";\r\n        timeInput.value = v.time.toFixed(1);\r\n        timeInput.className = \"vision-time-input\";\r\n        timeInput.disabled = (i === 0);\r\n        timeInput.onclick = (e) => e.stopPropagation();\r\n        timeInput.onchange = () => {\r\n          v.time = parseFloat(timeInput.value);\r\n          visoes.sort((a, b) => a.time - b.time);\r\n          renderMarkers();\r\n        };\r\n        info.appendChild(timeInput);\r\n\r\n        const actions = document.createElement(\"div\");\r\n        actions.className = \"vision-actions\";\r\n\r\n        const anchorBtn = document.createElement(\"button\");\r\n        anchorBtn.className = \"anchor-toggle\" + (v.anchor ? \" active\" : \"\");\r\n        anchorBtn.innerHTML = \"&#9875;\";\r\n        anchorBtn.title = I18N.ancora;\r\n        anchorBtn.onclick = (e) => {\r\n          e.stopPropagation();\r\n          v.anchor = !v.anchor;\r\n          renderMarkers();\r\n        };\r\n        actions.appendChild(anchorBtn);\r\n\r\n        const delBtn = document.createElement(\"button\");\r\n        delBtn.className = \"delete-btn\";\r\n        delBtn.innerHTML = \"&times;\";\r\n        delBtn.title = I18N.excluir;\r\n        delBtn.onclick = (e) => {\r\n          e.stopPropagation();\r\n          visoes.splice(i, 1);\r\n          if (visoes.length > 0) visoes[0].time = 0.0;\r\n          syncActiveTimeline();\r\n          renderMarkers();\r\n          renderSavedTimelines();\r\n        };\r\n        actions.appendChild(delBtn);\r\n\r\n        item.appendChild(num);\r\n        item.appendChild(img);\r\n        item.appendChild(info);\r\n        item.appendChild(actions);\r\n        lista.appendChild(item);\r\n      });\r\n    }\r\n\r\n    /* --- Playback --- */\r\n    function togglePlay() {\r\n      if (!playing) {\r\n        if (visoes.length < 2) return alert(I18N.min_duas_visoes);\r\n        if (currentIndex >= visoes.length - 1) currentIndex = 0;\r\n        playing = true;\r\n        document.body.classList.add(\"playing\");\r\n        document.getElementById(\"play_button\").innerHTML = \"&#9724; \" + I18N.stop;\r\n        document.getElementById(\"play_button\").className = \"btn btn-danger\";\r\n        sketchup.play_tour(JSON.stringify(visoes), document.getElementById(\"loop_checkbox\").checked, false, document.getElementById(\"easing_checkbox\").checked, currentIndex);\r\n      } else {\r\n        resetPlayButton();\r\n        sketchup.stop_tour();\r\n      }\r\n    }\r\n\r\n    function resetPlayButton() {\r\n      playing = false;\r\n      document.body.classList.remove(\"playing\");\r\n      document.getElementById(\"play_button\").innerHTML = \"&#9654; \" + I18N.play;\r\n      document.getElementById(\"play_button\").className = \"btn btn-success\";\r\n    }\r\n\r\n    function togglePlayAll() {\r\n      if (playingAll) {\r\n        resetPlayAll();\r\n        sketchup.stop_tour();\r\n        return;\r\n      }\r\n      if (savedTimelines.length < 2) return;\r\n      /* Save current timeline state */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n      /* Build queue of timelines with 2+ visions */\r\n      playAllQueue = savedTimelines.map(function(tl, i) { return i; }).filter(function(i) { return savedTimelines[i].visoes.length >= 2; });\r\n      if (playAllQueue.length < 1) { alert(I18N.sem_tl_2mais); return; }\r\n      playingAll = true;\r\n      playAllCurrentIdx = 0;\r\n      document.body.classList.add(\"playing\");\r\n      document.getElementById(\"play_all_button\").innerHTML = \"&#9724; \" + I18N.stop_all;\r\n      document.getElementById(\"play_all_button\").className = \"btn btn-danger btn-sm\";\r\n      playTimelineAtQueueIndex(0);\r\n    }\r\n\r\n    function playTimelineAtQueueIndex(qIdx) {\r\n      var tlIdx = playAllQueue[qIdx];\r\n      var tl = savedTimelines[tlIdx];\r\n      visoes = JSON.parse(JSON.stringify(tl.visoes));\r\n      document.getElementById(\"max_time\").value = tl.maxTime;\r\n      document.getElementById(\"timeline_range\").max = tl.maxTime;\r\n      activeTimelineIndex = tlIdx;\r\n      currentIndex = 0;\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n      sketchup.play_tour(\r\n        JSON.stringify(visoes),\r\n        false,\r\n        false,\r\n        document.getElementById(\"easing_checkbox\").checked,\r\n        0\r\n      );\r\n    }\r\n\r\n    function resetPlayAll() {\r\n      playingAll = false;\r\n      playAllQueue = [];\r\n      playAllCurrentIdx = 0;\r\n      document.body.classList.remove(\"playing\");\r\n      var btn = document.getElementById(\"play_all_button\");\r\n      btn.innerHTML = '<svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><polygon points=\"5 3 19 12 5 21 5 3\"/><line x1=\"19\" y1=\"3\" x2=\"19\" y2=\"21\"/></svg> ' + I18N.play_all;\r\n      btn.className = \"btn btn-outline btn-sm\";\r\n      playing = false;\r\n      document.getElementById(\"play_button\").innerHTML = \"&#9654; \" + I18N.play;\r\n      document.getElementById(\"play_button\").className = \"btn btn-success\";\r\n    }\r\n\r\n    function startRecordingPlayAll(startTlIdx, startVisionIdx) {\r\n      syncActiveTimeline();\r\n      /* Montar fila de timelines com 2+ visões, a partir de startTlIdx */\r\n      playAllQueue = [];\r\n      for (var i = startTlIdx; i < savedTimelines.length; i++) {\r\n        if (savedTimelines[i].visoes.length >= 2) playAllQueue.push(i);\r\n      }\r\n      if (playAllQueue.length === 0) return;\r\n\r\n      playingAll = true;\r\n      playAllCurrentIdx = 0;\r\n      playing = true;\r\n      document.body.classList.add(\"playing\");\r\n      document.getElementById(\"play_button\").innerHTML = \"&#9724; \" + I18N.stop;\r\n      document.getElementById(\"play_button\").className = \"btn btn-danger\";\r\n\r\n      /* Carregar a primeira timeline da fila */\r\n      var firstTlIdx = playAllQueue[0];\r\n      var tl = savedTimelines[firstTlIdx];\r\n      visoes = JSON.parse(JSON.stringify(tl.visoes));\r\n      document.getElementById(\"max_time\").value = tl.maxTime;\r\n      document.getElementById(\"timeline_range\").max = tl.maxTime;\r\n      activeTimelineIndex = firstTlIdx;\r\n      currentIndex = startVisionIdx;\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n\r\n      sketchup.play_tour(\r\n        JSON.stringify(visoes),\r\n        false,\r\n        false,\r\n        document.getElementById(\"easing_checkbox\").checked,\r\n        startVisionIdx\r\n      );\r\n    }\r\n\r\n    function updatePlayAllButton() {\r\n      var btn = document.getElementById(\"play_all_button\");\r\n      if (savedTimelines.length > 1) {\r\n        btn.classList.remove(\"hidden\");\r\n      } else {\r\n        btn.classList.add(\"hidden\");\r\n      }\r\n    }\r\n\r\n    function pauseAtIndex(idx) {\r\n      currentIndex = idx;\r\n      if (playingAll) {\r\n        playAllCurrentIdx++;\r\n        if (playAllCurrentIdx < playAllQueue.length) {\r\n          playTimelineAtQueueIndex(playAllCurrentIdx);\r\n          return;\r\n        } else {\r\n          resetPlayAll();\r\n          return;\r\n        }\r\n      }\r\n      resetPlayButton();\r\n    }\r\n    function triggerSpaceFromRuby() { togglePlay(); }\r\n    function updatePlayhead(time) {\r\n      var slider = document.getElementById(\"timeline_range\");\r\n      slider.value = time;\r\n      document.getElementById(\"current_time\").innerText = parseFloat(time).toFixed(1);\r\n    }\r\n\r\n    /* --- Timeline Management --- */\r\n    function exportarTimeline() {\r\n      if (visoes.length === 0) { alert(I18N.sem_visoes_exportar); return; }\r\n      var tlName = (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length)\r\n        ? savedTimelines[activeTimelineIndex].name : \"Time Line\";\r\n      /* Download JSON */\r\n      var dataStr = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(visoes, null, 2));\r\n      var a = document.createElement(\"a\");\r\n      a.setAttribute(\"href\", dataStr);\r\n      a.setAttribute(\"download\", tlName.replace(/[^a-zA-Z0-9_-]/g, \"_\") + \".json\");\r\n      document.body.appendChild(a); a.click(); a.remove();\r\n      /* Salvar na lista */\r\n      saveCurrentToTimelines(tlName);\r\n    }\r\n\r\n    function exportarProjeto() {\r\n      syncActiveTimeline();\r\n      if (savedTimelines.length === 0) { alert(I18N.sem_tl_exportar); return; }\r\n      var projeto = { type: \"tour_virtual_project\", timelines: savedTimelines };\r\n      var dataStr = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(projeto, null, 2));\r\n      var a = document.createElement(\"a\");\r\n      a.setAttribute(\"href\", dataStr);\r\n      a.setAttribute(\"download\", \"projeto_tour_virtual.json\");\r\n      document.body.appendChild(a); a.click(); a.remove();\r\n    }\r\n\r\n    function saveCurrentToTimelines(name) {\r\n      var maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      var entry = { name: name, visoes: JSON.parse(JSON.stringify(visoes)), maxTime: maxTime };\r\n      /* Atualizar existente se ativo, senão adicionar novo */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex] = entry;\r\n      } else {\r\n        savedTimelines.push(entry);\r\n        activeTimelineIndex = savedTimelines.length - 1;\r\n      }\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    function importarTimeline(input) {\r\n      var file = input.files[0];\r\n      if (!file) return;\r\n      var reader = new FileReader();\r\n      reader.onload = function(e) {\r\n        try {\r\n          var imported = JSON.parse(e.target.result);\r\n          /* Detectar se é um projeto completo */\r\n          if (imported && imported.type === \"tour_virtual_project\" && Array.isArray(imported.timelines)) {\r\n            syncActiveTimeline();\r\n            imported.timelines.forEach(function(tl) {\r\n              if (tl.visoes) {\r\n                tl.visoes.sort(function(a, b) { return a.time - b.time; });\r\n                if (tl.visoes.length > 0) tl.visoes[0].time = 0.0;\r\n              }\r\n              savedTimelines.push({ name: tl.name || I18N.importada, visoes: tl.visoes || [], maxTime: tl.maxTime || 60 });\r\n            });\r\n            if (savedTimelines.length > 0 && activeTimelineIndex < 0) {\r\n              activeTimelineIndex = 0;\r\n              var first = savedTimelines[0];\r\n              visoes = JSON.parse(JSON.stringify(first.visoes));\r\n              document.getElementById(\"max_time\").value = first.maxTime;\r\n              document.getElementById(\"timeline_range\").max = first.maxTime;\r\n              renderMarkers();\r\n            }\r\n            renderSavedTimelines();\r\n            return;\r\n          }\r\n          /* Time Line única */\r\n          if (!Array.isArray(imported)) throw I18N.formato_invalido;\r\n          imported.sort(function(a, b) { return a.time - b.time; });\r\n          if (imported.length > 0) imported[0].time = 0.0;\r\n          var maxTime = imported.length > 0 ? Math.ceil(imported[imported.length - 1].time + 1) : 60;\r\n          var name = file.name.replace(/\\\\.json$/i, \"\");\r\n          savedTimelines.push({ name: name, visoes: imported, maxTime: maxTime });\r\n          renderSavedTimelines();\r\n        } catch (err) { alert(I18N.erro_importar + err); }\r\n      };\r\n      reader.readAsText(file);\r\n      input.value = \"\";\r\n    }\r\n\r\n    function switchTimeline(index) {\r\n      if (index === activeTimelineIndex) return;\r\n      /* Save current state if there's an active timeline */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n      /* Load selected timeline */\r\n      const tl = savedTimelines[index];\r\n      visoes = JSON.parse(JSON.stringify(tl.visoes));\r\n      document.getElementById(\"max_time\").value = tl.maxTime;\r\n      document.getElementById(\"timeline_range\").max = tl.maxTime;\r\n      activeTimelineIndex = index;\r\n      currentIndex = 0;\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    function deleteTimeline(index) {\r\n      if (index === activeTimelineIndex) return;\r\n      savedTimelines.splice(index, 1);\r\n      if (activeTimelineIndex > index) activeTimelineIndex--;\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    function renderSavedTimelines() {\r\n      var container = document.getElementById(\"saved_timelines_list\");\r\n      container.innerHTML = \"\";\r\n      if (savedTimelines.length === 0) { updatePlayAllButton(); return; }\r\n      var dragSrcIndex = null;\r\n\r\n      savedTimelines.forEach(function(tl, i) {\r\n        var item = document.createElement(\"div\");\r\n        item.className = \"tl-item\" + (i === activeTimelineIndex ? \" active\" : \"\");\r\n        item.draggable = true;\r\n        item.dataset.index = i;\r\n\r\n        /* Drag handle */\r\n        var handle = document.createElement(\"span\");\r\n        handle.className = \"tl-drag-handle\";\r\n        handle.innerHTML = \"&#9776;\";\r\n        item.appendChild(handle);\r\n\r\n        /* Drag events */\r\n        item.addEventListener(\"dragstart\", function(e) {\r\n          dragSrcIndex = i;\r\n          item.classList.add(\"dragging\");\r\n          e.dataTransfer.effectAllowed = \"move\";\r\n        });\r\n        item.addEventListener(\"dragover\", function(e) {\r\n          e.preventDefault();\r\n          e.dataTransfer.dropEffect = \"move\";\r\n          var rect = item.getBoundingClientRect();\r\n          var midY = rect.top + rect.height / 2;\r\n          item.classList.remove(\"drag-over-top\", \"drag-over-bottom\");\r\n          item.classList.add(e.clientY < midY ? \"drag-over-top\" : \"drag-over-bottom\");\r\n        });\r\n        item.addEventListener(\"dragleave\", function() {\r\n          item.classList.remove(\"drag-over-top\", \"drag-over-bottom\");\r\n        });\r\n        item.addEventListener(\"drop\", function(e) {\r\n          e.preventDefault();\r\n          item.classList.remove(\"drag-over-top\", \"drag-over-bottom\");\r\n          if (dragSrcIndex === null || dragSrcIndex === i) return;\r\n          var rect = item.getBoundingClientRect();\r\n          var midY = rect.top + rect.height / 2;\r\n          var targetIndex = e.clientY < midY ? i : i + 1;\r\n          if (dragSrcIndex < targetIndex) targetIndex--;\r\n          var moved = savedTimelines.splice(dragSrcIndex, 1)[0];\r\n          savedTimelines.splice(targetIndex, 0, moved);\r\n          if (activeTimelineIndex === dragSrcIndex) {\r\n            activeTimelineIndex = targetIndex;\r\n          } else if (dragSrcIndex < activeTimelineIndex && targetIndex >= activeTimelineIndex) {\r\n            activeTimelineIndex--;\r\n          } else if (dragSrcIndex > activeTimelineIndex && targetIndex <= activeTimelineIndex) {\r\n            activeTimelineIndex++;\r\n          }\r\n          renderSavedTimelines();\r\n        });\r\n        item.addEventListener(\"dragend\", function() {\r\n          item.classList.remove(\"dragging\");\r\n          dragSrcIndex = null;\r\n        });\r\n\r\n        item.onclick = function() { switchTimeline(i); };\r\n\r\n        var indicator = document.createElement(\"span\");\r\n        indicator.className = \"tl-indicator\";\r\n        item.appendChild(indicator);\r\n\r\n        var nameEl = document.createElement(\"span\");\r\n        nameEl.className = \"tl-name\";\r\n        nameEl.textContent = tl.name;\r\n        item.appendChild(nameEl);\r\n\r\n        var count = document.createElement(\"span\");\r\n        count.className = \"tl-count\";\r\n        count.textContent = tl.visoes.length + \" \" + I18N.visoes;\r\n        item.appendChild(count);\r\n\r\n        if (i !== activeTimelineIndex) {\r\n          var del = document.createElement(\"button\");\r\n          del.className = \"tl-delete\";\r\n          del.innerHTML = \"&times;\";\r\n          del.title = I18N.excluir;\r\n          del.onclick = function(e) { e.stopPropagation(); deleteTimeline(i); };\r\n          item.appendChild(del);\r\n        }\r\n\r\n        container.appendChild(item);\r\n      });\r\n\r\n      updatePlayAllButton();\r\n    }\r\n\r\n    function novaTimeline() {\r\n      abrirModalTimeline(I18N.nova_timeline, \"Time Line \" + (savedTimelines.length + 1), function(name) {\r\n        /* Salvar timeline atual na lista se pertencer a uma timeline salva */\r\n        if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n          savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n          savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n        }\r\n        /* Criar nova timeline vazia e adicioná-la à lista */\r\n        savedTimelines.push({ name: name, visoes: [], maxTime: 60 });\r\n        activeTimelineIndex = savedTimelines.length - 1;\r\n        /* Limpar estado */\r\n        visoes = [];\r\n        currentIndex = 0;\r\n        document.getElementById(\"max_time\").value = 60;\r\n        document.getElementById(\"timeline_range\").max = 60;\r\n        document.getElementById(\"timeline_range\").value = 0;\r\n        updateTime(0);\r\n        renderMarkers();\r\n        renderSavedTimelines();\r\n      });\r\n    }\r\n\r\n    /* --- Video Export with Proportional Presets --- */\r\n    function onPresetChange() {\r\n      const sel = document.getElementById(\"preset_select\");\r\n      const preview = document.getElementById(\"preset_preview\");\r\n      const customDims = document.getElementById(\"custom_dims\");\r\n      const btnRecord = document.getElementById(\"btn_record\");\r\n      const idx = parseInt(sel.value);\r\n\r\n      if (isNaN(idx)) {\r\n        customDims.classList.remove(\"visible\");\r\n        preview.style.display = \"none\";\r\n        btnRecord.disabled = true;\r\n        if (window.sketchup) window.sketchup.hide_export_preview();\r\n        return;\r\n      }\r\n\r\n      const fmt = EXPORT_FORMATS[idx];\r\n      btnRecord.disabled = false;\r\n\r\n      if (fmt.custom) {\r\n        customDims.classList.add(\"visible\");\r\n        preview.style.display = \"none\";\r\n        if (window.sketchup) window.sketchup.hide_export_preview();\r\n      } else {\r\n        customDims.classList.remove(\"visible\");\r\n        let dims;\r\n        if (fmt.ratio) {\r\n          dims = calcEffectiveDims(fmt.ratio[0], fmt.ratio[1], viewportW, viewportH);\r\n        } else {\r\n          dims = { w: viewportW % 2 === 0 ? viewportW : viewportW - 1, h: viewportH % 2 === 0 ? viewportH : viewportH - 1 };\r\n        }\r\n        preview.textContent = I18N.area_gravacao + dims.w + \" x \" + dims.h + \" px\";\r\n        preview.style.display = \"flex\";\r\n        /* Show preview overlay in viewport */\r\n        if (window.sketchup) window.sketchup.show_export_preview(dims.w, dims.h);\r\n      }\r\n    }\r\n\r\n    function getExportDimensions() {\r\n      const sel = document.getElementById(\"preset_select\");\r\n      const idx = parseInt(sel.value);\r\n      if (isNaN(idx)) return null;\r\n      const fmt = EXPORT_FORMATS[idx];\r\n      if (fmt.custom) {\r\n        return {\r\n          w: parseInt(document.getElementById(\"custom_w\").value) || 1280,\r\n          h: parseInt(document.getElementById(\"custom_h\").value) || 720\r\n        };\r\n      }\r\n      if (fmt.ratio) {\r\n        return calcEffectiveDims(fmt.ratio[0], fmt.ratio[1], viewportW, viewportH);\r\n      }\r\n      return { w: viewportW % 2 === 0 ? viewportW : viewportW - 1, h: viewportH % 2 === 0 ? viewportH : viewportH - 1 };\r\n    }\r\n\r\n    function iniciarGravacao() {\r\n      var gravarProjeto = document.getElementById(\"rec_projeto\").checked;\r\n      var desdeInicio = document.getElementById(\"rec_inicio\").checked;\r\n\r\n      if (gravarProjeto) {\r\n        syncActiveTimeline();\r\n        var temVisoes = savedTimelines.some(function(tl) { return tl.visoes.length >= 2; });\r\n        if (!temVisoes) { alert(I18N.sem_tl_min_duas); return; }\r\n      } else {\r\n        if (visoes.length < 2) { alert(I18N.min_duas_visoes); return; }\r\n      }\r\n      var dims = getExportDimensions();\r\n      if (!dims || dims.w < 50 || dims.h < 50) { alert(I18N.dims_invalidas); return; }\r\n\r\n      /* Mostrar modal de nome */\r\n      document.getElementById(\"filename_input\").value = gravarProjeto ? \"projeto_tour\" : \"tour_final\";\r\n      document.getElementById(\"filename_modal\").style.display = \"flex\";\r\n      document.getElementById(\"filename_input\").focus();\r\n      document.getElementById(\"filename_input\").select();\r\n    }\r\n\r\n    function fecharModalFilename() {\r\n      document.getElementById(\"filename_modal\").style.display = \"none\";\r\n    }\r\n\r\n    function confirmarFilename() {\r\n      var nome = document.getElementById(\"filename_input\").value.trim();\r\n      if (!nome) { alert(I18N.digite_nome); return; }\r\n      document.getElementById(\"filename_modal\").style.display = \"none\";\r\n\r\n      var gravarProjeto = document.getElementById(\"rec_projeto\").checked;\r\n      var desdeInicio = document.getElementById(\"rec_inicio\").checked;\r\n      var dims = getExportDimensions();\r\n      var startIdx = desdeInicio ? 0 : currentIndex;\r\n\r\n      if (window.sketchup) window.sketchup.hide_export_preview();\r\n\r\n      if (gravarProjeto) {\r\n        syncActiveTimeline();\r\n        var allTimelines = JSON.stringify(savedTimelines);\r\n        var startTl = desdeInicio ? 0 : activeTimelineIndex;\r\n        var startVision = desdeInicio ? 0 : currentIndex;\r\n        if (window.sketchup) {\r\n          window.sketchup.start_export_project(\r\n            allTimelines,\r\n            document.getElementById(\"easing_checkbox\").checked,\r\n            startTl,\r\n            startVision,\r\n            dims.w,\r\n            dims.h,\r\n            nome\r\n          );\r\n        }\r\n      } else {\r\n        if (window.sketchup) {\r\n          window.sketchup.start_export_process(\r\n            JSON.stringify(visoes),\r\n            document.getElementById(\"easing_checkbox\").checked,\r\n            startIdx,\r\n            dims.w,\r\n            dims.h,\r\n            nome\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    function showRecordingIndicator() {\r\n      document.getElementById(\"recording_bar\").classList.add(\"active\");\r\n    }\r\n    function hideRecordingIndicator() {\r\n      document.getElementById(\"recording_bar\").classList.remove(\"active\");\r\n    }\r\n\r\n    function instalarExportacao() {\r\n      if (window.sketchup) { window.sketchup.install_ffmpeg(); }\r\n    }\r\n\r\n    /* --- Hotkey --- */\r\n    function mostrarCampoAtalho() {\r\n      capturingHotkey = true; pendingHotkey = null;\r\n      document.getElementById(\"hotkey_input\").value = \"\";\r\n      document.getElementById(\"hotkey_edit\").classList.add(\"visible\");\r\n      document.getElementById(\"hotkey_input\").focus();\r\n    }\r\n    function capturarAtalhoInput(e) {\r\n      e.preventDefault();\r\n      /* Ignorar teclas modificadoras sozinhas */\r\n      if ([16, 17, 18, 91, 93].includes(e.keyCode)) return;\r\n      pendingHotkey = {\r\n        keyCode: e.keyCode,\r\n        ctrl: e.ctrlKey,\r\n        alt: e.altKey,\r\n        shift: e.shiftKey\r\n      };\r\n      /* Montar label legivel */\r\n      var parts = [];\r\n      if (e.ctrlKey) parts.push(\"Ctrl\");\r\n      if (e.altKey) parts.push(\"Alt\");\r\n      if (e.shiftKey) parts.push(\"Shift\");\r\n      parts.push(e.code.replace(\"Key\", \"\").replace(\"Digit\", \"\"));\r\n      document.getElementById(\"hotkey_input\").value = parts.join(\" + \");\r\n    }\r\n    function confirmarAtalho() {\r\n      if (pendingHotkey !== null) {\r\n        hotkey = pendingHotkey;\r\n        if (window.sketchup) {\r\n          window.sketchup.set_hotkey(hotkey.keyCode, hotkey.ctrl, hotkey.alt, hotkey.shift);\r\n        }\r\n      }\r\n      capturingHotkey = false;\r\n      document.getElementById(\"hotkey_edit\").classList.remove(\"visible\");\r\n    }\r\n\r\n    /* --- Global bindings --- */\r\n    window.captureVisionFromRuby = captureVisionFromRuby;\r\n    window.resetPlayButton = resetPlayButton;\r\n    window.pauseAtIndex = pauseAtIndex;\r\n    window.triggerSpaceFromRuby = triggerSpaceFromRuby;\r\n    window.showRecordingIndicator = showRecordingIndicator;\r\n    window.hideRecordingIndicator = hideRecordingIndicator;\r\n    window.updatePlayhead = updatePlayhead;\r\n    window.resetPlayAll = resetPlayAll;\r\n    window.startRecordingPlayAll = startRecordingPlayAll;\r\n    window.addEventListener(\"resize\", () => { renderMarkers(); });\r\n\r\n    document.addEventListener(\"keydown\", (e) => {\r\n      if (!capturingHotkey &&\r\n          e.keyCode === hotkey.keyCode &&\r\n          e.ctrlKey === hotkey.ctrl &&\r\n          e.altKey === hotkey.alt &&\r\n          e.shiftKey === hotkey.shift &&\r\n          ![\"INPUT\", \"TEXTAREA\"].includes(e.target.tagName)) {\r\n        e.preventDefault(); togglePlay();\r\n      }\r\n    });\r\n\r\n    /* Init */\r\n    populatePresets();\r\n    renderMarkers();\r\n</script>\r\n</body>\r\n</html>\r\nHTML\r\n\r\n      @dialog ||= UI::HtmlDialog.new({\r\n        :dialog_title => obter_texto(:titulo_dialogo),\r\n        :preferences_key => \"com.example.tour\",\r\n        :scrollable => true,\r\n        :resizable => true,\r\n        :width => 430,\r\n        :height => 790,\r\n        :style => UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n\r\n      @dialog.set_html(html)\r\n      start_space_timer\r\n\r\n      @dialog.add_action_callback(\"set_hotkey\") do |_, key_code, ctrl, alt, shift|\r\n        GlobalKey.set_hotkey(key_code.to_i, ctrl, alt, shift)\r\n        Sketchup.write_default(\"TourVirtual\", \"Hotkey\", key_code.to_i)\r\n        Sketchup.write_default(\"TourVirtual\", \"HotkeyCtrl\", ctrl ? true : false)\r\n        Sketchup.write_default(\"TourVirtual\", \"HotkeyAlt\", alt ? true : false)\r\n        Sketchup.write_default(\"TourVirtual\", \"HotkeyShift\", shift ? true : false)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"capture_camera\") do |_, time_code|\r\n        cam = Sketchup.active_model.active_view.camera\r\n        thumb = capture_thumbnail\r\n        camera_data = {\r\n          time: time_code.to_f,\r\n          eye: cam.eye.to_a,\r\n          target: cam.target.to_a,\r\n          up: cam.up.to_a,\r\n          fov: cam.fov,\r\n          perspective: cam.perspective?,\r\n          thumb: thumb,\r\n          anchor: false\r\n        }\r\n        json_str = camera_data.to_json.gsub('\"', '\\\"')\r\n        @dialog.execute_script(\"captureVisionFromRuby(\\\"#{json_str}\\\")\")\r\n      end\r\n\r\n      @dialog.add_action_callback(\"goto_camera\") do |_, cam_json|\r\n        cam_data = JSON.parse(cam_json, symbolize_names: true)\r\n        cam = Sketchup::Camera.new(cam_data[:eye], cam_data[:target], cam_data[:up], cam_data[:perspective])\r\n        cam.fov = cam_data[:fov]\r\n        Sketchup.active_model.active_view.camera = cam\r\n      end\r\n\r\n      @dialog.add_action_callback(\"play_tour\") do |_, json_data, loop_enabled, inverse_mode, use_easing, start_index|\r\n        @camera_keys = JSON.parse(json_data, symbolize_names: true)\r\n        view = Sketchup.active_model.active_view\r\n        return if @camera_keys.length < 2\r\n        @camera_keys.sort_by! { |v| v[:time] }\r\n        @index = start_index.to_i\r\n        @direction = 1\r\n        @ping_pong = loop_enabled && inverse_mode\r\n\r\n        define_singleton_method(:ease_in_out_quad) do |t|\r\n          t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t\r\n        end\r\n\r\n        define_singleton_method(:catmull_rom) do |p0, p1, p2, p3, t|\r\n          t2 = t * t\r\n          t3 = t2 * t\r\n          [\r\n            0.5 * ((2 * p1[0]) + (-p0[0] + p2[0]) * t + (2*p0[0] - 5*p1[0] + 4*p2[0] - p3[0]) * t2 + (-p0[0] + 3*p1[0] - 3*p2[0] + p3[0]) * t3),\r\n            0.5 * ((2 * p1[1]) + (-p0[1] + p2[1]) * t + (2*p0[1] - 5*p1[1] + 4*p2[1] - p3[1]) * t2 + (-p0[1] + 3*p1[1] - 3*p2[1] + p3[1]) * t3),\r\n            0.5 * ((2 * p1[2]) + (-p0[2] + p2[2]) * t + (2*p0[2] - 5*p1[2] + 4*p2[2] - p3[2]) * t2 + (-p0[2] + 3*p1[2] - 3*p2[2] + p3[2]) * t3)\r\n          ]\r\n        end\r\n\r\n        define_singleton_method(:catmull_rom_1d) do |p0, p1, p2, p3, t|\r\n          t2 = t * t\r\n          t3 = t2 * t\r\n          0.5 * ((2 * p1) + (-p0 + p2) * t + (2*p0 - 5*p1 + 4*p2 - p3) * t2 + (-p0 + 3*p1 - 3*p2 + p3) * t3)\r\n        end\r\n\r\n        define_singleton_method(:play_transition) do\r\n          current = @camera_keys[@index]\r\n          next_index = @index + @direction\r\n\r\n          if next_index >= @camera_keys.size || next_index < 0\r\n            if loop_enabled\r\n               @index = 0\r\n               UI.start_timer(0.01) { play_transition }\r\n               return\r\n            else\r\n              @dialog.execute_script(\"pauseAtIndex(0)\")\r\n              return\r\n            end\r\n          end\r\n\r\n          next_cam = @camera_keys[next_index]\r\n          duration = (next_cam[:time] - current[:time]).abs\r\n          t_start = Time.now\r\n\r\n          p0 = @camera_keys[[@index - 1, 0].max]\r\n          p1 = current\r\n          p2 = next_cam\r\n          p3 = @camera_keys[[@index + 2, @camera_keys.size - 1].min]\r\n\r\n          @walk_shake = {\r\n            z_phase: rand * Math::PI * 2, x_phase: rand * Math::PI * 2,\r\n            z_amp: 0.8 + rand * 0.4, x_amp: 0.3 + rand * 0.4\r\n          }\r\n          playhead_counter = 0\r\n\r\n          @timer_id = UI.start_timer(0.03, true) do\r\n            t_elapsed = Time.now - t_start\r\n            t = duration.zero? ? 1.0 : [t_elapsed / duration, 1.0].min\r\n            t = use_easing ? ease_in_out_quad(t) : t\r\n\r\n            # Atualizar playhead na timeline (~a cada 0.09s)\r\n            playhead_counter += 1\r\n            if playhead_counter % 3 == 0\r\n              interpolated_time = current[:time] + t * (next_cam[:time] - current[:time])\r\n              @dialog.execute_script(\"updatePlayhead(#{interpolated_time.round(1)})\")\r\n            end\r\n\r\n            eye    = catmull_rom(p0[:eye],    p1[:eye],    p2[:eye],    p3[:eye],    t)\r\n            target = catmull_rom(p0[:target], p1[:target], p2[:target], p3[:target], t)\r\n            up     = catmull_rom(p0[:up],     p1[:up],     p2[:up],     p3[:up],     t)\r\n\r\n            # Interpolação Catmull-Rom para o FOV: suavidade total acompanhando a curva da câmera\r\n            fov = catmull_rom_1d(p0[:fov], p1[:fov], p2[:fov], p3[:fov], t)\r\n\r\n            if current[:walk]\r\n              eye[2] += Math.sin(t * Math::PI * 6 + @walk_shake[:z_phase]) * @walk_shake[:z_amp]\r\n              eye[0] += Math.sin(t * Math::PI * 3 + @walk_shake[:x_phase]) * @walk_shake[:x_amp]\r\n            end\r\n\r\n            cam = Sketchup::Camera.new(eye, target, up, current[:perspective])\r\n            cam.fov = fov\r\n            view.camera = cam\r\n            view.refresh\r\n\r\n            if t >= 1.0\r\n              UI.stop_timer(@timer_id)\r\n              @index = next_index\r\n              if @camera_keys[@index][:anchor] && @index > 0\r\n                @dialog.execute_script(\"pauseAtIndex(#{@index})\")\r\n              else\r\n                play_transition\r\n              end\r\n            end\r\n          end\r\n        end\r\n\r\n        play_transition\r\n      end\r\n\r\n      # Callback de exportação com presets de resolução\r\n      @dialog.add_action_callback(\"start_export_process\") do |_, json_data, use_easing, start_index, width, height, filename|\r\n        iniciar_processo_exportacao(json_data, use_easing, start_index, width.to_i, height.to_i, filename.to_s)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"start_export_project\") do |_, all_timelines_json, use_easing, active_tl_index, start_vision_index, width, height, filename|\r\n        iniciar_processo_exportacao_projeto(all_timelines_json, use_easing, active_tl_index.to_i, start_vision_index.to_i, width.to_i, height.to_i, filename.to_s)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"install_ffmpeg\") do |_|\r\n        eval(FFMPEG_INSTALL_SCRIPT)\r\n        UI.messagebox(obter_texto(:ffmpeg_instalado))\r\n      end\r\n\r\n      @dialog.add_action_callback(\"stop_tour\") do |_|\r\n        UI.stop_timer(@timer_id) if @timer_id\r\n        @dialog.execute_script(\"resetPlayButton()\")\r\n      end\r\n\r\n      @dialog.add_action_callback(\"show_export_preview\") do |_, width, height|\r\n        @preview_tool = ExportPreviewTool.new(width.to_i, height.to_i)\r\n        Sketchup.active_model.select_tool(@preview_tool)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"hide_export_preview\") do |_|\r\n        Sketchup.active_model.select_tool(nil)\r\n        @preview_tool = nil\r\n      end\r\n\r\n      @dialog.set_on_closed {\r\n        UI.stop_timer(@timer_id) if defined?(@timer_id) && @timer_id\r\n        stop_space_timer\r\n        if @preview_tool\r\n          Sketchup.active_model.select_tool(nil)\r\n          @preview_tool = nil\r\n        end\r\n      }\r\n\r\n      @dialog.show\r\n    end\r\n  end\r\nend\r\n\r\ndef self.executar\r\n  TourPlugin::CameraTimeline.start_ui\r\nend\r\n\r\nend # module TourVirtual\r\nend # module ScriptUpComunidade\r\n\r\nScriptUpComunidade::TourVirtual.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "tour-virtual-970qu",
    "title": {
      "pt": "Tour Virtual",
      "en": "Virtual Tour",
      "es": "Visita virtual"
    },
    "author": "Fábio Coutinho",
    "version": "2.9",
    "description": {
      "pt": "Permite criar e gerenciar a criação de cenas em linha de tempo, várias linhas de tempo, apresentar a transição entre elas de forma suave e sem impacto de troca de cena e exportação de vídeo com FFMPEG de forma rápida por captura de tela enquanto apresenta.",
      "en": "It allows you to create and manage timeline scenes, multiple timelines, present the transition between them smoothly and without scene change impact, and quickly export video with FFMPEG by screen capture while presenting.",
      "es": "Le permite crear y administrar escenas de línea de tiempo, múltiples líneas de tiempo, presentar la transición entre ellas sin problemas y sin impacto en el cambio de escena, y exportar rápidamente video con FFMPEG mediante captura de pantalla mientras se presenta."
    },
    "keywords": {
      "pt": [
        "tour",
        "apresentação",
        "vídeo"
      ],
      "en": [
        "tour",
        "presentation",
        "video"
      ],
      "es": [
        "recorrido",
        "presentación",
        "video"
      ]
    },
    "code": {
      "pt": "require 'json'\r\nrequire 'sketchup.rb'\r\nrequire 'base64'\r\nrequire 'tmpdir'\r\nrequire 'fiddle/import'\r\nrequire 'fileutils'\r\nrequire 'open3'\r\nrequire 'etc'\r\nrequire 'open-uri'\r\nif Sketchup.platform == :platform_win\r\n  require 'win32ole'\r\nend\r\n\r\nmodule ScriptUpComunidade\r\nmodule TourVirtual\r\n\r\n# --- Definições de Diretórios ---\r\nplugins_root = Sketchup.find_support_file(\"Plugins\")\r\nPLUGIN_DIR = if plugins_root\r\n               File.expand_path(File.join(plugins_root, 'ScriptUp'))\r\n             else\r\n               File.expand_path(File.dirname(__FILE__))\r\n             end unless defined?(PLUGIN_DIR)\r\n\r\nIDIOMAS ||= {\r\n  'pt-BR' => {\r\n    :status_clicar_arrastar  => \"CLIQUE E ARRASTE para definir a área de gravação do vídeo.\",\r\n    :area_pequena            => \"Área muito pequena. Tente novamente.\",\r\n    :selecionar_pasta        => \"Selecione a pasta para salvar\",\r\n    :ffmpeg_nao_encontrado   => \"FFmpeg não encontrado.\",\r\n    :erro_gravador           => \"Erro ao iniciar gravador: \",\r\n    :gravacao_finalizada     => \"Gravação finalizada!\\nSalvo em: \",\r\n    :ffmpeg_instalado        => \"FFmpeg instalado. Execute o Tour Virtual novamente.\",\r\n    :titulo_dialogo          => \"Tour Virtual\",\r\n    :ffmpeg_plugins_erro     => \"Não foi possível resolver a pasta Plugins automaticamente.\",\r\n    :ffmpeg_instalar_em      => \"Instalar FFmpeg em:\",\r\n    :ffmpeg_origem           => \"Origem:\",\r\n    :ffmpeg_continuar        => \"Continuar?\",\r\n    :ffmpeg_cancelada        => \"Instalação cancelada.\",\r\n    :ffmpeg_ja_existe        => \"Já existe:\",\r\n    :ffmpeg_sobrescrever     => \"Deseja sobrescrever?\",\r\n    :ffmpeg_falha_expand     => \"Falha no Expand-Archive (PowerShell).\",\r\n    :ffmpeg_falha_unzip      => \"Falha no unzip (macOS).\",\r\n    :ffmpeg_exe_nao_encontrado => \"Executável ffmpeg não encontrado no pacote baixado.\",\r\n    :ffmpeg_sucesso          => \"FFmpeg instalado com sucesso em:\",\r\n    :ffmpeg_falhou           => \"Falhou:\",\r\n    :ffmpeg_abrindo_nav      => \"Abrindo o link no navegador...\",\r\n    :titulo                  => \"Tour Virtual\",\r\n    :subtitulo               => \"Linha do Tempo\",\r\n    :total                   => \"Total:\",\r\n    :visao                   => \"Visão\",\r\n    :play                    => \"Play\",\r\n    :stop                    => \"Stop\",\r\n    :play_all                => \"Play All\",\r\n    :stop_all                => \"Stop All\",\r\n    :atalho                  => \"Atalho\",\r\n    :pressione               => \"Pressione...\",\r\n    :ok                      => \"Ok\",\r\n    :loop                    => \"Loop\",\r\n    :easing                  => \"Easing\",\r\n    :visoes_salvas           => \"Visões salvas\",\r\n    :gerenciar_timeline      => \"Gerenciar Time Line\",\r\n    :nova                    => \"Nova\",\r\n    :exportar_atual          => \"Exportar Atual\",\r\n    :exportar_projeto        => \"Exportar Projeto\",\r\n    :importar                => \"Importar\",\r\n    :exportar_video          => \"Exportar Vídeo\",\r\n    :selecione_formato       => \"Selecione o formato…\",\r\n    :largura                 => \"Largura\",\r\n    :altura                  => \"Altura\",\r\n    :gravar_projeto          => \"Gravar todo o projeto (todas as Time Lines)\",\r\n    :iniciar_quadro1         => \"Iniciar do quadro 1\",\r\n    :iniciar_gravacao        => \"Iniciar Gravação\",\r\n    :gravando                => \"Gravando...\",\r\n    :ffmpeg_necessario       => \"FFmpeg necessário para gravar vídeo.\",\r\n    :instalar_ffmpeg         => \"Instalar FFmpeg\",\r\n    :nome_arquivo            => \"Nome do arquivo\",\r\n    :extensao_mp4            => \"A extensão .mp4 será adicionada automaticamente.\",\r\n    :cancelar                => \"Cancelar\",\r\n    :salvar                  => \"Salvar\",\r\n    :viewport_atual          => \"Viewport atual:\",\r\n    :paisagem                => \"Paisagem\",\r\n    :retrato                 => \"Retrato\",\r\n    :quadrado                => \"Quadrado\",\r\n    :classico                => \"Clássico\",\r\n    :ultra_wide              => \"Ultra-wide\",\r\n    :viewport_inteira        => \"Viewport Inteira\",\r\n    :personalizado           => \"Personalizado\",\r\n    :nome_timeline           => \"Nome da Time Line:\",\r\n    :nenhuma_visao           => \"Nenhuma visão adicionada.\",\r\n    :dica_visao              => \"Posicione a câmera e clique em <b>+ Visão</b>.\",\r\n    :ancora                  => \"Âncora\",\r\n    :excluir                 => \"Excluir\",\r\n    :min_duas_visoes         => \"Adicione pelo menos duas visões.\",\r\n    :sem_tl_2mais            => \"Nenhuma Time Line com 2+ visões.\",\r\n    :sem_visoes_exportar     => \"Nenhuma visão para exportar.\",\r\n    :sem_tl_exportar         => \"Nenhuma Time Line para exportar.\",\r\n    :importada               => \"Importada\",\r\n    :formato_invalido        => \"Formato inválido.\",\r\n    :erro_importar           => \"Erro ao importar: \",\r\n    :visoes                  => \"visões\",\r\n    :nova_timeline           => \"Nome da nova Time Line:\",\r\n    :area_gravacao           => \"Área de gravação: \",\r\n    :sem_tl_min_duas         => \"Nenhuma Time Line com pelo menos duas visões.\",\r\n    :dims_invalidas          => \"Dimensões inválidas (mínimo 50 x 50 px).\",\r\n    :digite_nome             => \"Digite um nome para o arquivo.\",\r\n  },\r\n  'en-US' => {\r\n    :status_clicar_arrastar  => \"CLICK AND DRAG to define the video recording area.\",\r\n    :area_pequena            => \"Area too small. Try again.\",\r\n    :selecionar_pasta        => \"Select folder to save\",\r\n    :ffmpeg_nao_encontrado   => \"FFmpeg not found.\",\r\n    :erro_gravador           => \"Error starting recorder: \",\r\n    :gravacao_finalizada     => \"Recording finished!\\nSaved to: \",\r\n    :ffmpeg_instalado        => \"FFmpeg installed. Run Virtual Tour again.\",\r\n    :titulo_dialogo          => \"Virtual Tour\",\r\n    :ffmpeg_plugins_erro     => \"Could not resolve the Plugins folder automatically.\",\r\n    :ffmpeg_instalar_em      => \"Install FFmpeg to:\",\r\n    :ffmpeg_origem           => \"Source:\",\r\n    :ffmpeg_continuar        => \"Continue?\",\r\n    :ffmpeg_cancelada        => \"Installation cancelled.\",\r\n    :ffmpeg_ja_existe        => \"Already exists:\",\r\n    :ffmpeg_sobrescrever     => \"Overwrite?\",\r\n    :ffmpeg_falha_expand     => \"Expand-Archive failed (PowerShell).\",\r\n    :ffmpeg_falha_unzip      => \"unzip failed (macOS).\",\r\n    :ffmpeg_exe_nao_encontrado => \"FFmpeg executable not found in downloaded package.\",\r\n    :ffmpeg_sucesso          => \"FFmpeg successfully installed to:\",\r\n    :ffmpeg_falhou           => \"Failed:\",\r\n    :ffmpeg_abrindo_nav      => \"Opening the link in browser...\",\r\n    :titulo                  => \"Virtual Tour\",\r\n    :subtitulo               => \"Timeline\",\r\n    :total                   => \"Total:\",\r\n    :visao                   => \"Vision\",\r\n    :play                    => \"Play\",\r\n    :stop                    => \"Stop\",\r\n    :play_all                => \"Play All\",\r\n    :stop_all                => \"Stop All\",\r\n    :atalho                  => \"Hotkey\",\r\n    :pressione               => \"Press a key...\",\r\n    :ok                      => \"Ok\",\r\n    :loop                    => \"Loop\",\r\n    :easing                  => \"Easing\",\r\n    :visoes_salvas           => \"Saved visions\",\r\n    :gerenciar_timeline      => \"Manage Timeline\",\r\n    :nova                    => \"New\",\r\n    :exportar_atual          => \"Export Current\",\r\n    :exportar_projeto        => \"Export Project\",\r\n    :importar                => \"Import\",\r\n    :exportar_video          => \"Export Video\",\r\n    :selecione_formato       => \"Select format…\",\r\n    :largura                 => \"Width\",\r\n    :altura                  => \"Height\",\r\n    :gravar_projeto          => \"Record entire project (all Timelines)\",\r\n    :iniciar_quadro1         => \"Start from frame 1\",\r\n    :iniciar_gravacao        => \"Start Recording\",\r\n    :gravando                => \"Recording...\",\r\n    :ffmpeg_necessario       => \"FFmpeg is required to record video.\",\r\n    :instalar_ffmpeg         => \"Install FFmpeg\",\r\n    :nome_arquivo            => \"File name\",\r\n    :extensao_mp4            => \"The .mp4 extension will be added automatically.\",\r\n    :cancelar                => \"Cancel\",\r\n    :salvar                  => \"Save\",\r\n    :viewport_atual          => \"Current viewport:\",\r\n    :paisagem                => \"Landscape\",\r\n    :retrato                 => \"Portrait\",\r\n    :quadrado                => \"Square\",\r\n    :classico                => \"Classic\",\r\n    :ultra_wide              => \"Ultra-wide\",\r\n    :viewport_inteira        => \"Full Viewport\",\r\n    :personalizado           => \"Custom\",\r\n    :nome_timeline           => \"Timeline name:\",\r\n    :nenhuma_visao           => \"No visions added.\",\r\n    :dica_visao              => \"Position the camera and click <b>+ Vision</b>.\",\r\n    :ancora                  => \"Anchor\",\r\n    :excluir                 => \"Delete\",\r\n    :min_duas_visoes         => \"Add at least two visions.\",\r\n    :sem_tl_2mais            => \"No Timeline with 2+ visions.\",\r\n    :sem_visoes_exportar     => \"No visions to export.\",\r\n    :sem_tl_exportar         => \"No Timeline to export.\",\r\n    :importada               => \"Imported\",\r\n    :formato_invalido        => \"Invalid format.\",\r\n    :erro_importar           => \"Import error: \",\r\n    :visoes                  => \"visions\",\r\n    :nova_timeline           => \"New Timeline name:\",\r\n    :area_gravacao           => \"Recording area: \",\r\n    :sem_tl_min_duas         => \"No Timeline with at least two visions.\",\r\n    :dims_invalidas          => \"Invalid dimensions (minimum 50 x 50 px).\",\r\n    :digite_nome             => \"Enter a file name.\",\r\n  },\r\n  'es' => {\r\n    :status_clicar_arrastar  => \"HAZ CLIC Y ARRASTRA para definir el área de grabación del video.\",\r\n    :area_pequena            => \"Área demasiado pequeña. Inténtalo de nuevo.\",\r\n    :selecionar_pasta        => \"Selecciona la carpeta para guardar\",\r\n    :ffmpeg_nao_encontrado   => \"FFmpeg no encontrado.\",\r\n    :erro_gravador           => \"Error al iniciar grabador: \",\r\n    :gravacao_finalizada     => \"¡Grabación finalizada!\\nGuardado en: \",\r\n    :ffmpeg_instalado        => \"FFmpeg instalado. Ejecuta Tour Virtual de nuevo.\",\r\n    :titulo_dialogo          => \"Tour Virtual\",\r\n    :ffmpeg_plugins_erro     => \"No se pudo resolver la carpeta Plugins automáticamente.\",\r\n    :ffmpeg_instalar_em      => \"Instalar FFmpeg en:\",\r\n    :ffmpeg_origem           => \"Origen:\",\r\n    :ffmpeg_continuar        => \"¿Continuar?\",\r\n    :ffmpeg_cancelada        => \"Instalación cancelada.\",\r\n    :ffmpeg_ja_existe        => \"Ya existe:\",\r\n    :ffmpeg_sobrescrever     => \"¿Sobrescribir?\",\r\n    :ffmpeg_falha_expand     => \"Error en Expand-Archive (PowerShell).\",\r\n    :ffmpeg_falha_unzip      => \"Error en unzip (macOS).\",\r\n    :ffmpeg_exe_nao_encontrado => \"Ejecutable FFmpeg no encontrado en el paquete descargado.\",\r\n    :ffmpeg_sucesso          => \"FFmpeg instalado con éxito en:\",\r\n    :ffmpeg_falhou           => \"Falló:\",\r\n    :ffmpeg_abrindo_nav      => \"Abriendo el enlace en el navegador...\",\r\n    :titulo                  => \"Tour Virtual\",\r\n    :subtitulo               => \"Línea de Tiempo\",\r\n    :total                   => \"Total:\",\r\n    :visao                   => \"Visión\",\r\n    :play                    => \"Play\",\r\n    :stop                    => \"Stop\",\r\n    :play_all                => \"Play All\",\r\n    :stop_all                => \"Stop All\",\r\n    :atalho                  => \"Atajo\",\r\n    :pressione               => \"Presiona...\",\r\n    :ok                      => \"Ok\",\r\n    :loop                    => \"Loop\",\r\n    :easing                  => \"Easing\",\r\n    :visoes_salvas           => \"Visiones guardadas\",\r\n    :gerenciar_timeline      => \"Gestionar Línea de Tiempo\",\r\n    :nova                    => \"Nueva\",\r\n    :exportar_atual          => \"Exportar Actual\",\r\n    :exportar_projeto        => \"Exportar Proyecto\",\r\n    :importar                => \"Importar\",\r\n    :exportar_video          => \"Exportar Video\",\r\n    :selecione_formato       => \"Selecciona el formato…\",\r\n    :largura                 => \"Ancho\",\r\n    :altura                  => \"Alto\",\r\n    :gravar_projeto          => \"Grabar todo el proyecto (todas las Líneas de Tiempo)\",\r\n    :iniciar_quadro1         => \"Iniciar desde el cuadro 1\",\r\n    :iniciar_gravacao        => \"Iniciar Grabación\",\r\n    :gravando                => \"Grabando...\",\r\n    :ffmpeg_necessario       => \"FFmpeg necesario para grabar video.\",\r\n    :instalar_ffmpeg         => \"Instalar FFmpeg\",\r\n    :nome_arquivo            => \"Nombre del archivo\",\r\n    :extensao_mp4            => \"La extensión .mp4 se añadirá automáticamente.\",\r\n    :cancelar                => \"Cancelar\",\r\n    :salvar                  => \"Guardar\",\r\n    :viewport_atual          => \"Viewport actual:\",\r\n    :paisagem                => \"Paisaje\",\r\n    :retrato                 => \"Retrato\",\r\n    :quadrado                => \"Cuadrado\",\r\n    :classico                => \"Clásico\",\r\n    :ultra_wide              => \"Ultra-wide\",\r\n    :viewport_inteira        => \"Viewport Completa\",\r\n    :personalizado           => \"Personalizado\",\r\n    :nome_timeline           => \"Nombre de la Línea de Tiempo:\",\r\n    :nenhuma_visao           => \"Ninguna visión añadida.\",\r\n    :dica_visao              => \"Posiciona la cámara y haz clic en <b>+ Visión</b>.\",\r\n    :ancora                  => \"Ancla\",\r\n    :excluir                 => \"Eliminar\",\r\n    :min_duas_visoes         => \"Añade al menos dos visiones.\",\r\n    :sem_tl_2mais            => \"Ninguna Línea de Tiempo con 2+ visiones.\",\r\n    :sem_visoes_exportar     => \"Ninguna visión para exportar.\",\r\n    :sem_tl_exportar         => \"Ninguna Línea de Tiempo para exportar.\",\r\n    :importada               => \"Importada\",\r\n    :formato_invalido        => \"Formato inválido.\",\r\n    :erro_importar           => \"Error al importar: \",\r\n    :visoes                  => \"visiones\",\r\n    :nova_timeline           => \"Nombre de la nueva Línea de Tiempo:\",\r\n    :area_gravacao           => \"Área de grabación: \",\r\n    :sem_tl_min_duas         => \"Ninguna Línea de Tiempo con al menos dos visiones.\",\r\n    :dims_invalidas          => \"Dimensiones inválidas (mínimo 50 x 50 px).\",\r\n    :digite_nome             => \"Escribe un nombre para el archivo.\",\r\n  },\r\n}\r\n\r\ndef self.obter_texto(chave)\r\n  locale = Sketchup.get_locale\r\n  lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n  IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\nend\r\n\r\n# --- Script de Instalação do FFmpeg (Mantido) ---\r\nFFMPEG_INSTALL_SCRIPT ||= <<~'RUBY'\r\n  require 'sketchup'\r\n  require 'open-uri'\r\n  require 'fileutils'\r\n  require 'tmpdir'\r\n\r\n  URL_WIN ||= 'https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-master-latest-win64-gpl.zip'\r\n  URL_MAC ||= 'https://evermeet.cx/ffmpeg/getrelease/zip'\r\n\r\n  win = Sketchup.platform == :platform_win\r\n  major = Sketchup.version.to_s[/^\\d+/].to_i\r\n  sketchup_year = 2000 + major\r\n\r\n  plugins_dir = Sketchup.find_support_file('Plugins')\r\n  if !plugins_dir || plugins_dir.empty? || !Dir.exist?(plugins_dir)\r\n    if win\r\n      base = ENV['APPDATA'].to_s\r\n      plugins_dir = File.join(base, 'SketchUp', \"SketchUp #{sketchup_year}\", 'SketchUp', 'Plugins')\r\n    else\r\n      plugins_dir = File.expand_path(\"~/Library/Application Support/SketchUp #{sketchup_year}/SketchUp/Plugins\")\r\n    end\r\n  end\r\n\r\n  target_dir = File.join(plugins_dir, 'ScriptUp', 'ffmpeg')\r\n  target_exe = File.join(target_dir, win ? 'ffmpeg.exe' : 'ffmpeg')\r\n  url = win ? URL_WIN : URL_MAC\r\n  default_zip_name = win ? 'ffmpeg-win64-gpl-latest.zip' : 'ffmpeg-macos-release.zip'\r\n\r\n  proceed = true\r\n\r\n  unless plugins_dir && !plugins_dir.empty?\r\n    UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_plugins_erro))\r\n    proceed = false\r\n  end\r\n\r\n  if proceed\r\n    msg = \"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_instalar_em)}\\n#{target_dir}\\n\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_origem)}\\n#{url}\\n\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_continuar)}\"\r\n    if UI.messagebox(msg, MB_YESNO) != IDYES\r\n      UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_cancelada))\r\n      proceed = false\r\n    end\r\n  end\r\n\r\n  if proceed && File.exist?(target_exe)\r\n    overwrite = UI.messagebox(\"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_ja_existe)}\\n#{target_exe}\\n\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_sobrescrever)}\", MB_YESNO)\r\n    if overwrite != IDYES\r\n      UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_cancelada))\r\n      proceed = false\r\n    end\r\n  end\r\n\r\n  if proceed\r\n    Dir.mktmpdir('ffmpeg_dl_') do |tmp|\r\n      zip_path = File.join(tmp, default_zip_name)\r\n      extract_dir = File.join(tmp, 'unzipped')\r\n      begin\r\n        URI.open(url, 'rb') do |io|\r\n          File.open(zip_path, 'wb') { |f| IO.copy_stream(io, f) }\r\n        end\r\n        Dir.mkdir(extract_dir)\r\n        if win\r\n          ps = 'powershell -NoProfile -ExecutionPolicy Bypass -Command'\r\n          cmd = \"#{ps} \\\"Expand-Archive -LiteralPath '#{zip_path}' -DestinationPath '#{extract_dir}' -Force\\\"\"\r\n          ok = system(cmd)\r\n          raise ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_falha_expand) unless ok\r\n        else\r\n          ok = system(\"unzip -o -q '#{zip_path}' -d '#{extract_dir}'\")\r\n          raise ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_falha_unzip) unless ok\r\n        end\r\n\r\n        pattern = win ? '**/ffmpeg.exe' : '**/ffmpeg'\r\n        bin = Dir.glob(File.join(extract_dir, pattern)).find { |p| File.file?(p) }\r\n        raise ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_exe_nao_encontrado) unless bin\r\n\r\n        FileUtils.mkdir_p(target_dir) unless Dir.exist?(target_dir)\r\n        FileUtils.cp(bin, target_exe)\r\n        unless win\r\n          FileUtils.chmod(0o755, target_exe)\r\n          system(\"xattr -d com.apple.quarantine '#{target_exe}' 2>/dev/null\")\r\n        end\r\n\r\n        UI.messagebox(\"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_sucesso)}\\n#{target_exe}\")\r\n        puts \"OK: #{target_exe}\"\r\n      rescue => e\r\n        UI.messagebox(\"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_falhou)} #{e.message}\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_abrindo_nav)}\")\r\n        UI.openURL(url)\r\n      end\r\n    end\r\n  end\r\nRUBY\r\n\r\n# --- Módulo WindowUtils ---\r\nmodule WindowUtils\r\n  extend Fiddle::Importer\r\n  dlload 'user32.dll' if Sketchup.platform == :platform_win\r\n\r\n  if Sketchup.platform == :platform_win\r\n    typealias 'HWND', 'void*'\r\n    extern 'HWND GetActiveWindow()'\r\n    extern 'HWND GetForegroundWindow()'\r\n    extern 'HWND GetWindow(HWND, int)'\r\n    extern 'int GetWindowRect(HWND, void*)'\r\n    extern 'HWND GetParent(HWND)'\r\n    \r\n    GW_CHILD = 5 unless defined?(GW_CHILD)\r\n    GW_HWNDNEXT = 2 unless defined?(GW_HWNDNEXT)\r\n    Rect = struct ['long left', 'long top', 'long right', 'long bottom'] unless defined?(Rect)\r\n  end\r\n\r\n  def self.get_viewport_rect_deep(view)\r\n    return nil unless Sketchup.platform == :platform_win\r\n    \r\n    hwnd = GetForegroundWindow()\r\n    return nil if hwnd.nil? || hwnd == 0\r\n\r\n    vw = view.vpwidth\r\n    vh = view.vpheight\r\n    \r\n    found = find_recursive(hwnd, vw, vh)\r\n    return found if found\r\n\r\n    parent = GetParent(hwnd)\r\n    if parent && parent != 0\r\n      found = find_recursive(parent, vw, vh)\r\n      return found if found\r\n    end\r\n\r\n    nil\r\n  end\r\n\r\n  def self.find_recursive(parent_hwnd, target_w, target_h)\r\n    child = GetWindow(parent_hwnd, GW_CHILD)\r\n    while child && child.to_i != 0\r\n      rect = Rect.malloc\r\n      if GetWindowRect(child, rect) != 0\r\n        w = rect.right - rect.left\r\n        h = rect.bottom - rect.top\r\n        match = check_match(w, h, target_w, target_h, rect)\r\n        return match if match\r\n      end\r\n      found_in_child = find_recursive(child, target_w, target_h)\r\n      return found_in_child if found_in_child\r\n      child = GetWindow(child, GW_HWNDNEXT)\r\n    end\r\n    nil\r\n  end\r\n\r\n  def self.check_match(w, h, target_w, target_h, rect)\r\n    tol = 30\r\n    [1.0, 1.25, 1.5, 2.0].each do |scale|\r\n      if (w - target_w * scale).abs <= tol && (h - target_h * scale).abs <= tol\r\n        return { :x => rect.left, :y => rect.top, :w => w, :h => h, :scale => scale }\r\n      end\r\n    end\r\n    nil\r\n  end\r\nend\r\n\r\n# --- Módulo ScreenCapture (GDI32) ---\r\n# Captures the SketchUp viewport via Win32 GDI and produces a BMP thumbnail\r\n# encoded as Base64, suitable for embedding in an HTML <img> tag.\r\n#\r\n# Uses Fiddle::Importer (Ruby stdlib) to call gdi32.dll and user32.dll functions.\r\n# Also declares PrintWindow from user32.dll as a fallback for occluded windows.\r\n#\r\n# Fiddle type mapping reference (from fiddle/types.rb Win32Types):\r\n#   HANDLE / HDC / HWND / HBITMAP  ->  void*   (pointer-sized, correct for 32/64-bit)\r\n#   DWORD                          ->  unsigned long\r\n#   BOOL                           ->  int\r\n#   UINT                           ->  unsigned int\r\n#\r\n# The extern signatures below use 'void*' directly for all handle types\r\n# (HDC, HBITMAP, HGDIOBJ) so we do not need to include Fiddle::Win32Types\r\n# or add custom typealiases beyond what WindowUtils already defines.\r\nmodule ScreenCapture\r\n  extend Fiddle::Importer\r\n\r\n  if Sketchup.platform == :platform_win\r\n    dlload 'gdi32.dll', 'user32.dll'\r\n\r\n    # --- user32.dll functions ---\r\n    # HDC GetDC(HWND hWnd)\r\n    #   hWnd=NULL(0) returns DC for entire screen\r\n    extern 'void* GetDC(void*)'\r\n\r\n    # int ReleaseDC(HWND hWnd, HDC hDC)\r\n    extern 'int ReleaseDC(void*, void*)'\r\n\r\n    # BOOL PrintWindow(HWND hwnd, HDC hdcBlt, UINT nFlags)\r\n    #   Asks the window to paint itself into the given DC.\r\n    #   Works even when the window is partially occluded (unlike BitBlt from screen DC).\r\n    extern 'int PrintWindow(void*, void*, unsigned int)'\r\n\r\n    # --- gdi32.dll functions ---\r\n    # HDC CreateCompatibleDC(HDC hdc)\r\n    extern 'void* CreateCompatibleDC(void*)'\r\n\r\n    # HBITMAP CreateCompatibleBitmap(HDC hdc, int cx, int cy)\r\n    extern 'void* CreateCompatibleBitmap(void*, int, int)'\r\n\r\n    # HGDIOBJ SelectObject(HDC hdc, HGDIOBJ h)\r\n    extern 'void* SelectObject(void*, void*)'\r\n\r\n    # BOOL BitBlt(HDC hdc, int x, int y, int cx, int cy,\r\n    #             HDC hdcSrc, int x1, int y1, DWORD rop)\r\n    extern 'int BitBlt(void*, int, int, int, int, void*, int, int, unsigned long)'\r\n\r\n    # BOOL StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest,\r\n    #                 HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop)\r\n    extern 'int StretchBlt(void*, int, int, int, int, void*, int, int, int, int, unsigned long)'\r\n\r\n    # int SetStretchBltMode(HDC hdc, int mode)\r\n    extern 'int SetStretchBltMode(void*, int)'\r\n\r\n    # int GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines,\r\n    #               LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage)\r\n    #   lpvBits and lpbmi are both void* (raw pointers to caller-allocated buffers)\r\n    extern 'int GetDIBits(void*, void*, unsigned int, unsigned int, void*, void*, unsigned int)'\r\n\r\n    # BOOL DeleteDC(HDC hdc)\r\n    extern 'int DeleteDC(void*)'\r\n\r\n    # BOOL DeleteObject(HGDIOBJ ho)\r\n    extern 'int DeleteObject(void*)'\r\n\r\n    # --- Raster-operation and mode constants ---\r\n    SRCCOPY        = 0x00CC0020 unless defined?(SRCCOPY)\r\n    HALFTONE       = 4 unless defined?(HALFTONE)          # SetStretchBltMode mode for high-quality shrinking\r\n    DIB_RGB_COLORS = 0 unless defined?(DIB_RGB_COLORS)    # GetDIBits color table usage\r\n\r\n    # --- PrintWindow flags ---\r\n    PW_CLIENTONLY          = 0x00000001 unless defined?(PW_CLIENTONLY)          # capture client area only (no title bar)\r\n    PW_RENDERFULLCONTENT   = 0x00000002 unless defined?(PW_RENDERFULLCONTENT)  # Win 8.1+: captures DirectX/DWM content\r\n  end\r\n\r\n  # Build a 40-byte BITMAPINFOHEADER as a packed binary string.\r\n  #\r\n  # The BITMAPINFOHEADER struct layout (40 bytes total):\r\n  #   DWORD  biSize          (4 bytes, unsigned 32-bit LE)   = 40\r\n  #   LONG   biWidth         (4 bytes, signed   32-bit LE)\r\n  #   LONG   biHeight        (4 bytes, signed   32-bit LE)   negative = top-down DIB\r\n  #   WORD   biPlanes        (2 bytes, unsigned 16-bit LE)   = 1\r\n  #   WORD   biBitCount      (2 bytes, unsigned 16-bit LE)   = 24 for RGB\r\n  #   DWORD  biCompression   (4 bytes, unsigned 32-bit LE)   = 0 (BI_RGB)\r\n  #   DWORD  biSizeImage     (4 bytes, unsigned 32-bit LE)\r\n  #   LONG   biXPelsPerMeter (4 bytes, signed   32-bit LE)   = 0\r\n  #   LONG   biYPelsPerMeter (4 bytes, signed   32-bit LE)   = 0\r\n  #   DWORD  biClrUsed       (4 bytes, unsigned 32-bit LE)   = 0\r\n  #   DWORD  biClrImportant  (4 bytes, unsigned 32-bit LE)   = 0\r\n  #\r\n  # Pack template: 'L<' = uint32 LE, 'l<' = int32 LE, 'S<' = uint16 LE\r\n  # Combined: 'L< l< l< S< S< L< L< l< l< L< L<'  (spaces for clarity)\r\n  #\r\n  # Using negative biHeight produces a top-down DIB, which means:\r\n  #  - Row 0 in memory is the top row of the image\r\n  #  - No vertical flip is needed when writing the BMP file\r\n  #  - The BMP file header must also use the negative height to match\r\n  def self.pack_bitmapinfoheader(width, height, image_size)\r\n    [\r\n      40,           # biSize\r\n      width,        # biWidth\r\n      -height,      # biHeight (negative = top-down)\r\n      1,            # biPlanes\r\n      24,           # biBitCount (24-bit RGB)\r\n      0,            # biCompression (BI_RGB = uncompressed)\r\n      image_size,   # biSizeImage\r\n      0,            # biXPelsPerMeter\r\n      0,            # biYPelsPerMeter\r\n      0,            # biClrUsed\r\n      0             # biClrImportant\r\n    ].pack('L<l<l<S<S<L<L<l<l<L<L<')\r\n  end\r\n\r\n  # Build the 14-byte BMP file header (BITMAPFILEHEADER).\r\n  #\r\n  # Layout:\r\n  #   WORD   bfType      = 0x4D42 (\"BM\")\r\n  #   DWORD  bfSize      = total file size in bytes\r\n  #   WORD   bfReserved1 = 0\r\n  #   WORD   bfReserved2 = 0\r\n  #   DWORD  bfOffBits   = offset to pixel data = 14 + 40 = 54\r\n  #\r\n  # Pack template: 'S< L< S< S< L<'\r\n  def self.pack_bmp_file_header(pixel_data_size)\r\n    file_size = 14 + 40 + pixel_data_size\r\n    [\r\n      0x4D42,       # bfType (\"BM\")\r\n      file_size,    # bfSize\r\n      0,            # bfReserved1\r\n      0,            # bfReserved2\r\n      54            # bfOffBits (14-byte file header + 40-byte info header)\r\n    ].pack('S<L<S<S<L<')\r\n  end\r\n\r\n  # Capture the SketchUp viewport as a scaled-down BMP thumbnail and return\r\n  # a Base64-encoded string. Returns nil on failure (non-Windows, HWND not found, etc.).\r\n  #\r\n  # Strategy:\r\n  #   1. StretchBlt from screen DC (fast, works when viewport is visible)\r\n  #   2. If vp[:hwnd] is available, PrintWindow can be used as alternative\r\n  #\r\n  # Parameters:\r\n  #   view     - Sketchup::View instance\r\n  #   thumb_w  - desired thumbnail width  in pixels (default 96)\r\n  #   thumb_h  - desired thumbnail height in pixels (default 60)\r\n  #\r\n  # Returns: Base64-encoded BMP string, or nil on failure.\r\n  def self.capture_viewport(view, thumb_w = 96, thumb_h = 60)\r\n    return nil unless Sketchup.platform == :platform_win\r\n\r\n    vp = WindowUtils.get_viewport_rect_deep(view)\r\n    return nil unless vp\r\n\r\n    src_w = vp[:w]\r\n    src_h = vp[:h]\r\n\r\n    # Get screen DC -- needed for CreateCompatibleBitmap color depth\r\n    screen_dc = GetDC(0)\r\n    return nil if screen_dc.nil? || screen_dc.to_i == 0\r\n\r\n    begin\r\n      # Create a memory DC compatible with the screen\r\n      mem_dc = CreateCompatibleDC(screen_dc)\r\n      return nil if mem_dc.nil? || mem_dc.to_i == 0\r\n\r\n      begin\r\n        # Create a bitmap at the desired thumbnail size\r\n        bmp = CreateCompatibleBitmap(screen_dc, thumb_w, thumb_h)\r\n        return nil if bmp.nil? || bmp.to_i == 0\r\n\r\n        begin\r\n          old = SelectObject(mem_dc, bmp)\r\n          SetStretchBltMode(mem_dc, HALFTONE)\r\n\r\n          # StretchBlt from the screen DC directly into the thumbnail-sized bitmap.\r\n          # This both captures AND scales in a single operation.\r\n          ok = StretchBlt(\r\n            mem_dc, 0, 0, thumb_w, thumb_h,\r\n            screen_dc, vp[:x], vp[:y], src_w, src_h,\r\n            SRCCOPY\r\n          )\r\n          return nil if ok == 0\r\n\r\n          # IMPORTANT: Deselect the bitmap from the DC before calling GetDIBits.\r\n          # Per MSDN: \"The bitmap identified by hbmp must not be selected into\r\n          # a device context when the application calls this function.\"\r\n          SelectObject(mem_dc, old)\r\n          old = nil\r\n\r\n          # Calculate row stride (BMP rows must be padded to 4-byte boundaries)\r\n          stride     = ((thumb_w * 3 + 3) & ~3)\r\n          pixel_size = stride * thumb_h\r\n\r\n          # Pack the BITMAPINFOHEADER into a Fiddle::Pointer buffer.\r\n          # GetDIBits may modify the header (e.g., filling in biSizeImage),\r\n          # so we use a mutable native buffer rather than a Ruby String.\r\n          bmi_bytes = pack_bitmapinfoheader(thumb_w, thumb_h, pixel_size)\r\n          bmi_ptr   = Fiddle::Pointer.malloc(bmi_bytes.bytesize)\r\n          bmi_ptr[0, bmi_bytes.bytesize] = bmi_bytes\r\n\r\n          # Allocate the pixel data buffer\r\n          buf = Fiddle::Pointer.malloc(pixel_size)\r\n\r\n          begin\r\n            # GetDIBits(hdc, hbm, start, cLines, lpvBits, lpbmi, usage)\r\n            # hdc: a DC compatible with the bitmap (mem_dc works)\r\n            # hbm: the bitmap handle (NOT selected into any DC)\r\n            rows = GetDIBits(mem_dc, bmp, 0, thumb_h, buf, bmi_ptr, DIB_RGB_COLORS)\r\n            return nil if rows == 0\r\n\r\n            # Read the raw pixel bytes from the Fiddle::Pointer buffer.\r\n            # ptr[offset, length] returns a Ruby String (binary safe, works since Ruby 2.0).\r\n            pixel_data = buf[0, pixel_size]\r\n\r\n            # Assemble the complete BMP file: file header + info header + pixel data\r\n            file_hdr = pack_bmp_file_header(pixel_size)\r\n            info_hdr = pack_bitmapinfoheader(thumb_w, thumb_h, pixel_size)\r\n\r\n            Base64.strict_encode64(file_hdr + info_hdr + pixel_data)\r\n          ensure\r\n            Fiddle.free(bmi_ptr) if bmi_ptr\r\n            Fiddle.free(buf)     if buf\r\n          end\r\n        ensure\r\n          SelectObject(mem_dc, old) if old\r\n          DeleteObject(bmp)\r\n        end\r\n      ensure\r\n        DeleteDC(mem_dc)\r\n      end\r\n    ensure\r\n      ReleaseDC(0, screen_dc)\r\n    end\r\n  rescue => e\r\n    puts \"ScreenCapture error: #{e.message}\"\r\n    puts e.backtrace.first(5).join(\"\\n\")\r\n    nil\r\n  end\r\nend\r\n\r\nmodule TourPlugin\r\n  class AreaSelectorTool\r\n    def initialize(callback)\r\n      @callback = callback\r\n      @start_x = nil; @start_y = nil; @current_x = nil; @current_y = nil\r\n      @drawing = false\r\n    end\r\n\r\n    def activate\r\n      Sketchup.active_model.active_view.invalidate\r\n      Sketchup.status_text = ScriptUpComunidade::TourVirtual.obter_texto(:status_clicar_arrastar)\r\n    end\r\n\r\n    def onLButtonDown(flags, x, y, view)\r\n      @start_x = x; @start_y = y; @current_x = x; @current_y = y\r\n      @drawing = true\r\n    end\r\n\r\n    def onMouseMove(flags, x, y, view)\r\n      if @drawing\r\n        @current_x = x; @current_y = y\r\n        view.invalidate\r\n      end\r\n    end\r\n\r\n    def onLButtonUp(flags, x, y, view)\r\n      return unless @drawing\r\n      @drawing = false\r\n      x1 = [@start_x, @current_x].min\r\n      y1 = [@start_y, @current_y].min\r\n      x2 = [@start_x, @current_x].max\r\n      y2 = [@start_y, @current_y].max\r\n      width = x2 - x1\r\n      height = y2 - y1\r\n\r\n      if width < 50 || height < 50\r\n        UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:area_pequena))\r\n        Sketchup.active_model.select_tool(nil)\r\n        return\r\n      end\r\n\r\n      @callback.call({ :x => x1, :y => y1, :w => width, :h => height })\r\n      Sketchup.active_model.select_tool(nil) \r\n    end\r\n\r\n    def draw(view)\r\n      return unless @drawing && @start_x && @current_x\r\n      points = [\r\n        Geom::Point3d.new(@start_x, @start_y, 0),\r\n        Geom::Point3d.new(@current_x, @start_y, 0),\r\n        Geom::Point3d.new(@current_x, @current_y, 0),\r\n        Geom::Point3d.new(@start_x, @current_y, 0)\r\n      ]\r\n      view.line_width = 3\r\n      view.drawing_color = 'red'\r\n      view.draw2d(GL_LINE_LOOP, points)\r\n    end\r\n  end\r\n\r\n  class ExportPreviewTool\r\n    def initialize(target_w, target_h)\r\n      @target_w = target_w\r\n      @target_h = target_h\r\n    end\r\n\r\n    def activate\r\n      Sketchup.active_model.active_view.invalidate\r\n    end\r\n\r\n    def deactivate(view)\r\n      view.invalidate\r\n    end\r\n\r\n    def draw(view)\r\n      vw = view.vpwidth\r\n      vh = view.vpheight\r\n      ew = [@target_w, vw].min\r\n      eh = [@target_h, vh].min\r\n      ox = (vw - ew) / 2\r\n      oy = (vh - eh) / 2\r\n\r\n      # Escurecer áreas fora da gravação (letterbox/pillarbox)\r\n      view.drawing_color = Sketchup::Color.new(0, 0, 0, 120)\r\n      if oy > 0\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(0, 0, 0), Geom::Point3d.new(vw, 0, 0),\r\n          Geom::Point3d.new(vw, oy, 0), Geom::Point3d.new(0, oy, 0)\r\n        ])\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(0, oy + eh, 0), Geom::Point3d.new(vw, oy + eh, 0),\r\n          Geom::Point3d.new(vw, vh, 0), Geom::Point3d.new(0, vh, 0)\r\n        ])\r\n      end\r\n      if ox > 0\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(0, oy, 0), Geom::Point3d.new(ox, oy, 0),\r\n          Geom::Point3d.new(ox, oy + eh, 0), Geom::Point3d.new(0, oy + eh, 0)\r\n        ])\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(ox + ew, oy, 0), Geom::Point3d.new(vw, oy, 0),\r\n          Geom::Point3d.new(vw, oy + eh, 0), Geom::Point3d.new(ox + ew, oy + eh, 0)\r\n        ])\r\n      end\r\n\r\n      # Borda branca ao redor da área de gravação\r\n      view.line_width = 2\r\n      view.drawing_color = Sketchup::Color.new(255, 255, 255, 200)\r\n      view.draw2d(GL_LINE_LOOP, [\r\n        Geom::Point3d.new(ox, oy, 0), Geom::Point3d.new(ox + ew, oy, 0),\r\n        Geom::Point3d.new(ox + ew, oy + eh, 0), Geom::Point3d.new(ox, oy + eh, 0)\r\n      ])\r\n    end\r\n  end\r\n\r\n  module CameraTimeline\r\n    def self.obter_texto(chave)\r\n      ScriptUpComunidade::TourVirtual.obter_texto(chave)\r\n    end\r\n\r\n    module GlobalKey\r\n      extend Fiddle::Importer\r\n      if Sketchup.platform == :platform_win\r\n        dlload 'user32.dll'\r\n        extern 'short GetAsyncKeyState(int)'\r\n      else\r\n        dlload '/System/Library/Frameworks/ApplicationServices.framework/ApplicationServices'\r\n        extern 'bool CGEventSourceKeyState(int, int)'\r\n      end\r\n\r\n      DEFAULT_HOTKEY = (Sketchup.platform == :platform_win ? 0x6B : 69) unless defined?(DEFAULT_HOTKEY)\r\n      @key_code = Sketchup.read_default(\"TourVirtual\", \"Hotkey\", DEFAULT_HOTKEY).to_i\r\n      @ctrl = Sketchup.read_default(\"TourVirtual\", \"HotkeyCtrl\", false)\r\n      @alt = Sketchup.read_default(\"TourVirtual\", \"HotkeyAlt\", false)\r\n      @shift = Sketchup.read_default(\"TourVirtual\", \"HotkeyShift\", false)\r\n\r\n      # Windows virtual key codes for modifiers\r\n      VK_CONTROL = 0x11 unless defined?(VK_CONTROL)\r\n      VK_MENU    = 0x12 unless defined?(VK_MENU)\r\n      VK_SHIFT   = 0x10 unless defined?(VK_SHIFT)\r\n      # macOS key codes for modifiers\r\n      MAC_CTRL  = 59 unless defined?(MAC_CTRL)\r\n      MAC_SHIFT = 56 unless defined?(MAC_SHIFT)\r\n      MAC_ALT   = 58 unless defined?(MAC_ALT)\r\n\r\n      def self.set_hotkey(code, ctrl, alt, shift)\r\n        @key_code = code.to_i\r\n        @ctrl = ctrl\r\n        @alt = alt\r\n        @shift = shift\r\n      end\r\n\r\n      def self.key_code; @key_code; end\r\n      def self.ctrl; @ctrl; end\r\n      def self.alt; @alt; end\r\n      def self.shift; @shift; end\r\n\r\n      def self.key_pressed?(code)\r\n        if Sketchup.platform == :platform_win\r\n          GetAsyncKeyState(code) & 0x8000 != 0\r\n        else\r\n          CGEventSourceKeyState(0, code)\r\n        end\r\n      end\r\n\r\n      def self.space_pressed?\r\n        return false unless key_pressed?(@key_code)\r\n        if Sketchup.platform == :platform_win\r\n          return false if @ctrl && !key_pressed?(VK_CONTROL)\r\n          return false if @alt && !key_pressed?(VK_MENU)\r\n          return false if @shift && !key_pressed?(VK_SHIFT)\r\n        else\r\n          return false if @ctrl && !key_pressed?(MAC_CTRL)\r\n          return false if @alt && !key_pressed?(MAC_ALT)\r\n          return false if @shift && !key_pressed?(MAC_SHIFT)\r\n        end\r\n        true\r\n      end\r\n    end\r\n\r\n    def self.start_space_timer\r\n      return if defined?(@space_timer) && @space_timer\r\n      @space_down = false\r\n      @space_timer = UI.start_timer(0.1, true) do\r\n        if GlobalKey.space_pressed?\r\n          unless @space_down\r\n            @space_down = true\r\n            @dialog.execute_script('triggerSpaceFromRuby()')\r\n          end\r\n        else\r\n          @space_down = false\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.stop_space_timer\r\n      if defined?(@space_timer) && @space_timer\r\n        UI.stop_timer(@space_timer)\r\n        @space_timer = nil\r\n      end\r\n    end\r\n\r\n    def self.capture_thumbnail\r\n      view = Sketchup.active_model.active_view\r\n      # Tentar screen capture instantâneo via GDI32 (Windows)\r\n      result = ScreenCapture.capture_viewport(view, 96, 60) rescue nil\r\n      return result if result && result.length > 0\r\n      # Fallback: write_image (lento, mas funciona em qualquer plataforma)\r\n      path = File.join(Dir.tmpdir, \"thumb_#{Time.now.to_i}.jpg\")\r\n      view.write_image(path, 96, 60, false, 0.5)\r\n      encoded = Base64.strict_encode64(File.binread(path))\r\n      File.delete(path) if File.exist?(path)\r\n      encoded\r\n    end\r\n\r\n    # --- Lógica de Exportação ---\r\n    def self.calcular_rect_gravacao(export_width, export_height)\r\n      view = Sketchup.active_model.active_view\r\n      viewport_global = WindowUtils.get_viewport_rect_deep(view)\r\n\r\n      unless viewport_global\r\n        viewport_global = { :x => 0, :y => 0, :w => view.vpwidth, :h => view.vpheight, :scale => 1.0 }\r\n      end\r\n\r\n      vp_w = viewport_global[:w]\r\n      vp_h = viewport_global[:h]\r\n\r\n      final_w = [export_width.to_i, vp_w].min\r\n      final_h = [export_height.to_i, vp_h].min\r\n\r\n      offset_x = viewport_global[:x] + ((vp_w - final_w) / 2).to_i\r\n      offset_y = viewport_global[:y] + ((vp_h - final_h) / 2).to_i\r\n\r\n      final_w -= 1 if final_w.odd?\r\n      final_h -= 1 if final_h.odd?\r\n\r\n      { :x => offset_x, :y => offset_y, :w => final_w, :h => final_h }\r\n    end\r\n\r\n    def self.iniciar_processo_exportacao(json_data, use_easing, start_index_from_js, export_width, export_height, filename)\r\n      effective_index = start_index_from_js.to_i\r\n\r\n      if effective_index == 0\r\n        @dialog.execute_script(\"currentIndex = 0; updateTime(0); sketchup.goto_camera(JSON.stringify(visoes[0]));\")\r\n        sleep(0.5)\r\n      end\r\n\r\n      rect = calcular_rect_gravacao(export_width, export_height)\r\n      executar_gravacao_ffmpeg(json_data, use_easing, rect, effective_index, filename)\r\n    end\r\n\r\n    def self.iniciar_processo_exportacao_projeto(all_timelines_json, use_easing, active_tl_index, start_vision_index, export_width, export_height, filename)\r\n      timelines = JSON.parse(all_timelines_json, symbolize_names: true)\r\n      rect = calcular_rect_gravacao(export_width, export_height)\r\n\r\n      start_tl = active_tl_index.to_i\r\n      start_vision = start_vision_index.to_i\r\n\r\n      # Calcular duração total a partir do ponto de início\r\n      total_time = 0.0\r\n      timelines.each_with_index do |tl, i|\r\n        next if i < start_tl\r\n        next unless tl[:visoes] && tl[:visoes].length >= 2\r\n        sorted = tl[:visoes].sort_by { |v| v[:time] }\r\n        first_v = (i == start_tl && start_vision > 0 && start_vision < sorted.length) ? start_vision : 0\r\n        if first_v < sorted.length - 1\r\n          total_time += sorted.last[:time] - sorted[first_v][:time]\r\n          total_time += 0.5\r\n        end\r\n      end\r\n\r\n      play_cmd = \"startRecordingPlayAll(#{start_tl}, #{start_vision})\"\r\n      executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, play_cmd)\r\n    end\r\n\r\n    def self.executar_gravacao_ffmpeg(json_data, use_easing, rect, start_index, filename)\r\n      camera_keys = JSON.parse(json_data, symbolize_names: true)\r\n      camera_keys.sort_by! { |v| v[:time] }\r\n\r\n      total_time = 0\r\n      if start_index < camera_keys.length - 1\r\n        relevant_keys = camera_keys[start_index..-1]\r\n        relevant_keys.each_cons(2) { |c, n| total_time += (n[:time] - c[:time]).abs }\r\n      end\r\n\r\n      executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, \"triggerSpaceFromRuby()\")\r\n    end\r\n\r\n    def self.executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, play_command)\r\n      folder = UI.select_directory(title: obter_texto(:selecionar_pasta))\r\n      return unless folder\r\n\r\n      output_path = File.join(folder, \"#{filename}.mp4\")\r\n\r\n      is_win = Sketchup.platform == :platform_win\r\n      ffmpeg_path = File.join(PLUGIN_DIR, 'ffmpeg', is_win ? 'ffmpeg.exe' : 'ffmpeg')\r\n\r\n      unless File.exist?(ffmpeg_path)\r\n        UI.messagebox(obter_texto(:ffmpeg_nao_encontrado))\r\n        return\r\n      end\r\n\r\n      duration_padding = 4.0\r\n      recording_duration = total_time + duration_padding\r\n\r\n      input_format = is_win ? 'gdigrab' : 'avfoundation'\r\n      input_source = is_win ? 'desktop' : '1:none'\r\n\r\n      cmd_array = [\r\n        \"\\\"#{ffmpeg_path}\\\"\",\r\n        '-y',\r\n        '-f', input_format,\r\n        '-framerate', '30',\r\n        '-t', recording_duration.to_s\r\n      ]\r\n\r\n      if is_win\r\n        cmd_array.concat([\r\n          '-draw_mouse', '0',\r\n          '-offset_x', rect[:x].to_s,\r\n          '-offset_y', rect[:y].to_s,\r\n          '-video_size', \"#{rect[:w]}x#{rect[:h]}\",\r\n          '-i', input_source\r\n        ])\r\n      else\r\n        cmd_array.concat([\r\n          '-i', input_source,\r\n          '-vf', \"crop=#{rect[:w]}:#{rect[:h]}:#{rect[:x]}:#{rect[:y]}\"\r\n        ])\r\n      end\r\n\r\n      cmd_array.concat([\r\n        '-c:v', 'libx264',\r\n        '-preset', 'ultrafast',\r\n        '-pix_fmt', 'yuv420p',\r\n        \"\\\"#{output_path}\\\"\"\r\n      ])\r\n\r\n      cmd = cmd_array.join(' ')\r\n\r\n      begin\r\n        if is_win\r\n           WIN32OLE.new('WScript.Shell').Run(cmd, 0, false)\r\n        else\r\n           pid = spawn(cmd)\r\n           Process.detach(pid)\r\n        end\r\n      rescue => e\r\n        UI.messagebox(\"#{obter_texto(:erro_gravador)}#{e.message}\")\r\n        return\r\n      end\r\n\r\n      sleep(1.5)\r\n\r\n      @dialog.execute_script(\"showRecordingIndicator()\")\r\n      @dialog.execute_script(play_command)\r\n\r\n      UI.start_timer(recording_duration + 1.0, false) do\r\n        @dialog.execute_script(\"hideRecordingIndicator()\")\r\n        UI.messagebox(\"#{obter_texto(:gravacao_finalizada)}#{output_path}\")\r\n        @dialog.execute_script(\"resetPlayButton(); resetPlayAll();\")\r\n      end\r\n    end\r\n\r\n    def self.start_ui\r\n      current_hotkey = GlobalKey.key_code\r\n      hotkey_ctrl = GlobalKey.ctrl ? 'true' : 'false'\r\n      hotkey_alt = GlobalKey.alt ? 'true' : 'false'\r\n      hotkey_shift = GlobalKey.shift ? 'true' : 'false'\r\n      ffmpeg_path = File.join(PLUGIN_DIR, 'ffmpeg', Sketchup.platform == :platform_win ? 'ffmpeg.exe' : 'ffmpeg')\r\n      \r\n      has_ffmpeg = File.exist?(ffmpeg_path)\r\n\r\n      view = Sketchup.active_model.active_view\r\n      vp_width = view.vpwidth\r\n      vp_height = view.vpheight\r\n\r\n      js_i18n_hash = {}\r\n      IDIOMAS[IDIOMAS.key?(Sketchup.get_locale) ? Sketchup.get_locale : 'en-US'].each { |k, v| js_i18n_hash[k] = v }\r\n      js_i18n_json = js_i18n_hash.to_json\r\n\r\n      html = <<-HTML\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n  <meta charset=\"utf-8\">\r\n  <title>#{obter_texto(:titulo)}</title>\r\n  <style>\r\n    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }\r\n    body {\r\n      font-family: system-ui, -apple-system, 'Segoe UI', sans-serif;\r\n      background: #f5f5f5; color: #333; font-size: 13px;\r\n      padding: 16px; line-height: 1.4;\r\n    }\r\n\r\n    /* Header */\r\n    .header {\r\n      display: flex; align-items: center; gap: 10px;\r\n      padding-bottom: 14px; border-bottom: 2px solid #0066cc;\r\n      margin-bottom: 16px;\r\n    }\r\n    .header svg { flex-shrink: 0; }\r\n    .header h1 { font-size: 17px; font-weight: 700; color: #1a1a1a; }\r\n    .header .subtitle { font-size: 11px; color: #888; font-weight: 400; }\r\n\r\n    /* Cards */\r\n    .card {\r\n      background: #fff; border: 1px solid #e0e0e0; border-radius: 8px;\r\n      box-shadow: 0 1px 3px rgba(0,0,0,0.06); margin-bottom: 12px;\r\n      overflow: hidden;\r\n    }\r\n    .card-header {\r\n      display: flex; align-items: center; justify-content: space-between;\r\n      padding: 10px 14px; background: #fafafa; border-bottom: 1px solid #eee;\r\n      cursor: pointer; user-select: none;\r\n    }\r\n    .card-header h2 { font-size: 13px; font-weight: 600; color: #444; }\r\n    .card-header .toggle-icon { font-size: 11px; color: #999; transition: transform 0.2s; }\r\n    .card-header.collapsed .toggle-icon { transform: rotate(-90deg); }\r\n    .card-body { padding: 14px; }\r\n    .card-body.collapsed { display: none; }\r\n\r\n    /* Timeline */\r\n    .timeline-wrapper { position: relative; padding: 8px 0 20px; }\r\n    .timeline-track {\r\n      position: absolute; top: 20px; left: 6px; right: 6px; height: 4px;\r\n      background: #ddd; border-radius: 2px; z-index: 0;\r\n    }\r\n    #timeline_range {\r\n      -webkit-appearance: none; appearance: none; width: 100%;\r\n      height: 6px; background: transparent; outline: none;\r\n      position: relative; z-index: 2; cursor: pointer;\r\n    }\r\n    #timeline_range::-webkit-slider-runnable-track {\r\n      height: 6px; background: linear-gradient(90deg, #0066cc 0%, #4da6ff 100%);\r\n      border-radius: 3px;\r\n    }\r\n    #timeline_range::-webkit-slider-thumb {\r\n      -webkit-appearance: none; width: 16px; height: 16px;\r\n      background: #0066cc; border: 2px solid #fff; border-radius: 50%;\r\n      margin-top: -5px; cursor: grab; box-shadow: 0 1px 4px rgba(0,0,0,0.2);\r\n    }\r\n    #timeline_range::-webkit-slider-thumb:active { cursor: grabbing; transform: scale(1.15); }\r\n    #markers_layer {\r\n      position: absolute; top: 0; left: 0; width: 100%; height: 40px;\r\n      pointer-events: none; z-index: 3;\r\n    }\r\n    .marker {\r\n      position: absolute; top: 26px; width: 14px; height: 14px;\r\n      background: #0066cc; border-radius: 50%; border: 2px solid #fff;\r\n      transform: translateX(-50%); pointer-events: auto; cursor: pointer;\r\n      box-shadow: 0 1px 3px rgba(0,0,0,0.15); transition: transform 0.15s, background 0.15s;\r\n    }\r\n    .marker:hover { transform: translateX(-50%) scale(1.25); }\r\n    .marker.anchor { background: #dc3545; }\r\n    .marker .marker-tooltip {\r\n      position: absolute; bottom: 18px; left: 50%; transform: translateX(-50%);\r\n      background: #333; color: #fff; font-size: 10px; padding: 2px 6px;\r\n      border-radius: 3px; white-space: nowrap; opacity: 0;\r\n      pointer-events: none; transition: opacity 0.15s;\r\n    }\r\n    .marker:hover .marker-tooltip { opacity: 1; }\r\n    .time-row {\r\n      display: flex; align-items: center; justify-content: space-between;\r\n      margin-top: 8px; gap: 12px;\r\n    }\r\n    .time-display { font-size: 20px; font-weight: 700; color: #0066cc; font-variant-numeric: tabular-nums; }\r\n    .time-display small { font-size: 12px; color: #888; font-weight: 400; }\r\n    .time-input-group { display: flex; align-items: center; gap: 6px; }\r\n    .time-input-group label { font-size: 11px; color: #666; }\r\n\r\n    /* Buttons */\r\n    .btn {\r\n      display: inline-flex; align-items: center; justify-content: center; gap: 6px;\r\n      padding: 7px 14px; border: 1px solid transparent; border-radius: 6px;\r\n      font-size: 12px; font-weight: 500; cursor: pointer;\r\n      transition: all 0.15s; outline: none; font-family: inherit;\r\n    }\r\n    .btn:active { transform: scale(0.97); }\r\n    .btn-primary { background: #0066cc; color: #fff; }\r\n    .btn-primary:hover { background: #0052a3; }\r\n    .btn-success { background: #28a745; color: #fff; }\r\n    .btn-success:hover { background: #218838; }\r\n    .btn-danger { background: #dc3545; color: #fff; }\r\n    .btn-danger:hover { background: #c82333; }\r\n    .btn-outline { background: transparent; border: 1px solid #ccc; color: #555; }\r\n    .btn-outline:hover { background: #f0f0f0; border-color: #aaa; }\r\n    .btn-sm { padding: 4px 10px; font-size: 11px; }\r\n    .btn-record { background: #dc3545; color: #fff; padding: 10px 20px; font-size: 13px; font-weight: 600; }\r\n    .btn-record:hover { background: #c82333; }\r\n    .btn-record:disabled { background: #ccc; color: #888; cursor: not-allowed; }\r\n\r\n    .btn-group { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }\r\n\r\n    /* Checkboxes */\r\n    .check-group { display: flex; align-items: center; gap: 16px; margin-top: 10px; }\r\n    .check-item { display: flex; align-items: center; gap: 5px; }\r\n    .check-item input[type=\"checkbox\"] {\r\n      width: 15px; height: 15px; accent-color: #0066cc; cursor: pointer;\r\n    }\r\n    .check-item label { font-size: 12px; color: #555; cursor: pointer; }\r\n\r\n    /* Hotkey */\r\n    .hotkey-editor {\r\n      display: none; align-items: center; gap: 6px;\r\n      background: #f9f9f9; padding: 6px 10px; border-radius: 6px; border: 1px solid #ddd;\r\n    }\r\n    .hotkey-editor.visible { display: inline-flex; }\r\n    .hotkey-editor input {\r\n      width: 100px; padding: 4px 8px; border: 1px solid #ccc;\r\n      border-radius: 4px; font-size: 12px; font-family: monospace;\r\n      outline: none;\r\n    }\r\n    .hotkey-editor input:focus { border-color: #0066cc; }\r\n\r\n    /* Vision List */\r\n    .vision-list { max-height: 350px; overflow-y: auto; }\r\n    .vision-list::-webkit-scrollbar { width: 6px; }\r\n    .vision-list::-webkit-scrollbar-track { background: #f0f0f0; border-radius: 3px; }\r\n    .vision-list::-webkit-scrollbar-thumb { background: #ccc; border-radius: 3px; }\r\n    .vision-list::-webkit-scrollbar-thumb:hover { background: #aaa; }\r\n    .vision-item {\r\n      display: flex; align-items: center; gap: 10px; padding: 8px 10px;\r\n      border-bottom: 1px solid #f0f0f0; cursor: pointer;\r\n      transition: background 0.12s;\r\n    }\r\n    .vision-item:hover { background: #f7faff; }\r\n    .vision-item:last-child { border-bottom: none; }\r\n    .vision-item .vision-num {\r\n      font-size: 11px; font-weight: 700; color: #999; width: 20px;\r\n      text-align: center; flex-shrink: 0;\r\n    }\r\n    .vision-item img {\r\n      width: 72px; height: 45px; object-fit: cover; border-radius: 4px;\r\n      border: 1px solid #ddd; flex-shrink: 0;\r\n    }\r\n    .vision-item img.thumb-placeholder {\r\n      background: linear-gradient(135deg, #e0e0e0 0%, #c0c0c0 100%);\r\n      animation: pulse-placeholder 1s ease-in-out infinite alternate;\r\n    }\r\n    @keyframes pulse-placeholder {\r\n      from { opacity: 0.6; }\r\n      to { opacity: 1.0; }\r\n    }\r\n    .vision-item .vision-info { flex: 1; min-width: 0; }\r\n    .vision-item .vision-time-input {\r\n      width: 58px; padding: 3px 6px; border: 1px solid #ddd; border-radius: 4px;\r\n      font-size: 12px; text-align: center; outline: none; font-family: inherit;\r\n    }\r\n    .vision-item .vision-time-input:focus { border-color: #0066cc; }\r\n    .vision-item .vision-time-input:disabled { background: #f5f5f5; color: #999; }\r\n    .vision-actions { display: flex; align-items: center; gap: 6px; flex-shrink: 0; }\r\n    .anchor-toggle {\r\n      width: 26px; height: 26px; border-radius: 50%; border: 2px solid #ddd;\r\n      background: transparent; cursor: pointer; display: flex;\r\n      align-items: center; justify-content: center; transition: all 0.15s;\r\n      font-size: 12px; color: #ccc;\r\n    }\r\n    .anchor-toggle:hover { border-color: #dc3545; color: #dc3545; }\r\n    .anchor-toggle.active { background: #dc3545; border-color: #dc3545; color: #fff; }\r\n    .delete-btn {\r\n      width: 26px; height: 26px; border-radius: 50%; border: 1px solid #eee;\r\n      background: transparent; cursor: pointer; display: flex;\r\n      align-items: center; justify-content: center; transition: all 0.15s;\r\n      font-size: 14px; color: #ccc;\r\n    }\r\n    .delete-btn:hover { background: #fee; border-color: #dc3545; color: #dc3545; }\r\n    .empty-state {\r\n      text-align: center; padding: 30px 16px; color: #aaa;\r\n    }\r\n    .empty-state svg { margin-bottom: 8px; opacity: 0.4; }\r\n    .empty-state p { font-size: 12px; }\r\n\r\n    /* Export Section */\r\n    .preset-select {\r\n      width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px;\r\n      font-size: 12px; font-family: inherit; outline: none; background: #fff;\r\n      cursor: pointer; color: #333;\r\n    }\r\n    .preset-select:focus { border-color: #0066cc; }\r\n    .preset-preview {\r\n      display: flex; align-items: center; justify-content: center;\r\n      padding: 8px; margin-top: 8px; background: #f7faff;\r\n      border: 1px dashed #b3d4fc; border-radius: 6px;\r\n      font-size: 12px; color: #0066cc; font-weight: 600;\r\n    }\r\n    .custom-dims {\r\n      display: none; gap: 8px; align-items: center; margin-top: 8px;\r\n    }\r\n    .custom-dims.visible { display: flex; }\r\n    .custom-dims input {\r\n      width: 80px; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px;\r\n      font-size: 12px; text-align: center; outline: none; font-family: inherit;\r\n    }\r\n    .custom-dims input:focus { border-color: #0066cc; }\r\n    .custom-dims span { color: #999; font-weight: 600; }\r\n\r\n    /* Recording indicator */\r\n    .recording-bar {\r\n      display: none; align-items: center; gap: 8px; padding: 10px 14px;\r\n      background: #fff5f5; border: 1px solid #f5c6cb; border-radius: 6px;\r\n      margin-top: 10px;\r\n    }\r\n    .recording-bar.active { display: flex; }\r\n    .recording-dot {\r\n      width: 10px; height: 10px; background: #dc3545; border-radius: 50%;\r\n      animation: pulse 1s infinite;\r\n    }\r\n    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }\r\n    .recording-bar span { font-size: 12px; color: #dc3545; font-weight: 600; }\r\n\r\n    /* Playing overlay */\r\n    body.playing .card { opacity: 0.6; pointer-events: none; }\r\n    body.playing .card.playback-card { opacity: 1; pointer-events: auto; }\r\n    body.playing .card.playback-card .btn:not(#play_button):not(#play_all_button) { pointer-events: none; opacity: 0.4; }\r\n    body.playing #play_button, body.playing #play_all_button { pointer-events: auto !important; opacity: 1 !important; }\r\n\r\n    /* Input base */\r\n    input[type=\"number\"] {\r\n      -moz-appearance: textfield;\r\n    }\r\n    input[type=\"number\"]::-webkit-inner-spin-button {\r\n      -webkit-appearance: none;\r\n    }\r\n\r\n    /* Draggable markers */\r\n    .marker { cursor: grab; }\r\n    .marker.dragging {\r\n      transform: translateX(-50%) scale(1.3);\r\n      z-index: 20;\r\n      cursor: grabbing;\r\n    }\r\n    .marker.no-drag { cursor: default; }\r\n\r\n    /* Saved timelines list */\r\n    .saved-timelines-list { margin-top: 10px; }\r\n    .saved-timelines-list:empty { display: none; }\r\n    .tl-item {\r\n      display: flex; align-items: center; gap: 8px;\r\n      padding: 6px 10px; border-bottom: 1px solid #f0f0f0;\r\n      cursor: pointer; transition: background 0.12s; font-size: 12px;\r\n    }\r\n    .tl-item:hover { background: #f7faff; }\r\n    .tl-item:last-child { border-bottom: none; }\r\n    .tl-item .tl-indicator {\r\n      width: 8px; height: 8px; border-radius: 50%;\r\n      background: #ccc; flex-shrink: 0;\r\n    }\r\n    .tl-item.active .tl-indicator { background: #0066cc; }\r\n    .tl-item .tl-name { flex: 1; font-weight: 500; color: #333; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }\r\n    .tl-item .tl-count { color: #999; font-size: 11px; flex-shrink: 0; }\r\n    .tl-item .tl-delete {\r\n      width: 20px; height: 20px; border-radius: 50%; border: 1px solid #eee;\r\n      background: transparent; cursor: pointer; display: flex;\r\n      align-items: center; justify-content: center; font-size: 12px; color: #ccc;\r\n      flex-shrink: 0; transition: all 0.15s;\r\n    }\r\n    .tl-item .tl-delete:hover { background: #fee; border-color: #dc3545; color: #dc3545; }\r\n\r\n    /* Drag-and-drop for timeline reordering */\r\n    .tl-drag-handle {\r\n      cursor: grab; flex-shrink: 0; color: #ccc; font-size: 14px;\r\n      padding: 0 4px; user-select: none;\r\n    }\r\n    .tl-drag-handle:active { cursor: grabbing; }\r\n    .tl-item.dragging { opacity: 0.4; }\r\n    .tl-item.drag-over-top { border-top: 2px solid #0066cc; }\r\n    .tl-item.drag-over-bottom { border-bottom: 2px solid #0066cc; }\r\n\r\n    /* Viewport info */\r\n    .viewport-info {\r\n      font-size: 11px; color: #666; margin-bottom: 10px;\r\n      padding: 6px 10px; background: #f9f9f9; border-radius: 4px; border: 1px solid #eee;\r\n    }\r\n\r\n    /* Misc */\r\n    .hidden { display: none !important; }\r\n    .mt-8 { margin-top: 8px; }\r\n  </style>\r\n</head>\r\n<body>\r\n\r\n<!-- Header -->\r\n<div class=\"header\">\r\n  <svg width=\"28\" height=\"28\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"#0066cc\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <path d=\"M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z\"/>\r\n    <circle cx=\"12\" cy=\"13\" r=\"4\"/>\r\n  </svg>\r\n  <div>\r\n    <h1>#{obter_texto(:titulo)}</h1>\r\n    <span class=\"subtitle\">#{obter_texto(:subtitulo)}</span>\r\n  </div>\r\n</div>\r\n\r\n<!-- Timeline Card -->\r\n<div class=\"card\">\r\n  <div class=\"card-body\">\r\n    <div class=\"timeline-wrapper\">\r\n      <div class=\"timeline-track\"></div>\r\n      <input type=\"range\" min=\"0\" max=\"60\" step=\"0.1\" value=\"0\" id=\"timeline_range\" oninput=\"updateTime(this.value)\">\r\n      <div id=\"markers_layer\"></div>\r\n    </div>\r\n    <div class=\"time-row\">\r\n      <div class=\"time-display\"><span id=\"current_time\">0.0</span><small>s</small></div>\r\n      <div class=\"time-input-group\">\r\n        <label>#{obter_texto(:total)}</label>\r\n        <input id=\"max_time\" type=\"number\" step=\"1\" value=\"60\" min=\"1\" onchange=\"atualizarTempoTotal()\"\r\n          style=\"width:65px; padding:4px 8px; border:1px solid #ddd; border-radius:4px; font-size:12px; text-align:center; outline:none; font-family:inherit;\">\r\n        <small style=\"color:#888;\">s</small>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Playback Controls Card -->\r\n<div class=\"card playback-card\">\r\n  <div class=\"card-body\">\r\n    <div class=\"btn-group\">\r\n      <button class=\"btn btn-primary\" onclick=\"addVision()\">\r\n        <svg width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2.5\"><line x1=\"12\" y1=\"5\" x2=\"12\" y2=\"19\"/><line x1=\"5\" y1=\"12\" x2=\"19\" y2=\"12\"/></svg>\r\n        #{obter_texto(:visao)}\r\n      </button>\r\n      <button id=\"play_button\" class=\"btn btn-success\" onclick=\"togglePlay()\">&#9654; #{obter_texto(:play)}</button>\r\n      <button id=\"play_all_button\" class=\"btn btn-outline btn-sm hidden\" onclick=\"togglePlayAll()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><polygon points=\"5 3 19 12 5 21 5 3\"/><line x1=\"19\" y1=\"3\" x2=\"19\" y2=\"21\"/></svg>\r\n        #{obter_texto(:play_all)}\r\n      </button>\r\n      <button class=\"btn btn-outline btn-sm\" onclick=\"mostrarCampoAtalho()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><rect x=\"2\" y=\"4\" width=\"20\" height=\"16\" rx=\"2\"/><line x1=\"6\" y1=\"8\" x2=\"6\" y2=\"8\"/><line x1=\"10\" y1=\"8\" x2=\"10\" y2=\"8\"/><line x1=\"14\" y1=\"8\" x2=\"14\" y2=\"8\"/><line x1=\"18\" y1=\"8\" x2=\"18\" y2=\"8\"/><line x1=\"8\" y1=\"16\" x2=\"16\" y2=\"16\"/></svg>\r\n        #{obter_texto(:atalho)}\r\n      </button>\r\n      <span id=\"hotkey_edit\" class=\"hotkey-editor\">\r\n        <input id=\"hotkey_input\" type=\"text\" placeholder=\"#{obter_texto(:pressione)}\" onkeydown=\"capturarAtalhoInput(event)\">\r\n        <button class=\"btn btn-primary btn-sm\" onclick=\"confirmarAtalho()\">#{obter_texto(:ok)}</button>\r\n      </span>\r\n    </div>\r\n    <div class=\"check-group\">\r\n      <div class=\"check-item\">\r\n        <input type=\"checkbox\" id=\"loop_checkbox\">\r\n        <label for=\"loop_checkbox\">#{obter_texto(:loop)}</label>\r\n      </div>\r\n      <div class=\"check-item\">\r\n        <input type=\"checkbox\" id=\"easing_checkbox\">\r\n        <label for=\"easing_checkbox\">#{obter_texto(:easing)}</label>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Visions Card -->\r\n<div class=\"card\">\r\n  <div class=\"card-header\" onclick=\"toggleSection('visions')\">\r\n    <h2>#{obter_texto(:visoes_salvas)} <span id=\"vision_count\" style=\"color:#999; font-weight:400;\"></span></h2>\r\n    <span class=\"toggle-icon\" id=\"visions_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body\" id=\"visions_body\">\r\n    <div class=\"vision-list\" id=\"lista_visoes\"></div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Gerenciar Time Line Card -->\r\n<div class=\"card\">\r\n  <div class=\"card-header\" onclick=\"toggleSection('timeline_mgr')\">\r\n    <h2>#{obter_texto(:gerenciar_timeline)}</h2>\r\n    <span class=\"toggle-icon\" id=\"timeline_mgr_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body\" id=\"timeline_mgr_body\">\r\n    <div class=\"btn-group\">\r\n      <button class=\"btn btn-outline\" onclick=\"novaTimeline()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z\"/><polyline points=\"14 2 14 8 20 8\"/><line x1=\"12\" y1=\"18\" x2=\"12\" y2=\"12\"/><line x1=\"9\" y1=\"15\" x2=\"15\" y2=\"15\"/></svg>\r\n        #{obter_texto(:nova)}\r\n      </button>\r\n      <button class=\"btn btn-outline\" onclick=\"exportarTimeline()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\"/><polyline points=\"7 10 12 15 17 10\"/><line x1=\"12\" y1=\"15\" x2=\"12\" y2=\"3\"/></svg>\r\n        #{obter_texto(:exportar_atual)}\r\n      </button>\r\n      <button class=\"btn btn-outline\" onclick=\"exportarProjeto()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z\"/><polyline points=\"9 14 12 17 15 14\"/><line x1=\"12\" y1=\"17\" x2=\"12\" y2=\"10\"/></svg>\r\n        #{obter_texto(:exportar_projeto)}\r\n      </button>\r\n      <input type=\"file\" id=\"import_file\" class=\"hidden\" accept=\".json\" onchange=\"importarTimeline(this)\">\r\n      <button class=\"btn btn-outline\" onclick=\"document.getElementById('import_file').click()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\"/><polyline points=\"17 8 12 3 7 8\"/><line x1=\"12\" y1=\"3\" x2=\"12\" y2=\"15\"/></svg>\r\n        #{obter_texto(:importar)}\r\n      </button>\r\n    </div>\r\n    <div id=\"saved_timelines_list\" class=\"saved-timelines-list\"></div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Exportar Vídeo Card (colapsado por padrão) -->\r\n<div class=\"card\">\r\n  <div class=\"card-header collapsed\" onclick=\"toggleSection('export')\">\r\n    <h2>#{obter_texto(:exportar_video)}</h2>\r\n    <span class=\"toggle-icon\" id=\"export_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body collapsed\" id=\"export_body\">\r\n    <div id=\"ffmpeg_section\" class=\"#{has_ffmpeg ? '' : 'hidden'}\">\r\n      <div class=\"viewport-info\">\r\n        #{obter_texto(:viewport_atual)} <strong>#{vp_width} x #{vp_height} px</strong>\r\n      </div>\r\n\r\n      <select id=\"preset_select\" class=\"preset-select\" onchange=\"onPresetChange()\">\r\n        <option value=\"\" disabled selected>#{obter_texto(:selecione_formato)}</option>\r\n      </select>\r\n\r\n      <div class=\"custom-dims\" id=\"custom_dims\">\r\n        <input type=\"number\" id=\"custom_w\" min=\"50\" placeholder=\"#{obter_texto(:largura)}\" value=\"1280\">\r\n        <span>x</span>\r\n        <input type=\"number\" id=\"custom_h\" min=\"50\" placeholder=\"#{obter_texto(:altura)}\" value=\"720\">\r\n        <small style=\"color:#888;\">px</small>\r\n      </div>\r\n\r\n      <div class=\"preset-preview\" id=\"preset_preview\" style=\"display:none;\"></div>\r\n\r\n      <div class=\"check-group\" style=\"margin-top:12px; flex-direction:column; align-items:flex-start; gap:8px;\">\r\n        <div class=\"check-item\">\r\n          <input type=\"checkbox\" id=\"rec_projeto\">\r\n          <label for=\"rec_projeto\">#{obter_texto(:gravar_projeto)}</label>\r\n        </div>\r\n        <div class=\"check-item\">\r\n          <input type=\"checkbox\" id=\"rec_inicio\" checked>\r\n          <label for=\"rec_inicio\">#{obter_texto(:iniciar_quadro1)}</label>\r\n        </div>\r\n      </div>\r\n\r\n      <button class=\"btn btn-record mt-8\" id=\"btn_record\" onclick=\"iniciarGravacao()\" disabled style=\"width:100%; margin-top:12px;\">\r\n        <svg width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><circle cx=\"12\" cy=\"12\" r=\"4\" fill=\"currentColor\"/></svg>\r\n        #{obter_texto(:iniciar_gravacao)}\r\n      </button>\r\n\r\n      <div class=\"recording-bar\" id=\"recording_bar\">\r\n        <div class=\"recording-dot\"></div>\r\n        <span>#{obter_texto(:gravando)}</span>\r\n      </div>\r\n    </div>\r\n\r\n    <div id=\"ffmpeg_install\" class=\"#{has_ffmpeg ? 'hidden' : ''}\" style=\"text-align:center; padding:12px 0;\">\r\n      <p style=\"color:#888; font-size:12px; margin-bottom:10px;\">#{obter_texto(:ffmpeg_necessario)}</p>\r\n      <button class=\"btn btn-primary\" onclick=\"instalarExportacao()\">#{obter_texto(:instalar_ffmpeg)}</button>\r\n    </div>\r\n\r\n    <!-- Modal de nome do arquivo -->\r\n    <div id=\"filename_modal\" style=\"display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.4);z-index:100;align-items:center;justify-content:center;\">\r\n      <div style=\"background:#fff;border-radius:10px;padding:24px;width:320px;box-shadow:0 8px 30px rgba(0,0,0,0.2);\">\r\n        <h3 style=\"font-size:14px;font-weight:600;color:#333;margin-bottom:12px;\">#{obter_texto(:nome_arquivo)}</h3>\r\n        <input id=\"filename_input\" type=\"text\" value=\"tour_final\" style=\"width:100%;padding:8px 12px;border:1px solid #ddd;border-radius:6px;font-size:13px;font-family:inherit;outline:none;margin-bottom:6px;\">\r\n        <small style=\"color:#888;\">#{obter_texto(:extensao_mp4)}</small>\r\n        <div style=\"display:flex;gap:8px;margin-top:16px;justify-content:flex-end;\">\r\n          <button class=\"btn btn-outline btn-sm\" onclick=\"fecharModalFilename()\">#{obter_texto(:cancelar)}</button>\r\n          <button class=\"btn btn-primary btn-sm\" onclick=\"confirmarFilename()\">#{obter_texto(:salvar)}</button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Modal de nome da timeline -->\r\n<div id=\"timeline_name_modal\" style=\"display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.4);z-index:100;align-items:center;justify-content:center;\">\r\n  <div style=\"background:#fff;border-radius:10px;padding:24px;width:320px;box-shadow:0 8px 30px rgba(0,0,0,0.2);\">\r\n    <h3 id=\"timeline_name_title\" style=\"font-size:14px;font-weight:600;color:#333;margin-bottom:12px;\"></h3>\r\n    <input id=\"timeline_name_input\" type=\"text\" onkeydown=\"if(event.keyCode===13){confirmarModalTimeline();}\" style=\"width:100%;padding:8px 12px;border:1px solid #ddd;border-radius:6px;font-size:13px;font-family:inherit;outline:none;margin-bottom:6px;\">\r\n    <div style=\"display:flex;gap:8px;margin-top:16px;justify-content:flex-end;\">\r\n      <button class=\"btn btn-outline btn-sm\" onclick=\"fecharModalTimeline()\">#{obter_texto(:cancelar)}</button>\r\n      <button class=\"btn btn-primary btn-sm\" onclick=\"confirmarModalTimeline()\">#{obter_texto(:ok)}</button>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<script>\r\n    const I18N = #{js_i18n_json};\r\n    let visoes = [], playing = false, currentIndex = 0;\r\n    let hotkey = { keyCode: #{current_hotkey}, ctrl: #{hotkey_ctrl}, alt: #{hotkey_alt}, shift: #{hotkey_shift} };\r\n    let capturingHotkey = false, pendingHotkey = null;\r\n    let savedTimelines = [];\r\n    let activeTimelineIndex = -1;\r\n    let playingAll = false, playAllQueue = [], playAllCurrentIdx = 0;\r\n    var viewportW = #{vp_width}, viewportH = #{vp_height};\r\n\r\n    if (window.sketchup) { window.sketchup.set_hotkey(hotkey.keyCode, hotkey.ctrl, hotkey.alt, hotkey.shift); }\r\n\r\n    /* --- Export Formats (aspect ratios) --- */\r\n    const EXPORT_FORMATS = [\r\n      { label: '16:9 ' + I18N.paisagem, ratio: [16, 9] },\r\n      { label: '9:16 ' + I18N.retrato, ratio: [9, 16] },\r\n      { label: '1:1 ' + I18N.quadrado, ratio: [1, 1] },\r\n      { label: '4:3 ' + I18N.classico, ratio: [4, 3] },\r\n      { label: '21:9 ' + I18N.ultra_wide, ratio: [21, 9] },\r\n      { label: I18N.viewport_inteira, ratio: null },\r\n      { label: I18N.personalizado, ratio: null, custom: true }\r\n    ];\r\n\r\n    function calcEffectiveDims(ratioW, ratioH, vpW, vpH) {\r\n      const scaleW = vpW / ratioW;\r\n      const scaleH = vpH / ratioH;\r\n      const scale = Math.min(scaleW, scaleH);\r\n      let w = Math.floor(ratioW * scale);\r\n      let h = Math.floor(ratioH * scale);\r\n      w = w % 2 === 0 ? w : w - 1;\r\n      h = h % 2 === 0 ? h : h - 1;\r\n      return { w: w, h: h };\r\n    }\r\n\r\n    function populatePresets() {\r\n      const sel = document.getElementById(\"preset_select\");\r\n      sel.innerHTML = '<option value=\"\" disabled selected>' + I18N.selecione_formato + '</option>';\r\n      EXPORT_FORMATS.forEach((fmt, i) => {\r\n        const opt = document.createElement(\"option\");\r\n        opt.value = i.toString();\r\n        if (fmt.custom) {\r\n          opt.textContent = fmt.label;\r\n        } else if (fmt.ratio) {\r\n          const dims = calcEffectiveDims(fmt.ratio[0], fmt.ratio[1], viewportW, viewportH);\r\n          opt.textContent = fmt.label + \" (\" + dims.w + \" x \" + dims.h + \" px)\";\r\n        } else {\r\n          let w = viewportW % 2 === 0 ? viewportW : viewportW - 1;\r\n          let h = viewportH % 2 === 0 ? viewportH : viewportH - 1;\r\n          opt.textContent = fmt.label + \" (\" + w + \" x \" + h + \" px)\";\r\n        }\r\n        sel.appendChild(opt);\r\n      });\r\n    }\r\n\r\n    /* --- Section Toggle --- */\r\n    function toggleSection(name) {\r\n      const body = document.getElementById(name + '_body');\r\n      const icon = document.getElementById(name + '_toggle');\r\n      const header = icon.parentElement;\r\n      const wasCollapsed = body.classList.contains('collapsed');\r\n      if (wasCollapsed) {\r\n        body.classList.remove('collapsed');\r\n        header.classList.remove('collapsed');\r\n      } else {\r\n        body.classList.add('collapsed');\r\n        header.classList.add('collapsed');\r\n      }\r\n      /* Hide viewport preview when closing export card */\r\n      if (name === 'export' && !wasCollapsed) {\r\n        if (window.sketchup) window.sketchup.hide_export_preview();\r\n      }\r\n    }\r\n\r\n    /* --- Timeline --- */\r\n    function updateTime(val) {\r\n      document.getElementById(\"current_time\").innerText = parseFloat(val).toFixed(1);\r\n    }\r\n\r\n    function atualizarTempoTotal() {\r\n      const novoMax = parseFloat(document.getElementById(\"max_time\").value);\r\n      if (isNaN(novoMax) || novoMax <= 0) return;\r\n      document.getElementById(\"timeline_range\").max = novoMax;\r\n      visoes.forEach(v => { if (v.time > novoMax) v.time = novoMax - 0.1; });\r\n      renderMarkers();\r\n    }\r\n\r\n    /* --- Timeline Name Modal --- */\r\n    var _timelineModalCallback = null;\r\n\r\n    function abrirModalTimeline(titulo, valorPadrao, callback) {\r\n      _timelineModalCallback = callback;\r\n      document.getElementById(\"timeline_name_title\").textContent = titulo;\r\n      var input = document.getElementById(\"timeline_name_input\");\r\n      input.value = valorPadrao;\r\n      var modal = document.getElementById(\"timeline_name_modal\");\r\n      modal.style.display = \"flex\";\r\n      setTimeout(function() { input.focus(); input.select(); }, 50);\r\n    }\r\n\r\n    function fecharModalTimeline() {\r\n      document.getElementById(\"timeline_name_modal\").style.display = \"none\";\r\n      _timelineModalCallback = null;\r\n    }\r\n\r\n    function confirmarModalTimeline() {\r\n      var name = document.getElementById(\"timeline_name_input\").value.trim();\r\n      if (!name) return;\r\n      document.getElementById(\"timeline_name_modal\").style.display = \"none\";\r\n      if (_timelineModalCallback) {\r\n        _timelineModalCallback(name);\r\n        _timelineModalCallback = null;\r\n      }\r\n    }\r\n\r\n    /* --- Visions --- */\r\n    function addVision() {\r\n      if (savedTimelines.length === 0 && visoes.length === 0) {\r\n        abrirModalTimeline(I18N.nome_timeline, \"Time Line 1\", function(name) {\r\n          savedTimelines.push({ name: name, visoes: [], maxTime: 60 });\r\n          activeTimelineIndex = 0;\r\n          renderSavedTimelines();\r\n          var time = parseFloat(document.getElementById(\"timeline_range\").value);\r\n          sketchup.capture_camera(time);\r\n        });\r\n        return;\r\n      }\r\n      var time = parseFloat(document.getElementById(\"timeline_range\").value);\r\n      sketchup.capture_camera(time);\r\n    }\r\n\r\n    function captureVisionFromRuby(camJson) {\r\n      const obj = JSON.parse(camJson);\r\n      obj.walk = false; obj.anchor = false;\r\n      visoes = visoes.filter(v => v.time !== obj.time);\r\n      visoes.push(obj);\r\n      visoes.sort((a, b) => a.time - b.time);\r\n      visoes[0].time = 0.0;\r\n      syncActiveTimeline();\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    /* --- Draggable markers --- */\r\n    function setupMarkerDrag(marker, visionIndex, slider, maxTime) {\r\n      if (visionIndex === 0) {\r\n        marker.classList.add(\"no-drag\");\r\n        return;\r\n      }\r\n      marker.addEventListener(\"mousedown\", function(e) {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        marker.classList.add(\"dragging\");\r\n        const sliderPadding = 8;\r\n\r\n        function onMove(ev) {\r\n          const sliderRect = slider.getBoundingClientRect();\r\n          const usableWidth = sliderRect.width - sliderPadding * 2;\r\n          const relativeX = Math.max(0, Math.min(ev.clientX - sliderRect.left - sliderPadding, usableWidth));\r\n          const newTime = parseFloat(((relativeX / usableWidth) * maxTime).toFixed(1));\r\n          marker.style.left = (relativeX + sliderPadding) + \"px\";\r\n          const tooltip = marker.querySelector(\".marker-tooltip\");\r\n          if (tooltip) tooltip.textContent = newTime.toFixed(1) + \"s\";\r\n        }\r\n\r\n        function onUp(ev) {\r\n          marker.classList.remove(\"dragging\");\r\n          document.removeEventListener(\"mousemove\", onMove);\r\n          document.removeEventListener(\"mouseup\", onUp);\r\n          const sliderRect = slider.getBoundingClientRect();\r\n          const usableWidth = sliderRect.width - sliderPadding * 2;\r\n          const relativeX = Math.max(0, Math.min(ev.clientX - sliderRect.left - sliderPadding, usableWidth));\r\n          const newTime = parseFloat(((relativeX / usableWidth) * maxTime).toFixed(1));\r\n          visoes[visionIndex].time = Math.max(0.1, newTime);\r\n          visoes.sort((a, b) => a.time - b.time);\r\n          if (visoes.length > 0) visoes[0].time = 0.0;\r\n          renderMarkers();\r\n        }\r\n\r\n        document.addEventListener(\"mousemove\", onMove);\r\n        document.addEventListener(\"mouseup\", onUp);\r\n      });\r\n    }\r\n\r\n    function syncActiveTimeline() {\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n    }\r\n\r\n    function renderMarkers() {\r\n      const layer = document.getElementById(\"markers_layer\");\r\n      const lista = document.getElementById(\"lista_visoes\");\r\n      const slider = document.getElementById(\"timeline_range\");\r\n      const max = parseFloat(slider.max);\r\n      const width = slider.offsetWidth;\r\n      const countEl = document.getElementById(\"vision_count\");\r\n\r\n      layer.innerHTML = \"\"; lista.innerHTML = \"\";\r\n      countEl.textContent = visoes.length > 0 ? \"(\" + visoes.length + \")\" : \"\";\r\n\r\n      if (visoes.length === 0) {\r\n        lista.innerHTML = '<div class=\"empty-state\">' +\r\n          '<svg width=\"36\" height=\"36\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"#ccc\" stroke-width=\"1.5\"><path d=\"M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z\"/><circle cx=\"12\" cy=\"13\" r=\"4\"/></svg>' +\r\n          '<p>' + I18N.nenhuma_visao + '<br>' + I18N.dica_visao + '</p></div>';\r\n        return;\r\n      }\r\n\r\n      visoes.forEach((v, i) => {\r\n        /* Marker on timeline */\r\n        const percent = max > 0 ? v.time / max : 0;\r\n        const marker = document.createElement(\"div\");\r\n        marker.className = \"marker\" + (v.anchor ? \" anchor\" : \"\");\r\n        const sliderPadding = 8;\r\n        const usableWidth = width - sliderPadding * 2;\r\n        marker.style.left = (percent * usableWidth + sliderPadding) + \"px\";\r\n        const tooltip = document.createElement(\"span\");\r\n        tooltip.className = \"marker-tooltip\";\r\n        tooltip.textContent = v.time.toFixed(1) + \"s\";\r\n        marker.appendChild(tooltip);\r\n        marker.onclick = () => {\r\n          slider.value = v.time; updateTime(v.time); currentIndex = i;\r\n          resetPlayButton(); sketchup.goto_camera(JSON.stringify(v));\r\n        };\r\n        /* Draggable */\r\n        setupMarkerDrag(marker, i, slider, max);\r\n        layer.appendChild(marker);\r\n\r\n        /* Vision list item */\r\n        const item = document.createElement(\"div\");\r\n        item.className = \"vision-item\";\r\n        item.onclick = () => {\r\n          slider.value = v.time; updateTime(v.time); currentIndex = i;\r\n          resetPlayButton(); sketchup.goto_camera(JSON.stringify(v));\r\n        };\r\n\r\n        const num = document.createElement(\"span\");\r\n        num.className = \"vision-num\";\r\n        num.textContent = (i + 1);\r\n\r\n        const img = document.createElement(\"img\");\r\n        if (v.thumb && v.thumb.length > 0) {\r\n          const mime = v.thumb.startsWith(\"/9j/\") ? \"image/jpeg\" : \"image/bmp\";\r\n          img.src = \"data:\" + mime + \";base64,\" + v.thumb;\r\n        } else {\r\n          img.src = \"\";\r\n          img.className = \"thumb-placeholder\";\r\n        }\r\n\r\n        const info = document.createElement(\"div\");\r\n        info.className = \"vision-info\";\r\n        const timeInput = document.createElement(\"input\");\r\n        timeInput.type = \"number\"; timeInput.step = \"0.1\";\r\n        timeInput.value = v.time.toFixed(1);\r\n        timeInput.className = \"vision-time-input\";\r\n        timeInput.disabled = (i === 0);\r\n        timeInput.onclick = (e) => e.stopPropagation();\r\n        timeInput.onchange = () => {\r\n          v.time = parseFloat(timeInput.value);\r\n          visoes.sort((a, b) => a.time - b.time);\r\n          renderMarkers();\r\n        };\r\n        info.appendChild(timeInput);\r\n\r\n        const actions = document.createElement(\"div\");\r\n        actions.className = \"vision-actions\";\r\n\r\n        const anchorBtn = document.createElement(\"button\");\r\n        anchorBtn.className = \"anchor-toggle\" + (v.anchor ? \" active\" : \"\");\r\n        anchorBtn.innerHTML = \"&#9875;\";\r\n        anchorBtn.title = I18N.ancora;\r\n        anchorBtn.onclick = (e) => {\r\n          e.stopPropagation();\r\n          v.anchor = !v.anchor;\r\n          renderMarkers();\r\n        };\r\n        actions.appendChild(anchorBtn);\r\n\r\n        const delBtn = document.createElement(\"button\");\r\n        delBtn.className = \"delete-btn\";\r\n        delBtn.innerHTML = \"&times;\";\r\n        delBtn.title = I18N.excluir;\r\n        delBtn.onclick = (e) => {\r\n          e.stopPropagation();\r\n          visoes.splice(i, 1);\r\n          if (visoes.length > 0) visoes[0].time = 0.0;\r\n          syncActiveTimeline();\r\n          renderMarkers();\r\n          renderSavedTimelines();\r\n        };\r\n        actions.appendChild(delBtn);\r\n\r\n        item.appendChild(num);\r\n        item.appendChild(img);\r\n        item.appendChild(info);\r\n        item.appendChild(actions);\r\n        lista.appendChild(item);\r\n      });\r\n    }\r\n\r\n    /* --- Playback --- */\r\n    function togglePlay() {\r\n      if (!playing) {\r\n        if (visoes.length < 2) return alert(I18N.min_duas_visoes);\r\n        if (currentIndex >= visoes.length - 1) currentIndex = 0;\r\n        playing = true;\r\n        document.body.classList.add(\"playing\");\r\n        document.getElementById(\"play_button\").innerHTML = \"&#9724; \" + I18N.stop;\r\n        document.getElementById(\"play_button\").className = \"btn btn-danger\";\r\n        sketchup.play_tour(JSON.stringify(visoes), document.getElementById(\"loop_checkbox\").checked, false, document.getElementById(\"easing_checkbox\").checked, currentIndex);\r\n      } else {\r\n        resetPlayButton();\r\n        sketchup.stop_tour();\r\n      }\r\n    }\r\n\r\n    function resetPlayButton() {\r\n      playing = false;\r\n      document.body.classList.remove(\"playing\");\r\n      document.getElementById(\"play_button\").innerHTML = \"&#9654; \" + I18N.play;\r\n      document.getElementById(\"play_button\").className = \"btn btn-success\";\r\n    }\r\n\r\n    function togglePlayAll() {\r\n      if (playingAll) {\r\n        resetPlayAll();\r\n        sketchup.stop_tour();\r\n        return;\r\n      }\r\n      if (savedTimelines.length < 2) return;\r\n      /* Save current timeline state */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n      /* Build queue of timelines with 2+ visions */\r\n      playAllQueue = savedTimelines.map(function(tl, i) { return i; }).filter(function(i) { return savedTimelines[i].visoes.length >= 2; });\r\n      if (playAllQueue.length < 1) { alert(I18N.sem_tl_2mais); return; }\r\n      playingAll = true;\r\n      playAllCurrentIdx = 0;\r\n      document.body.classList.add(\"playing\");\r\n      document.getElementById(\"play_all_button\").innerHTML = \"&#9724; \" + I18N.stop_all;\r\n      document.getElementById(\"play_all_button\").className = \"btn btn-danger btn-sm\";\r\n      playTimelineAtQueueIndex(0);\r\n    }\r\n\r\n    function playTimelineAtQueueIndex(qIdx) {\r\n      var tlIdx = playAllQueue[qIdx];\r\n      var tl = savedTimelines[tlIdx];\r\n      visoes = JSON.parse(JSON.stringify(tl.visoes));\r\n      document.getElementById(\"max_time\").value = tl.maxTime;\r\n      document.getElementById(\"timeline_range\").max = tl.maxTime;\r\n      activeTimelineIndex = tlIdx;\r\n      currentIndex = 0;\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n      sketchup.play_tour(\r\n        JSON.stringify(visoes),\r\n        false,\r\n        false,\r\n        document.getElementById(\"easing_checkbox\").checked,\r\n        0\r\n      );\r\n    }\r\n\r\n    function resetPlayAll() {\r\n      playingAll = false;\r\n      playAllQueue = [];\r\n      playAllCurrentIdx = 0;\r\n      document.body.classList.remove(\"playing\");\r\n      var btn = document.getElementById(\"play_all_button\");\r\n      btn.innerHTML = '<svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><polygon points=\"5 3 19 12 5 21 5 3\"/><line x1=\"19\" y1=\"3\" x2=\"19\" y2=\"21\"/></svg> ' + I18N.play_all;\r\n      btn.className = \"btn btn-outline btn-sm\";\r\n      playing = false;\r\n      document.getElementById(\"play_button\").innerHTML = \"&#9654; \" + I18N.play;\r\n      document.getElementById(\"play_button\").className = \"btn btn-success\";\r\n    }\r\n\r\n    function startRecordingPlayAll(startTlIdx, startVisionIdx) {\r\n      syncActiveTimeline();\r\n      /* Montar fila de timelines com 2+ visões, a partir de startTlIdx */\r\n      playAllQueue = [];\r\n      for (var i = startTlIdx; i < savedTimelines.length; i++) {\r\n        if (savedTimelines[i].visoes.length >= 2) playAllQueue.push(i);\r\n      }\r\n      if (playAllQueue.length === 0) return;\r\n\r\n      playingAll = true;\r\n      playAllCurrentIdx = 0;\r\n      playing = true;\r\n      document.body.classList.add(\"playing\");\r\n      document.getElementById(\"play_button\").innerHTML = \"&#9724; \" + I18N.stop;\r\n      document.getElementById(\"play_button\").className = \"btn btn-danger\";\r\n\r\n      /* Carregar a primeira timeline da fila */\r\n      var firstTlIdx = playAllQueue[0];\r\n      var tl = savedTimelines[firstTlIdx];\r\n      visoes = JSON.parse(JSON.stringify(tl.visoes));\r\n      document.getElementById(\"max_time\").value = tl.maxTime;\r\n      document.getElementById(\"timeline_range\").max = tl.maxTime;\r\n      activeTimelineIndex = firstTlIdx;\r\n      currentIndex = startVisionIdx;\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n\r\n      sketchup.play_tour(\r\n        JSON.stringify(visoes),\r\n        false,\r\n        false,\r\n        document.getElementById(\"easing_checkbox\").checked,\r\n        startVisionIdx\r\n      );\r\n    }\r\n\r\n    function updatePlayAllButton() {\r\n      var btn = document.getElementById(\"play_all_button\");\r\n      if (savedTimelines.length > 1) {\r\n        btn.classList.remove(\"hidden\");\r\n      } else {\r\n        btn.classList.add(\"hidden\");\r\n      }\r\n    }\r\n\r\n    function pauseAtIndex(idx) {\r\n      currentIndex = idx;\r\n      if (playingAll) {\r\n        playAllCurrentIdx++;\r\n        if (playAllCurrentIdx < playAllQueue.length) {\r\n          playTimelineAtQueueIndex(playAllCurrentIdx);\r\n          return;\r\n        } else {\r\n          resetPlayAll();\r\n          return;\r\n        }\r\n      }\r\n      resetPlayButton();\r\n    }\r\n    function triggerSpaceFromRuby() { togglePlay(); }\r\n    function updatePlayhead(time) {\r\n      var slider = document.getElementById(\"timeline_range\");\r\n      slider.value = time;\r\n      document.getElementById(\"current_time\").innerText = parseFloat(time).toFixed(1);\r\n    }\r\n\r\n    /* --- Timeline Management --- */\r\n    function exportarTimeline() {\r\n      if (visoes.length === 0) { alert(I18N.sem_visoes_exportar); return; }\r\n      var tlName = (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length)\r\n        ? savedTimelines[activeTimelineIndex].name : \"Time Line\";\r\n      /* Download JSON */\r\n      var dataStr = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(visoes, null, 2));\r\n      var a = document.createElement(\"a\");\r\n      a.setAttribute(\"href\", dataStr);\r\n      a.setAttribute(\"download\", tlName.replace(/[^a-zA-Z0-9_-]/g, \"_\") + \".json\");\r\n      document.body.appendChild(a); a.click(); a.remove();\r\n      /* Salvar na lista */\r\n      saveCurrentToTimelines(tlName);\r\n    }\r\n\r\n    function exportarProjeto() {\r\n      syncActiveTimeline();\r\n      if (savedTimelines.length === 0) { alert(I18N.sem_tl_exportar); return; }\r\n      var projeto = { type: \"tour_virtual_project\", timelines: savedTimelines };\r\n      var dataStr = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(projeto, null, 2));\r\n      var a = document.createElement(\"a\");\r\n      a.setAttribute(\"href\", dataStr);\r\n      a.setAttribute(\"download\", \"projeto_tour_virtual.json\");\r\n      document.body.appendChild(a); a.click(); a.remove();\r\n    }\r\n\r\n    function saveCurrentToTimelines(name) {\r\n      var maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      var entry = { name: name, visoes: JSON.parse(JSON.stringify(visoes)), maxTime: maxTime };\r\n      /* Atualizar existente se ativo, senão adicionar novo */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex] = entry;\r\n      } else {\r\n        savedTimelines.push(entry);\r\n        activeTimelineIndex = savedTimelines.length - 1;\r\n      }\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    function importarTimeline(input) {\r\n      var file = input.files[0];\r\n      if (!file) return;\r\n      var reader = new FileReader();\r\n      reader.onload = function(e) {\r\n        try {\r\n          var imported = JSON.parse(e.target.result);\r\n          /* Detectar se é um projeto completo */\r\n          if (imported && imported.type === \"tour_virtual_project\" && Array.isArray(imported.timelines)) {\r\n            syncActiveTimeline();\r\n            imported.timelines.forEach(function(tl) {\r\n              if (tl.visoes) {\r\n                tl.visoes.sort(function(a, b) { return a.time - b.time; });\r\n                if (tl.visoes.length > 0) tl.visoes[0].time = 0.0;\r\n              }\r\n              savedTimelines.push({ name: tl.name || I18N.importada, visoes: tl.visoes || [], maxTime: tl.maxTime || 60 });\r\n            });\r\n            if (savedTimelines.length > 0 && activeTimelineIndex < 0) {\r\n              activeTimelineIndex = 0;\r\n              var first = savedTimelines[0];\r\n              visoes = JSON.parse(JSON.stringify(first.visoes));\r\n              document.getElementById(\"max_time\").value = first.maxTime;\r\n              document.getElementById(\"timeline_range\").max = first.maxTime;\r\n              renderMarkers();\r\n            }\r\n            renderSavedTimelines();\r\n            return;\r\n          }\r\n          /* Time Line única */\r\n          if (!Array.isArray(imported)) throw I18N.formato_invalido;\r\n          imported.sort(function(a, b) { return a.time - b.time; });\r\n          if (imported.length > 0) imported[0].time = 0.0;\r\n          var maxTime = imported.length > 0 ? Math.ceil(imported[imported.length - 1].time + 1) : 60;\r\n          var name = file.name.replace(/\\\\.json$/i, \"\");\r\n          savedTimelines.push({ name: name, visoes: imported, maxTime: maxTime });\r\n          renderSavedTimelines();\r\n        } catch (err) { alert(I18N.erro_importar + err); }\r\n      };\r\n      reader.readAsText(file);\r\n      input.value = \"\";\r\n    }\r\n\r\n    function switchTimeline(index) {\r\n      if (index === activeTimelineIndex) return;\r\n      /* Save current state if there's an active timeline */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n      /* Load selected timeline */\r\n      const tl = savedTimelines[index];\r\n      visoes = JSON.parse(JSON.stringify(tl.visoes));\r\n      document.getElementById(\"max_time\").value = tl.maxTime;\r\n      document.getElementById(\"timeline_range\").max = tl.maxTime;\r\n      activeTimelineIndex = index;\r\n      currentIndex = 0;\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    function deleteTimeline(index) {\r\n      if (index === activeTimelineIndex) return;\r\n      savedTimelines.splice(index, 1);\r\n      if (activeTimelineIndex > index) activeTimelineIndex--;\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    function renderSavedTimelines() {\r\n      var container = document.getElementById(\"saved_timelines_list\");\r\n      container.innerHTML = \"\";\r\n      if (savedTimelines.length === 0) { updatePlayAllButton(); return; }\r\n      var dragSrcIndex = null;\r\n\r\n      savedTimelines.forEach(function(tl, i) {\r\n        var item = document.createElement(\"div\");\r\n        item.className = \"tl-item\" + (i === activeTimelineIndex ? \" active\" : \"\");\r\n        item.draggable = true;\r\n        item.dataset.index = i;\r\n\r\n        /* Drag handle */\r\n        var handle = document.createElement(\"span\");\r\n        handle.className = \"tl-drag-handle\";\r\n        handle.innerHTML = \"&#9776;\";\r\n        item.appendChild(handle);\r\n\r\n        /* Drag events */\r\n        item.addEventListener(\"dragstart\", function(e) {\r\n          dragSrcIndex = i;\r\n          item.classList.add(\"dragging\");\r\n          e.dataTransfer.effectAllowed = \"move\";\r\n        });\r\n        item.addEventListener(\"dragover\", function(e) {\r\n          e.preventDefault();\r\n          e.dataTransfer.dropEffect = \"move\";\r\n          var rect = item.getBoundingClientRect();\r\n          var midY = rect.top + rect.height / 2;\r\n          item.classList.remove(\"drag-over-top\", \"drag-over-bottom\");\r\n          item.classList.add(e.clientY < midY ? \"drag-over-top\" : \"drag-over-bottom\");\r\n        });\r\n        item.addEventListener(\"dragleave\", function() {\r\n          item.classList.remove(\"drag-over-top\", \"drag-over-bottom\");\r\n        });\r\n        item.addEventListener(\"drop\", function(e) {\r\n          e.preventDefault();\r\n          item.classList.remove(\"drag-over-top\", \"drag-over-bottom\");\r\n          if (dragSrcIndex === null || dragSrcIndex === i) return;\r\n          var rect = item.getBoundingClientRect();\r\n          var midY = rect.top + rect.height / 2;\r\n          var targetIndex = e.clientY < midY ? i : i + 1;\r\n          if (dragSrcIndex < targetIndex) targetIndex--;\r\n          var moved = savedTimelines.splice(dragSrcIndex, 1)[0];\r\n          savedTimelines.splice(targetIndex, 0, moved);\r\n          if (activeTimelineIndex === dragSrcIndex) {\r\n            activeTimelineIndex = targetIndex;\r\n          } else if (dragSrcIndex < activeTimelineIndex && targetIndex >= activeTimelineIndex) {\r\n            activeTimelineIndex--;\r\n          } else if (dragSrcIndex > activeTimelineIndex && targetIndex <= activeTimelineIndex) {\r\n            activeTimelineIndex++;\r\n          }\r\n          renderSavedTimelines();\r\n        });\r\n        item.addEventListener(\"dragend\", function() {\r\n          item.classList.remove(\"dragging\");\r\n          dragSrcIndex = null;\r\n        });\r\n\r\n        item.onclick = function() { switchTimeline(i); };\r\n\r\n        var indicator = document.createElement(\"span\");\r\n        indicator.className = \"tl-indicator\";\r\n        item.appendChild(indicator);\r\n\r\n        var nameEl = document.createElement(\"span\");\r\n        nameEl.className = \"tl-name\";\r\n        nameEl.textContent = tl.name;\r\n        item.appendChild(nameEl);\r\n\r\n        var count = document.createElement(\"span\");\r\n        count.className = \"tl-count\";\r\n        count.textContent = tl.visoes.length + \" \" + I18N.visoes;\r\n        item.appendChild(count);\r\n\r\n        if (i !== activeTimelineIndex) {\r\n          var del = document.createElement(\"button\");\r\n          del.className = \"tl-delete\";\r\n          del.innerHTML = \"&times;\";\r\n          del.title = I18N.excluir;\r\n          del.onclick = function(e) { e.stopPropagation(); deleteTimeline(i); };\r\n          item.appendChild(del);\r\n        }\r\n\r\n        container.appendChild(item);\r\n      });\r\n\r\n      updatePlayAllButton();\r\n    }\r\n\r\n    function novaTimeline() {\r\n      abrirModalTimeline(I18N.nova_timeline, \"Time Line \" + (savedTimelines.length + 1), function(name) {\r\n        /* Salvar timeline atual na lista se pertencer a uma timeline salva */\r\n        if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n          savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n          savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n        }\r\n        /* Criar nova timeline vazia e adicioná-la à lista */\r\n        savedTimelines.push({ name: name, visoes: [], maxTime: 60 });\r\n        activeTimelineIndex = savedTimelines.length - 1;\r\n        /* Limpar estado */\r\n        visoes = [];\r\n        currentIndex = 0;\r\n        document.getElementById(\"max_time\").value = 60;\r\n        document.getElementById(\"timeline_range\").max = 60;\r\n        document.getElementById(\"timeline_range\").value = 0;\r\n        updateTime(0);\r\n        renderMarkers();\r\n        renderSavedTimelines();\r\n      });\r\n    }\r\n\r\n    /* --- Video Export with Proportional Presets --- */\r\n    function onPresetChange() {\r\n      const sel = document.getElementById(\"preset_select\");\r\n      const preview = document.getElementById(\"preset_preview\");\r\n      const customDims = document.getElementById(\"custom_dims\");\r\n      const btnRecord = document.getElementById(\"btn_record\");\r\n      const idx = parseInt(sel.value);\r\n\r\n      if (isNaN(idx)) {\r\n        customDims.classList.remove(\"visible\");\r\n        preview.style.display = \"none\";\r\n        btnRecord.disabled = true;\r\n        if (window.sketchup) window.sketchup.hide_export_preview();\r\n        return;\r\n      }\r\n\r\n      const fmt = EXPORT_FORMATS[idx];\r\n      btnRecord.disabled = false;\r\n\r\n      if (fmt.custom) {\r\n        customDims.classList.add(\"visible\");\r\n        preview.style.display = \"none\";\r\n        if (window.sketchup) window.sketchup.hide_export_preview();\r\n      } else {\r\n        customDims.classList.remove(\"visible\");\r\n        let dims;\r\n        if (fmt.ratio) {\r\n          dims = calcEffectiveDims(fmt.ratio[0], fmt.ratio[1], viewportW, viewportH);\r\n        } else {\r\n          dims = { w: viewportW % 2 === 0 ? viewportW : viewportW - 1, h: viewportH % 2 === 0 ? viewportH : viewportH - 1 };\r\n        }\r\n        preview.textContent = I18N.area_gravacao + dims.w + \" x \" + dims.h + \" px\";\r\n        preview.style.display = \"flex\";\r\n        /* Show preview overlay in viewport */\r\n        if (window.sketchup) window.sketchup.show_export_preview(dims.w, dims.h);\r\n      }\r\n    }\r\n\r\n    function getExportDimensions() {\r\n      const sel = document.getElementById(\"preset_select\");\r\n      const idx = parseInt(sel.value);\r\n      if (isNaN(idx)) return null;\r\n      const fmt = EXPORT_FORMATS[idx];\r\n      if (fmt.custom) {\r\n        return {\r\n          w: parseInt(document.getElementById(\"custom_w\").value) || 1280,\r\n          h: parseInt(document.getElementById(\"custom_h\").value) || 720\r\n        };\r\n      }\r\n      if (fmt.ratio) {\r\n        return calcEffectiveDims(fmt.ratio[0], fmt.ratio[1], viewportW, viewportH);\r\n      }\r\n      return { w: viewportW % 2 === 0 ? viewportW : viewportW - 1, h: viewportH % 2 === 0 ? viewportH : viewportH - 1 };\r\n    }\r\n\r\n    function iniciarGravacao() {\r\n      var gravarProjeto = document.getElementById(\"rec_projeto\").checked;\r\n      var desdeInicio = document.getElementById(\"rec_inicio\").checked;\r\n\r\n      if (gravarProjeto) {\r\n        syncActiveTimeline();\r\n        var temVisoes = savedTimelines.some(function(tl) { return tl.visoes.length >= 2; });\r\n        if (!temVisoes) { alert(I18N.sem_tl_min_duas); return; }\r\n      } else {\r\n        if (visoes.length < 2) { alert(I18N.min_duas_visoes); return; }\r\n      }\r\n      var dims = getExportDimensions();\r\n      if (!dims || dims.w < 50 || dims.h < 50) { alert(I18N.dims_invalidas); return; }\r\n\r\n      /* Mostrar modal de nome */\r\n      document.getElementById(\"filename_input\").value = gravarProjeto ? \"projeto_tour\" : \"tour_final\";\r\n      document.getElementById(\"filename_modal\").style.display = \"flex\";\r\n      document.getElementById(\"filename_input\").focus();\r\n      document.getElementById(\"filename_input\").select();\r\n    }\r\n\r\n    function fecharModalFilename() {\r\n      document.getElementById(\"filename_modal\").style.display = \"none\";\r\n    }\r\n\r\n    function confirmarFilename() {\r\n      var nome = document.getElementById(\"filename_input\").value.trim();\r\n      if (!nome) { alert(I18N.digite_nome); return; }\r\n      document.getElementById(\"filename_modal\").style.display = \"none\";\r\n\r\n      var gravarProjeto = document.getElementById(\"rec_projeto\").checked;\r\n      var desdeInicio = document.getElementById(\"rec_inicio\").checked;\r\n      var dims = getExportDimensions();\r\n      var startIdx = desdeInicio ? 0 : currentIndex;\r\n\r\n      if (window.sketchup) window.sketchup.hide_export_preview();\r\n\r\n      if (gravarProjeto) {\r\n        syncActiveTimeline();\r\n        var allTimelines = JSON.stringify(savedTimelines);\r\n        var startTl = desdeInicio ? 0 : activeTimelineIndex;\r\n        var startVision = desdeInicio ? 0 : currentIndex;\r\n        if (window.sketchup) {\r\n          window.sketchup.start_export_project(\r\n            allTimelines,\r\n            document.getElementById(\"easing_checkbox\").checked,\r\n            startTl,\r\n            startVision,\r\n            dims.w,\r\n            dims.h,\r\n            nome\r\n          );\r\n        }\r\n      } else {\r\n        if (window.sketchup) {\r\n          window.sketchup.start_export_process(\r\n            JSON.stringify(visoes),\r\n            document.getElementById(\"easing_checkbox\").checked,\r\n            startIdx,\r\n            dims.w,\r\n            dims.h,\r\n            nome\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    function showRecordingIndicator() {\r\n      document.getElementById(\"recording_bar\").classList.add(\"active\");\r\n    }\r\n    function hideRecordingIndicator() {\r\n      document.getElementById(\"recording_bar\").classList.remove(\"active\");\r\n    }\r\n\r\n    function instalarExportacao() {\r\n      if (window.sketchup) { window.sketchup.install_ffmpeg(); }\r\n    }\r\n\r\n    /* --- Hotkey --- */\r\n    function mostrarCampoAtalho() {\r\n      capturingHotkey = true; pendingHotkey = null;\r\n      document.getElementById(\"hotkey_input\").value = \"\";\r\n      document.getElementById(\"hotkey_edit\").classList.add(\"visible\");\r\n      document.getElementById(\"hotkey_input\").focus();\r\n    }\r\n    function capturarAtalhoInput(e) {\r\n      e.preventDefault();\r\n      /* Ignorar teclas modificadoras sozinhas */\r\n      if ([16, 17, 18, 91, 93].includes(e.keyCode)) return;\r\n      pendingHotkey = {\r\n        keyCode: e.keyCode,\r\n        ctrl: e.ctrlKey,\r\n        alt: e.altKey,\r\n        shift: e.shiftKey\r\n      };\r\n      /* Montar label legivel */\r\n      var parts = [];\r\n      if (e.ctrlKey) parts.push(\"Ctrl\");\r\n      if (e.altKey) parts.push(\"Alt\");\r\n      if (e.shiftKey) parts.push(\"Shift\");\r\n      parts.push(e.code.replace(\"Key\", \"\").replace(\"Digit\", \"\"));\r\n      document.getElementById(\"hotkey_input\").value = parts.join(\" + \");\r\n    }\r\n    function confirmarAtalho() {\r\n      if (pendingHotkey !== null) {\r\n        hotkey = pendingHotkey;\r\n        if (window.sketchup) {\r\n          window.sketchup.set_hotkey(hotkey.keyCode, hotkey.ctrl, hotkey.alt, hotkey.shift);\r\n        }\r\n      }\r\n      capturingHotkey = false;\r\n      document.getElementById(\"hotkey_edit\").classList.remove(\"visible\");\r\n    }\r\n\r\n    /* --- Global bindings --- */\r\n    window.captureVisionFromRuby = captureVisionFromRuby;\r\n    window.resetPlayButton = resetPlayButton;\r\n    window.pauseAtIndex = pauseAtIndex;\r\n    window.triggerSpaceFromRuby = triggerSpaceFromRuby;\r\n    window.showRecordingIndicator = showRecordingIndicator;\r\n    window.hideRecordingIndicator = hideRecordingIndicator;\r\n    window.updatePlayhead = updatePlayhead;\r\n    window.resetPlayAll = resetPlayAll;\r\n    window.startRecordingPlayAll = startRecordingPlayAll;\r\n    window.addEventListener(\"resize\", () => { renderMarkers(); });\r\n\r\n    document.addEventListener(\"keydown\", (e) => {\r\n      if (!capturingHotkey &&\r\n          e.keyCode === hotkey.keyCode &&\r\n          e.ctrlKey === hotkey.ctrl &&\r\n          e.altKey === hotkey.alt &&\r\n          e.shiftKey === hotkey.shift &&\r\n          ![\"INPUT\", \"TEXTAREA\"].includes(e.target.tagName)) {\r\n        e.preventDefault(); togglePlay();\r\n      }\r\n    });\r\n\r\n    /* Init */\r\n    populatePresets();\r\n    renderMarkers();\r\n</script>\r\n</body>\r\n</html>\r\nHTML\r\n\r\n      @dialog ||= UI::HtmlDialog.new({\r\n        :dialog_title => obter_texto(:titulo_dialogo),\r\n        :preferences_key => \"com.example.tour\",\r\n        :scrollable => true,\r\n        :resizable => true,\r\n        :width => 430,\r\n        :height => 790,\r\n        :style => UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n\r\n      @dialog.set_html(html)\r\n      start_space_timer\r\n\r\n      @dialog.add_action_callback(\"set_hotkey\") do |_, key_code, ctrl, alt, shift|\r\n        GlobalKey.set_hotkey(key_code.to_i, ctrl, alt, shift)\r\n        Sketchup.write_default(\"TourVirtual\", \"Hotkey\", key_code.to_i)\r\n        Sketchup.write_default(\"TourVirtual\", \"HotkeyCtrl\", ctrl ? true : false)\r\n        Sketchup.write_default(\"TourVirtual\", \"HotkeyAlt\", alt ? true : false)\r\n        Sketchup.write_default(\"TourVirtual\", \"HotkeyShift\", shift ? true : false)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"capture_camera\") do |_, time_code|\r\n        cam = Sketchup.active_model.active_view.camera\r\n        thumb = capture_thumbnail\r\n        camera_data = {\r\n          time: time_code.to_f,\r\n          eye: cam.eye.to_a,\r\n          target: cam.target.to_a,\r\n          up: cam.up.to_a,\r\n          fov: cam.fov,\r\n          perspective: cam.perspective?,\r\n          thumb: thumb,\r\n          anchor: false\r\n        }\r\n        json_str = camera_data.to_json.gsub('\"', '\\\"')\r\n        @dialog.execute_script(\"captureVisionFromRuby(\\\"#{json_str}\\\")\")\r\n      end\r\n\r\n      @dialog.add_action_callback(\"goto_camera\") do |_, cam_json|\r\n        cam_data = JSON.parse(cam_json, symbolize_names: true)\r\n        cam = Sketchup::Camera.new(cam_data[:eye], cam_data[:target], cam_data[:up], cam_data[:perspective])\r\n        cam.fov = cam_data[:fov]\r\n        Sketchup.active_model.active_view.camera = cam\r\n      end\r\n\r\n      @dialog.add_action_callback(\"play_tour\") do |_, json_data, loop_enabled, inverse_mode, use_easing, start_index|\r\n        @camera_keys = JSON.parse(json_data, symbolize_names: true)\r\n        view = Sketchup.active_model.active_view\r\n        return if @camera_keys.length < 2\r\n        @camera_keys.sort_by! { |v| v[:time] }\r\n        @index = start_index.to_i\r\n        @direction = 1\r\n        @ping_pong = loop_enabled && inverse_mode\r\n\r\n        define_singleton_method(:ease_in_out_quad) do |t|\r\n          t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t\r\n        end\r\n\r\n        define_singleton_method(:catmull_rom) do |p0, p1, p2, p3, t|\r\n          t2 = t * t\r\n          t3 = t2 * t\r\n          [\r\n            0.5 * ((2 * p1[0]) + (-p0[0] + p2[0]) * t + (2*p0[0] - 5*p1[0] + 4*p2[0] - p3[0]) * t2 + (-p0[0] + 3*p1[0] - 3*p2[0] + p3[0]) * t3),\r\n            0.5 * ((2 * p1[1]) + (-p0[1] + p2[1]) * t + (2*p0[1] - 5*p1[1] + 4*p2[1] - p3[1]) * t2 + (-p0[1] + 3*p1[1] - 3*p2[1] + p3[1]) * t3),\r\n            0.5 * ((2 * p1[2]) + (-p0[2] + p2[2]) * t + (2*p0[2] - 5*p1[2] + 4*p2[2] - p3[2]) * t2 + (-p0[2] + 3*p1[2] - 3*p2[2] + p3[2]) * t3)\r\n          ]\r\n        end\r\n\r\n        define_singleton_method(:catmull_rom_1d) do |p0, p1, p2, p3, t|\r\n          t2 = t * t\r\n          t3 = t2 * t\r\n          0.5 * ((2 * p1) + (-p0 + p2) * t + (2*p0 - 5*p1 + 4*p2 - p3) * t2 + (-p0 + 3*p1 - 3*p2 + p3) * t3)\r\n        end\r\n\r\n        define_singleton_method(:play_transition) do\r\n          current = @camera_keys[@index]\r\n          next_index = @index + @direction\r\n\r\n          if next_index >= @camera_keys.size || next_index < 0\r\n            if loop_enabled\r\n               @index = 0\r\n               UI.start_timer(0.01) { play_transition }\r\n               return\r\n            else\r\n              @dialog.execute_script(\"pauseAtIndex(0)\")\r\n              return\r\n            end\r\n          end\r\n\r\n          next_cam = @camera_keys[next_index]\r\n          duration = (next_cam[:time] - current[:time]).abs\r\n          t_start = Time.now\r\n\r\n          p0 = @camera_keys[[@index - 1, 0].max]\r\n          p1 = current\r\n          p2 = next_cam\r\n          p3 = @camera_keys[[@index + 2, @camera_keys.size - 1].min]\r\n\r\n          @walk_shake = {\r\n            z_phase: rand * Math::PI * 2, x_phase: rand * Math::PI * 2,\r\n            z_amp: 0.8 + rand * 0.4, x_amp: 0.3 + rand * 0.4\r\n          }\r\n          playhead_counter = 0\r\n\r\n          @timer_id = UI.start_timer(0.03, true) do\r\n            t_elapsed = Time.now - t_start\r\n            t = duration.zero? ? 1.0 : [t_elapsed / duration, 1.0].min\r\n            t = use_easing ? ease_in_out_quad(t) : t\r\n\r\n            # Atualizar playhead na timeline (~a cada 0.09s)\r\n            playhead_counter += 1\r\n            if playhead_counter % 3 == 0\r\n              interpolated_time = current[:time] + t * (next_cam[:time] - current[:time])\r\n              @dialog.execute_script(\"updatePlayhead(#{interpolated_time.round(1)})\")\r\n            end\r\n\r\n            eye    = catmull_rom(p0[:eye],    p1[:eye],    p2[:eye],    p3[:eye],    t)\r\n            target = catmull_rom(p0[:target], p1[:target], p2[:target], p3[:target], t)\r\n            up     = catmull_rom(p0[:up],     p1[:up],     p2[:up],     p3[:up],     t)\r\n\r\n            # Interpolação Catmull-Rom para o FOV: suavidade total acompanhando a curva da câmera\r\n            fov = catmull_rom_1d(p0[:fov], p1[:fov], p2[:fov], p3[:fov], t)\r\n\r\n            if current[:walk]\r\n              eye[2] += Math.sin(t * Math::PI * 6 + @walk_shake[:z_phase]) * @walk_shake[:z_amp]\r\n              eye[0] += Math.sin(t * Math::PI * 3 + @walk_shake[:x_phase]) * @walk_shake[:x_amp]\r\n            end\r\n\r\n            cam = Sketchup::Camera.new(eye, target, up, current[:perspective])\r\n            cam.fov = fov\r\n            view.camera = cam\r\n            view.refresh\r\n\r\n            if t >= 1.0\r\n              UI.stop_timer(@timer_id)\r\n              @index = next_index\r\n              if @camera_keys[@index][:anchor] && @index > 0\r\n                @dialog.execute_script(\"pauseAtIndex(#{@index})\")\r\n              else\r\n                play_transition\r\n              end\r\n            end\r\n          end\r\n        end\r\n\r\n        play_transition\r\n      end\r\n\r\n      # Callback de exportação com presets de resolução\r\n      @dialog.add_action_callback(\"start_export_process\") do |_, json_data, use_easing, start_index, width, height, filename|\r\n        iniciar_processo_exportacao(json_data, use_easing, start_index, width.to_i, height.to_i, filename.to_s)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"start_export_project\") do |_, all_timelines_json, use_easing, active_tl_index, start_vision_index, width, height, filename|\r\n        iniciar_processo_exportacao_projeto(all_timelines_json, use_easing, active_tl_index.to_i, start_vision_index.to_i, width.to_i, height.to_i, filename.to_s)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"install_ffmpeg\") do |_|\r\n        eval(FFMPEG_INSTALL_SCRIPT)\r\n        UI.messagebox(obter_texto(:ffmpeg_instalado))\r\n      end\r\n\r\n      @dialog.add_action_callback(\"stop_tour\") do |_|\r\n        UI.stop_timer(@timer_id) if @timer_id\r\n        @dialog.execute_script(\"resetPlayButton()\")\r\n      end\r\n\r\n      @dialog.add_action_callback(\"show_export_preview\") do |_, width, height|\r\n        @preview_tool = ExportPreviewTool.new(width.to_i, height.to_i)\r\n        Sketchup.active_model.select_tool(@preview_tool)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"hide_export_preview\") do |_|\r\n        Sketchup.active_model.select_tool(nil)\r\n        @preview_tool = nil\r\n      end\r\n\r\n      @dialog.set_on_closed {\r\n        UI.stop_timer(@timer_id) if defined?(@timer_id) && @timer_id\r\n        stop_space_timer\r\n        if @preview_tool\r\n          Sketchup.active_model.select_tool(nil)\r\n          @preview_tool = nil\r\n        end\r\n      }\r\n\r\n      @dialog.show\r\n    end\r\n  end\r\nend\r\n\r\ndef self.executar\r\n  TourPlugin::CameraTimeline.start_ui\r\nend\r\n\r\nend # module TourVirtual\r\nend # module ScriptUpComunidade\r\n\r\nScriptUpComunidade::TourVirtual.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "tour-virtual-97283",
    "title": {
      "pt": "Tour Virtual",
      "en": "Virtual Tour",
      "es": "Visita virtual"
    },
    "author": "Fábio Coutinho",
    "version": "2.10",
    "description": {
      "pt": "Permite criar e gerenciar a criação de cenas em linha de tempo, várias linhas de tempo, apresentar a transição entre elas de forma suave e sem impacto de troca de cena e exportação de vídeo com FFMPEG de forma rápida por captura de tela enquanto apresenta.",
      "en": "It allows you to create and manage timeline scenes, multiple timelines, present the transition between them smoothly and without scene change impact, and quickly export video with FFMPEG by screen capture while presenting.",
      "es": "Le permite crear y administrar escenas de línea de tiempo, múltiples líneas de tiempo, presentar la transición entre ellas sin problemas y sin impacto en el cambio de escena, y exportar rápidamente video con FFMPEG mediante captura de pantalla mientras se presenta."
    },
    "keywords": {
      "pt": [
        "tour",
        "apresentação",
        "vídeo"
      ],
      "en": [
        "tour",
        "presentation",
        "video"
      ],
      "es": [
        "recorrido",
        "presentación",
        "video"
      ]
    },
    "code": {
      "pt": "require 'json'\r\nrequire 'sketchup.rb'\r\nrequire 'base64'\r\nrequire 'tmpdir'\r\nrequire 'fiddle/import'\r\nrequire 'fileutils'\r\nrequire 'open3'\r\nrequire 'etc'\r\nrequire 'open-uri'\r\nif Sketchup.platform == :platform_win\r\n  require 'win32ole'\r\nend\r\n\r\nmodule ScriptUpComunidade\r\nmodule TourVirtual\r\n\r\n# --- Definições de Diretórios ---\r\nplugins_root = Sketchup.find_support_file(\"Plugins\")\r\nPLUGIN_DIR = if plugins_root\r\n               File.expand_path(File.join(plugins_root, 'ScriptUp'))\r\n             else\r\n               File.expand_path(File.dirname(__FILE__))\r\n             end unless defined?(PLUGIN_DIR)\r\n\r\nIDIOMAS ||= {\r\n  'pt-BR' => {\r\n    :status_clicar_arrastar  => \"CLIQUE E ARRASTE para definir a área de gravação do vídeo.\",\r\n    :area_pequena            => \"Área muito pequena. Tente novamente.\",\r\n    :selecionar_pasta        => \"Selecione a pasta para salvar\",\r\n    :ffmpeg_nao_encontrado   => \"FFmpeg não encontrado.\",\r\n    :erro_gravador           => \"Erro ao iniciar gravador: \",\r\n    :gravacao_finalizada     => \"Gravação finalizada!\\nSalvo em: \",\r\n    :ffmpeg_instalado        => \"FFmpeg instalado. Execute o Tour Virtual novamente.\",\r\n    :titulo_dialogo          => \"Tour Virtual\",\r\n    :ffmpeg_plugins_erro     => \"Não foi possível resolver a pasta Plugins automaticamente.\",\r\n    :ffmpeg_instalar_em      => \"Instalar FFmpeg em:\",\r\n    :ffmpeg_origem           => \"Origem:\",\r\n    :ffmpeg_continuar        => \"Continuar?\",\r\n    :ffmpeg_cancelada        => \"Instalação cancelada.\",\r\n    :ffmpeg_ja_existe        => \"Já existe:\",\r\n    :ffmpeg_sobrescrever     => \"Deseja sobrescrever?\",\r\n    :ffmpeg_falha_expand     => \"Falha no Expand-Archive (PowerShell).\",\r\n    :ffmpeg_falha_unzip      => \"Falha no unzip (macOS).\",\r\n    :ffmpeg_exe_nao_encontrado => \"Executável ffmpeg não encontrado no pacote baixado.\",\r\n    :ffmpeg_sucesso          => \"FFmpeg instalado com sucesso em:\",\r\n    :ffmpeg_falhou           => \"Falhou:\",\r\n    :ffmpeg_abrindo_nav      => \"Abrindo o link no navegador...\",\r\n    :titulo                  => \"Tour Virtual\",\r\n    :subtitulo               => \"Linha do Tempo\",\r\n    :total                   => \"Total:\",\r\n    :visao                   => \"Visão\",\r\n    :play                    => \"Play\",\r\n    :stop                    => \"Stop\",\r\n    :play_all                => \"Play All\",\r\n    :stop_all                => \"Stop All\",\r\n    :atalho                  => \"Atalho\",\r\n    :pressione               => \"Pressione...\",\r\n    :ok                      => \"Ok\",\r\n    :loop                    => \"Loop\",\r\n    :easing                  => \"Easing\",\r\n    :visoes_salvas           => \"Visões salvas\",\r\n    :gerenciar_timeline      => \"Gerenciar Time Line\",\r\n    :nova                    => \"Nova\",\r\n    :exportar_atual          => \"Exportar Atual\",\r\n    :exportar_projeto        => \"Exportar Projeto\",\r\n    :importar                => \"Importar\",\r\n    :exportar_video          => \"Exportar Vídeo\",\r\n    :selecione_formato       => \"Selecione o formato…\",\r\n    :largura                 => \"Largura\",\r\n    :altura                  => \"Altura\",\r\n    :gravar_projeto          => \"Gravar todo o projeto (todas as Time Lines)\",\r\n    :iniciar_quadro1         => \"Iniciar do quadro 1\",\r\n    :iniciar_gravacao        => \"Iniciar Gravação\",\r\n    :gravando                => \"Gravando...\",\r\n    :ffmpeg_necessario       => \"FFmpeg necessário para gravar vídeo.\",\r\n    :instalar_ffmpeg         => \"Instalar FFmpeg\",\r\n    :nome_arquivo            => \"Nome do arquivo\",\r\n    :extensao_mp4            => \"A extensão .mp4 será adicionada automaticamente.\",\r\n    :cancelar                => \"Cancelar\",\r\n    :salvar                  => \"Salvar\",\r\n    :viewport_atual          => \"Viewport atual:\",\r\n    :paisagem                => \"Paisagem\",\r\n    :retrato                 => \"Retrato\",\r\n    :quadrado                => \"Quadrado\",\r\n    :classico                => \"Clássico\",\r\n    :ultra_wide              => \"Ultra-wide\",\r\n    :viewport_inteira        => \"Viewport Inteira\",\r\n    :personalizado           => \"Personalizado\",\r\n    :nome_timeline           => \"Nome da Time Line:\",\r\n    :nenhuma_visao           => \"Nenhuma visão adicionada.\",\r\n    :dica_visao              => \"Posicione a câmera e clique em <b>+ Visão</b>.\",\r\n    :ancora                  => \"Âncora\",\r\n    :excluir                 => \"Excluir\",\r\n    :min_duas_visoes         => \"Adicione pelo menos duas visões.\",\r\n    :sem_tl_2mais            => \"Nenhuma Time Line com 2+ visões.\",\r\n    :sem_visoes_exportar     => \"Nenhuma visão para exportar.\",\r\n    :sem_tl_exportar         => \"Nenhuma Time Line para exportar.\",\r\n    :importada               => \"Importada\",\r\n    :formato_invalido        => \"Formato inválido.\",\r\n    :erro_importar           => \"Erro ao importar: \",\r\n    :visoes                  => \"visões\",\r\n    :nova_timeline           => \"Nome da nova Time Line:\",\r\n    :area_gravacao           => \"Área de gravação: \",\r\n    :sem_tl_min_duas         => \"Nenhuma Time Line com pelo menos duas visões.\",\r\n    :dims_invalidas          => \"Dimensões inválidas (mínimo 50 x 50 px).\",\r\n    :digite_nome             => \"Digite um nome para o arquivo.\",\r\n  },\r\n  'en-US' => {\r\n    :status_clicar_arrastar  => \"CLICK AND DRAG to define the video recording area.\",\r\n    :area_pequena            => \"Area too small. Try again.\",\r\n    :selecionar_pasta        => \"Select folder to save\",\r\n    :ffmpeg_nao_encontrado   => \"FFmpeg not found.\",\r\n    :erro_gravador           => \"Error starting recorder: \",\r\n    :gravacao_finalizada     => \"Recording finished!\\nSaved to: \",\r\n    :ffmpeg_instalado        => \"FFmpeg installed. Run Virtual Tour again.\",\r\n    :titulo_dialogo          => \"Virtual Tour\",\r\n    :ffmpeg_plugins_erro     => \"Could not resolve the Plugins folder automatically.\",\r\n    :ffmpeg_instalar_em      => \"Install FFmpeg to:\",\r\n    :ffmpeg_origem           => \"Source:\",\r\n    :ffmpeg_continuar        => \"Continue?\",\r\n    :ffmpeg_cancelada        => \"Installation cancelled.\",\r\n    :ffmpeg_ja_existe        => \"Already exists:\",\r\n    :ffmpeg_sobrescrever     => \"Overwrite?\",\r\n    :ffmpeg_falha_expand     => \"Expand-Archive failed (PowerShell).\",\r\n    :ffmpeg_falha_unzip      => \"unzip failed (macOS).\",\r\n    :ffmpeg_exe_nao_encontrado => \"FFmpeg executable not found in downloaded package.\",\r\n    :ffmpeg_sucesso          => \"FFmpeg successfully installed to:\",\r\n    :ffmpeg_falhou           => \"Failed:\",\r\n    :ffmpeg_abrindo_nav      => \"Opening the link in browser...\",\r\n    :titulo                  => \"Virtual Tour\",\r\n    :subtitulo               => \"Timeline\",\r\n    :total                   => \"Total:\",\r\n    :visao                   => \"Vision\",\r\n    :play                    => \"Play\",\r\n    :stop                    => \"Stop\",\r\n    :play_all                => \"Play All\",\r\n    :stop_all                => \"Stop All\",\r\n    :atalho                  => \"Hotkey\",\r\n    :pressione               => \"Press a key...\",\r\n    :ok                      => \"Ok\",\r\n    :loop                    => \"Loop\",\r\n    :easing                  => \"Easing\",\r\n    :visoes_salvas           => \"Saved visions\",\r\n    :gerenciar_timeline      => \"Manage Timeline\",\r\n    :nova                    => \"New\",\r\n    :exportar_atual          => \"Export Current\",\r\n    :exportar_projeto        => \"Export Project\",\r\n    :importar                => \"Import\",\r\n    :exportar_video          => \"Export Video\",\r\n    :selecione_formato       => \"Select format…\",\r\n    :largura                 => \"Width\",\r\n    :altura                  => \"Height\",\r\n    :gravar_projeto          => \"Record entire project (all Timelines)\",\r\n    :iniciar_quadro1         => \"Start from frame 1\",\r\n    :iniciar_gravacao        => \"Start Recording\",\r\n    :gravando                => \"Recording...\",\r\n    :ffmpeg_necessario       => \"FFmpeg is required to record video.\",\r\n    :instalar_ffmpeg         => \"Install FFmpeg\",\r\n    :nome_arquivo            => \"File name\",\r\n    :extensao_mp4            => \"The .mp4 extension will be added automatically.\",\r\n    :cancelar                => \"Cancel\",\r\n    :salvar                  => \"Save\",\r\n    :viewport_atual          => \"Current viewport:\",\r\n    :paisagem                => \"Landscape\",\r\n    :retrato                 => \"Portrait\",\r\n    :quadrado                => \"Square\",\r\n    :classico                => \"Classic\",\r\n    :ultra_wide              => \"Ultra-wide\",\r\n    :viewport_inteira        => \"Full Viewport\",\r\n    :personalizado           => \"Custom\",\r\n    :nome_timeline           => \"Timeline name:\",\r\n    :nenhuma_visao           => \"No visions added.\",\r\n    :dica_visao              => \"Position the camera and click <b>+ Vision</b>.\",\r\n    :ancora                  => \"Anchor\",\r\n    :excluir                 => \"Delete\",\r\n    :min_duas_visoes         => \"Add at least two visions.\",\r\n    :sem_tl_2mais            => \"No Timeline with 2+ visions.\",\r\n    :sem_visoes_exportar     => \"No visions to export.\",\r\n    :sem_tl_exportar         => \"No Timeline to export.\",\r\n    :importada               => \"Imported\",\r\n    :formato_invalido        => \"Invalid format.\",\r\n    :erro_importar           => \"Import error: \",\r\n    :visoes                  => \"visions\",\r\n    :nova_timeline           => \"New Timeline name:\",\r\n    :area_gravacao           => \"Recording area: \",\r\n    :sem_tl_min_duas         => \"No Timeline with at least two visions.\",\r\n    :dims_invalidas          => \"Invalid dimensions (minimum 50 x 50 px).\",\r\n    :digite_nome             => \"Enter a file name.\",\r\n  },\r\n  'es' => {\r\n    :status_clicar_arrastar  => \"HAZ CLIC Y ARRASTRA para definir el área de grabación del video.\",\r\n    :area_pequena            => \"Área demasiado pequeña. Inténtalo de nuevo.\",\r\n    :selecionar_pasta        => \"Selecciona la carpeta para guardar\",\r\n    :ffmpeg_nao_encontrado   => \"FFmpeg no encontrado.\",\r\n    :erro_gravador           => \"Error al iniciar grabador: \",\r\n    :gravacao_finalizada     => \"¡Grabación finalizada!\\nGuardado en: \",\r\n    :ffmpeg_instalado        => \"FFmpeg instalado. Ejecuta Tour Virtual de nuevo.\",\r\n    :titulo_dialogo          => \"Tour Virtual\",\r\n    :ffmpeg_plugins_erro     => \"No se pudo resolver la carpeta Plugins automáticamente.\",\r\n    :ffmpeg_instalar_em      => \"Instalar FFmpeg en:\",\r\n    :ffmpeg_origem           => \"Origen:\",\r\n    :ffmpeg_continuar        => \"¿Continuar?\",\r\n    :ffmpeg_cancelada        => \"Instalación cancelada.\",\r\n    :ffmpeg_ja_existe        => \"Ya existe:\",\r\n    :ffmpeg_sobrescrever     => \"¿Sobrescribir?\",\r\n    :ffmpeg_falha_expand     => \"Error en Expand-Archive (PowerShell).\",\r\n    :ffmpeg_falha_unzip      => \"Error en unzip (macOS).\",\r\n    :ffmpeg_exe_nao_encontrado => \"Ejecutable FFmpeg no encontrado en el paquete descargado.\",\r\n    :ffmpeg_sucesso          => \"FFmpeg instalado con éxito en:\",\r\n    :ffmpeg_falhou           => \"Falló:\",\r\n    :ffmpeg_abrindo_nav      => \"Abriendo el enlace en el navegador...\",\r\n    :titulo                  => \"Tour Virtual\",\r\n    :subtitulo               => \"Línea de Tiempo\",\r\n    :total                   => \"Total:\",\r\n    :visao                   => \"Visión\",\r\n    :play                    => \"Play\",\r\n    :stop                    => \"Stop\",\r\n    :play_all                => \"Play All\",\r\n    :stop_all                => \"Stop All\",\r\n    :atalho                  => \"Atajo\",\r\n    :pressione               => \"Presiona...\",\r\n    :ok                      => \"Ok\",\r\n    :loop                    => \"Loop\",\r\n    :easing                  => \"Easing\",\r\n    :visoes_salvas           => \"Visiones guardadas\",\r\n    :gerenciar_timeline      => \"Gestionar Línea de Tiempo\",\r\n    :nova                    => \"Nueva\",\r\n    :exportar_atual          => \"Exportar Actual\",\r\n    :exportar_projeto        => \"Exportar Proyecto\",\r\n    :importar                => \"Importar\",\r\n    :exportar_video          => \"Exportar Video\",\r\n    :selecione_formato       => \"Selecciona el formato…\",\r\n    :largura                 => \"Ancho\",\r\n    :altura                  => \"Alto\",\r\n    :gravar_projeto          => \"Grabar todo el proyecto (todas las Líneas de Tiempo)\",\r\n    :iniciar_quadro1         => \"Iniciar desde el cuadro 1\",\r\n    :iniciar_gravacao        => \"Iniciar Grabación\",\r\n    :gravando                => \"Grabando...\",\r\n    :ffmpeg_necessario       => \"FFmpeg necesario para grabar video.\",\r\n    :instalar_ffmpeg         => \"Instalar FFmpeg\",\r\n    :nome_arquivo            => \"Nombre del archivo\",\r\n    :extensao_mp4            => \"La extensión .mp4 se añadirá automáticamente.\",\r\n    :cancelar                => \"Cancelar\",\r\n    :salvar                  => \"Guardar\",\r\n    :viewport_atual          => \"Viewport actual:\",\r\n    :paisagem                => \"Paisaje\",\r\n    :retrato                 => \"Retrato\",\r\n    :quadrado                => \"Cuadrado\",\r\n    :classico                => \"Clásico\",\r\n    :ultra_wide              => \"Ultra-wide\",\r\n    :viewport_inteira        => \"Viewport Completa\",\r\n    :personalizado           => \"Personalizado\",\r\n    :nome_timeline           => \"Nombre de la Línea de Tiempo:\",\r\n    :nenhuma_visao           => \"Ninguna visión añadida.\",\r\n    :dica_visao              => \"Posiciona la cámara y haz clic en <b>+ Visión</b>.\",\r\n    :ancora                  => \"Ancla\",\r\n    :excluir                 => \"Eliminar\",\r\n    :min_duas_visoes         => \"Añade al menos dos visiones.\",\r\n    :sem_tl_2mais            => \"Ninguna Línea de Tiempo con 2+ visiones.\",\r\n    :sem_visoes_exportar     => \"Ninguna visión para exportar.\",\r\n    :sem_tl_exportar         => \"Ninguna Línea de Tiempo para exportar.\",\r\n    :importada               => \"Importada\",\r\n    :formato_invalido        => \"Formato inválido.\",\r\n    :erro_importar           => \"Error al importar: \",\r\n    :visoes                  => \"visiones\",\r\n    :nova_timeline           => \"Nombre de la nueva Línea de Tiempo:\",\r\n    :area_gravacao           => \"Área de grabación: \",\r\n    :sem_tl_min_duas         => \"Ninguna Línea de Tiempo con al menos dos visiones.\",\r\n    :dims_invalidas          => \"Dimensiones inválidas (mínimo 50 x 50 px).\",\r\n    :digite_nome             => \"Escribe un nombre para el archivo.\",\r\n  },\r\n}\r\n\r\ndef self.obter_texto(chave)\r\n  locale = Sketchup.get_locale\r\n  lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n  IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\nend\r\n\r\n# --- Script de Instalação do FFmpeg (Mantido) ---\r\nFFMPEG_INSTALL_SCRIPT ||= <<~'RUBY'\r\n  require 'sketchup'\r\n  require 'open-uri'\r\n  require 'fileutils'\r\n  require 'tmpdir'\r\n\r\n  URL_WIN ||= 'https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-master-latest-win64-gpl.zip'\r\n  URL_MAC ||= 'https://evermeet.cx/ffmpeg/getrelease/zip'\r\n\r\n  win = Sketchup.platform == :platform_win\r\n  major = Sketchup.version.to_s[/^\\d+/].to_i\r\n  sketchup_year = 2000 + major\r\n\r\n  plugins_dir = Sketchup.find_support_file('Plugins')\r\n  if !plugins_dir || plugins_dir.empty? || !Dir.exist?(plugins_dir)\r\n    if win\r\n      base = ENV['APPDATA'].to_s\r\n      plugins_dir = File.join(base, 'SketchUp', \"SketchUp #{sketchup_year}\", 'SketchUp', 'Plugins')\r\n    else\r\n      plugins_dir = File.expand_path(\"~/Library/Application Support/SketchUp #{sketchup_year}/SketchUp/Plugins\")\r\n    end\r\n  end\r\n\r\n  target_dir = File.join(plugins_dir, 'ScriptUp', 'ffmpeg')\r\n  target_exe = File.join(target_dir, win ? 'ffmpeg.exe' : 'ffmpeg')\r\n  url = win ? URL_WIN : URL_MAC\r\n  default_zip_name = win ? 'ffmpeg-win64-gpl-latest.zip' : 'ffmpeg-macos-release.zip'\r\n\r\n  proceed = true\r\n\r\n  unless plugins_dir && !plugins_dir.empty?\r\n    UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_plugins_erro))\r\n    proceed = false\r\n  end\r\n\r\n  if proceed\r\n    msg = \"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_instalar_em)}\\n#{target_dir}\\n\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_origem)}\\n#{url}\\n\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_continuar)}\"\r\n    if UI.messagebox(msg, MB_YESNO) != IDYES\r\n      UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_cancelada))\r\n      proceed = false\r\n    end\r\n  end\r\n\r\n  if proceed && File.exist?(target_exe)\r\n    overwrite = UI.messagebox(\"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_ja_existe)}\\n#{target_exe}\\n\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_sobrescrever)}\", MB_YESNO)\r\n    if overwrite != IDYES\r\n      UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_cancelada))\r\n      proceed = false\r\n    end\r\n  end\r\n\r\n  if proceed\r\n    Dir.mktmpdir('ffmpeg_dl_') do |tmp|\r\n      zip_path = File.join(tmp, default_zip_name)\r\n      extract_dir = File.join(tmp, 'unzipped')\r\n      begin\r\n        URI.open(url, 'rb') do |io|\r\n          File.open(zip_path, 'wb') { |f| IO.copy_stream(io, f) }\r\n        end\r\n        Dir.mkdir(extract_dir)\r\n        if win\r\n          ps = 'powershell -NoProfile -ExecutionPolicy Bypass -Command'\r\n          cmd = \"#{ps} \\\"Expand-Archive -LiteralPath '#{zip_path}' -DestinationPath '#{extract_dir}' -Force\\\"\"\r\n          ok = system(cmd)\r\n          raise ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_falha_expand) unless ok\r\n        else\r\n          ok = system(\"unzip -o -q '#{zip_path}' -d '#{extract_dir}'\")\r\n          raise ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_falha_unzip) unless ok\r\n        end\r\n\r\n        pattern = win ? '**/ffmpeg.exe' : '**/ffmpeg'\r\n        bin = Dir.glob(File.join(extract_dir, pattern)).find { |p| File.file?(p) }\r\n        raise ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_exe_nao_encontrado) unless bin\r\n\r\n        FileUtils.mkdir_p(target_dir) unless Dir.exist?(target_dir)\r\n        FileUtils.cp(bin, target_exe)\r\n        unless win\r\n          FileUtils.chmod(0o755, target_exe)\r\n          system(\"xattr -d com.apple.quarantine '#{target_exe}' 2>/dev/null\")\r\n        end\r\n\r\n        UI.messagebox(\"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_sucesso)}\\n#{target_exe}\")\r\n        puts \"OK: #{target_exe}\"\r\n      rescue => e\r\n        UI.messagebox(\"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_falhou)} #{e.message}\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_abrindo_nav)}\")\r\n        UI.openURL(url)\r\n      end\r\n    end\r\n  end\r\nRUBY\r\n\r\n# --- Módulo WindowUtils ---\r\nmodule WindowUtils\r\n  extend Fiddle::Importer\r\n  dlload 'user32.dll' if Sketchup.platform == :platform_win\r\n\r\n  if Sketchup.platform == :platform_win\r\n    typealias 'HWND', 'void*'\r\n    extern 'HWND GetActiveWindow()'\r\n    extern 'HWND GetForegroundWindow()'\r\n    extern 'HWND GetWindow(HWND, int)'\r\n    extern 'int GetWindowRect(HWND, void*)'\r\n    extern 'HWND GetParent(HWND)'\r\n    \r\n    GW_CHILD = 5 unless defined?(GW_CHILD)\r\n    GW_HWNDNEXT = 2 unless defined?(GW_HWNDNEXT)\r\n    Rect = struct ['long left', 'long top', 'long right', 'long bottom'] unless defined?(Rect)\r\n  end\r\n\r\n  def self.get_viewport_rect_deep(view)\r\n    return nil unless Sketchup.platform == :platform_win\r\n    \r\n    hwnd = GetForegroundWindow()\r\n    return nil if hwnd.nil? || hwnd == 0\r\n\r\n    vw = view.vpwidth\r\n    vh = view.vpheight\r\n    \r\n    found = find_recursive(hwnd, vw, vh)\r\n    return found if found\r\n\r\n    parent = GetParent(hwnd)\r\n    if parent && parent != 0\r\n      found = find_recursive(parent, vw, vh)\r\n      return found if found\r\n    end\r\n\r\n    nil\r\n  end\r\n\r\n  def self.find_recursive(parent_hwnd, target_w, target_h)\r\n    child = GetWindow(parent_hwnd, GW_CHILD)\r\n    while child && child.to_i != 0\r\n      rect = Rect.malloc\r\n      if GetWindowRect(child, rect) != 0\r\n        w = rect.right - rect.left\r\n        h = rect.bottom - rect.top\r\n        match = check_match(w, h, target_w, target_h, rect)\r\n        return match if match\r\n      end\r\n      found_in_child = find_recursive(child, target_w, target_h)\r\n      return found_in_child if found_in_child\r\n      child = GetWindow(child, GW_HWNDNEXT)\r\n    end\r\n    nil\r\n  end\r\n\r\n  def self.check_match(w, h, target_w, target_h, rect)\r\n    tol = 30\r\n    [1.0, 1.25, 1.5, 2.0].each do |scale|\r\n      if (w - target_w * scale).abs <= tol && (h - target_h * scale).abs <= tol\r\n        return { :x => rect.left, :y => rect.top, :w => w, :h => h, :scale => scale }\r\n      end\r\n    end\r\n    nil\r\n  end\r\nend\r\n\r\n# --- Módulo ScreenCapture (GDI32) ---\r\n# Captures the SketchUp viewport via Win32 GDI and produces a BMP thumbnail\r\n# encoded as Base64, suitable for embedding in an HTML <img> tag.\r\n#\r\n# Uses Fiddle::Importer (Ruby stdlib) to call gdi32.dll and user32.dll functions.\r\n# Also declares PrintWindow from user32.dll as a fallback for occluded windows.\r\n#\r\n# Fiddle type mapping reference (from fiddle/types.rb Win32Types):\r\n#   HANDLE / HDC / HWND / HBITMAP  ->  void*   (pointer-sized, correct for 32/64-bit)\r\n#   DWORD                          ->  unsigned long\r\n#   BOOL                           ->  int\r\n#   UINT                           ->  unsigned int\r\n#\r\n# The extern signatures below use 'void*' directly for all handle types\r\n# (HDC, HBITMAP, HGDIOBJ) so we do not need to include Fiddle::Win32Types\r\n# or add custom typealiases beyond what WindowUtils already defines.\r\nmodule ScreenCapture\r\n  extend Fiddle::Importer\r\n\r\n  if Sketchup.platform == :platform_win\r\n    dlload 'gdi32.dll', 'user32.dll'\r\n\r\n    # --- user32.dll functions ---\r\n    # HDC GetDC(HWND hWnd)\r\n    #   hWnd=NULL(0) returns DC for entire screen\r\n    extern 'void* GetDC(void*)'\r\n\r\n    # int ReleaseDC(HWND hWnd, HDC hDC)\r\n    extern 'int ReleaseDC(void*, void*)'\r\n\r\n    # BOOL PrintWindow(HWND hwnd, HDC hdcBlt, UINT nFlags)\r\n    #   Asks the window to paint itself into the given DC.\r\n    #   Works even when the window is partially occluded (unlike BitBlt from screen DC).\r\n    extern 'int PrintWindow(void*, void*, unsigned int)'\r\n\r\n    # --- gdi32.dll functions ---\r\n    # HDC CreateCompatibleDC(HDC hdc)\r\n    extern 'void* CreateCompatibleDC(void*)'\r\n\r\n    # HBITMAP CreateCompatibleBitmap(HDC hdc, int cx, int cy)\r\n    extern 'void* CreateCompatibleBitmap(void*, int, int)'\r\n\r\n    # HGDIOBJ SelectObject(HDC hdc, HGDIOBJ h)\r\n    extern 'void* SelectObject(void*, void*)'\r\n\r\n    # BOOL BitBlt(HDC hdc, int x, int y, int cx, int cy,\r\n    #             HDC hdcSrc, int x1, int y1, DWORD rop)\r\n    extern 'int BitBlt(void*, int, int, int, int, void*, int, int, unsigned long)'\r\n\r\n    # BOOL StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest,\r\n    #                 HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop)\r\n    extern 'int StretchBlt(void*, int, int, int, int, void*, int, int, int, int, unsigned long)'\r\n\r\n    # int SetStretchBltMode(HDC hdc, int mode)\r\n    extern 'int SetStretchBltMode(void*, int)'\r\n\r\n    # int GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines,\r\n    #               LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage)\r\n    #   lpvBits and lpbmi are both void* (raw pointers to caller-allocated buffers)\r\n    extern 'int GetDIBits(void*, void*, unsigned int, unsigned int, void*, void*, unsigned int)'\r\n\r\n    # BOOL DeleteDC(HDC hdc)\r\n    extern 'int DeleteDC(void*)'\r\n\r\n    # BOOL DeleteObject(HGDIOBJ ho)\r\n    extern 'int DeleteObject(void*)'\r\n\r\n    # --- Raster-operation and mode constants ---\r\n    SRCCOPY        = 0x00CC0020 unless defined?(SRCCOPY)\r\n    HALFTONE       = 4 unless defined?(HALFTONE)          # SetStretchBltMode mode for high-quality shrinking\r\n    DIB_RGB_COLORS = 0 unless defined?(DIB_RGB_COLORS)    # GetDIBits color table usage\r\n\r\n    # --- PrintWindow flags ---\r\n    PW_CLIENTONLY          = 0x00000001 unless defined?(PW_CLIENTONLY)          # capture client area only (no title bar)\r\n    PW_RENDERFULLCONTENT   = 0x00000002 unless defined?(PW_RENDERFULLCONTENT)  # Win 8.1+: captures DirectX/DWM content\r\n  end\r\n\r\n  # Build a 40-byte BITMAPINFOHEADER as a packed binary string.\r\n  #\r\n  # The BITMAPINFOHEADER struct layout (40 bytes total):\r\n  #   DWORD  biSize          (4 bytes, unsigned 32-bit LE)   = 40\r\n  #   LONG   biWidth         (4 bytes, signed   32-bit LE)\r\n  #   LONG   biHeight        (4 bytes, signed   32-bit LE)   negative = top-down DIB\r\n  #   WORD   biPlanes        (2 bytes, unsigned 16-bit LE)   = 1\r\n  #   WORD   biBitCount      (2 bytes, unsigned 16-bit LE)   = 24 for RGB\r\n  #   DWORD  biCompression   (4 bytes, unsigned 32-bit LE)   = 0 (BI_RGB)\r\n  #   DWORD  biSizeImage     (4 bytes, unsigned 32-bit LE)\r\n  #   LONG   biXPelsPerMeter (4 bytes, signed   32-bit LE)   = 0\r\n  #   LONG   biYPelsPerMeter (4 bytes, signed   32-bit LE)   = 0\r\n  #   DWORD  biClrUsed       (4 bytes, unsigned 32-bit LE)   = 0\r\n  #   DWORD  biClrImportant  (4 bytes, unsigned 32-bit LE)   = 0\r\n  #\r\n  # Pack template: 'L<' = uint32 LE, 'l<' = int32 LE, 'S<' = uint16 LE\r\n  # Combined: 'L< l< l< S< S< L< L< l< l< L< L<'  (spaces for clarity)\r\n  #\r\n  # Using negative biHeight produces a top-down DIB, which means:\r\n  #  - Row 0 in memory is the top row of the image\r\n  #  - No vertical flip is needed when writing the BMP file\r\n  #  - The BMP file header must also use the negative height to match\r\n  def self.pack_bitmapinfoheader(width, height, image_size)\r\n    [\r\n      40,           # biSize\r\n      width,        # biWidth\r\n      -height,      # biHeight (negative = top-down)\r\n      1,            # biPlanes\r\n      24,           # biBitCount (24-bit RGB)\r\n      0,            # biCompression (BI_RGB = uncompressed)\r\n      image_size,   # biSizeImage\r\n      0,            # biXPelsPerMeter\r\n      0,            # biYPelsPerMeter\r\n      0,            # biClrUsed\r\n      0             # biClrImportant\r\n    ].pack('L<l<l<S<S<L<L<l<l<L<L<')\r\n  end\r\n\r\n  # Build the 14-byte BMP file header (BITMAPFILEHEADER).\r\n  #\r\n  # Layout:\r\n  #   WORD   bfType      = 0x4D42 (\"BM\")\r\n  #   DWORD  bfSize      = total file size in bytes\r\n  #   WORD   bfReserved1 = 0\r\n  #   WORD   bfReserved2 = 0\r\n  #   DWORD  bfOffBits   = offset to pixel data = 14 + 40 = 54\r\n  #\r\n  # Pack template: 'S< L< S< S< L<'\r\n  def self.pack_bmp_file_header(pixel_data_size)\r\n    file_size = 14 + 40 + pixel_data_size\r\n    [\r\n      0x4D42,       # bfType (\"BM\")\r\n      file_size,    # bfSize\r\n      0,            # bfReserved1\r\n      0,            # bfReserved2\r\n      54            # bfOffBits (14-byte file header + 40-byte info header)\r\n    ].pack('S<L<S<S<L<')\r\n  end\r\n\r\n  # Capture the SketchUp viewport as a scaled-down BMP thumbnail and return\r\n  # a Base64-encoded string. Returns nil on failure (non-Windows, HWND not found, etc.).\r\n  #\r\n  # Strategy:\r\n  #   1. StretchBlt from screen DC (fast, works when viewport is visible)\r\n  #   2. If vp[:hwnd] is available, PrintWindow can be used as alternative\r\n  #\r\n  # Parameters:\r\n  #   view     - Sketchup::View instance\r\n  #   thumb_w  - desired thumbnail width  in pixels (default 96)\r\n  #   thumb_h  - desired thumbnail height in pixels (default 60)\r\n  #\r\n  # Returns: Base64-encoded BMP string, or nil on failure.\r\n  def self.capture_viewport(view, thumb_w = 96, thumb_h = 60)\r\n    return nil unless Sketchup.platform == :platform_win\r\n\r\n    vp = WindowUtils.get_viewport_rect_deep(view)\r\n    return nil unless vp\r\n\r\n    src_w = vp[:w]\r\n    src_h = vp[:h]\r\n\r\n    # Get screen DC -- needed for CreateCompatibleBitmap color depth\r\n    screen_dc = GetDC(0)\r\n    return nil if screen_dc.nil? || screen_dc.to_i == 0\r\n\r\n    begin\r\n      # Create a memory DC compatible with the screen\r\n      mem_dc = CreateCompatibleDC(screen_dc)\r\n      return nil if mem_dc.nil? || mem_dc.to_i == 0\r\n\r\n      begin\r\n        # Create a bitmap at the desired thumbnail size\r\n        bmp = CreateCompatibleBitmap(screen_dc, thumb_w, thumb_h)\r\n        return nil if bmp.nil? || bmp.to_i == 0\r\n\r\n        begin\r\n          old = SelectObject(mem_dc, bmp)\r\n          SetStretchBltMode(mem_dc, HALFTONE)\r\n\r\n          # StretchBlt from the screen DC directly into the thumbnail-sized bitmap.\r\n          # This both captures AND scales in a single operation.\r\n          ok = StretchBlt(\r\n            mem_dc, 0, 0, thumb_w, thumb_h,\r\n            screen_dc, vp[:x], vp[:y], src_w, src_h,\r\n            SRCCOPY\r\n          )\r\n          return nil if ok == 0\r\n\r\n          # IMPORTANT: Deselect the bitmap from the DC before calling GetDIBits.\r\n          # Per MSDN: \"The bitmap identified by hbmp must not be selected into\r\n          # a device context when the application calls this function.\"\r\n          SelectObject(mem_dc, old)\r\n          old = nil\r\n\r\n          # Calculate row stride (BMP rows must be padded to 4-byte boundaries)\r\n          stride     = ((thumb_w * 3 + 3) & ~3)\r\n          pixel_size = stride * thumb_h\r\n\r\n          # Pack the BITMAPINFOHEADER into a Fiddle::Pointer buffer.\r\n          # GetDIBits may modify the header (e.g., filling in biSizeImage),\r\n          # so we use a mutable native buffer rather than a Ruby String.\r\n          bmi_bytes = pack_bitmapinfoheader(thumb_w, thumb_h, pixel_size)\r\n          bmi_ptr   = Fiddle::Pointer.malloc(bmi_bytes.bytesize)\r\n          bmi_ptr[0, bmi_bytes.bytesize] = bmi_bytes\r\n\r\n          # Allocate the pixel data buffer\r\n          buf = Fiddle::Pointer.malloc(pixel_size)\r\n\r\n          begin\r\n            # GetDIBits(hdc, hbm, start, cLines, lpvBits, lpbmi, usage)\r\n            # hdc: a DC compatible with the bitmap (mem_dc works)\r\n            # hbm: the bitmap handle (NOT selected into any DC)\r\n            rows = GetDIBits(mem_dc, bmp, 0, thumb_h, buf, bmi_ptr, DIB_RGB_COLORS)\r\n            return nil if rows == 0\r\n\r\n            # Read the raw pixel bytes from the Fiddle::Pointer buffer.\r\n            # ptr[offset, length] returns a Ruby String (binary safe, works since Ruby 2.0).\r\n            pixel_data = buf[0, pixel_size]\r\n\r\n            # Assemble the complete BMP file: file header + info header + pixel data\r\n            file_hdr = pack_bmp_file_header(pixel_size)\r\n            info_hdr = pack_bitmapinfoheader(thumb_w, thumb_h, pixel_size)\r\n\r\n            Base64.strict_encode64(file_hdr + info_hdr + pixel_data)\r\n          ensure\r\n            Fiddle.free(bmi_ptr) if bmi_ptr\r\n            Fiddle.free(buf)     if buf\r\n          end\r\n        ensure\r\n          SelectObject(mem_dc, old) if old\r\n          DeleteObject(bmp)\r\n        end\r\n      ensure\r\n        DeleteDC(mem_dc)\r\n      end\r\n    ensure\r\n      ReleaseDC(0, screen_dc)\r\n    end\r\n  rescue => e\r\n    puts \"ScreenCapture error: #{e.message}\"\r\n    puts e.backtrace.first(5).join(\"\\n\")\r\n    nil\r\n  end\r\nend\r\n\r\nmodule TourPlugin\r\n  class AreaSelectorTool\r\n    def initialize(callback)\r\n      @callback = callback\r\n      @start_x = nil; @start_y = nil; @current_x = nil; @current_y = nil\r\n      @drawing = false\r\n    end\r\n\r\n    def activate\r\n      Sketchup.active_model.active_view.invalidate\r\n      Sketchup.status_text = ScriptUpComunidade::TourVirtual.obter_texto(:status_clicar_arrastar)\r\n    end\r\n\r\n    def onLButtonDown(flags, x, y, view)\r\n      @start_x = x; @start_y = y; @current_x = x; @current_y = y\r\n      @drawing = true\r\n    end\r\n\r\n    def onMouseMove(flags, x, y, view)\r\n      if @drawing\r\n        @current_x = x; @current_y = y\r\n        view.invalidate\r\n      end\r\n    end\r\n\r\n    def onLButtonUp(flags, x, y, view)\r\n      return unless @drawing\r\n      @drawing = false\r\n      x1 = [@start_x, @current_x].min\r\n      y1 = [@start_y, @current_y].min\r\n      x2 = [@start_x, @current_x].max\r\n      y2 = [@start_y, @current_y].max\r\n      width = x2 - x1\r\n      height = y2 - y1\r\n\r\n      if width < 50 || height < 50\r\n        UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:area_pequena))\r\n        Sketchup.active_model.select_tool(nil)\r\n        return\r\n      end\r\n\r\n      @callback.call({ :x => x1, :y => y1, :w => width, :h => height })\r\n      Sketchup.active_model.select_tool(nil) \r\n    end\r\n\r\n    def draw(view)\r\n      return unless @drawing && @start_x && @current_x\r\n      points = [\r\n        Geom::Point3d.new(@start_x, @start_y, 0),\r\n        Geom::Point3d.new(@current_x, @start_y, 0),\r\n        Geom::Point3d.new(@current_x, @current_y, 0),\r\n        Geom::Point3d.new(@start_x, @current_y, 0)\r\n      ]\r\n      view.line_width = 3\r\n      view.drawing_color = 'red'\r\n      view.draw2d(GL_LINE_LOOP, points)\r\n    end\r\n  end\r\n\r\n  class ExportPreviewTool\r\n    def initialize(target_w, target_h)\r\n      @target_w = target_w\r\n      @target_h = target_h\r\n    end\r\n\r\n    def activate\r\n      Sketchup.active_model.active_view.invalidate\r\n    end\r\n\r\n    def deactivate(view)\r\n      view.invalidate\r\n    end\r\n\r\n    def draw(view)\r\n      vw = view.vpwidth\r\n      vh = view.vpheight\r\n      ew = [@target_w, vw].min\r\n      eh = [@target_h, vh].min\r\n      ox = (vw - ew) / 2\r\n      oy = (vh - eh) / 2\r\n\r\n      # Escurecer áreas fora da gravação (letterbox/pillarbox)\r\n      view.drawing_color = Sketchup::Color.new(0, 0, 0, 120)\r\n      if oy > 0\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(0, 0, 0), Geom::Point3d.new(vw, 0, 0),\r\n          Geom::Point3d.new(vw, oy, 0), Geom::Point3d.new(0, oy, 0)\r\n        ])\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(0, oy + eh, 0), Geom::Point3d.new(vw, oy + eh, 0),\r\n          Geom::Point3d.new(vw, vh, 0), Geom::Point3d.new(0, vh, 0)\r\n        ])\r\n      end\r\n      if ox > 0\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(0, oy, 0), Geom::Point3d.new(ox, oy, 0),\r\n          Geom::Point3d.new(ox, oy + eh, 0), Geom::Point3d.new(0, oy + eh, 0)\r\n        ])\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(ox + ew, oy, 0), Geom::Point3d.new(vw, oy, 0),\r\n          Geom::Point3d.new(vw, oy + eh, 0), Geom::Point3d.new(ox + ew, oy + eh, 0)\r\n        ])\r\n      end\r\n\r\n      # Borda branca ao redor da área de gravação\r\n      view.line_width = 2\r\n      view.drawing_color = Sketchup::Color.new(255, 255, 255, 200)\r\n      view.draw2d(GL_LINE_LOOP, [\r\n        Geom::Point3d.new(ox, oy, 0), Geom::Point3d.new(ox + ew, oy, 0),\r\n        Geom::Point3d.new(ox + ew, oy + eh, 0), Geom::Point3d.new(ox, oy + eh, 0)\r\n      ])\r\n    end\r\n  end\r\n\r\n  module CameraTimeline\r\n    def self.obter_texto(chave)\r\n      ScriptUpComunidade::TourVirtual.obter_texto(chave)\r\n    end\r\n\r\n    module GlobalKey\r\n      extend Fiddle::Importer\r\n      if Sketchup.platform == :platform_win\r\n        dlload 'user32.dll'\r\n        extern 'short GetAsyncKeyState(int)'\r\n      else\r\n        dlload '/System/Library/Frameworks/ApplicationServices.framework/ApplicationServices'\r\n        extern 'bool CGEventSourceKeyState(int, int)'\r\n      end\r\n\r\n      DEFAULT_HOTKEY = (Sketchup.platform == :platform_win ? 0x6B : 69) unless defined?(DEFAULT_HOTKEY)\r\n      @key_code = Sketchup.read_default(\"TourVirtual\", \"Hotkey\", DEFAULT_HOTKEY).to_i\r\n      @ctrl = Sketchup.read_default(\"TourVirtual\", \"HotkeyCtrl\", false)\r\n      @alt = Sketchup.read_default(\"TourVirtual\", \"HotkeyAlt\", false)\r\n      @shift = Sketchup.read_default(\"TourVirtual\", \"HotkeyShift\", false)\r\n\r\n      # Windows virtual key codes for modifiers\r\n      VK_CONTROL = 0x11 unless defined?(VK_CONTROL)\r\n      VK_MENU    = 0x12 unless defined?(VK_MENU)\r\n      VK_SHIFT   = 0x10 unless defined?(VK_SHIFT)\r\n      # macOS key codes for modifiers\r\n      MAC_CTRL  = 59 unless defined?(MAC_CTRL)\r\n      MAC_SHIFT = 56 unless defined?(MAC_SHIFT)\r\n      MAC_ALT   = 58 unless defined?(MAC_ALT)\r\n\r\n      def self.set_hotkey(code, ctrl, alt, shift)\r\n        @key_code = code.to_i\r\n        @ctrl = ctrl\r\n        @alt = alt\r\n        @shift = shift\r\n      end\r\n\r\n      def self.key_code; @key_code; end\r\n      def self.ctrl; @ctrl; end\r\n      def self.alt; @alt; end\r\n      def self.shift; @shift; end\r\n\r\n      def self.key_pressed?(code)\r\n        if Sketchup.platform == :platform_win\r\n          GetAsyncKeyState(code) & 0x8000 != 0\r\n        else\r\n          CGEventSourceKeyState(0, code)\r\n        end\r\n      end\r\n\r\n      def self.space_pressed?\r\n        return false unless key_pressed?(@key_code)\r\n        if Sketchup.platform == :platform_win\r\n          return false if @ctrl && !key_pressed?(VK_CONTROL)\r\n          return false if @alt && !key_pressed?(VK_MENU)\r\n          return false if @shift && !key_pressed?(VK_SHIFT)\r\n        else\r\n          return false if @ctrl && !key_pressed?(MAC_CTRL)\r\n          return false if @alt && !key_pressed?(MAC_ALT)\r\n          return false if @shift && !key_pressed?(MAC_SHIFT)\r\n        end\r\n        true\r\n      end\r\n    end\r\n\r\n    def self.start_space_timer\r\n      return if defined?(@space_timer) && @space_timer\r\n      @space_down = false\r\n      @space_timer = UI.start_timer(0.1, true) do\r\n        if GlobalKey.space_pressed?\r\n          unless @space_down\r\n            @space_down = true\r\n            @dialog.execute_script('triggerSpaceFromRuby()')\r\n          end\r\n        else\r\n          @space_down = false\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.stop_space_timer\r\n      if defined?(@space_timer) && @space_timer\r\n        UI.stop_timer(@space_timer)\r\n        @space_timer = nil\r\n      end\r\n    end\r\n\r\n    def self.capture_thumbnail\r\n      view = Sketchup.active_model.active_view\r\n      # Tentar screen capture instantâneo via GDI32 (Windows)\r\n      result = ScreenCapture.capture_viewport(view, 96, 60) rescue nil\r\n      return result if result && result.length > 0\r\n      # Fallback: write_image (lento, mas funciona em qualquer plataforma)\r\n      path = File.join(Dir.tmpdir, \"thumb_#{Time.now.to_i}.jpg\")\r\n      view.write_image(path, 96, 60, false, 0.5)\r\n      encoded = Base64.strict_encode64(File.binread(path))\r\n      File.delete(path) if File.exist?(path)\r\n      encoded\r\n    end\r\n\r\n    # --- Lógica de Exportação ---\r\n    def self.calcular_rect_gravacao(export_width, export_height)\r\n      view = Sketchup.active_model.active_view\r\n      viewport_global = WindowUtils.get_viewport_rect_deep(view)\r\n\r\n      unless viewport_global\r\n        viewport_global = { :x => 0, :y => 0, :w => view.vpwidth, :h => view.vpheight, :scale => 1.0 }\r\n      end\r\n\r\n      vp_w = viewport_global[:w]\r\n      vp_h = viewport_global[:h]\r\n\r\n      final_w = [export_width.to_i, vp_w].min\r\n      final_h = [export_height.to_i, vp_h].min\r\n\r\n      offset_x = viewport_global[:x] + ((vp_w - final_w) / 2).to_i\r\n      offset_y = viewport_global[:y] + ((vp_h - final_h) / 2).to_i\r\n\r\n      final_w -= 1 if final_w.odd?\r\n      final_h -= 1 if final_h.odd?\r\n\r\n      { :x => offset_x, :y => offset_y, :w => final_w, :h => final_h }\r\n    end\r\n\r\n    def self.iniciar_processo_exportacao(json_data, use_easing, start_index_from_js, export_width, export_height, filename)\r\n      effective_index = start_index_from_js.to_i\r\n\r\n      if effective_index == 0\r\n        @dialog.execute_script(\"currentIndex = 0; updateTime(0); sketchup.goto_camera(JSON.stringify(visoes[0]));\")\r\n        sleep(0.5)\r\n      end\r\n\r\n      rect = calcular_rect_gravacao(export_width, export_height)\r\n      executar_gravacao_ffmpeg(json_data, use_easing, rect, effective_index, filename)\r\n    end\r\n\r\n    def self.iniciar_processo_exportacao_projeto(all_timelines_json, use_easing, active_tl_index, start_vision_index, export_width, export_height, filename)\r\n      timelines = JSON.parse(all_timelines_json, symbolize_names: true)\r\n      rect = calcular_rect_gravacao(export_width, export_height)\r\n\r\n      start_tl = active_tl_index.to_i\r\n      start_vision = start_vision_index.to_i\r\n\r\n      # Calcular duração total a partir do ponto de início\r\n      total_time = 0.0\r\n      timelines.each_with_index do |tl, i|\r\n        next if i < start_tl\r\n        next unless tl[:visoes] && tl[:visoes].length >= 2\r\n        sorted = tl[:visoes].sort_by { |v| v[:time] }\r\n        first_v = (i == start_tl && start_vision > 0 && start_vision < sorted.length) ? start_vision : 0\r\n        if first_v < sorted.length - 1\r\n          total_time += sorted.last[:time] - sorted[first_v][:time]\r\n          total_time += 0.5\r\n        end\r\n      end\r\n\r\n      play_cmd = \"startRecordingPlayAll(#{start_tl}, #{start_vision})\"\r\n      executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, play_cmd)\r\n    end\r\n\r\n    def self.executar_gravacao_ffmpeg(json_data, use_easing, rect, start_index, filename)\r\n      camera_keys = JSON.parse(json_data, symbolize_names: true)\r\n      camera_keys.sort_by! { |v| v[:time] }\r\n\r\n      total_time = 0\r\n      if start_index < camera_keys.length - 1\r\n        relevant_keys = camera_keys[start_index..-1]\r\n        relevant_keys.each_cons(2) { |c, n| total_time += (n[:time] - c[:time]).abs }\r\n      end\r\n\r\n      executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, \"triggerSpaceFromRuby()\")\r\n    end\r\n\r\n    def self.executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, play_command)\r\n      folder = UI.select_directory(title: obter_texto(:selecionar_pasta))\r\n      return unless folder\r\n\r\n      output_path = File.join(folder, \"#{filename}.mp4\")\r\n\r\n      is_win = Sketchup.platform == :platform_win\r\n      ffmpeg_path = File.join(PLUGIN_DIR, 'ffmpeg', is_win ? 'ffmpeg.exe' : 'ffmpeg')\r\n\r\n      unless File.exist?(ffmpeg_path)\r\n        UI.messagebox(obter_texto(:ffmpeg_nao_encontrado))\r\n        return\r\n      end\r\n\r\n      duration_padding = 4.0\r\n      recording_duration = total_time + duration_padding\r\n\r\n      input_format = is_win ? 'gdigrab' : 'avfoundation'\r\n      input_source = is_win ? 'desktop' : '1:none'\r\n\r\n      cmd_array = [\r\n        \"\\\"#{ffmpeg_path}\\\"\",\r\n        '-y',\r\n        '-f', input_format,\r\n        '-framerate', '30',\r\n        '-t', recording_duration.to_s\r\n      ]\r\n\r\n      if is_win\r\n        cmd_array.concat([\r\n          '-draw_mouse', '0',\r\n          '-offset_x', rect[:x].to_s,\r\n          '-offset_y', rect[:y].to_s,\r\n          '-video_size', \"#{rect[:w]}x#{rect[:h]}\",\r\n          '-i', input_source\r\n        ])\r\n      else\r\n        cmd_array.concat([\r\n          '-i', input_source,\r\n          '-vf', \"crop=#{rect[:w]}:#{rect[:h]}:#{rect[:x]}:#{rect[:y]}\"\r\n        ])\r\n      end\r\n\r\n      cmd_array.concat([\r\n        '-c:v', 'libx264',\r\n        '-preset', 'ultrafast',\r\n        '-pix_fmt', 'yuv420p',\r\n        \"\\\"#{output_path}\\\"\"\r\n      ])\r\n\r\n      cmd = cmd_array.join(' ')\r\n\r\n      begin\r\n        if is_win\r\n           WIN32OLE.new('WScript.Shell').Run(cmd, 0, false)\r\n        else\r\n           pid = spawn(cmd)\r\n           Process.detach(pid)\r\n        end\r\n      rescue => e\r\n        UI.messagebox(\"#{obter_texto(:erro_gravador)}#{e.message}\")\r\n        return\r\n      end\r\n\r\n      sleep(1.5)\r\n\r\n      @dialog.execute_script(\"showRecordingIndicator()\")\r\n      @dialog.execute_script(play_command)\r\n\r\n      UI.start_timer(recording_duration + 1.0, false) do\r\n        @dialog.execute_script(\"hideRecordingIndicator()\")\r\n        UI.messagebox(\"#{obter_texto(:gravacao_finalizada)}#{output_path}\")\r\n        @dialog.execute_script(\"resetPlayButton(); resetPlayAll();\")\r\n      end\r\n    end\r\n\r\n    def self.start_ui\r\n      current_hotkey = GlobalKey.key_code\r\n      hotkey_ctrl = GlobalKey.ctrl ? 'true' : 'false'\r\n      hotkey_alt = GlobalKey.alt ? 'true' : 'false'\r\n      hotkey_shift = GlobalKey.shift ? 'true' : 'false'\r\n      ffmpeg_path = File.join(PLUGIN_DIR, 'ffmpeg', Sketchup.platform == :platform_win ? 'ffmpeg.exe' : 'ffmpeg')\r\n      \r\n      has_ffmpeg = File.exist?(ffmpeg_path)\r\n\r\n      view = Sketchup.active_model.active_view\r\n      vp_width = view.vpwidth\r\n      vp_height = view.vpheight\r\n\r\n      js_i18n_hash = {}\r\n      IDIOMAS[IDIOMAS.key?(Sketchup.get_locale) ? Sketchup.get_locale : 'en-US'].each { |k, v| js_i18n_hash[k] = v }\r\n      js_i18n_json = js_i18n_hash.to_json\r\n\r\n      html = <<-HTML\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n  <meta charset=\"utf-8\">\r\n  <title>#{obter_texto(:titulo)}</title>\r\n  <style>\r\n    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }\r\n    body {\r\n      font-family: system-ui, -apple-system, 'Segoe UI', sans-serif;\r\n      background: #f5f5f5; color: #333; font-size: 13px;\r\n      padding: 16px; line-height: 1.4;\r\n    }\r\n\r\n    /* Header */\r\n    .header {\r\n      display: flex; align-items: center; gap: 10px;\r\n      padding-bottom: 14px; border-bottom: 2px solid #0066cc;\r\n      margin-bottom: 16px;\r\n    }\r\n    .header svg { flex-shrink: 0; }\r\n    .header h1 { font-size: 17px; font-weight: 700; color: #1a1a1a; }\r\n    .header .subtitle { font-size: 11px; color: #888; font-weight: 400; }\r\n\r\n    /* Cards */\r\n    .card {\r\n      background: #fff; border: 1px solid #e0e0e0; border-radius: 8px;\r\n      box-shadow: 0 1px 3px rgba(0,0,0,0.06); margin-bottom: 12px;\r\n      overflow: hidden;\r\n    }\r\n    .card-header {\r\n      display: flex; align-items: center; justify-content: space-between;\r\n      padding: 10px 14px; background: #fafafa; border-bottom: 1px solid #eee;\r\n      cursor: pointer; user-select: none;\r\n    }\r\n    .card-header h2 { font-size: 13px; font-weight: 600; color: #444; }\r\n    .card-header .toggle-icon { font-size: 11px; color: #999; transition: transform 0.2s; }\r\n    .card-header.collapsed .toggle-icon { transform: rotate(-90deg); }\r\n    .card-body { padding: 14px; }\r\n    .card-body.collapsed { display: none; }\r\n\r\n    /* Timeline */\r\n    .timeline-wrapper { position: relative; padding: 8px 0 20px; }\r\n    .timeline-track {\r\n      position: absolute; top: 20px; left: 6px; right: 6px; height: 4px;\r\n      background: #ddd; border-radius: 2px; z-index: 0;\r\n    }\r\n    #timeline_range {\r\n      -webkit-appearance: none; appearance: none; width: 100%;\r\n      height: 6px; background: transparent; outline: none;\r\n      position: relative; z-index: 2; cursor: pointer;\r\n    }\r\n    #timeline_range::-webkit-slider-runnable-track {\r\n      height: 6px; background: linear-gradient(90deg, #0066cc 0%, #4da6ff 100%);\r\n      border-radius: 3px;\r\n    }\r\n    #timeline_range::-webkit-slider-thumb {\r\n      -webkit-appearance: none; width: 16px; height: 16px;\r\n      background: #0066cc; border: 2px solid #fff; border-radius: 50%;\r\n      margin-top: -5px; cursor: grab; box-shadow: 0 1px 4px rgba(0,0,0,0.2);\r\n    }\r\n    #timeline_range::-webkit-slider-thumb:active { cursor: grabbing; transform: scale(1.15); }\r\n    #markers_layer {\r\n      position: absolute; top: 0; left: 0; width: 100%; height: 40px;\r\n      pointer-events: none; z-index: 3;\r\n    }\r\n    .marker {\r\n      position: absolute; top: 26px; width: 14px; height: 14px;\r\n      background: #0066cc; border-radius: 50%; border: 2px solid #fff;\r\n      transform: translateX(-50%); pointer-events: auto; cursor: pointer;\r\n      box-shadow: 0 1px 3px rgba(0,0,0,0.15); transition: transform 0.15s, background 0.15s;\r\n    }\r\n    .marker:hover { transform: translateX(-50%) scale(1.25); }\r\n    .marker.anchor { background: #dc3545; }\r\n    .marker .marker-tooltip {\r\n      position: absolute; bottom: 18px; left: 50%; transform: translateX(-50%);\r\n      background: #333; color: #fff; font-size: 10px; padding: 2px 6px;\r\n      border-radius: 3px; white-space: nowrap; opacity: 0;\r\n      pointer-events: none; transition: opacity 0.15s;\r\n    }\r\n    .marker:hover .marker-tooltip { opacity: 1; }\r\n    .time-row {\r\n      display: flex; align-items: center; justify-content: space-between;\r\n      margin-top: 8px; gap: 12px;\r\n    }\r\n    .time-display { font-size: 20px; font-weight: 700; color: #0066cc; font-variant-numeric: tabular-nums; }\r\n    .time-display small { font-size: 12px; color: #888; font-weight: 400; }\r\n    .time-input-group { display: flex; align-items: center; gap: 6px; }\r\n    .time-input-group label { font-size: 11px; color: #666; }\r\n\r\n    /* Buttons */\r\n    .btn {\r\n      display: inline-flex; align-items: center; justify-content: center; gap: 6px;\r\n      padding: 7px 14px; border: 1px solid transparent; border-radius: 6px;\r\n      font-size: 12px; font-weight: 500; cursor: pointer;\r\n      transition: all 0.15s; outline: none; font-family: inherit;\r\n    }\r\n    .btn:active { transform: scale(0.97); }\r\n    .btn-primary { background: #0066cc; color: #fff; }\r\n    .btn-primary:hover { background: #0052a3; }\r\n    .btn-success { background: #28a745; color: #fff; }\r\n    .btn-success:hover { background: #218838; }\r\n    .btn-danger { background: #dc3545; color: #fff; }\r\n    .btn-danger:hover { background: #c82333; }\r\n    .btn-outline { background: transparent; border: 1px solid #ccc; color: #555; }\r\n    .btn-outline:hover { background: #f0f0f0; border-color: #aaa; }\r\n    .btn-sm { padding: 4px 10px; font-size: 11px; }\r\n    .btn-record { background: #dc3545; color: #fff; padding: 10px 20px; font-size: 13px; font-weight: 600; }\r\n    .btn-record:hover { background: #c82333; }\r\n    .btn-record:disabled { background: #ccc; color: #888; cursor: not-allowed; }\r\n\r\n    .btn-group { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }\r\n\r\n    /* Checkboxes */\r\n    .check-group { display: flex; align-items: center; gap: 16px; margin-top: 10px; }\r\n    .check-item { display: flex; align-items: center; gap: 5px; }\r\n    .check-item input[type=\"checkbox\"] {\r\n      width: 15px; height: 15px; accent-color: #0066cc; cursor: pointer;\r\n    }\r\n    .check-item label { font-size: 12px; color: #555; cursor: pointer; }\r\n\r\n    /* Hotkey */\r\n    .hotkey-editor {\r\n      display: none; align-items: center; gap: 6px;\r\n      background: #f9f9f9; padding: 6px 10px; border-radius: 6px; border: 1px solid #ddd;\r\n    }\r\n    .hotkey-editor.visible { display: inline-flex; }\r\n    .hotkey-editor input {\r\n      width: 100px; padding: 4px 8px; border: 1px solid #ccc;\r\n      border-radius: 4px; font-size: 12px; font-family: monospace;\r\n      outline: none;\r\n    }\r\n    .hotkey-editor input:focus { border-color: #0066cc; }\r\n\r\n    /* Vision List */\r\n    .vision-list { max-height: 350px; overflow-y: auto; }\r\n    .vision-list::-webkit-scrollbar { width: 6px; }\r\n    .vision-list::-webkit-scrollbar-track { background: #f0f0f0; border-radius: 3px; }\r\n    .vision-list::-webkit-scrollbar-thumb { background: #ccc; border-radius: 3px; }\r\n    .vision-list::-webkit-scrollbar-thumb:hover { background: #aaa; }\r\n    .vision-item {\r\n      display: flex; align-items: center; gap: 10px; padding: 8px 10px;\r\n      border-bottom: 1px solid #f0f0f0; cursor: pointer;\r\n      transition: background 0.12s;\r\n    }\r\n    .vision-item:hover { background: #f7faff; }\r\n    .vision-item:last-child { border-bottom: none; }\r\n    .vision-item .vision-num {\r\n      font-size: 11px; font-weight: 700; color: #999; width: 20px;\r\n      text-align: center; flex-shrink: 0;\r\n    }\r\n    .vision-item img {\r\n      width: 72px; height: 45px; object-fit: cover; border-radius: 4px;\r\n      border: 1px solid #ddd; flex-shrink: 0;\r\n    }\r\n    .vision-item img.thumb-placeholder {\r\n      background: linear-gradient(135deg, #e0e0e0 0%, #c0c0c0 100%);\r\n      animation: pulse-placeholder 1s ease-in-out infinite alternate;\r\n    }\r\n    @keyframes pulse-placeholder {\r\n      from { opacity: 0.6; }\r\n      to { opacity: 1.0; }\r\n    }\r\n    .vision-item .vision-info { flex: 1; min-width: 0; }\r\n    .vision-item .vision-time-input {\r\n      width: 58px; padding: 3px 6px; border: 1px solid #ddd; border-radius: 4px;\r\n      font-size: 12px; text-align: center; outline: none; font-family: inherit;\r\n    }\r\n    .vision-item .vision-time-input:focus { border-color: #0066cc; }\r\n    .vision-item .vision-time-input:disabled { background: #f5f5f5; color: #999; }\r\n    .vision-actions { display: flex; align-items: center; gap: 6px; flex-shrink: 0; }\r\n    .anchor-toggle {\r\n      width: 26px; height: 26px; border-radius: 50%; border: 2px solid #ddd;\r\n      background: transparent; cursor: pointer; display: flex;\r\n      align-items: center; justify-content: center; transition: all 0.15s;\r\n      font-size: 12px; color: #ccc;\r\n    }\r\n    .anchor-toggle:hover { border-color: #dc3545; color: #dc3545; }\r\n    .anchor-toggle.active { background: #dc3545; border-color: #dc3545; color: #fff; }\r\n    .delete-btn {\r\n      width: 26px; height: 26px; border-radius: 50%; border: 1px solid #eee;\r\n      background: transparent; cursor: pointer; display: flex;\r\n      align-items: center; justify-content: center; transition: all 0.15s;\r\n      font-size: 14px; color: #ccc;\r\n    }\r\n    .delete-btn:hover { background: #fee; border-color: #dc3545; color: #dc3545; }\r\n    .empty-state {\r\n      text-align: center; padding: 30px 16px; color: #aaa;\r\n    }\r\n    .empty-state svg { margin-bottom: 8px; opacity: 0.4; }\r\n    .empty-state p { font-size: 12px; }\r\n\r\n    /* Export Section */\r\n    .preset-select {\r\n      width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px;\r\n      font-size: 12px; font-family: inherit; outline: none; background: #fff;\r\n      cursor: pointer; color: #333;\r\n    }\r\n    .preset-select:focus { border-color: #0066cc; }\r\n    .preset-preview {\r\n      display: flex; align-items: center; justify-content: center;\r\n      padding: 8px; margin-top: 8px; background: #f7faff;\r\n      border: 1px dashed #b3d4fc; border-radius: 6px;\r\n      font-size: 12px; color: #0066cc; font-weight: 600;\r\n    }\r\n    .custom-dims {\r\n      display: none; gap: 8px; align-items: center; margin-top: 8px;\r\n    }\r\n    .custom-dims.visible { display: flex; }\r\n    .custom-dims input {\r\n      width: 80px; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px;\r\n      font-size: 12px; text-align: center; outline: none; font-family: inherit;\r\n    }\r\n    .custom-dims input:focus { border-color: #0066cc; }\r\n    .custom-dims span { color: #999; font-weight: 600; }\r\n\r\n    /* Recording indicator */\r\n    .recording-bar {\r\n      display: none; align-items: center; gap: 8px; padding: 10px 14px;\r\n      background: #fff5f5; border: 1px solid #f5c6cb; border-radius: 6px;\r\n      margin-top: 10px;\r\n    }\r\n    .recording-bar.active { display: flex; }\r\n    .recording-dot {\r\n      width: 10px; height: 10px; background: #dc3545; border-radius: 50%;\r\n      animation: pulse 1s infinite;\r\n    }\r\n    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }\r\n    .recording-bar span { font-size: 12px; color: #dc3545; font-weight: 600; }\r\n\r\n    /* Playing overlay */\r\n    body.playing .card { opacity: 0.6; pointer-events: none; }\r\n    body.playing .card.playback-card { opacity: 1; pointer-events: auto; }\r\n    body.playing .card.playback-card .btn:not(#play_button):not(#play_all_button) { pointer-events: none; opacity: 0.4; }\r\n    body.playing #play_button, body.playing #play_all_button { pointer-events: auto !important; opacity: 1 !important; }\r\n\r\n    /* Input base */\r\n    input[type=\"number\"] {\r\n      -moz-appearance: textfield;\r\n    }\r\n    input[type=\"number\"]::-webkit-inner-spin-button {\r\n      -webkit-appearance: none;\r\n    }\r\n\r\n    /* Draggable markers */\r\n    .marker { cursor: grab; }\r\n    .marker.dragging {\r\n      transform: translateX(-50%) scale(1.3);\r\n      z-index: 20;\r\n      cursor: grabbing;\r\n    }\r\n    .marker.no-drag { cursor: default; }\r\n\r\n    /* Saved timelines list */\r\n    .saved-timelines-list { margin-top: 10px; }\r\n    .saved-timelines-list:empty { display: none; }\r\n    .tl-item {\r\n      display: flex; align-items: center; gap: 8px;\r\n      padding: 6px 10px; border-bottom: 1px solid #f0f0f0;\r\n      cursor: pointer; transition: background 0.12s; font-size: 12px;\r\n    }\r\n    .tl-item:hover { background: #f7faff; }\r\n    .tl-item:last-child { border-bottom: none; }\r\n    .tl-item .tl-indicator {\r\n      width: 8px; height: 8px; border-radius: 50%;\r\n      background: #ccc; flex-shrink: 0;\r\n    }\r\n    .tl-item.active .tl-indicator { background: #0066cc; }\r\n    .tl-item .tl-name { flex: 1; font-weight: 500; color: #333; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }\r\n    .tl-item .tl-count { color: #999; font-size: 11px; flex-shrink: 0; }\r\n    .tl-item .tl-delete {\r\n      width: 20px; height: 20px; border-radius: 50%; border: 1px solid #eee;\r\n      background: transparent; cursor: pointer; display: flex;\r\n      align-items: center; justify-content: center; font-size: 12px; color: #ccc;\r\n      flex-shrink: 0; transition: all 0.15s;\r\n    }\r\n    .tl-item .tl-delete:hover { background: #fee; border-color: #dc3545; color: #dc3545; }\r\n\r\n    /* Drag-and-drop for timeline reordering */\r\n    .tl-drag-handle {\r\n      cursor: grab; flex-shrink: 0; color: #ccc; font-size: 14px;\r\n      padding: 0 4px; user-select: none;\r\n    }\r\n    .tl-drag-handle:active { cursor: grabbing; }\r\n    .tl-item.dragging { opacity: 0.4; }\r\n    .tl-item.drag-over-top { border-top: 2px solid #0066cc; }\r\n    .tl-item.drag-over-bottom { border-bottom: 2px solid #0066cc; }\r\n\r\n    /* Viewport info */\r\n    .viewport-info {\r\n      font-size: 11px; color: #666; margin-bottom: 10px;\r\n      padding: 6px 10px; background: #f9f9f9; border-radius: 4px; border: 1px solid #eee;\r\n    }\r\n\r\n    /* Misc */\r\n    .hidden { display: none !important; }\r\n    .mt-8 { margin-top: 8px; }\r\n  </style>\r\n</head>\r\n<body>\r\n\r\n<!-- Header -->\r\n<div class=\"header\">\r\n  <svg width=\"28\" height=\"28\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"#0066cc\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <path d=\"M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z\"/>\r\n    <circle cx=\"12\" cy=\"13\" r=\"4\"/>\r\n  </svg>\r\n  <div>\r\n    <h1>#{obter_texto(:titulo)}</h1>\r\n    <span class=\"subtitle\">#{obter_texto(:subtitulo)}</span>\r\n  </div>\r\n</div>\r\n\r\n<!-- Timeline Card -->\r\n<div class=\"card\">\r\n  <div class=\"card-body\">\r\n    <div class=\"timeline-wrapper\">\r\n      <div class=\"timeline-track\"></div>\r\n      <input type=\"range\" min=\"0\" max=\"60\" step=\"0.1\" value=\"0\" id=\"timeline_range\" oninput=\"updateTime(this.value)\">\r\n      <div id=\"markers_layer\"></div>\r\n    </div>\r\n    <div class=\"time-row\">\r\n      <div class=\"time-display\"><span id=\"current_time\">0.0</span><small>s</small></div>\r\n      <div class=\"time-input-group\">\r\n        <label>#{obter_texto(:total)}</label>\r\n        <input id=\"max_time\" type=\"number\" step=\"1\" value=\"60\" min=\"1\" onchange=\"atualizarTempoTotal()\"\r\n          style=\"width:65px; padding:4px 8px; border:1px solid #ddd; border-radius:4px; font-size:12px; text-align:center; outline:none; font-family:inherit;\">\r\n        <small style=\"color:#888;\">s</small>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Playback Controls Card -->\r\n<div class=\"card playback-card\">\r\n  <div class=\"card-body\">\r\n    <div class=\"btn-group\">\r\n      <button class=\"btn btn-primary\" onclick=\"addVision()\">\r\n        <svg width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2.5\"><line x1=\"12\" y1=\"5\" x2=\"12\" y2=\"19\"/><line x1=\"5\" y1=\"12\" x2=\"19\" y2=\"12\"/></svg>\r\n        #{obter_texto(:visao)}\r\n      </button>\r\n      <button id=\"play_button\" class=\"btn btn-success\" onclick=\"togglePlay()\">&#9654; #{obter_texto(:play)}</button>\r\n      <button id=\"play_all_button\" class=\"btn btn-outline btn-sm hidden\" onclick=\"togglePlayAll()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><polygon points=\"5 3 19 12 5 21 5 3\"/><line x1=\"19\" y1=\"3\" x2=\"19\" y2=\"21\"/></svg>\r\n        #{obter_texto(:play_all)}\r\n      </button>\r\n      <button class=\"btn btn-outline btn-sm\" onclick=\"mostrarCampoAtalho()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><rect x=\"2\" y=\"4\" width=\"20\" height=\"16\" rx=\"2\"/><line x1=\"6\" y1=\"8\" x2=\"6\" y2=\"8\"/><line x1=\"10\" y1=\"8\" x2=\"10\" y2=\"8\"/><line x1=\"14\" y1=\"8\" x2=\"14\" y2=\"8\"/><line x1=\"18\" y1=\"8\" x2=\"18\" y2=\"8\"/><line x1=\"8\" y1=\"16\" x2=\"16\" y2=\"16\"/></svg>\r\n        #{obter_texto(:atalho)}\r\n      </button>\r\n      <span id=\"hotkey_edit\" class=\"hotkey-editor\">\r\n        <input id=\"hotkey_input\" type=\"text\" placeholder=\"#{obter_texto(:pressione)}\" onkeydown=\"capturarAtalhoInput(event)\">\r\n        <button class=\"btn btn-primary btn-sm\" onclick=\"confirmarAtalho()\">#{obter_texto(:ok)}</button>\r\n      </span>\r\n    </div>\r\n    <div class=\"check-group\">\r\n      <div class=\"check-item\">\r\n        <input type=\"checkbox\" id=\"loop_checkbox\">\r\n        <label for=\"loop_checkbox\">#{obter_texto(:loop)}</label>\r\n      </div>\r\n      <div class=\"check-item\">\r\n        <input type=\"checkbox\" id=\"easing_checkbox\">\r\n        <label for=\"easing_checkbox\">#{obter_texto(:easing)}</label>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Visions Card -->\r\n<div class=\"card\">\r\n  <div class=\"card-header\" onclick=\"toggleSection('visions')\">\r\n    <h2>#{obter_texto(:visoes_salvas)} <span id=\"vision_count\" style=\"color:#999; font-weight:400;\"></span></h2>\r\n    <span class=\"toggle-icon\" id=\"visions_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body\" id=\"visions_body\">\r\n    <div class=\"vision-list\" id=\"lista_visoes\"></div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Gerenciar Time Line Card -->\r\n<div class=\"card\">\r\n  <div class=\"card-header\" onclick=\"toggleSection('timeline_mgr')\">\r\n    <h2>#{obter_texto(:gerenciar_timeline)}</h2>\r\n    <span class=\"toggle-icon\" id=\"timeline_mgr_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body\" id=\"timeline_mgr_body\">\r\n    <div class=\"btn-group\">\r\n      <button class=\"btn btn-outline\" onclick=\"novaTimeline()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z\"/><polyline points=\"14 2 14 8 20 8\"/><line x1=\"12\" y1=\"18\" x2=\"12\" y2=\"12\"/><line x1=\"9\" y1=\"15\" x2=\"15\" y2=\"15\"/></svg>\r\n        #{obter_texto(:nova)}\r\n      </button>\r\n      <button class=\"btn btn-outline\" onclick=\"exportarTimeline()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\"/><polyline points=\"7 10 12 15 17 10\"/><line x1=\"12\" y1=\"15\" x2=\"12\" y2=\"3\"/></svg>\r\n        #{obter_texto(:exportar_atual)}\r\n      </button>\r\n      <button class=\"btn btn-outline\" onclick=\"exportarProjeto()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z\"/><polyline points=\"9 14 12 17 15 14\"/><line x1=\"12\" y1=\"17\" x2=\"12\" y2=\"10\"/></svg>\r\n        #{obter_texto(:exportar_projeto)}\r\n      </button>\r\n      <input type=\"file\" id=\"import_file\" class=\"hidden\" accept=\".json\" onchange=\"importarTimeline(this)\">\r\n      <button class=\"btn btn-outline\" onclick=\"document.getElementById('import_file').click()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\"/><polyline points=\"17 8 12 3 7 8\"/><line x1=\"12\" y1=\"3\" x2=\"12\" y2=\"15\"/></svg>\r\n        #{obter_texto(:importar)}\r\n      </button>\r\n    </div>\r\n    <div id=\"saved_timelines_list\" class=\"saved-timelines-list\"></div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Exportar Vídeo Card (colapsado por padrão) -->\r\n<div class=\"card\">\r\n  <div class=\"card-header collapsed\" onclick=\"toggleSection('export')\">\r\n    <h2>#{obter_texto(:exportar_video)}</h2>\r\n    <span class=\"toggle-icon\" id=\"export_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body collapsed\" id=\"export_body\">\r\n    <div id=\"ffmpeg_section\" class=\"#{has_ffmpeg ? '' : 'hidden'}\">\r\n      <div class=\"viewport-info\">\r\n        #{obter_texto(:viewport_atual)} <strong>#{vp_width} x #{vp_height} px</strong>\r\n      </div>\r\n\r\n      <select id=\"preset_select\" class=\"preset-select\" onchange=\"onPresetChange()\">\r\n        <option value=\"\" disabled selected>#{obter_texto(:selecione_formato)}</option>\r\n      </select>\r\n\r\n      <div class=\"custom-dims\" id=\"custom_dims\">\r\n        <input type=\"number\" id=\"custom_w\" min=\"50\" placeholder=\"#{obter_texto(:largura)}\" value=\"1280\">\r\n        <span>x</span>\r\n        <input type=\"number\" id=\"custom_h\" min=\"50\" placeholder=\"#{obter_texto(:altura)}\" value=\"720\">\r\n        <small style=\"color:#888;\">px</small>\r\n      </div>\r\n\r\n      <div class=\"preset-preview\" id=\"preset_preview\" style=\"display:none;\"></div>\r\n\r\n      <div class=\"check-group\" style=\"margin-top:12px; flex-direction:column; align-items:flex-start; gap:8px;\">\r\n        <div class=\"check-item\">\r\n          <input type=\"checkbox\" id=\"rec_projeto\">\r\n          <label for=\"rec_projeto\">#{obter_texto(:gravar_projeto)}</label>\r\n        </div>\r\n        <div class=\"check-item\">\r\n          <input type=\"checkbox\" id=\"rec_inicio\" checked>\r\n          <label for=\"rec_inicio\">#{obter_texto(:iniciar_quadro1)}</label>\r\n        </div>\r\n      </div>\r\n\r\n      <button class=\"btn btn-record mt-8\" id=\"btn_record\" onclick=\"iniciarGravacao()\" disabled style=\"width:100%; margin-top:12px;\">\r\n        <svg width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><circle cx=\"12\" cy=\"12\" r=\"4\" fill=\"currentColor\"/></svg>\r\n        #{obter_texto(:iniciar_gravacao)}\r\n      </button>\r\n\r\n      <div class=\"recording-bar\" id=\"recording_bar\">\r\n        <div class=\"recording-dot\"></div>\r\n        <span>#{obter_texto(:gravando)}</span>\r\n      </div>\r\n    </div>\r\n\r\n    <div id=\"ffmpeg_install\" class=\"#{has_ffmpeg ? 'hidden' : ''}\" style=\"text-align:center; padding:12px 0;\">\r\n      <p style=\"color:#888; font-size:12px; margin-bottom:10px;\">#{obter_texto(:ffmpeg_necessario)}</p>\r\n      <button class=\"btn btn-primary\" onclick=\"instalarExportacao()\">#{obter_texto(:instalar_ffmpeg)}</button>\r\n    </div>\r\n\r\n    <!-- Modal de nome do arquivo -->\r\n    <div id=\"filename_modal\" style=\"display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.4);z-index:100;align-items:center;justify-content:center;\">\r\n      <div style=\"background:#fff;border-radius:10px;padding:24px;width:320px;box-shadow:0 8px 30px rgba(0,0,0,0.2);\">\r\n        <h3 style=\"font-size:14px;font-weight:600;color:#333;margin-bottom:12px;\">#{obter_texto(:nome_arquivo)}</h3>\r\n        <input id=\"filename_input\" type=\"text\" value=\"tour_final\" style=\"width:100%;padding:8px 12px;border:1px solid #ddd;border-radius:6px;font-size:13px;font-family:inherit;outline:none;margin-bottom:6px;\">\r\n        <small style=\"color:#888;\">#{obter_texto(:extensao_mp4)}</small>\r\n        <div style=\"display:flex;gap:8px;margin-top:16px;justify-content:flex-end;\">\r\n          <button class=\"btn btn-outline btn-sm\" onclick=\"fecharModalFilename()\">#{obter_texto(:cancelar)}</button>\r\n          <button class=\"btn btn-primary btn-sm\" onclick=\"confirmarFilename()\">#{obter_texto(:salvar)}</button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Modal de nome da timeline -->\r\n<div id=\"timeline_name_modal\" style=\"display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.4);z-index:100;align-items:center;justify-content:center;\">\r\n  <div style=\"background:#fff;border-radius:10px;padding:24px;width:320px;box-shadow:0 8px 30px rgba(0,0,0,0.2);\">\r\n    <h3 id=\"timeline_name_title\" style=\"font-size:14px;font-weight:600;color:#333;margin-bottom:12px;\"></h3>\r\n    <input id=\"timeline_name_input\" type=\"text\" onkeydown=\"if(event.keyCode===13){confirmarModalTimeline();}\" style=\"width:100%;padding:8px 12px;border:1px solid #ddd;border-radius:6px;font-size:13px;font-family:inherit;outline:none;margin-bottom:6px;\">\r\n    <div style=\"display:flex;gap:8px;margin-top:16px;justify-content:flex-end;\">\r\n      <button class=\"btn btn-outline btn-sm\" onclick=\"fecharModalTimeline()\">#{obter_texto(:cancelar)}</button>\r\n      <button class=\"btn btn-primary btn-sm\" onclick=\"confirmarModalTimeline()\">#{obter_texto(:ok)}</button>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<script>\r\n    const I18N = #{js_i18n_json};\r\n    let visoes = [], playing = false, currentIndex = 0;\r\n    let hotkey = { keyCode: #{current_hotkey}, ctrl: #{hotkey_ctrl}, alt: #{hotkey_alt}, shift: #{hotkey_shift} };\r\n    let capturingHotkey = false, pendingHotkey = null;\r\n    let savedTimelines = [];\r\n    let activeTimelineIndex = -1;\r\n    let playingAll = false, playAllQueue = [], playAllCurrentIdx = 0;\r\n    var viewportW = #{vp_width}, viewportH = #{vp_height};\r\n\r\n    if (window.sketchup) { window.sketchup.set_hotkey(hotkey.keyCode, hotkey.ctrl, hotkey.alt, hotkey.shift); }\r\n\r\n    /* --- Export Formats (aspect ratios) --- */\r\n    const EXPORT_FORMATS = [\r\n      { label: '16:9 ' + I18N.paisagem, ratio: [16, 9] },\r\n      { label: '9:16 ' + I18N.retrato, ratio: [9, 16] },\r\n      { label: '1:1 ' + I18N.quadrado, ratio: [1, 1] },\r\n      { label: '4:3 ' + I18N.classico, ratio: [4, 3] },\r\n      { label: '21:9 ' + I18N.ultra_wide, ratio: [21, 9] },\r\n      { label: I18N.viewport_inteira, ratio: null },\r\n      { label: I18N.personalizado, ratio: null, custom: true }\r\n    ];\r\n\r\n    function calcEffectiveDims(ratioW, ratioH, vpW, vpH) {\r\n      const scaleW = vpW / ratioW;\r\n      const scaleH = vpH / ratioH;\r\n      const scale = Math.min(scaleW, scaleH);\r\n      let w = Math.floor(ratioW * scale);\r\n      let h = Math.floor(ratioH * scale);\r\n      w = w % 2 === 0 ? w : w - 1;\r\n      h = h % 2 === 0 ? h : h - 1;\r\n      return { w: w, h: h };\r\n    }\r\n\r\n    function populatePresets() {\r\n      const sel = document.getElementById(\"preset_select\");\r\n      sel.innerHTML = '<option value=\"\" disabled selected>' + I18N.selecione_formato + '</option>';\r\n      EXPORT_FORMATS.forEach((fmt, i) => {\r\n        const opt = document.createElement(\"option\");\r\n        opt.value = i.toString();\r\n        if (fmt.custom) {\r\n          opt.textContent = fmt.label;\r\n        } else if (fmt.ratio) {\r\n          const dims = calcEffectiveDims(fmt.ratio[0], fmt.ratio[1], viewportW, viewportH);\r\n          opt.textContent = fmt.label + \" (\" + dims.w + \" x \" + dims.h + \" px)\";\r\n        } else {\r\n          let w = viewportW % 2 === 0 ? viewportW : viewportW - 1;\r\n          let h = viewportH % 2 === 0 ? viewportH : viewportH - 1;\r\n          opt.textContent = fmt.label + \" (\" + w + \" x \" + h + \" px)\";\r\n        }\r\n        sel.appendChild(opt);\r\n      });\r\n    }\r\n\r\n    /* --- Section Toggle --- */\r\n    function toggleSection(name) {\r\n      const body = document.getElementById(name + '_body');\r\n      const icon = document.getElementById(name + '_toggle');\r\n      const header = icon.parentElement;\r\n      const wasCollapsed = body.classList.contains('collapsed');\r\n      if (wasCollapsed) {\r\n        body.classList.remove('collapsed');\r\n        header.classList.remove('collapsed');\r\n      } else {\r\n        body.classList.add('collapsed');\r\n        header.classList.add('collapsed');\r\n      }\r\n      /* Hide viewport preview when closing export card */\r\n      if (name === 'export' && !wasCollapsed) {\r\n        if (window.sketchup) window.sketchup.hide_export_preview();\r\n      }\r\n    }\r\n\r\n    /* --- Timeline --- */\r\n    function updateTime(val) {\r\n      document.getElementById(\"current_time\").innerText = parseFloat(val).toFixed(1);\r\n    }\r\n\r\n    function atualizarTempoTotal() {\r\n      const novoMax = parseFloat(document.getElementById(\"max_time\").value);\r\n      if (isNaN(novoMax) || novoMax <= 0) return;\r\n      document.getElementById(\"timeline_range\").max = novoMax;\r\n      visoes.forEach(v => { if (v.time > novoMax) v.time = novoMax - 0.1; });\r\n      renderMarkers();\r\n    }\r\n\r\n    /* --- Timeline Name Modal --- */\r\n    var _timelineModalCallback = null;\r\n\r\n    function abrirModalTimeline(titulo, valorPadrao, callback) {\r\n      _timelineModalCallback = callback;\r\n      document.getElementById(\"timeline_name_title\").textContent = titulo;\r\n      var input = document.getElementById(\"timeline_name_input\");\r\n      input.value = valorPadrao;\r\n      var modal = document.getElementById(\"timeline_name_modal\");\r\n      modal.style.display = \"flex\";\r\n      setTimeout(function() { input.focus(); input.select(); }, 50);\r\n    }\r\n\r\n    function fecharModalTimeline() {\r\n      document.getElementById(\"timeline_name_modal\").style.display = \"none\";\r\n      _timelineModalCallback = null;\r\n    }\r\n\r\n    function confirmarModalTimeline() {\r\n      var name = document.getElementById(\"timeline_name_input\").value.trim();\r\n      if (!name) return;\r\n      document.getElementById(\"timeline_name_modal\").style.display = \"none\";\r\n      if (_timelineModalCallback) {\r\n        _timelineModalCallback(name);\r\n        _timelineModalCallback = null;\r\n      }\r\n    }\r\n\r\n    /* --- Visions --- */\r\n    function addVision() {\r\n      if (savedTimelines.length === 0 && visoes.length === 0) {\r\n        abrirModalTimeline(I18N.nome_timeline, \"Time Line 1\", function(name) {\r\n          savedTimelines.push({ name: name, visoes: [], maxTime: 60 });\r\n          activeTimelineIndex = 0;\r\n          renderSavedTimelines();\r\n          var time = parseFloat(document.getElementById(\"timeline_range\").value);\r\n          sketchup.capture_camera(time);\r\n        });\r\n        return;\r\n      }\r\n      var time = parseFloat(document.getElementById(\"timeline_range\").value);\r\n      sketchup.capture_camera(time);\r\n    }\r\n\r\n    function captureVisionFromRuby(camJson) {\r\n      const obj = JSON.parse(camJson);\r\n      obj.walk = false; obj.anchor = false;\r\n      visoes = visoes.filter(v => v.time !== obj.time);\r\n      visoes.push(obj);\r\n      visoes.sort((a, b) => a.time - b.time);\r\n      visoes[0].time = 0.0;\r\n      syncActiveTimeline();\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    /* --- Draggable markers --- */\r\n    function setupMarkerDrag(marker, visionIndex, slider, maxTime) {\r\n      if (visionIndex === 0) {\r\n        marker.classList.add(\"no-drag\");\r\n        return;\r\n      }\r\n      marker.addEventListener(\"mousedown\", function(e) {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        marker.classList.add(\"dragging\");\r\n        const sliderPadding = 8;\r\n\r\n        function onMove(ev) {\r\n          const sliderRect = slider.getBoundingClientRect();\r\n          const usableWidth = sliderRect.width - sliderPadding * 2;\r\n          const relativeX = Math.max(0, Math.min(ev.clientX - sliderRect.left - sliderPadding, usableWidth));\r\n          const newTime = parseFloat(((relativeX / usableWidth) * maxTime).toFixed(1));\r\n          marker.style.left = (relativeX + sliderPadding) + \"px\";\r\n          const tooltip = marker.querySelector(\".marker-tooltip\");\r\n          if (tooltip) tooltip.textContent = newTime.toFixed(1) + \"s\";\r\n        }\r\n\r\n        function onUp(ev) {\r\n          marker.classList.remove(\"dragging\");\r\n          document.removeEventListener(\"mousemove\", onMove);\r\n          document.removeEventListener(\"mouseup\", onUp);\r\n          const sliderRect = slider.getBoundingClientRect();\r\n          const usableWidth = sliderRect.width - sliderPadding * 2;\r\n          const relativeX = Math.max(0, Math.min(ev.clientX - sliderRect.left - sliderPadding, usableWidth));\r\n          const newTime = parseFloat(((relativeX / usableWidth) * maxTime).toFixed(1));\r\n          visoes[visionIndex].time = Math.max(0.1, newTime);\r\n          visoes.sort((a, b) => a.time - b.time);\r\n          if (visoes.length > 0) visoes[0].time = 0.0;\r\n          renderMarkers();\r\n        }\r\n\r\n        document.addEventListener(\"mousemove\", onMove);\r\n        document.addEventListener(\"mouseup\", onUp);\r\n      });\r\n    }\r\n\r\n    function syncActiveTimeline() {\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n    }\r\n\r\n    function renderMarkers() {\r\n      const layer = document.getElementById(\"markers_layer\");\r\n      const lista = document.getElementById(\"lista_visoes\");\r\n      const slider = document.getElementById(\"timeline_range\");\r\n      const max = parseFloat(slider.max);\r\n      const width = slider.offsetWidth;\r\n      const countEl = document.getElementById(\"vision_count\");\r\n\r\n      layer.innerHTML = \"\"; lista.innerHTML = \"\";\r\n      countEl.textContent = visoes.length > 0 ? \"(\" + visoes.length + \")\" : \"\";\r\n\r\n      if (visoes.length === 0) {\r\n        lista.innerHTML = '<div class=\"empty-state\">' +\r\n          '<svg width=\"36\" height=\"36\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"#ccc\" stroke-width=\"1.5\"><path d=\"M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z\"/><circle cx=\"12\" cy=\"13\" r=\"4\"/></svg>' +\r\n          '<p>' + I18N.nenhuma_visao + '<br>' + I18N.dica_visao + '</p></div>';\r\n        return;\r\n      }\r\n\r\n      visoes.forEach((v, i) => {\r\n        /* Marker on timeline */\r\n        const percent = max > 0 ? v.time / max : 0;\r\n        const marker = document.createElement(\"div\");\r\n        marker.className = \"marker\" + (v.anchor ? \" anchor\" : \"\");\r\n        const sliderPadding = 8;\r\n        const usableWidth = width - sliderPadding * 2;\r\n        marker.style.left = (percent * usableWidth + sliderPadding) + \"px\";\r\n        const tooltip = document.createElement(\"span\");\r\n        tooltip.className = \"marker-tooltip\";\r\n        tooltip.textContent = v.time.toFixed(1) + \"s\";\r\n        marker.appendChild(tooltip);\r\n        marker.onclick = () => {\r\n          slider.value = v.time; updateTime(v.time); currentIndex = i;\r\n          resetPlayButton(); sketchup.goto_camera(JSON.stringify(v));\r\n        };\r\n        /* Draggable */\r\n        setupMarkerDrag(marker, i, slider, max);\r\n        layer.appendChild(marker);\r\n\r\n        /* Vision list item */\r\n        const item = document.createElement(\"div\");\r\n        item.className = \"vision-item\";\r\n        item.onclick = () => {\r\n          slider.value = v.time; updateTime(v.time); currentIndex = i;\r\n          resetPlayButton(); sketchup.goto_camera(JSON.stringify(v));\r\n        };\r\n\r\n        const num = document.createElement(\"span\");\r\n        num.className = \"vision-num\";\r\n        num.textContent = (i + 1);\r\n\r\n        const img = document.createElement(\"img\");\r\n        if (v.thumb && v.thumb.length > 0) {\r\n          const mime = v.thumb.startsWith(\"/9j/\") ? \"image/jpeg\" : \"image/bmp\";\r\n          img.src = \"data:\" + mime + \";base64,\" + v.thumb;\r\n        } else {\r\n          img.src = \"\";\r\n          img.className = \"thumb-placeholder\";\r\n        }\r\n\r\n        const info = document.createElement(\"div\");\r\n        info.className = \"vision-info\";\r\n        const timeInput = document.createElement(\"input\");\r\n        timeInput.type = \"number\"; timeInput.step = \"0.1\";\r\n        timeInput.value = v.time.toFixed(1);\r\n        timeInput.className = \"vision-time-input\";\r\n        timeInput.disabled = (i === 0);\r\n        timeInput.onclick = (e) => e.stopPropagation();\r\n        timeInput.onchange = () => {\r\n          v.time = parseFloat(timeInput.value);\r\n          visoes.sort((a, b) => a.time - b.time);\r\n          renderMarkers();\r\n        };\r\n        info.appendChild(timeInput);\r\n\r\n        const actions = document.createElement(\"div\");\r\n        actions.className = \"vision-actions\";\r\n\r\n        const anchorBtn = document.createElement(\"button\");\r\n        anchorBtn.className = \"anchor-toggle\" + (v.anchor ? \" active\" : \"\");\r\n        anchorBtn.innerHTML = \"&#9875;\";\r\n        anchorBtn.title = I18N.ancora;\r\n        anchorBtn.onclick = (e) => {\r\n          e.stopPropagation();\r\n          v.anchor = !v.anchor;\r\n          renderMarkers();\r\n        };\r\n        actions.appendChild(anchorBtn);\r\n\r\n        const delBtn = document.createElement(\"button\");\r\n        delBtn.className = \"delete-btn\";\r\n        delBtn.innerHTML = \"&times;\";\r\n        delBtn.title = I18N.excluir;\r\n        delBtn.onclick = (e) => {\r\n          e.stopPropagation();\r\n          visoes.splice(i, 1);\r\n          if (visoes.length > 0) visoes[0].time = 0.0;\r\n          syncActiveTimeline();\r\n          renderMarkers();\r\n          renderSavedTimelines();\r\n        };\r\n        actions.appendChild(delBtn);\r\n\r\n        item.appendChild(num);\r\n        item.appendChild(img);\r\n        item.appendChild(info);\r\n        item.appendChild(actions);\r\n        lista.appendChild(item);\r\n      });\r\n    }\r\n\r\n    /* --- Playback --- */\r\n    function togglePlay() {\r\n      if (!playing) {\r\n        if (visoes.length < 2) return alert(I18N.min_duas_visoes);\r\n        if (currentIndex >= visoes.length - 1) currentIndex = 0;\r\n        playing = true;\r\n        document.body.classList.add(\"playing\");\r\n        document.getElementById(\"play_button\").innerHTML = \"&#9724; \" + I18N.stop;\r\n        document.getElementById(\"play_button\").className = \"btn btn-danger\";\r\n        sketchup.play_tour(JSON.stringify(visoes), document.getElementById(\"loop_checkbox\").checked, false, document.getElementById(\"easing_checkbox\").checked, currentIndex);\r\n      } else {\r\n        resetPlayButton();\r\n        sketchup.stop_tour();\r\n      }\r\n    }\r\n\r\n    function resetPlayButton() {\r\n      playing = false;\r\n      document.body.classList.remove(\"playing\");\r\n      document.getElementById(\"play_button\").innerHTML = \"&#9654; \" + I18N.play;\r\n      document.getElementById(\"play_button\").className = \"btn btn-success\";\r\n    }\r\n\r\n    function togglePlayAll() {\r\n      if (playingAll) {\r\n        resetPlayAll();\r\n        sketchup.stop_tour();\r\n        return;\r\n      }\r\n      if (savedTimelines.length < 2) return;\r\n      /* Save current timeline state */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n      /* Build queue of timelines with 2+ visions */\r\n      playAllQueue = savedTimelines.map(function(tl, i) { return i; }).filter(function(i) { return savedTimelines[i].visoes.length >= 2; });\r\n      if (playAllQueue.length < 1) { alert(I18N.sem_tl_2mais); return; }\r\n      playingAll = true;\r\n      playAllCurrentIdx = 0;\r\n      document.body.classList.add(\"playing\");\r\n      document.getElementById(\"play_all_button\").innerHTML = \"&#9724; \" + I18N.stop_all;\r\n      document.getElementById(\"play_all_button\").className = \"btn btn-danger btn-sm\";\r\n      playTimelineAtQueueIndex(0);\r\n    }\r\n\r\n    function playTimelineAtQueueIndex(qIdx) {\r\n      var tlIdx = playAllQueue[qIdx];\r\n      var tl = savedTimelines[tlIdx];\r\n      visoes = JSON.parse(JSON.stringify(tl.visoes));\r\n      document.getElementById(\"max_time\").value = tl.maxTime;\r\n      document.getElementById(\"timeline_range\").max = tl.maxTime;\r\n      activeTimelineIndex = tlIdx;\r\n      currentIndex = 0;\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n      sketchup.play_tour(\r\n        JSON.stringify(visoes),\r\n        false,\r\n        false,\r\n        document.getElementById(\"easing_checkbox\").checked,\r\n        0\r\n      );\r\n    }\r\n\r\n    function resetPlayAll() {\r\n      playingAll = false;\r\n      playAllQueue = [];\r\n      playAllCurrentIdx = 0;\r\n      document.body.classList.remove(\"playing\");\r\n      var btn = document.getElementById(\"play_all_button\");\r\n      btn.innerHTML = '<svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><polygon points=\"5 3 19 12 5 21 5 3\"/><line x1=\"19\" y1=\"3\" x2=\"19\" y2=\"21\"/></svg> ' + I18N.play_all;\r\n      btn.className = \"btn btn-outline btn-sm\";\r\n      playing = false;\r\n      document.getElementById(\"play_button\").innerHTML = \"&#9654; \" + I18N.play;\r\n      document.getElementById(\"play_button\").className = \"btn btn-success\";\r\n    }\r\n\r\n    function startRecordingPlayAll(startTlIdx, startVisionIdx) {\r\n      syncActiveTimeline();\r\n      /* Montar fila de timelines com 2+ visões, a partir de startTlIdx */\r\n      playAllQueue = [];\r\n      for (var i = startTlIdx; i < savedTimelines.length; i++) {\r\n        if (savedTimelines[i].visoes.length >= 2) playAllQueue.push(i);\r\n      }\r\n      if (playAllQueue.length === 0) return;\r\n\r\n      playingAll = true;\r\n      playAllCurrentIdx = 0;\r\n      playing = true;\r\n      document.body.classList.add(\"playing\");\r\n      document.getElementById(\"play_button\").innerHTML = \"&#9724; \" + I18N.stop;\r\n      document.getElementById(\"play_button\").className = \"btn btn-danger\";\r\n\r\n      /* Carregar a primeira timeline da fila */\r\n      var firstTlIdx = playAllQueue[0];\r\n      var tl = savedTimelines[firstTlIdx];\r\n      visoes = JSON.parse(JSON.stringify(tl.visoes));\r\n      document.getElementById(\"max_time\").value = tl.maxTime;\r\n      document.getElementById(\"timeline_range\").max = tl.maxTime;\r\n      activeTimelineIndex = firstTlIdx;\r\n      currentIndex = startVisionIdx;\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n\r\n      sketchup.play_tour(\r\n        JSON.stringify(visoes),\r\n        false,\r\n        false,\r\n        document.getElementById(\"easing_checkbox\").checked,\r\n        startVisionIdx\r\n      );\r\n    }\r\n\r\n    function updatePlayAllButton() {\r\n      var btn = document.getElementById(\"play_all_button\");\r\n      if (savedTimelines.length > 1) {\r\n        btn.classList.remove(\"hidden\");\r\n      } else {\r\n        btn.classList.add(\"hidden\");\r\n      }\r\n    }\r\n\r\n    function pauseAtIndex(idx) {\r\n      currentIndex = idx;\r\n      if (playingAll) {\r\n        playAllCurrentIdx++;\r\n        if (playAllCurrentIdx < playAllQueue.length) {\r\n          playTimelineAtQueueIndex(playAllCurrentIdx);\r\n          return;\r\n        } else {\r\n          resetPlayAll();\r\n          return;\r\n        }\r\n      }\r\n      resetPlayButton();\r\n    }\r\n    function triggerSpaceFromRuby() { togglePlay(); }\r\n    function updatePlayhead(time) {\r\n      var slider = document.getElementById(\"timeline_range\");\r\n      slider.value = time;\r\n      document.getElementById(\"current_time\").innerText = parseFloat(time).toFixed(1);\r\n    }\r\n\r\n    /* --- Timeline Management --- */\r\n    function exportarTimeline() {\r\n      if (visoes.length === 0) { alert(I18N.sem_visoes_exportar); return; }\r\n      var tlName = (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length)\r\n        ? savedTimelines[activeTimelineIndex].name : \"Time Line\";\r\n      /* Download JSON */\r\n      var dataStr = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(visoes, null, 2));\r\n      var a = document.createElement(\"a\");\r\n      a.setAttribute(\"href\", dataStr);\r\n      a.setAttribute(\"download\", tlName.replace(/[^a-zA-Z0-9_-]/g, \"_\") + \".json\");\r\n      document.body.appendChild(a); a.click(); a.remove();\r\n      /* Salvar na lista */\r\n      saveCurrentToTimelines(tlName);\r\n    }\r\n\r\n    function exportarProjeto() {\r\n      syncActiveTimeline();\r\n      if (savedTimelines.length === 0) { alert(I18N.sem_tl_exportar); return; }\r\n      var projeto = { type: \"tour_virtual_project\", timelines: savedTimelines };\r\n      var dataStr = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(projeto, null, 2));\r\n      var a = document.createElement(\"a\");\r\n      a.setAttribute(\"href\", dataStr);\r\n      a.setAttribute(\"download\", \"projeto_tour_virtual.json\");\r\n      document.body.appendChild(a); a.click(); a.remove();\r\n    }\r\n\r\n    function saveCurrentToTimelines(name) {\r\n      var maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      var entry = { name: name, visoes: JSON.parse(JSON.stringify(visoes)), maxTime: maxTime };\r\n      /* Atualizar existente se ativo, senão adicionar novo */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex] = entry;\r\n      } else {\r\n        savedTimelines.push(entry);\r\n        activeTimelineIndex = savedTimelines.length - 1;\r\n      }\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    function importarTimeline(input) {\r\n      var file = input.files[0];\r\n      if (!file) return;\r\n      var reader = new FileReader();\r\n      reader.onload = function(e) {\r\n        try {\r\n          var imported = JSON.parse(e.target.result);\r\n          /* Detectar se é um projeto completo */\r\n          if (imported && imported.type === \"tour_virtual_project\" && Array.isArray(imported.timelines)) {\r\n            syncActiveTimeline();\r\n            imported.timelines.forEach(function(tl) {\r\n              if (tl.visoes) {\r\n                tl.visoes.sort(function(a, b) { return a.time - b.time; });\r\n                if (tl.visoes.length > 0) tl.visoes[0].time = 0.0;\r\n              }\r\n              savedTimelines.push({ name: tl.name || I18N.importada, visoes: tl.visoes || [], maxTime: tl.maxTime || 60 });\r\n            });\r\n            if (savedTimelines.length > 0 && activeTimelineIndex < 0) {\r\n              activeTimelineIndex = 0;\r\n              var first = savedTimelines[0];\r\n              visoes = JSON.parse(JSON.stringify(first.visoes));\r\n              document.getElementById(\"max_time\").value = first.maxTime;\r\n              document.getElementById(\"timeline_range\").max = first.maxTime;\r\n              renderMarkers();\r\n            }\r\n            renderSavedTimelines();\r\n            return;\r\n          }\r\n          /* Time Line única */\r\n          if (!Array.isArray(imported)) throw I18N.formato_invalido;\r\n          imported.sort(function(a, b) { return a.time - b.time; });\r\n          if (imported.length > 0) imported[0].time = 0.0;\r\n          var maxTime = imported.length > 0 ? Math.ceil(imported[imported.length - 1].time + 1) : 60;\r\n          var name = file.name.replace(/\\\\.json$/i, \"\");\r\n          savedTimelines.push({ name: name, visoes: imported, maxTime: maxTime });\r\n          renderSavedTimelines();\r\n        } catch (err) { alert(I18N.erro_importar + err); }\r\n      };\r\n      reader.readAsText(file);\r\n      input.value = \"\";\r\n    }\r\n\r\n    function switchTimeline(index) {\r\n      if (index === activeTimelineIndex) return;\r\n      /* Save current state if there's an active timeline */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n      /* Load selected timeline */\r\n      const tl = savedTimelines[index];\r\n      visoes = JSON.parse(JSON.stringify(tl.visoes));\r\n      document.getElementById(\"max_time\").value = tl.maxTime;\r\n      document.getElementById(\"timeline_range\").max = tl.maxTime;\r\n      activeTimelineIndex = index;\r\n      currentIndex = 0;\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    function deleteTimeline(index) {\r\n      if (index === activeTimelineIndex) return;\r\n      savedTimelines.splice(index, 1);\r\n      if (activeTimelineIndex > index) activeTimelineIndex--;\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    function renderSavedTimelines() {\r\n      var container = document.getElementById(\"saved_timelines_list\");\r\n      container.innerHTML = \"\";\r\n      if (savedTimelines.length === 0) { updatePlayAllButton(); return; }\r\n      var dragSrcIndex = null;\r\n\r\n      savedTimelines.forEach(function(tl, i) {\r\n        var item = document.createElement(\"div\");\r\n        item.className = \"tl-item\" + (i === activeTimelineIndex ? \" active\" : \"\");\r\n        item.draggable = true;\r\n        item.dataset.index = i;\r\n\r\n        /* Drag handle */\r\n        var handle = document.createElement(\"span\");\r\n        handle.className = \"tl-drag-handle\";\r\n        handle.innerHTML = \"&#9776;\";\r\n        item.appendChild(handle);\r\n\r\n        /* Drag events */\r\n        item.addEventListener(\"dragstart\", function(e) {\r\n          dragSrcIndex = i;\r\n          item.classList.add(\"dragging\");\r\n          e.dataTransfer.effectAllowed = \"move\";\r\n        });\r\n        item.addEventListener(\"dragover\", function(e) {\r\n          e.preventDefault();\r\n          e.dataTransfer.dropEffect = \"move\";\r\n          var rect = item.getBoundingClientRect();\r\n          var midY = rect.top + rect.height / 2;\r\n          item.classList.remove(\"drag-over-top\", \"drag-over-bottom\");\r\n          item.classList.add(e.clientY < midY ? \"drag-over-top\" : \"drag-over-bottom\");\r\n        });\r\n        item.addEventListener(\"dragleave\", function() {\r\n          item.classList.remove(\"drag-over-top\", \"drag-over-bottom\");\r\n        });\r\n        item.addEventListener(\"drop\", function(e) {\r\n          e.preventDefault();\r\n          item.classList.remove(\"drag-over-top\", \"drag-over-bottom\");\r\n          if (dragSrcIndex === null || dragSrcIndex === i) return;\r\n          var rect = item.getBoundingClientRect();\r\n          var midY = rect.top + rect.height / 2;\r\n          var targetIndex = e.clientY < midY ? i : i + 1;\r\n          if (dragSrcIndex < targetIndex) targetIndex--;\r\n          var moved = savedTimelines.splice(dragSrcIndex, 1)[0];\r\n          savedTimelines.splice(targetIndex, 0, moved);\r\n          if (activeTimelineIndex === dragSrcIndex) {\r\n            activeTimelineIndex = targetIndex;\r\n          } else if (dragSrcIndex < activeTimelineIndex && targetIndex >= activeTimelineIndex) {\r\n            activeTimelineIndex--;\r\n          } else if (dragSrcIndex > activeTimelineIndex && targetIndex <= activeTimelineIndex) {\r\n            activeTimelineIndex++;\r\n          }\r\n          renderSavedTimelines();\r\n        });\r\n        item.addEventListener(\"dragend\", function() {\r\n          item.classList.remove(\"dragging\");\r\n          dragSrcIndex = null;\r\n        });\r\n\r\n        item.onclick = function() { switchTimeline(i); };\r\n\r\n        var indicator = document.createElement(\"span\");\r\n        indicator.className = \"tl-indicator\";\r\n        item.appendChild(indicator);\r\n\r\n        var nameEl = document.createElement(\"span\");\r\n        nameEl.className = \"tl-name\";\r\n        nameEl.textContent = tl.name;\r\n        item.appendChild(nameEl);\r\n\r\n        var count = document.createElement(\"span\");\r\n        count.className = \"tl-count\";\r\n        count.textContent = tl.visoes.length + \" \" + I18N.visoes;\r\n        item.appendChild(count);\r\n\r\n        if (i !== activeTimelineIndex) {\r\n          var del = document.createElement(\"button\");\r\n          del.className = \"tl-delete\";\r\n          del.innerHTML = \"&times;\";\r\n          del.title = I18N.excluir;\r\n          del.onclick = function(e) { e.stopPropagation(); deleteTimeline(i); };\r\n          item.appendChild(del);\r\n        }\r\n\r\n        container.appendChild(item);\r\n      });\r\n\r\n      updatePlayAllButton();\r\n    }\r\n\r\n    function novaTimeline() {\r\n      abrirModalTimeline(I18N.nova_timeline, \"Time Line \" + (savedTimelines.length + 1), function(name) {\r\n        /* Salvar timeline atual na lista se pertencer a uma timeline salva */\r\n        if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n          savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n          savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n        }\r\n        /* Criar nova timeline vazia e adicioná-la à lista */\r\n        savedTimelines.push({ name: name, visoes: [], maxTime: 60 });\r\n        activeTimelineIndex = savedTimelines.length - 1;\r\n        /* Limpar estado */\r\n        visoes = [];\r\n        currentIndex = 0;\r\n        document.getElementById(\"max_time\").value = 60;\r\n        document.getElementById(\"timeline_range\").max = 60;\r\n        document.getElementById(\"timeline_range\").value = 0;\r\n        updateTime(0);\r\n        renderMarkers();\r\n        renderSavedTimelines();\r\n      });\r\n    }\r\n\r\n    /* --- Video Export with Proportional Presets --- */\r\n    function onPresetChange() {\r\n      const sel = document.getElementById(\"preset_select\");\r\n      const preview = document.getElementById(\"preset_preview\");\r\n      const customDims = document.getElementById(\"custom_dims\");\r\n      const btnRecord = document.getElementById(\"btn_record\");\r\n      const idx = parseInt(sel.value);\r\n\r\n      if (isNaN(idx)) {\r\n        customDims.classList.remove(\"visible\");\r\n        preview.style.display = \"none\";\r\n        btnRecord.disabled = true;\r\n        if (window.sketchup) window.sketchup.hide_export_preview();\r\n        return;\r\n      }\r\n\r\n      const fmt = EXPORT_FORMATS[idx];\r\n      btnRecord.disabled = false;\r\n\r\n      if (fmt.custom) {\r\n        customDims.classList.add(\"visible\");\r\n        preview.style.display = \"none\";\r\n        if (window.sketchup) window.sketchup.hide_export_preview();\r\n      } else {\r\n        customDims.classList.remove(\"visible\");\r\n        let dims;\r\n        if (fmt.ratio) {\r\n          dims = calcEffectiveDims(fmt.ratio[0], fmt.ratio[1], viewportW, viewportH);\r\n        } else {\r\n          dims = { w: viewportW % 2 === 0 ? viewportW : viewportW - 1, h: viewportH % 2 === 0 ? viewportH : viewportH - 1 };\r\n        }\r\n        preview.textContent = I18N.area_gravacao + dims.w + \" x \" + dims.h + \" px\";\r\n        preview.style.display = \"flex\";\r\n        /* Show preview overlay in viewport */\r\n        if (window.sketchup) window.sketchup.show_export_preview(dims.w, dims.h);\r\n      }\r\n    }\r\n\r\n    function getExportDimensions() {\r\n      const sel = document.getElementById(\"preset_select\");\r\n      const idx = parseInt(sel.value);\r\n      if (isNaN(idx)) return null;\r\n      const fmt = EXPORT_FORMATS[idx];\r\n      if (fmt.custom) {\r\n        return {\r\n          w: parseInt(document.getElementById(\"custom_w\").value) || 1280,\r\n          h: parseInt(document.getElementById(\"custom_h\").value) || 720\r\n        };\r\n      }\r\n      if (fmt.ratio) {\r\n        return calcEffectiveDims(fmt.ratio[0], fmt.ratio[1], viewportW, viewportH);\r\n      }\r\n      return { w: viewportW % 2 === 0 ? viewportW : viewportW - 1, h: viewportH % 2 === 0 ? viewportH : viewportH - 1 };\r\n    }\r\n\r\n    function iniciarGravacao() {\r\n      var gravarProjeto = document.getElementById(\"rec_projeto\").checked;\r\n      var desdeInicio = document.getElementById(\"rec_inicio\").checked;\r\n\r\n      if (gravarProjeto) {\r\n        syncActiveTimeline();\r\n        var temVisoes = savedTimelines.some(function(tl) { return tl.visoes.length >= 2; });\r\n        if (!temVisoes) { alert(I18N.sem_tl_min_duas); return; }\r\n      } else {\r\n        if (visoes.length < 2) { alert(I18N.min_duas_visoes); return; }\r\n      }\r\n      var dims = getExportDimensions();\r\n      if (!dims || dims.w < 50 || dims.h < 50) { alert(I18N.dims_invalidas); return; }\r\n\r\n      /* Mostrar modal de nome */\r\n      document.getElementById(\"filename_input\").value = gravarProjeto ? \"projeto_tour\" : \"tour_final\";\r\n      document.getElementById(\"filename_modal\").style.display = \"flex\";\r\n      document.getElementById(\"filename_input\").focus();\r\n      document.getElementById(\"filename_input\").select();\r\n    }\r\n\r\n    function fecharModalFilename() {\r\n      document.getElementById(\"filename_modal\").style.display = \"none\";\r\n    }\r\n\r\n    function confirmarFilename() {\r\n      var nome = document.getElementById(\"filename_input\").value.trim();\r\n      if (!nome) { alert(I18N.digite_nome); return; }\r\n      document.getElementById(\"filename_modal\").style.display = \"none\";\r\n\r\n      var gravarProjeto = document.getElementById(\"rec_projeto\").checked;\r\n      var desdeInicio = document.getElementById(\"rec_inicio\").checked;\r\n      var dims = getExportDimensions();\r\n      var startIdx = desdeInicio ? 0 : currentIndex;\r\n\r\n      if (window.sketchup) window.sketchup.hide_export_preview();\r\n\r\n      if (gravarProjeto) {\r\n        syncActiveTimeline();\r\n        var allTimelines = JSON.stringify(savedTimelines);\r\n        var startTl = desdeInicio ? 0 : activeTimelineIndex;\r\n        var startVision = desdeInicio ? 0 : currentIndex;\r\n        if (window.sketchup) {\r\n          window.sketchup.start_export_project(\r\n            allTimelines,\r\n            document.getElementById(\"easing_checkbox\").checked,\r\n            startTl,\r\n            startVision,\r\n            dims.w,\r\n            dims.h,\r\n            nome\r\n          );\r\n        }\r\n      } else {\r\n        if (window.sketchup) {\r\n          window.sketchup.start_export_process(\r\n            JSON.stringify(visoes),\r\n            document.getElementById(\"easing_checkbox\").checked,\r\n            startIdx,\r\n            dims.w,\r\n            dims.h,\r\n            nome\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    function showRecordingIndicator() {\r\n      document.getElementById(\"recording_bar\").classList.add(\"active\");\r\n    }\r\n    function hideRecordingIndicator() {\r\n      document.getElementById(\"recording_bar\").classList.remove(\"active\");\r\n    }\r\n\r\n    function instalarExportacao() {\r\n      if (window.sketchup) { window.sketchup.install_ffmpeg(); }\r\n    }\r\n\r\n    /* --- Hotkey --- */\r\n    function mostrarCampoAtalho() {\r\n      capturingHotkey = true; pendingHotkey = null;\r\n      document.getElementById(\"hotkey_input\").value = \"\";\r\n      document.getElementById(\"hotkey_edit\").classList.add(\"visible\");\r\n      document.getElementById(\"hotkey_input\").focus();\r\n    }\r\n    function capturarAtalhoInput(e) {\r\n      e.preventDefault();\r\n      /* Ignorar teclas modificadoras sozinhas */\r\n      if ([16, 17, 18, 91, 93].includes(e.keyCode)) return;\r\n      pendingHotkey = {\r\n        keyCode: e.keyCode,\r\n        ctrl: e.ctrlKey,\r\n        alt: e.altKey,\r\n        shift: e.shiftKey\r\n      };\r\n      /* Montar label legivel */\r\n      var parts = [];\r\n      if (e.ctrlKey) parts.push(\"Ctrl\");\r\n      if (e.altKey) parts.push(\"Alt\");\r\n      if (e.shiftKey) parts.push(\"Shift\");\r\n      parts.push(e.code.replace(\"Key\", \"\").replace(\"Digit\", \"\"));\r\n      document.getElementById(\"hotkey_input\").value = parts.join(\" + \");\r\n    }\r\n    function confirmarAtalho() {\r\n      if (pendingHotkey !== null) {\r\n        hotkey = pendingHotkey;\r\n        if (window.sketchup) {\r\n          window.sketchup.set_hotkey(hotkey.keyCode, hotkey.ctrl, hotkey.alt, hotkey.shift);\r\n        }\r\n      }\r\n      capturingHotkey = false;\r\n      document.getElementById(\"hotkey_edit\").classList.remove(\"visible\");\r\n    }\r\n\r\n    /* --- Global bindings --- */\r\n    window.captureVisionFromRuby = captureVisionFromRuby;\r\n    window.resetPlayButton = resetPlayButton;\r\n    window.pauseAtIndex = pauseAtIndex;\r\n    window.triggerSpaceFromRuby = triggerSpaceFromRuby;\r\n    window.showRecordingIndicator = showRecordingIndicator;\r\n    window.hideRecordingIndicator = hideRecordingIndicator;\r\n    window.updatePlayhead = updatePlayhead;\r\n    window.resetPlayAll = resetPlayAll;\r\n    window.startRecordingPlayAll = startRecordingPlayAll;\r\n    window.addEventListener(\"resize\", () => { renderMarkers(); });\r\n\r\n    document.addEventListener(\"keydown\", (e) => {\r\n      if (!capturingHotkey &&\r\n          e.keyCode === hotkey.keyCode &&\r\n          e.ctrlKey === hotkey.ctrl &&\r\n          e.altKey === hotkey.alt &&\r\n          e.shiftKey === hotkey.shift &&\r\n          ![\"INPUT\", \"TEXTAREA\"].includes(e.target.tagName)) {\r\n        e.preventDefault(); togglePlay();\r\n      }\r\n    });\r\n\r\n    /* Init */\r\n    populatePresets();\r\n    renderMarkers();\r\n</script>\r\n</body>\r\n</html>\r\nHTML\r\n\r\n      @dialog ||= UI::HtmlDialog.new({\r\n        :dialog_title => obter_texto(:titulo_dialogo),\r\n        :preferences_key => \"com.example.tour\",\r\n        :scrollable => true,\r\n        :resizable => true,\r\n        :width => 430,\r\n        :height => 790,\r\n        :style => UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n\r\n      @dialog.set_html(html)\r\n      start_space_timer\r\n\r\n      @dialog.add_action_callback(\"set_hotkey\") do |_, key_code, ctrl, alt, shift|\r\n        GlobalKey.set_hotkey(key_code.to_i, ctrl, alt, shift)\r\n        Sketchup.write_default(\"TourVirtual\", \"Hotkey\", key_code.to_i)\r\n        Sketchup.write_default(\"TourVirtual\", \"HotkeyCtrl\", ctrl ? true : false)\r\n        Sketchup.write_default(\"TourVirtual\", \"HotkeyAlt\", alt ? true : false)\r\n        Sketchup.write_default(\"TourVirtual\", \"HotkeyShift\", shift ? true : false)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"capture_camera\") do |_, time_code|\r\n        cam = Sketchup.active_model.active_view.camera\r\n        thumb = capture_thumbnail\r\n        camera_data = {\r\n          time: time_code.to_f,\r\n          eye: cam.eye.to_a,\r\n          target: cam.target.to_a,\r\n          up: cam.up.to_a,\r\n          fov: cam.fov,\r\n          perspective: cam.perspective?,\r\n          thumb: thumb,\r\n          anchor: false\r\n        }\r\n        json_str = camera_data.to_json.gsub('\"', '\\\"')\r\n        @dialog.execute_script(\"captureVisionFromRuby(\\\"#{json_str}\\\")\")\r\n      end\r\n\r\n      @dialog.add_action_callback(\"goto_camera\") do |_, cam_json|\r\n        cam_data = JSON.parse(cam_json, symbolize_names: true)\r\n        cam = Sketchup::Camera.new(cam_data[:eye], cam_data[:target], cam_data[:up], cam_data[:perspective])\r\n        cam.fov = cam_data[:fov]\r\n        Sketchup.active_model.active_view.camera = cam\r\n      end\r\n\r\n      @dialog.add_action_callback(\"play_tour\") do |_, json_data, loop_enabled, inverse_mode, use_easing, start_index|\r\n        @camera_keys = JSON.parse(json_data, symbolize_names: true)\r\n        view = Sketchup.active_model.active_view\r\n        return if @camera_keys.length < 2\r\n        @camera_keys.sort_by! { |v| v[:time] }\r\n        @index = start_index.to_i\r\n        @direction = 1\r\n        @ping_pong = loop_enabled && inverse_mode\r\n\r\n        define_singleton_method(:ease_in_out_quad) do |t|\r\n          t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t\r\n        end\r\n\r\n        define_singleton_method(:catmull_rom) do |p0, p1, p2, p3, t|\r\n          t2 = t * t\r\n          t3 = t2 * t\r\n          [\r\n            0.5 * ((2 * p1[0]) + (-p0[0] + p2[0]) * t + (2*p0[0] - 5*p1[0] + 4*p2[0] - p3[0]) * t2 + (-p0[0] + 3*p1[0] - 3*p2[0] + p3[0]) * t3),\r\n            0.5 * ((2 * p1[1]) + (-p0[1] + p2[1]) * t + (2*p0[1] - 5*p1[1] + 4*p2[1] - p3[1]) * t2 + (-p0[1] + 3*p1[1] - 3*p2[1] + p3[1]) * t3),\r\n            0.5 * ((2 * p1[2]) + (-p0[2] + p2[2]) * t + (2*p0[2] - 5*p1[2] + 4*p2[2] - p3[2]) * t2 + (-p0[2] + 3*p1[2] - 3*p2[2] + p3[2]) * t3)\r\n          ]\r\n        end\r\n\r\n        define_singleton_method(:catmull_rom_1d) do |p0, p1, p2, p3, t|\r\n          t2 = t * t\r\n          t3 = t2 * t\r\n          0.5 * ((2 * p1) + (-p0 + p2) * t + (2*p0 - 5*p1 + 4*p2 - p3) * t2 + (-p0 + 3*p1 - 3*p2 + p3) * t3)\r\n        end\r\n\r\n        define_singleton_method(:play_transition) do\r\n          current = @camera_keys[@index]\r\n          next_index = @index + @direction\r\n\r\n          if next_index >= @camera_keys.size || next_index < 0\r\n            if loop_enabled\r\n               @index = 0\r\n               UI.start_timer(0.01) { play_transition }\r\n               return\r\n            else\r\n              @dialog.execute_script(\"pauseAtIndex(0)\")\r\n              return\r\n            end\r\n          end\r\n\r\n          next_cam = @camera_keys[next_index]\r\n          duration = (next_cam[:time] - current[:time]).abs\r\n          t_start = Time.now\r\n\r\n          p0 = @camera_keys[[@index - 1, 0].max]\r\n          p1 = current\r\n          p2 = next_cam\r\n          p3 = @camera_keys[[@index + 2, @camera_keys.size - 1].min]\r\n\r\n          @walk_shake = {\r\n            z_phase: rand * Math::PI * 2, x_phase: rand * Math::PI * 2,\r\n            z_amp: 0.8 + rand * 0.4, x_amp: 0.3 + rand * 0.4\r\n          }\r\n          playhead_counter = 0\r\n\r\n          @timer_id = UI.start_timer(0.03, true) do\r\n            t_elapsed = Time.now - t_start\r\n            t = duration.zero? ? 1.0 : [t_elapsed / duration, 1.0].min\r\n            t = use_easing ? ease_in_out_quad(t) : t\r\n\r\n            # Atualizar playhead na timeline (~a cada 0.09s)\r\n            playhead_counter += 1\r\n            if playhead_counter % 3 == 0\r\n              interpolated_time = current[:time] + t * (next_cam[:time] - current[:time])\r\n              @dialog.execute_script(\"updatePlayhead(#{interpolated_time.round(1)})\")\r\n            end\r\n\r\n            eye    = catmull_rom(p0[:eye],    p1[:eye],    p2[:eye],    p3[:eye],    t)\r\n            target = catmull_rom(p0[:target], p1[:target], p2[:target], p3[:target], t)\r\n            up     = catmull_rom(p0[:up],     p1[:up],     p2[:up],     p3[:up],     t)\r\n\r\n            # Interpolação Catmull-Rom para o FOV: suavidade total acompanhando a curva da câmera\r\n            fov = catmull_rom_1d(p0[:fov], p1[:fov], p2[:fov], p3[:fov], t)\r\n\r\n            if current[:walk]\r\n              eye[2] += Math.sin(t * Math::PI * 6 + @walk_shake[:z_phase]) * @walk_shake[:z_amp]\r\n              eye[0] += Math.sin(t * Math::PI * 3 + @walk_shake[:x_phase]) * @walk_shake[:x_amp]\r\n            end\r\n\r\n            cam = Sketchup::Camera.new(eye, target, up, current[:perspective])\r\n            cam.fov = fov\r\n            view.camera = cam\r\n            view.refresh\r\n\r\n            if t >= 1.0\r\n              UI.stop_timer(@timer_id)\r\n              @index = next_index\r\n              if @camera_keys[@index][:anchor] && @index > 0\r\n                @dialog.execute_script(\"pauseAtIndex(#{@index})\")\r\n              else\r\n                play_transition\r\n              end\r\n            end\r\n          end\r\n        end\r\n\r\n        play_transition\r\n      end\r\n\r\n      # Callback de exportação com presets de resolução\r\n      @dialog.add_action_callback(\"start_export_process\") do |_, json_data, use_easing, start_index, width, height, filename|\r\n        iniciar_processo_exportacao(json_data, use_easing, start_index, width.to_i, height.to_i, filename.to_s)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"start_export_project\") do |_, all_timelines_json, use_easing, active_tl_index, start_vision_index, width, height, filename|\r\n        iniciar_processo_exportacao_projeto(all_timelines_json, use_easing, active_tl_index.to_i, start_vision_index.to_i, width.to_i, height.to_i, filename.to_s)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"install_ffmpeg\") do |_|\r\n        eval(FFMPEG_INSTALL_SCRIPT)\r\n        UI.messagebox(obter_texto(:ffmpeg_instalado))\r\n      end\r\n\r\n      @dialog.add_action_callback(\"stop_tour\") do |_|\r\n        UI.stop_timer(@timer_id) if @timer_id\r\n        @dialog.execute_script(\"resetPlayButton()\")\r\n      end\r\n\r\n      @dialog.add_action_callback(\"show_export_preview\") do |_, width, height|\r\n        @preview_tool = ExportPreviewTool.new(width.to_i, height.to_i)\r\n        Sketchup.active_model.select_tool(@preview_tool)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"hide_export_preview\") do |_|\r\n        Sketchup.active_model.select_tool(nil)\r\n        @preview_tool = nil\r\n      end\r\n\r\n      @dialog.set_on_closed {\r\n        UI.stop_timer(@timer_id) if defined?(@timer_id) && @timer_id\r\n        stop_space_timer\r\n        if @preview_tool\r\n          Sketchup.active_model.select_tool(nil)\r\n          @preview_tool = nil\r\n        end\r\n      }\r\n\r\n      @dialog.show\r\n    end\r\n  end\r\nend\r\n\r\ndef self.executar\r\n  TourPlugin::CameraTimeline.start_ui\r\nend\r\n\r\nend # module TourVirtual\r\nend # module ScriptUpComunidade\r\n\r\nScriptUpComunidade::TourVirtual.executar"
    },
    "enabled": false,
    "execute": true
  }
]